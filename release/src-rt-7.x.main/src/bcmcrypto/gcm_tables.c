/*
 * gcm_tables.c
 *
 * Copyright (C) 2014, Broadcom Corporation
 * All Rights Reserved.
 * 
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
 * the contents of this file may not be disclosed to third parties, copied
 * or duplicated in any form, in whole or in part, without the prior
 * written permission of Broadcom Corporation.
 *
 * $Id: gcm_tables.c 349805 2012-08-09 19:01:57Z $
 */

/*
 * Copyright (c) 2010 The OpenSSL Project.  All rights reserved.
 *
 * This product includes software developed by the OpenSSL Project
 * for use in the OpenSSL Toolkit (http://www.openssl.org/)
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <typedefs.h>

#ifdef BCMDRIVER
#include <osl.h>
#else
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define ASSERT assert
#endif  /* BCMDRIVER */

#include <bcmendian.h>
#include <bcmutils.h>
#include <bcmcrypto/gcm.h>

/* fixed table R[byte[x,0]] = x.P^128 */
struct r_entry {
	uint8 hi;
	uint8 lo;
}; 
typedef struct r_entry r_entry_t;

/* Support for 4096 byte/key Shoup's 8 bit tables */
#if GCM_TABLE_SZ == 4096

/* Table R[x0..x7] = x.P^128 for all x belonging to S. Copied
 * from  OpenSSL - gcm128.c
 */
static r_entry_t R[GCM_TABLE_NUM_ENTRIES] = {
		{0x00, 0x00}, {0x01, 0xC2}, {0x03, 0x84}, {0x02, 0x46},
		{0x07, 0x08}, {0x06, 0xCA}, {0x04, 0x8C}, {0x05, 0x4E},
		{0x0E, 0x10}, {0x0F, 0xD2}, {0x0D, 0x94}, {0x0C, 0x56},
		{0x09, 0x18}, {0x08, 0xDA}, {0x0A, 0x9C}, {0x0B, 0x5E},
		{0x1C, 0x20}, {0x1D, 0xE2}, {0x1F, 0xA4}, {0x1E, 0x66},
		{0x1B, 0x28}, {0x1A, 0xEA}, {0x18, 0xAC}, {0x19, 0x6E},
		{0x12, 0x30}, {0x13, 0xF2}, {0x11, 0xB4}, {0x10, 0x76},
		{0x15, 0x38}, {0x14, 0xFA}, {0x16, 0xBC}, {0x17, 0x7E},
		{0x38, 0x40}, {0x39, 0x82}, {0x3B, 0xC4}, {0x3A, 0x06},
		{0x3F, 0x48}, {0x3E, 0x8A}, {0x3C, 0xCC}, {0x3D, 0x0E},
		{0x36, 0x50}, {0x37, 0x92}, {0x35, 0xD4}, {0x34, 0x16},
		{0x31, 0x58}, {0x30, 0x9A}, {0x32, 0xDC}, {0x33, 0x1E},
		{0x24, 0x60}, {0x25, 0xA2}, {0x27, 0xE4}, {0x26, 0x26},
		{0x23, 0x68}, {0x22, 0xAA}, {0x20, 0xEC}, {0x21, 0x2E},
		{0x2A, 0x70}, {0x2B, 0xB2}, {0x29, 0xF4}, {0x28, 0x36},
		{0x2D, 0x78}, {0x2C, 0xBA}, {0x2E, 0xFC}, {0x2F, 0x3E},
		{0x70, 0x80}, {0x71, 0x42}, {0x73, 0x04}, {0x72, 0xC6},
		{0x77, 0x88}, {0x76, 0x4A}, {0x74, 0x0C}, {0x75, 0xCE},
		{0x7E, 0x90}, {0x7F, 0x52}, {0x7D, 0x14}, {0x7C, 0xD6},
		{0x79, 0x98}, {0x78, 0x5A}, {0x7A, 0x1C}, {0x7B, 0xDE},
		{0x6C, 0xA0}, {0x6D, 0x62}, {0x6F, 0x24}, {0x6E, 0xE6},
		{0x6B, 0xA8}, {0x6A, 0x6A}, {0x68, 0x2C}, {0x69, 0xEE},
		{0x62, 0xB0}, {0x63, 0x72}, {0x61, 0x34}, {0x60, 0xF6},
		{0x65, 0xB8}, {0x64, 0x7A}, {0x66, 0x3C}, {0x67, 0xFE},
		{0x48, 0xC0}, {0x49, 0x02}, {0x4B, 0x44}, {0x4A, 0x86},
		{0x4F, 0xC8}, {0x4E, 0x0A}, {0x4C, 0x4C}, {0x4D, 0x8E},
		{0x46, 0xD0}, {0x47, 0x12}, {0x45, 0x54}, {0x44, 0x96},
		{0x41, 0xD8}, {0x40, 0x1A}, {0x42, 0x5C}, {0x43, 0x9E},
		{0x54, 0xE0}, {0x55, 0x22}, {0x57, 0x64}, {0x56, 0xA6},
		{0x53, 0xE8}, {0x52, 0x2A}, {0x50, 0x6C}, {0x51, 0xAE},
		{0x5A, 0xF0}, {0x5B, 0x32}, {0x59, 0x74}, {0x58, 0xB6},
		{0x5D, 0xF8}, {0x5C, 0x3A}, {0x5E, 0x7C}, {0x5F, 0xBE},
		{0xE1, 0x00}, {0xE0, 0xC2}, {0xE2, 0x84}, {0xE3, 0x46},
		{0xE6, 0x08}, {0xE7, 0xCA}, {0xE5, 0x8C}, {0xE4, 0x4E},
		{0xEF, 0x10}, {0xEE, 0xD2}, {0xEC, 0x94}, {0xED, 0x56},
		{0xE8, 0x18}, {0xE9, 0xDA}, {0xEB, 0x9C}, {0xEA, 0x5E},
		{0xFD, 0x20}, {0xFC, 0xE2}, {0xFE, 0xA4}, {0xFF, 0x66},
		{0xFA, 0x28}, {0xFB, 0xEA}, {0xF9, 0xAC}, {0xF8, 0x6E},
		{0xF3, 0x30}, {0xF2, 0xF2}, {0xF0, 0xB4}, {0xF1, 0x76},
		{0xF4, 0x38}, {0xF5, 0xFA}, {0xF7, 0xBC}, {0xF6, 0x7E},
		{0xD9, 0x40}, {0xD8, 0x82}, {0xDA, 0xC4}, {0xDB, 0x06},
		{0xDE, 0x48}, {0xDF, 0x8A}, {0xDD, 0xCC}, {0xDC, 0x0E},
		{0xD7, 0x50}, {0xD6, 0x92}, {0xD4, 0xD4}, {0xD5, 0x16},
		{0xD0, 0x58}, {0xD1, 0x9A}, {0xD3, 0xDC}, {0xD2, 0x1E},
		{0xC5, 0x60}, {0xC4, 0xA2}, {0xC6, 0xE4}, {0xC7, 0x26},
		{0xC2, 0x68}, {0xC3, 0xAA}, {0xC1, 0xEC}, {0xC0, 0x2E},
		{0xCB, 0x70}, {0xCA, 0xB2}, {0xC8, 0xF4}, {0xC9, 0x36},
		{0xCC, 0x78}, {0xCD, 0xBA}, {0xCF, 0xFC}, {0xCE, 0x3E},
		{0x91, 0x80}, {0x90, 0x42}, {0x92, 0x04}, {0x93, 0xC6},
		{0x96, 0x88}, {0x97, 0x4A}, {0x95, 0x0C}, {0x94, 0xCE},
		{0x9F, 0x90}, {0x9E, 0x52}, {0x9C, 0x14}, {0x9D, 0xD6},
		{0x98, 0x98}, {0x99, 0x5A}, {0x9B, 0x1C}, {0x9A, 0xDE},
		{0x8D, 0xA0}, {0x8C, 0x62}, {0x8E, 0x24}, {0x8F, 0xE6},
		{0x8A, 0xA8}, {0x8B, 0x6A}, {0x89, 0x2C}, {0x88, 0xEE},
		{0x83, 0xB0}, {0x82, 0x72}, {0x80, 0x34}, {0x81, 0xF6},
		{0x84, 0xB8}, {0x85, 0x7A}, {0x87, 0x3C}, {0x86, 0xFE},
		{0xA9, 0xC0}, {0xA8, 0x02}, {0xAA, 0x44}, {0xAB, 0x86},
		{0xAE, 0xC8}, {0xAF, 0x0A}, {0xAD, 0x4C}, {0xAC, 0x8E},
		{0xA7, 0xD0}, {0xA6, 0x12}, {0xA4, 0x54}, {0xA5, 0x96},
		{0xA0, 0xD8}, {0xA1, 0x1A}, {0xA3, 0x5C}, {0xA2, 0x9E},
		{0xB5, 0xE0}, {0xB4, 0x22}, {0xB6, 0x64}, {0xB7, 0xA6},
		{0xB2, 0xE8}, {0xB3, 0x2A}, {0xB1, 0x6C}, {0xB0, 0xAE},
		{0xBB, 0xF0}, {0xBA, 0x32}, {0xB8, 0x74}, {0xB9, 0xB6},
		{0xBC, 0xF8}, {0xBD, 0x3A}, {0xBF, 0x7C}, {0xBE, 0xBE}
};

#define B0_INIT_TABLE_VAL(i) (i)

/* multiply using tables - Note: out and x may overlap */
void
gcm_mul_with_table(const gcm_table_t *t, const gcm_block_t x, gcm_block_t out)
{
	gcm_block_t z;
	uint i, j;

	memset(z, 0, sizeof(z));

	/* process xn..x1  - See Algorithm 2  - gcm_spec.pdf */
	i = 16;
	while (--i > 0) {
		uint8 z15;
		xor_128bit_block(z, t->M0[x[i]], z);

		/* Z <-- Z . P^8 */
		z15 = z[15];
		j = 16;
		while (--j > 0)
			z[j] = z[j - 1];

		/* z[0] = 0 is implied - and no need to XOR trailing all 0 bits */
		z[0] =  R[z15].hi;
		z[1] ^=  R[z15].lo;
	}

	/* process x0 */
	xor_128bit_block(z, t->M0[x[0]], z);
	memcpy(out, z, sizeof(z));
}
#endif /*  GCM_TABLE_SZ == 4096 */

#if GCM_TABLE_SZ == 256

/* Table R[x0..3] = x.P^128 for all x belonging to S'. Copied
 * from  OpenSSL - gcm128.c
 */
static r_entry_t R[GCM_TABLE_NUM_ENTRIES] = {
	{0x00, 0x00}, {0x1C, 0x20}, {0x38, 0x40}, {0x24, 0x60},
	{0x70, 0x80}, {0x6C, 0xA0}, {0x48, 0xC0}, {0x54, 0xE0},
	{0xE1, 0x00}, {0xFD, 0x20}, {0xD9, 0x40}, {0xC5, 0x60},
	{0x91, 0x80}, {0x8D, 0xA0}, {0xA9, 0xC0}, {0xB5, 0xE0}
};

#define B0_INIT_TABLE_VAL(i) (i << 4)

void
gcm_mul_with_table(const gcm_table_t *t, const gcm_block_t x, gcm_block_t out)
{
	gcm_block_t z;
	uint i, j;
	uint8 z31;

	memset(z, 0, sizeof(z));

	/* process xn..x1  - See Algorithm 2  - gcm_spec.pdf */
	i = 32;
	while (--i > 0) {
		j = i >> 1;
		if (i & 0x1)
			xor_128bit_block(z, t->M0[x[j] & 0xf], z);
		else
			xor_128bit_block(z, t->M0[x[j] >> 4], z);

		/* Z <-- Z . P^4 */
		z31 = z[15] & 0xf;
		j = 16;
		while (--j > 0)
			z[j] = (z[j] >> 4) | ((z[j - 1] & 0xf) << 4);
		z[0] >>= 4;

		/* no need to XOR trailing all 0 bits */
		z[0] ^=  R[z31].hi;
		z[1] ^=  R[z31].lo;
	}

	/* process x0 */
	xor_128bit_block(z, t->M0[x[0] >> 4], z);
	memcpy(out, z, sizeof(z));
}
#endif /* GCM_TABLE_SZ == 256 */

void
gcm_init_table(gcm_table_t *t, gcm_block_t hk)
{
	uint i;
	gcm_block_t b;

	memset(t, 0, sizeof(*t));
	memset(b, 0, sizeof(b));

	for (i = 0; i < GCM_TABLE_NUM_ENTRIES; ++i) {
		b[0] = B0_INIT_TABLE_VAL(i);
		gcm_mul_block(b, hk, t->M0[i]);
	}
}
