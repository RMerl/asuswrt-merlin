/*
 * gcm_test.c
 *
 * Copyright (C) 2014, Broadcom Corporation
 * All Rights Reserved.
 * 
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
 * the contents of this file may not be disclosed to third parties, copied
 * or duplicated in any form, in whole or in part, without the prior
 * written permission of Broadcom Corporation.
 *
 * $Id$ 
 */

/* test references
 * 
 *	http://www.ieee802.org/1/files/public/docs2011\
 *		/bn-randall-test-vectors-0511-v1.pdf
 *  http://csrc.nist.gov/groups/ST/toolkit/BCM/documents\
 *		/proposedmodes/gcm/gcm-spec.pdf
 */

#include <bcmcrypto/aesgcm.h>

#include <typedefs.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define ASSERT assert

#ifdef DEBUG
static unsigned dbg_enabled = 0;
void dbgprint(const char* pfx, const uint8* buf, size_t len, int line);
#define DBG(pfx, buf, len) do {\
	if (dbg_enabled) \
		dbgprint(pfx, buf, len, __LINE__); \
} while (0);
#define ENABLE_DEBUG dbg_enabled=1
#define DISABLE_DEBUG dbg_enabled=0
#else
#define DBG(pfx, buf, len)
#define ENABLE_DEBUG 
#define DISABLE_DEBUG
#endif /* DEBUG */

typedef enum {
	OK=0,
	ERR = ~0
} status_t;

/* test 0 */
static const uint8 k0[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static const size_t klen0 = sizeof(k0);
static const uint8* p0 = NULL;
static const size_t plen0 = 0; 
static const uint8* a0 = 0;
static const size_t alen0 = 0;
static const uint8 n0[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x000 };
static const size_t nlen0 = sizeof(n0);
static const uint8 t0[] = {
	0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61, 
	0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a };
static const size_t tlen0 = sizeof(t0);

/* test 1, 2 */
uint8 k1[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static const size_t klen1 = sizeof(k1);
static const uint8 p1[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static const uint8 c1[] = {
	0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 
	0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78 };
static const size_t plen1 = 16;
static const uint8* a1 = 0;
static const size_t alen1 = 0;
static const uint8 n1[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x000 };
static const size_t nlen1 = sizeof(n1);
static const uint8 t1[] = {
	0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd, 
	0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf };
static const size_t tlen1 = sizeof(t1);

/* test 3 */
uint8 k3[] = {
	0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
	0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 };
static const size_t klen3 = sizeof(k3);
static const uint8 p3[] = {
	0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
    0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
	0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
	0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
	0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
	0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
	0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
	0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55 };
static const uint8 c3[] = {
	0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 
	0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
	0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 
	0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
	0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 
	0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
	0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 
	0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85 };
static const size_t plen3 = sizeof(p3);
static const uint8 n3[] = {
	0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 
	0xde, 0xca, 0xf8, 0x88 };
static const size_t nlen3 = sizeof(n3);
static const uint8 *a3 = 0; 
static const size_t alen3 = 0;
static const uint8 t3[] = {
	0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6, 
	0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4};
static const size_t tlen3 = sizeof(t3);

/* test 4 */
static const uint8 hk4[] =  {
	0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b, 
	0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e };
static const uint8 ac4[] = {
	0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 
	0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 };
static const size_t aclen4 = sizeof(ac4);
static const uint8 hac4[] = {
	0xf3, 0x8c, 0xbb, 0x1a, 0xd6, 0x92, 0x23, 0xdc, 
	0xc3, 0x45, 0x7a, 0xe5, 0xb6, 0xb0, 0xf8, 0x85 };
static const size_t haclen4 = sizeof(hac4);

/* test 5 */
static const uint8 k5[] = {
	0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 
	0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08 };
static size_t klen5 = sizeof(k5);
static const uint8 p5[] = {
	0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 
	0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
	0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda, 
	0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
	0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 
	0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
	0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 
	0xba, 0x63, 0x7b, 0x39 };
static size_t plen5 = sizeof(p5);
static const uint8 a5[] = {
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xab, 0xad, 0xda, 0xd2 };
static size_t alen5 = sizeof(a5);
static const uint8 n5[] = {
	0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
	0xde, 0xca, 0xf8, 0x88 };
static size_t nlen5 = sizeof(n5);
static const uint8 c5[] = {
	0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
	0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
	0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
	0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
	0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
	0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
	0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
	0x3d, 0x58, 0xe0, 0x91 };
static const uint8 t5[] = {
	0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,
	0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47 };
static size_t tlen5 = sizeof(t5);

/* test 6 */
static const uint8 n6[] = {
    0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad };
static const size_t nlen6 = sizeof(n6);
static const uint8 c6[] = {
	0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a,
	0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55,
	0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8,
	0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23,
	0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2,
	0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42,
	0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07,
	0xc2, 0x3f, 0x45, 0x98 };
static const uint8 t6[] = {
	0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85,
	0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb };
static const size_t tlen6 = sizeof(t6);

/* test 10 */
static const uint8 k10[] = {
	0xad, 0x7a, 0x2b, 0xd0, 0x3e, 0xac, 0x83, 0x5a,
	0x6f, 0x62, 0x0f, 0xdc, 0xb5, 0x06, 0xb3, 0x45 };
static const size_t klen10 = sizeof(k10);

static const uint8 p10[] = {
	0x08, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
	0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
	0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
	0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
	0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
	0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x00, 0x02
};
static const size_t plen10 = sizeof(p10);

static const uint8 a10[] = {
	0xd6, 0x09, 0xb1, 0xf0, 0x56, 0x63, 0x7a, 0x0d,
	0x46, 0xdf, 0x99, 0x8d, 0x88, 0xe5, 0x2e, 0x00,
	0xb2, 0xc2, 0x84, 0x65, 0x12, 0x15, 0x35, 0x24,
	0xc0, 0x89, 0x5e, 0x81
};
static const size_t alen10 = sizeof(a10);

static const uint8 n10[] = {
	0x12, 0x15, 0x35, 0x24, 0xc0, 0x89, 0x5e, 0x81,
	0xb2, 0xc2, 0x84, 0x65
};
static const size_t nlen10 = sizeof(n10);

static const uint8 c10[] = {
	0x70, 0x1a, 0xfa, 0x1c, 0xc0, 0x39, 0xc0, 0xd7,
	0x65, 0x12, 0x8a, 0x66, 0x5d, 0xab, 0x69, 0x24,
	0x38, 0x99, 0xbf, 0x73, 0x18, 0xcc, 0xdc, 0x81,
	0xc9, 0x93, 0x1d, 0xa1, 0x7f, 0xbe, 0x8e, 0xdd,
	0x7d, 0x17, 0xcb, 0x8b, 0x4c, 0x26, 0xfc, 0x81,
	0xe3, 0x28, 0x4f, 0x2b, 0x7f, 0xba, 0x71, 0x3d
};
static const size_t  clen10 = sizeof(c10);

static const uint8 t10[] = {
	0x4f, 0x8d, 0x55, 0xe7, 0xd3, 0xf0, 0x6f, 0xd5,
	0xa1, 0x3c, 0x0c, 0x29, 0xb9, 0xd5, 0xb8, 0x80
};
static const size_t tlen10 = sizeof(t10);

/* test 11 - same as 10, except 256 bit key */
static const uint8 k11[] = {
	0xe3, 0xc0, 0x8a, 0x8f, 0x06, 0xc6, 0xe3, 0xad,
	0x95, 0xa7, 0x05, 0x57, 0xb2, 0x3f, 0x75, 0x48,
	0x3c, 0xe3, 0x30, 0x21, 0xa9, 0xc7, 0x2b, 0x70,
	0x25, 0x66, 0x62, 0x04, 0xc6, 0x9c, 0x0b, 0x72
};
static const size_t klen11 = sizeof(k11);

static const uint8 c11[] = {
	0xe2, 0x00, 0x6e, 0xb4, 0x2f, 0x52, 0x77, 0x02,
	0x2d, 0x9b, 0x19, 0x92, 0x5b, 0xc4, 0x19, 0xd7,
	0xa5, 0x92, 0x66, 0x6c, 0x92, 0x5f, 0xe2, 0xef,
	0x71, 0x8e, 0xb4, 0xe3, 0x08, 0xef, 0xea, 0xa7,
	0xc5, 0x27, 0x3b, 0x39, 0x41, 0x18, 0x86, 0x0a,
	0x5b, 0xe2, 0xa9, 0x7f, 0x56, 0xab, 0x78, 0x36
};
static const size_t clen11 = sizeof(c11);

static const uint8 t11[] = {
	0x5c, 0xa5, 0x97, 0xcd, 0xbb, 0x3e, 0xdb, 0x8d,
	0x1a, 0x11, 0x51, 0xea, 0x0a, 0xf7, 0xb4, 0x36
};
static const size_t tlen11 = sizeof(t11);

/* test 12 */
static const uint8 k12[] = {
	0x01, 0x3f, 0xe0, 0x0b, 0x5f, 0x11, 0xbe, 0x7f,
	0x86, 0x6d, 0x0c, 0xbb, 0xc5, 0x5a, 0x7a, 0x90
};
static const size_t klen12 = sizeof(k12);

static const uint8 p12[] = {
	0x08, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
	0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
	0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
	0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c,
	0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
	0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x00,
	0x06
};
static const size_t plen12 = sizeof(p12);

static const uint8 a12[] = {
	0x84, 0xc5, 0xd5, 0x13, 0xd2, 0xaa, 0xf6, 0xe5,
	0xbb, 0xd2, 0x72, 0x77, 0x88, 0xe5, 0x2f, 0x00,
	0x89, 0x32, 0xd6, 0x12, 0x7c, 0xfd, 0xe9, 0xf9,
	0xe3, 0x37, 0x24, 0xc6
};
static const size_t alen12 = sizeof(a12);

static const uint8 n12[] = {
	0x7c, 0xfd, 0xe9, 0xf9, 0xe3, 0x37, 0x24, 0xc6,
	0x89, 0x32, 0xd6, 0x12
};
static const size_t nlen12 = sizeof(n12);

static const uint8 c12[] = {
	0x3a, 0x4d, 0xe6, 0xfa, 0x32, 0x19, 0x10, 0x14,
	0xdb, 0xb3, 0x03, 0xd9, 0x2e, 0xe3, 0xa9, 0xe8,
	0xa1, 0xb5, 0x99, 0xc1, 0x4d, 0x22, 0xfb, 0x08,
	0x00, 0x96, 0xe1, 0x38, 0x11, 0x81, 0x6a, 0x3c,
	0x9c, 0x9b, 0xcf, 0x7c, 0x1b, 0x9b, 0x96, 0xda,
	0x80, 0x92, 0x04, 0xe2, 0x9d, 0x0e, 0x2a, 0x76,
	0x42
};
static const size_t clen12 = sizeof(c12);

static const uint8 t12[] = {
	0xbf, 0xd3, 0x10, 0xa4, 0x83, 0x7c, 0x81, 0x6c,
	0xcf, 0xa5, 0xac, 0x23, 0xab, 0x00, 0x39, 0x88
};
static const size_t tlen12 = sizeof(t12);

/* test 13 - same as 12, except 256 bit key */

static const uint8 k13[] = {
	0x83, 0xc0, 0x93, 0xb5, 0x8d, 0xe7, 0xff, 0xe1,
	0xc0, 0xda, 0x92, 0x6a, 0xc4, 0x3f, 0xb3, 0x60,
	0x9a, 0xc1, 0xc8, 0x0f, 0xee, 0x1b, 0x62, 0x44,
	0x97, 0xef, 0x94, 0x2e, 0x2f, 0x79, 0xa8, 0x23
};
static const size_t klen13 = sizeof(k13);

static const uint8 c13[] = {
	0x11, 0x02, 0x22, 0xff, 0x80, 0x50, 0xcb, 0xec,
	0xe6, 0x6a, 0x81, 0x3a, 0xd0, 0x9a, 0x73, 0xed,
	0x7a, 0x9a, 0x08, 0x9c, 0x10, 0x6b, 0x95, 0x93,
	0x89, 0x16, 0x8e, 0xd6, 0xe8, 0x69, 0x8e, 0xa9,
	0x02, 0xeb, 0x12, 0x77, 0xdb, 0xec, 0x2e, 0x68,
	0xe4, 0x73, 0x15, 0x5a, 0x15, 0xa7, 0xda, 0xee,
	0xd4
};
static const size_t clen13 = sizeof(c13);

static const uint8 t13[] = {
	0xa1, 0x0f, 0x4e, 0x05, 0x13, 0x9c, 0x23, 0xdf,
	0x00, 0xb3, 0xaa, 0xdc, 0x71, 0xf0, 0x59, 0x6a
};
static const size_t tlen13 = sizeof(t13);

/* test 14 */
static const uint8 k14[] = {
	0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
	0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
	0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
	0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
};
static const size_t klen14 = sizeof(k14);

static const uint8 p14[] = {
	0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
	0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
	0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
	0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
	0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
	0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
	0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
	0xba, 0x63, 0x7b, 0x39
};
static const size_t plen14 = sizeof(p14);

static const uint8 a14[] = {
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xab, 0xad, 0xda, 0xd2
};
static const size_t alen14 = sizeof(a14);

static const uint8 n14[] = {
	0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad
};
static const size_t nlen14 = sizeof(n14);

static const uint8 c14[] = {
	0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32,
	0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb,
	0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa,
	0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0,
	0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0,
	0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78,
	0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99,
	0xf4, 0x7c, 0x9b, 0x1f
};
static const size_t clen14 = sizeof(c14);

static const uint8 t14[] = {
	0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4,
	0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2
};
static const size_t tlen14 = sizeof(t14);

#define _ERR(what, r, et, ct, lt) do { \
	ASSERT(r != OK); \
	printf("Error: %d\n", r); \
	DBG("expected " what, et, lt); \
	DBG("computed " what, ct, lt); \
} while (0)

#define TAG_ERR(r, et, ct, lt) _ERR("tag", r, et, ct, lt);
#define CTXT_ERR(r, et, ct, lt) _ERR("ctxt", r, et, ct, lt);
#define PTXT_ERR(r, et, ct, lt) _ERR("ptxt", r, et, ct, lt);

struct test_info {
	int num;
	const char *ref;
	int key_len;
} test_infos[] = {
	{0, "gcm_spec: McGrew & Vega", 128},
	{1, "gcm_spec: McGrew & Vega", 128},
	{2, "gcm_spec: McGrew & Vega", 128},
	{3, "gcm_spec: McGrew & Vega", 128},
	{4, "gcm_spec: McGrew & Vega", 128},
	{5, "gcm_spec: McGrew & Vega", 128},
	{6, "gcm_spec: McGrew & Vega", 128},
	{7, "gcm_spec: McGrew & Vega", 128},
	{8, "gcm_spec: McGrew & Vega", 128},
	{9, "gcm_spec: McGrew & Vega", 128},
	{10, "MAC Sec: bn-randall-*-0511-v1: 2.2.1, data len 48", 128},
	{11, "MAC Sec: bn-randall-*-0511-v1: 2.2.2, data len 48", 256},
	{12, "MAC Sec: bn-randall-*-0511-v1: 2.6.1, data len: 49", 128},
	{13, "MAC Sec: bn-randall-*-0511-v1: 2.6.2, data len: 49", 256},
	{14, "gcm_spec: McGrew & Vega: Test case 17, data len: 60", 256},
	{-1, NULL, -1}
};

#define BEGINT(i) begin_test(i, buf, sizeof(buf), tag, sizeof(tag))

static void begin_test(int i, uint8* buf, size_t blen, uint8* tag, size_t tlen)
{
	struct test_info *test = &test_infos[i];
	printf("test %d: starting - key_len: %d, ref: %s\n", 
		test->num, test->key_len, test->ref);
	memset(buf, 0, blen);
	memset(tag, 0, tlen);
}

#define ENDT(x,y) do { end_test(x, y, __LINE__); } while (0)
static void end_test(int i, status_t st, unsigned line)
{
	if (st == OK)
		printf("test %d: passed.\n", i);
	else
		printf("test %d: failed with error 0x%08x at line %u.\n", i, st, line);
}

int main(int argc, char **argv)
{
	uint8 buf[4096];
	uint8 tag[GCM_BLOCK_SZ];
	status_t res;

	ENABLE_DEBUG;

	BEGINT(0);
	memcpy(buf, p0, plen0);
	aes_gcm_encrypt(k0, klen0, n0, nlen0, a0, alen0, buf, plen0,
		tag, sizeof(tag));
	res = !memcmp(tag, t0, tlen0) ? OK : ERR;
	if (res != OK)
		TAG_ERR(res, t0, tag, tlen0);
	ENDT(0, res);

	BEGINT(1);
	memcpy(buf, p1, plen1);
	aes_gcm_mac(k1, klen1,  n1, nlen1, a1, alen1, buf, plen1,
		tag, sizeof(tag));
	res = !memcmp(tag, t1, tlen1) ? OK : ERR;
	if (res != OK)
		TAG_ERR(res, t1, tag, tlen1);
	ENDT(1, res);

	BEGINT(2);
	memcpy(buf, p1, plen1);
	aes_gcm_encrypt(k1, klen1, n1, nlen1, a1, alen1, buf, plen1,
		tag, sizeof(tag));

	res = !memcmp(c1, buf, plen1) ? OK : ERR;
	if (res != OK) {
		CTXT_ERR(res, c1, buf, plen1);
	} else {
		res = !memcmp(tag, t1, tlen1) ? OK : ERR;
		if (res != OK) 
			TAG_ERR(res, t1, tag, tlen1);
	}
	ENDT(2, res);

	BEGINT(3);
	memcpy(buf, p3, plen3);
	aes_gcm_encrypt(k3, klen3, n3, nlen3, a3, alen3, buf, plen3, 
		tag, sizeof(tag));

	res = !memcmp(c3, buf, plen3) ? OK : ERR;
	if (res != OK) {
		CTXT_ERR(res, c3, buf, plen3);
	} else {
		res = !memcmp(tag, t3, tlen3) ? OK : ERR;
		if (res != OK) 
			TAG_ERR(res, t3, tag, tlen3);
	}
	ENDT(3, res);

#ifdef HAVE_GCM_HASH
	BEGINT(4);
	gcm_hash(hk4, ac4, aclen4, buf, TRUE);
	res = !memcmp(hac4, buf, haclen4) ? OK : ERR;
	if (res != OK) 
		TAG_ERR(res, hac4, buf, haclen4);
	ENDT(4, res);
#endif

	BEGINT(5);
	memcpy(buf, p5, plen5);
	aes_gcm_encrypt(k5, klen5, n5, nlen5, a5, alen5, buf, plen5,
		tag, sizeof(tag));

	res = !memcmp(c5, buf, plen5) ? OK : ERR;
	if (res != OK) {
		CTXT_ERR(res, c5, buf, plen5);
	} else {
		res = !memcmp(tag, t5, tlen5) ? OK : ERR;
		if (res != OK) 
			TAG_ERR(res, t5, tag, tlen5);
	}
	ENDT(5, res);

	BEGINT(6);
	memcpy(buf, p5, plen5);
	aes_gcm_encrypt(k5, klen5, n6, nlen6, a5, alen5, buf, plen5,
		tag, sizeof(tag));

	res = !memcmp(c6, buf, plen5) ? OK : ERR;
	if (res != OK) {
		CTXT_ERR(res, c6, buf, plen5);
	} else {
		res = !memcmp(tag, t6, tlen6) ? OK : ERR;
		if (res != OK) 
			TAG_ERR(res, t6, tag, tlen6);
	}
	ENDT(6, res);


	BEGINT(7);
	memcpy(buf, c6, plen5);
    res = aes_gcm_decrypt(k5, klen5, n6, nlen6, a5, alen5, buf, plen5,
		t6, tlen6) ? OK : ERR;
	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
    	res = !memcmp(p5, buf, plen5) ? OK : ERR;
    	if (res != OK)
        	PTXT_ERR(res, p5, buf, plen5);
	}
	ENDT(7, res);

	BEGINT(8);
	memcpy(buf, p5, plen5);
    res = aes_gcm_verify(k5, klen5, n6, nlen6, a5, alen5, buf, plen5,
		t6, tlen6) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
    ENDT(8, res);

	BEGINT(9);
	memcpy(buf, p5, plen5);
    aes_gcm_mac(k5, klen5,  n6, nlen6, a5, alen5, buf, plen5,
		tag, sizeof(tag));

	res = !memcmp(tag, t6, tlen6) ? OK : ERR;
    if (res != OK)
    	TAG_ERR(res, t6, tag, tlen6);
    ENDT(9, res);

	BEGINT(10);
	/* validate encrypt */
	memcpy(buf, p10, plen10)	;
	aes_gcm_encrypt(k10, klen10, n10, nlen10, a10, alen10, buf, plen10,
		tag, sizeof(tag));

	res = !memcmp(c10, buf, plen10) ? OK : ERR;
    if (res != OK) {
        CTXT_ERR(res, c10, buf, plen10);
	} else {
		res = !memcmp(tag, t10, tlen10) ? OK : ERR;
		if (res != OK)
			TAG_ERR(res, t10, tag, tlen10);
	}

	/* validate (just) mac  */
	memcpy(buf, p10, plen10);
	aes_gcm_mac(k10, klen10, n10, nlen10, a10, alen10, buf, plen10,
		tag, sizeof(tag));
	res = !memcmp(tag, t10, tlen10) ? OK : ERR;
	if (res != OK)
            TAG_ERR(res, t10, tag, tlen10);

	/* validate decrypt */
	memcpy(buf, c10, clen10);
	res = aes_gcm_decrypt(k10, klen10, n10, nlen10, a10, alen10, buf, clen10,
		t10, tlen10) ? OK : ERR;

	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
		res = !memcmp(p10, buf, plen10) ? OK : ERR;
    	if (res != OK) {
        	PTXT_ERR(res, p10, buf, plen10);
    	} 
	}

	/* validate verify */
	memcpy(buf, p10, plen10);
    res = aes_gcm_verify(k10, klen10, n10, nlen10, a10, alen10, buf, plen10,
        t10, tlen10) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
	ENDT(10, res);

	BEGINT(11);
	/* validate encrypt */
	memcpy(buf, p10, plen10)	;
	aes_gcm_encrypt(k11, klen11, n10, nlen10, a10, alen10, buf, plen10,
		tag, sizeof(tag));

	res = !memcmp(c11, buf, plen10) ? OK : ERR;
    if (res != OK) {
        CTXT_ERR(res, c11, buf, plen10);
	} else {
		res = !memcmp(tag, t11, tlen11) ? OK : ERR;
		if (res != OK)
			TAG_ERR(res, t11, tag, tlen11);
	}

	/* validate (just) mac  */
	memcpy(buf, p10, plen10);
	aes_gcm_mac(k11, klen11, n10, nlen10, a10, alen10, buf, plen10,
		tag, sizeof(tag));
	res = !memcmp(tag, t11, tlen11) ? OK : ERR;
	if (res != OK)
            TAG_ERR(res, t11, tag, tlen11);

	/* validate decrypt */
	memcpy(buf, c11, clen11);
	res = aes_gcm_decrypt(k11, klen11, n10, nlen10, a10, alen10, buf, clen11,
		t11, tlen11) ? OK : ERR;

	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
		res = !memcmp(p10, buf, plen10) ? OK : ERR;
    	if (res != OK) {
        	PTXT_ERR(res, p10, buf, plen10);
    	} 
	}

	/* validate verify */
	memcpy(buf, p10, plen10);
    res = aes_gcm_verify(k11, klen11, n10, nlen10, a10, alen10, buf, plen10,
        t11, tlen11) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
	ENDT(11, res);

	BEGINT(12);
	/* validate encrypt */
	memcpy(buf, p12, plen12)	;
	aes_gcm_encrypt(k12, klen12, n12, nlen12, a12, alen12, buf, plen12,
		tag, sizeof(tag));

	res = !memcmp(c12, buf, plen12) ? OK : ERR;
    if (res != OK) {
        CTXT_ERR(res, c12, buf, plen12);
	} else {
		res = !memcmp(tag, t12, tlen12) ? OK : ERR;
		if (res != OK)
			TAG_ERR(res, t12, tag, tlen12);
	}

	/* validate (just) mac  */
	memcpy(buf, p12, plen12);
	aes_gcm_mac(k12, klen12, n12, nlen12, a12, alen12, buf, plen12,
		tag, sizeof(tag));
	res = !memcmp(tag, t12, tlen12) ? OK : ERR;
	if (res != OK)
            TAG_ERR(res, t12, tag, tlen12);

	/* validate decrypt */
	memcpy(buf, c12, clen12);
	res = aes_gcm_decrypt(k12, klen12, n12, nlen12, a12, alen12, buf, clen12,
		t12, tlen12) ? OK : ERR;

	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
		res = !memcmp(p12, buf, plen12) ? OK : ERR;
    	if (res != OK) {
        	PTXT_ERR(res, p12, buf, plen12);
    	} 
	}

	/* validate verify */
	memcpy(buf, p12, plen12);
    res = aes_gcm_verify(k12, klen12, n12, nlen12, a12, alen12, buf, plen12,
        t12, tlen12) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
	ENDT(12, res);

	BEGINT(13);
	/* validate encrypt */
	memcpy(buf, p12, plen12)	;
	aes_gcm_encrypt(k13, klen13, n12, nlen12, a12, alen12, buf, plen12,
		tag, sizeof(tag));

	res = !memcmp(c13, buf, plen12) ? OK : ERR;
    if (res != OK) {
        CTXT_ERR(res, c13, buf, plen12);
	} else {
		res = !memcmp(tag, t13, tlen13) ? OK : ERR;
		if (res != OK)
			TAG_ERR(res, t13, tag, tlen13);
	}

	/* validate (just) mac  */
	memcpy(buf, p12, plen12);
	aes_gcm_mac(k13, klen13, n12, nlen12, a12, alen12, buf, plen12,
		tag, sizeof(tag));
	res = !memcmp(tag, t13, tlen13) ? OK : ERR;
	if (res != OK)
            TAG_ERR(res, t13, tag, tlen13);

	/* validate decrypt */
	memcpy(buf, c13, clen13);
	res = aes_gcm_decrypt(k13, klen13, n12, nlen12, a12, alen12, buf, clen12,
		t13, tlen13) ? OK : ERR;

	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
		res = !memcmp(p12, buf, plen12) ? OK : ERR;
    	if (res != OK) {
        	PTXT_ERR(res, p12, buf, plen12);
    	} 
	}

	/* validate verify */
	memcpy(buf, p12, plen12);
    res = aes_gcm_verify(k13, klen13, n12, nlen12, a12, alen12, buf, plen12,
        t13, tlen13) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
	ENDT(13, res);

	BEGINT(14);
	/* validate encrypt */
	memcpy(buf, p14, plen14)	;
	aes_gcm_encrypt(k14, klen14, n14, nlen14, a14, alen14, buf, plen14,
		tag, sizeof(tag));

	res = !memcmp(c14, buf, plen14) ? OK : ERR;
    if (res != OK) {
        CTXT_ERR(res, c14, buf, plen14);
	} else {
		res = !memcmp(tag, t14, tlen14) ? OK : ERR;
		if (res != OK)
			TAG_ERR(res, t14, tag, tlen14);
	}

	/* validate (just) mac  */
	memcpy(buf, p14, plen14);
	aes_gcm_mac(k14, klen14, n14, nlen14, a14, alen14, buf, plen14,
		tag, sizeof(tag));
	res = !memcmp(tag, t14, tlen14) ? OK : ERR;
	if (res != OK)
            TAG_ERR(res, t14, tag, tlen14);

	/* validate decrypt */
	memcpy(buf, c14, clen14);
	res = aes_gcm_decrypt(k14, klen14, n14, nlen14, a14, alen14, buf, clen14,
		t14, tlen14) ? OK : ERR;

	if (res != OK) {
		DBG("aes_gcm_decrypt returned error", NULL, 0);
	} else {
		res = !memcmp(p14, buf, plen14) ? OK : ERR;
    	if (res != OK) {
        	PTXT_ERR(res, p14, buf, plen14);
    	} 
	}

	/* validate verify */
	memcpy(buf, p14, plen14);
    res = aes_gcm_verify(k14, klen14, n14, nlen14, a14, alen14, buf, plen14,
        t14, tlen14) ? OK : ERR;
    if (res != OK) {
		DBG("aes_gcm_verify returned error", NULL, 0);
	}
	ENDT(14, res);

	return 0;
}

#ifdef DEBUG
void dbgprint(const char* pfx, const uint8* buf, size_t len, int line)
{
	int i;
	printf("%d: %s: begin\n%s", line, pfx, (len ? "  " : ""));
	for (i = 0; i < len; ++i) {
		if (i != 0 && i%16 == 0)
			printf("  ");
		printf("%02x ", buf[i]);
		if ((i+1)%16 == 0)
			printf("\n");
	}
	if (len%16 != 0)
		printf("\n");
	printf("%d: %s: end\n", line, pfx );
}
#endif
