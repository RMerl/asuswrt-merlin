
config PRINTK_TIME
	bool "Show timing information on printks"
	depends on PRINTK
	help
	  Selecting this option causes timing information to be
	  included in printk output.  This allows you to measure
	  the interval between kernel operations, including bootup
	  operations.  This is useful for identifying long delays
	  in kernel startup.

config ENABLE_WARN_DEPRECATED
	bool "Enable __deprecated logic"
	default y
	help
	  Enable the __deprecated logic in the kernel build.
	  Disable this to suppress the "warning: 'foo' is deprecated
	  (declared at kernel/power/somefile.c:1234)" messages.

config ENABLE_MUST_CHECK
	bool "Enable __must_check logic"
	default y
	help
	  Enable the __must_check logic in the kernel build.  Disable this to
	  suppress the "warning: ignoring return value of 'foo', declared with
	  attribute warn_unused_result" messages.

config FRAME_WARN
	int "Warn for stack frames larger than (needs gcc 4.4)"
	range 0 8192
	default 1024 if !64BIT
	default 2048 if 64BIT
	help
	  Tell gcc to warn at build time for stack frames larger than this.
	  Setting this too low will cause a lot of warnings.
	  Setting it to 0 disables the warning.
	  Requires gcc 4.4

config MAGIC_SYSRQ
	bool "Magic SysRq key"
	depends on !UML
	help
	  If you say Y here, you will have some control over the system even
	  if the system crashes for example during kernel debugging (e.g., you
	  will be able to flush the buffer cache to disk, reboot the system
	  immediately or dump some status information). This is accomplished
	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
	  also works on a serial console (on PC hardware at least), if you
	  send a BREAK and then within 5 seconds a command keypress. The
	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
	  unless you really know what this hack does.

config STRIP_ASM_SYMS
	bool "Strip assembler-generated symbols during link"
	default n
	help
	  Strip internal assembler-generated symbols during a link (symbols
	  that look like '.Lxxx') so they don't pollute the output of
	  get_wchan() and suchlike.

config UNUSED_SYMBOLS
	bool "Enable unused/obsolete exported symbols"
	default y if X86
	help
	  Unused but exported symbols make the kernel needlessly bigger.  For
	  that reason most of these unused exports will soon be removed.  This
	  option is provided temporarily to provide a transition period in case
	  some external kernel module needs one of these symbols anyway. If you
	  encounter such a case in your module, consider if you are actually
	  using the right API.  (rationale: since nobody in the kernel is using
	  this in a module, there is a pretty good chance it's actually the
	  wrong interface to use).  If you really need the symbol, please send a
	  mail to the linux kernel mailing list mentioning the symbol and why
	  you really need it, and what the merge plan to the mainline kernel for
	  your module is.

config DEBUG_FS
	bool "Debug Filesystem"
	help
	  debugfs is a virtual file system that kernel developers use to put
	  debugging files into.  Enable this option to be able to read and
	  write to these files.

	  For detailed documentation on the debugfs API, see
	  Documentation/DocBook/filesystems.

	  If unsure, say N.

config HEADERS_CHECK
	bool "Run 'make headers_check' when building vmlinux"
	depends on !UML
	help
	  This option will extract the user-visible kernel headers whenever
	  building the kernel, and will run basic sanity checks on them to
	  ensure that exported files do not attempt to include files which
	  were not exported, etc.

	  If you're making modifications to header files which are
	  relevant for userspace, say 'Y', and check the headers
	  exported to $(INSTALL_HDR_PATH) (usually 'usr/include' in
	  your build tree), to make sure they're suitable.

config DEBUG_SECTION_MISMATCH
	bool "Enable full Section mismatch analysis"
	depends on UNDEFINED || (BLACKFIN)
	default y
	# This option is on purpose disabled for now.
	# It will be enabled when we are down to a reasonable number
	# of section mismatch warnings (< 10 for an allyesconfig build)
	help
	  The section mismatch analysis checks if there are illegal
	  references from one section to another section.
	  Linux will during link or during runtime drop some sections
	  and any use of code/data previously in these sections will
	  most likely result in an oops.
	  In the code functions and variables are annotated with
	  __init, __devinit etc. (see full list in include/linux/init.h)
	  which results in the code/data being placed in specific sections.
	  The section mismatch analysis is always done after a full
	  kernel build but enabling this option will in addition
	  do the following:
	  - Add the option -fno-inline-functions-called-once to gcc
	    When inlining a function annotated __init in a non-init
	    function we would lose the section information and thus
	    the analysis would not catch the illegal reference.
	    This option tells gcc to inline less but will also
	    result in a larger kernel.
	  - Run the section mismatch analysis for each module/built-in.o
	    When we run the section mismatch analysis on vmlinux.o we
	    lose valueble information about where the mismatch was
	    introduced.
	    Running the analysis for each module/built-in.o file
	    will tell where the mismatch happens much closer to the
	    source. The drawback is that we will report the same
	    mismatch at least twice.
	  - Enable verbose reporting from modpost to help solving
	    the section mismatches reported.

config DEBUG_KERNEL
	bool "Kernel debugging"
	help
	  Say Y here if you are developing drivers or trying to debug and
	  identify kernel problems.

config DEBUG_SHIRQ
	bool "Debug shared IRQ handlers"
	depends on DEBUG_KERNEL && GENERIC_HARDIRQS
	help
	  Enable this to generate a spurious interrupt as soon as a shared
	  interrupt handler is registered, and just before one is deregistered.
	  Drivers ought to be able to handle interrupts coming in at those
	  points; some don't and need to be caught.

config LOCKUP_DETECTOR
	bool "Detect Hard and Soft Lockups"
	depends on DEBUG_KERNEL && !S390
	help
	  Say Y here to enable the kernel to act as a watchdog to detect
	  hard and soft lockups.

	  Softlockups are bugs that cause the kernel to loop in kernel
	  mode for more than 60 seconds, without giving other tasks a
	  chance to run.  The current stack trace is displayed upon
	  detection and the system will stay locked up.

	  Hardlockups are bugs that cause the CPU to loop in kernel mode
	  for more than 60 seconds, without letting other interrupts have a
	  chance to run.  The current stack trace is displayed upon detection
	  and the system will stay locked up.

	  The overhead should be minimal.  A periodic hrtimer runs to
	  generate interrupts and kick the watchdog task every 10-12 seconds.
	  An NMI is generated every 60 seconds or so to check for hardlockups.

config HARDLOCKUP_DETECTOR
	def_bool LOCKUP_DETECTOR && PERF_EVENTS && HAVE_PERF_EVENTS_NMI

config BOOTPARAM_SOFTLOCKUP_PANIC
	bool "Panic (Reboot) On Soft Lockups"
	depends on LOCKUP_DETECTOR
	help
	  Say Y here to enable the kernel to panic on "soft lockups",
	  which are bugs that cause the kernel to loop in kernel
	  mode for more than 60 seconds, without giving other tasks a
	  chance to run.

	  The panic can be used in combination with panic_timeout,
	  to cause the system to reboot automatically after a
	  lockup has been detected. This feature is useful for
	  high-availability systems that have uptime guarantees and
	  where a lockup must be resolved ASAP.

	  Say N if unsure.

config BOOTPARAM_SOFTLOCKUP_PANIC_VALUE
	int
	depends on LOCKUP_DETECTOR
	range 0 1
	default 0 if !BOOTPARAM_SOFTLOCKUP_PANIC
	default 1 if BOOTPARAM_SOFTLOCKUP_PANIC

config DETECT_HUNG_TASK
	bool "Detect Hung Tasks"
	depends on DEBUG_KERNEL
	default DETECT_SOFTLOCKUP
	help
	  Say Y here to enable the kernel to detect "hung tasks",
	  which are bugs that cause the task to be stuck in
	  uninterruptible "D" state indefinitiley.

	  When a hung task is detected, the kernel will print the
	  current stack trace (which you should report), but the
	  task will stay in uninterruptible state. If lockdep is
	  enabled then all held locks will also be reported. This
	  feature has negligible overhead.

config BOOTPARAM_HUNG_TASK_PANIC
	bool "Panic (Reboot) On Hung Tasks"
	depends on DETECT_HUNG_TASK
	help
	  Say Y here to enable the kernel to panic on "hung tasks",
	  which are bugs that cause the kernel to leave a task stuck
	  in uninterruptible "D" state.

	  The panic can be used in combination with panic_timeout,
	  to cause the system to reboot automatically after a
	  hung task has been detected. This feature is useful for
	  high-availability systems that have uptime guarantees and
	  where a hung tasks must be resolved ASAP.

	  Say N if unsure.

config BOOTPARAM_HUNG_TASK_PANIC_VALUE
	int
	depends on DETECT_HUNG_TASK
	range 0 1
	default 0 if !BOOTPARAM_HUNG_TASK_PANIC
	default 1 if BOOTPARAM_HUNG_TASK_PANIC

config SCHED_DEBUG
	bool "Collect scheduler debugging info"
	depends on DEBUG_KERNEL && PROC_FS
	default y
	help
	  If you say Y here, the /proc/sched_debug file will be provided
	  that can help debug the scheduler. The runtime overhead of this
	  option is minimal.

config SCHEDSTATS
	bool "Collect scheduler statistics"
	depends on DEBUG_KERNEL && PROC_FS
	help
	  If you say Y here, additional code will be inserted into the
	  scheduler and related routines to collect statistics about
	  scheduler behavior and provide them in /proc/schedstat.  These
	  stats may be useful for both tuning and debugging the scheduler
	  If you aren't debugging the scheduler or trying to tune a specific
	  application, you can say N to avoid the very slight overhead
	  this adds.

config TIMER_STATS
	bool "Collect kernel timers statistics"
	depends on DEBUG_KERNEL && PROC_FS
	help
	  If you say Y here, additional code will be inserted into the
	  timer routines to collect statistics about kernel timers being
	  reprogrammed. The statistics can be read from /proc/timer_stats.
	  The statistics collection is started by writing 1 to /proc/timer_stats,
	  writing 0 stops it. This feature is useful to collect information
	  about timer usage patterns in kernel and userspace. This feature
	  is lightweight if enabled in the kernel config but not activated
	  (it defaults to deactivated on bootup and will only be activated
	  if some application like powertop activates it explicitly).

config DEBUG_OBJECTS
	bool "Debug object operations"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, additional code will be inserted into the
	  kernel to track the life time of various objects and validate
	  the operations on those objects.

config DEBUG_OBJECTS_SELFTEST
	bool "Debug objects selftest"
	depends on DEBUG_OBJECTS
	help
	  This enables the selftest of the object debug code.

config DEBUG_OBJECTS_FREE
	bool "Debug objects in freed memory"
	depends on DEBUG_OBJECTS
	help
	  This enables checks whether a k/v free operation frees an area
	  which contains an object which has not been deactivated
	  properly. This can make kmalloc/kfree-intensive workloads
	  much slower.

config DEBUG_OBJECTS_TIMERS
	bool "Debug timer objects"
	depends on DEBUG_OBJECTS
	help
	  If you say Y here, additional code will be inserted into the
	  timer routines to track the life time of timer objects and
	  validate the timer operations.

config DEBUG_OBJECTS_WORK
	bool "Debug work objects"
	depends on DEBUG_OBJECTS
	help
	  If you say Y here, additional code will be inserted into the
	  work queue routines to track the life time of work objects and
	  validate the work operations.

config DEBUG_OBJECTS_RCU_HEAD
	bool "Debug RCU callbacks objects"
	depends on DEBUG_OBJECTS && PREEMPT
	help
	  Enable this to turn on debugging of RCU list heads (call_rcu() usage).

config DEBUG_OBJECTS_ENABLE_DEFAULT
	int "debug_objects bootup default value (0-1)"
        range 0 1
        default "1"
        depends on DEBUG_OBJECTS
        help
          Debug objects boot parameter default value

config DEBUG_SLAB
	bool "Debug slab memory allocations"
	depends on DEBUG_KERNEL && SLAB && !KMEMCHECK
	help
	  Say Y here to have the kernel do limited verification on memory
	  allocation as well as poisoning memory on free to catch use of freed
	  memory. This can make kmalloc/kfree-intensive workloads much slower.

config DEBUG_SLAB_LEAK
	bool "Memory leak debugging"
	depends on DEBUG_SLAB

config SLUB_DEBUG_ON
	bool "SLUB debugging on by default"
	depends on SLUB && SLUB_DEBUG && !KMEMCHECK
	default n
	help
	  Boot with debugging on by default. SLUB boots by default with
	  the runtime debug capabilities switched off. Enabling this is
	  equivalent to specifying the "slub_debug" parameter on boot.
	  There is no support for more fine grained debug control like
	  possible with slub_debug=xxx. SLUB debugging may be switched
	  off in a kernel built with CONFIG_SLUB_DEBUG_ON by specifying
	  "slub_debug=-".

config SLUB_STATS
	default n
	bool "Enable SLUB performance statistics"
	depends on SLUB && SLUB_DEBUG && SYSFS
	help
	  SLUB statistics are useful to debug SLUBs allocation behavior in
	  order find ways to optimize the allocator. This should never be
	  enabled for production use since keeping statistics slows down
	  the allocator by a few percentage points. The slabinfo command
	  supports the determination of the most active slabs to figure
	  out which slabs are relevant to a particular load.
	  Try running: slabinfo -DA

config DEBUG_KMEMLEAK
	bool "Kernel memory leak detector"
	depends on DEBUG_KERNEL && EXPERIMENTAL && !MEMORY_HOTPLUG && \
		(X86 || ARM || PPC || S390 || SPARC64 || SUPERH || MICROBLAZE)

	select DEBUG_FS if SYSFS
	select STACKTRACE if STACKTRACE_SUPPORT
	select KALLSYMS
	select CRC32
	help
	  Say Y here if you want to enable the memory leak
	  detector. The memory allocation/freeing is traced in a way
	  similar to the Boehm's conservative garbage collector, the
	  difference being that the orphan objects are not freed but
	  only shown in /sys/kernel/debug/kmemleak. Enabling this
	  feature will introduce an overhead to memory
	  allocations. See Documentation/kmemleak.txt for more
	  details.

	  Enabling DEBUG_SLAB or SLUB_DEBUG may increase the chances
	  of finding leaks due to the slab objects poisoning.

	  In order to access the kmemleak file, debugfs needs to be
	  mounted (usually at /sys/kernel/debug).

config DEBUG_KMEMLEAK_EARLY_LOG_SIZE
	int "Maximum kmemleak early log entries"
	depends on DEBUG_KMEMLEAK
	range 200 40000
	default 400
	help
	  Kmemleak must track all the memory allocations to avoid
	  reporting false positives. Since memory may be allocated or
	  freed before kmemleak is initialised, an early log buffer is
	  used to store these actions. If kmemleak reports "early log
	  buffer exceeded", please increase this value.

config DEBUG_KMEMLEAK_TEST
	tristate "Simple test for the kernel memory leak detector"
	depends on DEBUG_KMEMLEAK
	help
	  Say Y or M here to build a test for the kernel memory leak
	  detector. This option enables a module that explicitly leaks
	  memory.

	  If unsure, say N.

config DEBUG_KMEMLEAK_DEFAULT_OFF
	bool "Default kmemleak to off"
	depends on DEBUG_KMEMLEAK
	help
	  Say Y here to disable kmemleak by default. It can then be enabled
	  on the command line via kmemleak=on.

config DEBUG_PREEMPT
	bool "Debug preemptible kernel"
	depends on DEBUG_KERNEL && PREEMPT && TRACE_IRQFLAGS_SUPPORT
	default y
	help
	  If you say Y here then the kernel will use a debug variant of the
	  commonly used smp_processor_id() function and will print warnings
	  if kernel code uses it in a preemption-unsafe way. Also, the kernel
	  will detect preemption count underflows.

config DEBUG_RT_MUTEXES
	bool "RT Mutex debugging, deadlock detection"
	depends on DEBUG_KERNEL && RT_MUTEXES
	help
	 This allows rt mutex semantics violations and rt mutex related
	 deadlocks (lockups) to be detected and reported automatically.

config DEBUG_PI_LIST
	bool
	default y
	depends on DEBUG_RT_MUTEXES

config RT_MUTEX_TESTER
	bool "Built-in scriptable tester for rt-mutexes"
	depends on DEBUG_KERNEL && RT_MUTEXES
	help
	  This option enables a rt-mutex tester.

config DEBUG_SPINLOCK
	bool "Spinlock and rw-lock debugging: basic checks"
	depends on DEBUG_KERNEL
	help
	  Say Y here and build SMP to catch missing spinlock initialization
	  and certain other kinds of spinlock errors commonly made.  This is
	  best used in conjunction with the NMI watchdog so that spinlock
	  deadlocks are also debuggable.

config DEBUG_MUTEXES
	bool "Mutex debugging: basic checks"
	depends on DEBUG_KERNEL
	help
	 This feature allows mutex semantics violations to be detected and
	 reported.

config DEBUG_LOCK_ALLOC
	bool "Lock debugging: detect incorrect freeing of live locks"
	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES
	select LOCKDEP
	help
	 This feature will check whether any held lock (spinlock, rwlock,
	 mutex or rwsem) is incorrectly freed by the kernel, via any of the
	 memory-freeing routines (kfree(), kmem_cache_free(), free_pages(),
	 vfree(), etc.), whether a live lock is incorrectly reinitialized via
	 spin_lock_init()/mutex_init()/etc., or whether there is any lock
	 held during task exit.

config PROVE_LOCKING
	bool "Lock debugging: prove locking correctness"
	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
	select LOCKDEP
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES
	select DEBUG_LOCK_ALLOC
	default n
	help
	 This feature enables the kernel to prove that all locking
	 that occurs in the kernel runtime is mathematically
	 correct: that under no circumstance could an arbitrary (and
	 not yet triggered) combination of observed locking
	 sequences (on an arbitrary number of CPUs, running an
	 arbitrary number of tasks and interrupt contexts) cause a
	 deadlock.

	 In short, this feature enables the kernel to report locking
	 related deadlocks before they actually occur.

	 The proof does not depend on how hard and complex a
	 deadlock scenario would be to trigger: how many
	 participant CPUs, tasks and irq-contexts would be needed
	 for it to trigger. The proof also does not depend on
	 timing: if a race and a resulting deadlock is possible
	 theoretically (no matter how unlikely the race scenario
	 is), it will be proven so and will immediately be
	 reported by the kernel (once the event is observed that
	 makes the deadlock theoretically possible).

	 If a deadlock is impossible (i.e. the locking rules, as
	 observed by the kernel, are mathematically correct), the
	 kernel reports nothing.

	 NOTE: this feature can also be enabled for rwlocks, mutexes
	 and rwsems - in which case all dependencies between these
	 different locking variants are observed and mapped too, and
	 the proof of observed correctness is also maintained for an
	 arbitrary combination of these separate locking variants.

	 For more details, see Documentation/lockdep-design.txt.

config PROVE_RCU
	bool "RCU debugging: prove RCU correctness"
	depends on PROVE_LOCKING
	default n
	help
	 This feature enables lockdep extensions that check for correct
	 use of RCU APIs.  This is currently under development.  Say Y
	 if you want to debug RCU usage or help work on the PROVE_RCU
	 feature.

	 Say N if you are unsure.

config PROVE_RCU_REPEATEDLY
	bool "RCU debugging: don't disable PROVE_RCU on first splat"
	depends on PROVE_RCU
	default n
	help
	 By itself, PROVE_RCU will disable checking upon issuing the
	 first warning (or "splat").  This feature prevents such
	 disabling, allowing multiple RCU-lockdep warnings to be printed
	 on a single reboot.

	 Say N if you are unsure.

config LOCKDEP
	bool
	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
	select STACKTRACE
	select FRAME_POINTER if !MIPS && !PPC && !ARM_UNWIND && !S390 && !MICROBLAZE
	select KALLSYMS
	select KALLSYMS_ALL

config LOCK_STAT
	bool "Lock usage statistics"
	depends on DEBUG_KERNEL && TRACE_IRQFLAGS_SUPPORT && STACKTRACE_SUPPORT && LOCKDEP_SUPPORT
	select LOCKDEP
	select DEBUG_SPINLOCK
	select DEBUG_MUTEXES
	select DEBUG_LOCK_ALLOC
	default n
	help
	 This feature enables tracking lock contention points

	 For more details, see Documentation/lockstat.txt

	 This also enables lock events required by "perf lock",
	 subcommand of perf.
	 If you want to use "perf lock", you also need to turn on
	 CONFIG_EVENT_TRACING.

	 CONFIG_LOCK_STAT defines "contended" and "acquired" lock events.
	 (CONFIG_LOCKDEP defines "acquire" and "release" events.)

config DEBUG_LOCKDEP
	bool "Lock dependency engine debugging"
	depends on DEBUG_KERNEL && LOCKDEP
	help
	  If you say Y here, the lock dependency engine will do
	  additional runtime checks to debug itself, at the price
	  of more runtime overhead.

config TRACE_IRQFLAGS
	depends on DEBUG_KERNEL
	bool
	default y
	depends on TRACE_IRQFLAGS_SUPPORT
	depends on PROVE_LOCKING

config DEBUG_SPINLOCK_SLEEP
	bool "Spinlock debugging: sleep-inside-spinlock checking"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, various routines which may sleep will become very
	  noisy if they are called with a spinlock held.

config DEBUG_LOCKING_API_SELFTESTS
	bool "Locking API boot-time self-tests"
	depends on DEBUG_KERNEL
	help
	  Say Y here if you want the kernel to run a short self-test during
	  bootup. The self-test checks whether common types of locking bugs
	  are detected by debugging mechanisms or not. (if you disable
	  lock debugging then those bugs wont be detected of course.)
	  The following locking APIs are covered: spinlocks, rwlocks,
	  mutexes and rwsems.

config STACKTRACE
	bool
	depends on STACKTRACE_SUPPORT

config DEBUG_KOBJECT
	bool "kobject debugging"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, some extra kobject debugging messages will be sent
	  to the syslog. 

config DEBUG_HIGHMEM
	bool "Highmem debugging"
	depends on DEBUG_KERNEL && HIGHMEM
	help
	  This options enables addition error checking for high memory systems.
	  Disable for production systems.

config DEBUG_BUGVERBOSE
	bool "Verbose BUG() reporting (adds 70K)" if DEBUG_KERNEL && EMBEDDED
	depends on BUG
	depends on ARM || AVR32 || M32R || M68K || SPARC32 || SPARC64 || \
		   FRV || SUPERH || GENERIC_BUG || BLACKFIN || MN10300
	default y
	help
	  Say Y here to make BUG() panics output the file name and line number
	  of the BUG call as well as the EIP and oops trace.  This aids
	  debugging but costs about 70-100K of memory.

config DEBUG_INFO
	bool "Compile the kernel with debug info"
	depends on DEBUG_KERNEL
	help
          If you say Y here the resulting kernel image will include
	  debugging info resulting in a larger kernel image.
	  This adds debug symbols to the kernel and modules (gcc -g), and
	  is needed if you intend to use kernel crashdump or binary object
	  tools like crash, kgdb, LKCD, gdb, etc on the kernel.
	  Say Y here only if you plan to debug the kernel.

	  If unsure, say N.

config DEBUG_INFO_REDUCED
	bool "Reduce debugging information"
	depends on DEBUG_INFO
	help
	  If you say Y here gcc is instructed to generate less debugging
	  information for structure types. This means that tools that
	  need full debugging information (like kgdb or systemtap) won't
	  be happy. But if you merely need debugging information to
	  resolve line numbers there is no loss. Advantage is that
	  build directory object sizes shrink dramatically over a full
	  DEBUG_INFO build and compile times are reduced too.
	  Only works with newer gcc versions.

config DEBUG_VM
	bool "Debug VM"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the virtual-memory system
          that may impact performance.

	  If unsure, say N.

config DEBUG_VIRTUAL
	bool "Debug VM translations"
	depends on DEBUG_KERNEL && X86
	help
	  Enable some costly sanity checks in virtual to page code. This can
	  catch mistakes with virt_to_page() and friends.

	  If unsure, say N.

config DEBUG_NOMMU_REGIONS
	bool "Debug the global anon/private NOMMU mapping region tree"
	depends on DEBUG_KERNEL && !MMU
	help
	  This option causes the global tree of anonymous and private mapping
	  regions to be regularly checked for invalid topology.

config DEBUG_WRITECOUNT
	bool "Debug filesystem writers count"
	depends on DEBUG_KERNEL
	help
	  Enable this to catch wrong use of the writers count in struct
	  vfsmount.  This will increase the size of each file struct by
	  32 bits.

	  If unsure, say N.

config DEBUG_MEMORY_INIT
	bool "Debug memory initialisation" if EMBEDDED
	default !EMBEDDED
	help
	  Enable this for additional checks during memory initialisation.
	  The sanity checks verify aspects of the VM such as the memory model
	  and other information provided by the architecture. Verbose
	  information will be printed at KERN_DEBUG loglevel depending
	  on the mminit_loglevel= command-line option.

	  If unsure, say Y

config DEBUG_LIST
	bool "Debug linked list manipulation"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on extended checks in the linked-list
	  walking routines.

	  If unsure, say N.

config DEBUG_SG
	bool "Debug SG table operations"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on checks on scatter-gather tables. This can
	  help find problems with drivers that do not properly initialize
	  their sg tables.

	  If unsure, say N.

config DEBUG_NOTIFIERS
	bool "Debug notifier call chains"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on sanity checking for notifier call chains.
	  This is most useful for kernel developers to make sure that
	  modules properly unregister themselves from notifier chains.
	  This is a relatively cheap check but if you care about maximum
	  performance, say N.

config DEBUG_CREDENTIALS
	bool "Debug credential management"
	depends on DEBUG_KERNEL
	help
	  Enable this to turn on some debug checking for credential
	  management.  The additional code keeps track of the number of
	  pointers from task_structs to any given cred struct, and checks to
	  see that this number never exceeds the usage count of the cred
	  struct.

	  Furthermore, if SELinux is enabled, this also checks that the
	  security pointer in the cred struct is never seen to be invalid.

	  If unsure, say N.

#
# Select this config option from the architecture Kconfig, if it
# it is preferred to always offer frame pointers as a config
# option on the architecture (regardless of KERNEL_DEBUG):
#
config ARCH_WANT_FRAME_POINTERS
	bool
	help

config FRAME_POINTER
	bool "Compile the kernel with frame pointers"
	depends on DEBUG_KERNEL && \
		(CRIS || M68K || M68KNOMMU || FRV || UML || \
		 AVR32 || SUPERH || BLACKFIN || MN10300) || \
		ARCH_WANT_FRAME_POINTERS
	default y if (DEBUG_INFO && UML) || ARCH_WANT_FRAME_POINTERS
	help
	  If you say Y here the resulting kernel image will be slightly
	  larger and slower, but it gives very useful debugging information
	  in case of kernel bugs. (precise oopses/stacktraces/warnings)

config BOOT_PRINTK_DELAY
	bool "Delay each boot printk message by N milliseconds"
	depends on DEBUG_KERNEL && PRINTK && GENERIC_CALIBRATE_DELAY
	help
	  This build option allows you to read kernel boot messages
	  by inserting a short delay after each one.  The delay is
	  specified in milliseconds on the kernel command line,
	  using "boot_delay=N".

	  It is likely that you would also need to use "lpj=M" to preset
	  the "loops per jiffie" value.
	  See a previous boot log for the "lpj" value to use for your
	  system, and then set "lpj=M" before setting "boot_delay=N".
	  NOTE:  Using this option may adversely affect SMP systems.
	  I.e., processors other than the first one may not boot up.
	  BOOT_PRINTK_DELAY also may cause DETECT_SOFTLOCKUP to detect
	  what it believes to be lockup conditions.

config RCU_TORTURE_TEST
	tristate "torture tests for RCU"
	depends on DEBUG_KERNEL
	default n
	help
	  This option provides a kernel module that runs torture tests
	  on the RCU infrastructure.  The kernel module may be built
	  after the fact on the running kernel to be tested, if desired.

	  Say Y here if you want RCU torture tests to be built into
	  the kernel.
	  Say M if you want the RCU torture tests to build as a module.
	  Say N if you are unsure.

config RCU_TORTURE_TEST_RUNNABLE
	bool "torture tests for RCU runnable by default"
	depends on RCU_TORTURE_TEST = y
	default n
	help
	  This option provides a way to build the RCU torture tests
	  directly into the kernel without them starting up at boot
	  time.  You can use /proc/sys/kernel/rcutorture_runnable
	  to manually override this setting.  This /proc file is
	  available only when the RCU torture tests have been built
	  into the kernel.

	  Say Y here if you want the RCU torture tests to start during
	  boot (you probably don't).
	  Say N here if you want the RCU torture tests to start only
	  after being manually enabled via /proc.

config RCU_CPU_STALL_DETECTOR
	bool "Check for stalled CPUs delaying RCU grace periods"
	depends on TREE_RCU || TREE_PREEMPT_RCU
	default y
	help
	  This option causes RCU to printk information on which
	  CPUs are delaying the current grace period, but only when
	  the grace period extends for excessive time periods.

	  Say N if you want to disable such checks.

	  Say Y if you are unsure.

config RCU_CPU_STALL_VERBOSE
	bool "Print additional per-task information for RCU_CPU_STALL_DETECTOR"
	depends on RCU_CPU_STALL_DETECTOR && TREE_PREEMPT_RCU
	default y
	help
	  This option causes RCU to printk detailed per-task information
	  for any tasks that are stalling the current RCU grace period.

	  Say N if you are unsure.

	  Say Y if you want to enable such checks.

config KPROBES_SANITY_TEST
	bool "Kprobes sanity tests"
	depends on DEBUG_KERNEL
	depends on KPROBES
	default n
	help
	  This option provides for testing basic kprobes functionality on
	  boot. A sample kprobe, jprobe and kretprobe are inserted and
	  verified for functionality.

	  Say N if you are unsure.

config BACKTRACE_SELF_TEST
	tristate "Self test for the backtrace code"
	depends on DEBUG_KERNEL
	default n
	help
	  This option provides a kernel module that can be used to test
	  the kernel stack backtrace code. This option is not useful
	  for distributions or general kernels, but only for kernel
	  developers working on architecture code.

	  Note that if you want to also test saved backtraces, you will
	  have to enable STACKTRACE as well.

	  Say N if you are unsure.

config DEBUG_BLOCK_EXT_DEVT
        bool "Force extended block device numbers and spread them"
	depends on DEBUG_KERNEL
	depends on BLOCK
	default n
	help
	  BIG FAT WARNING: ENABLING THIS OPTION MIGHT BREAK BOOTING ON
	  SOME DISTRIBUTIONS.  DO NOT ENABLE THIS UNLESS YOU KNOW WHAT
	  YOU ARE DOING.  Distros, please enable this and fix whatever
	  is broken.

	  Conventionally, block device numbers are allocated from
	  predetermined contiguous area.  However, extended block area
	  may introduce non-contiguous block device numbers.  This
	  option forces most block device numbers to be allocated from
	  the extended space and spreads them to discover kernel or
	  userland code paths which assume predetermined contiguous
	  device number allocation.

	  Note that turning on this debug option shuffles all the
	  device numbers for all IDE and SCSI devices including libata
	  ones, so root partition specified using device number
	  directly (via rdev or root=MAJ:MIN) won't work anymore.
	  Textual device names (root=/dev/sdXn) will continue to work.

	  Say N if you are unsure.

config DEBUG_FORCE_WEAK_PER_CPU
	bool "Force weak per-cpu definitions"
	depends on DEBUG_KERNEL
	help
	  s390 and alpha require percpu variables in modules to be
	  defined weak to work around addressing range issue which
	  puts the following two restrictions on percpu variable
	  definitions.

	  1. percpu symbols must be unique whether static or not
	  2. percpu variables can't be defined inside a function

	  To ensure that generic code follows the above rules, this
	  option forces all percpu variables to be defined as weak.

config LKDTM
	tristate "Linux Kernel Dump Test Tool Module"
	depends on DEBUG_FS
	depends on BLOCK
	default n
	help
	This module enables testing of the different dumping mechanisms by
	inducing system failures at predefined crash points.
	If you don't need it: say N
	Choose M here to compile this code as a module. The module will be
	called lkdtm.

	Documentation on how to use the module can be found in
	Documentation/fault-injection/provoke-crashes.txt

config CPU_NOTIFIER_ERROR_INJECT
	tristate "CPU notifier error injection module"
	depends on HOTPLUG_CPU && DEBUG_KERNEL
	help
	  This option provides a kernel module that can be used to test
	  the error handling of the cpu notifiers

	  To compile this code as a module, choose M here: the module will
	  be called cpu-notifier-error-inject.

	  If unsure, say N.

config FAULT_INJECTION
	bool "Fault-injection framework"
	depends on DEBUG_KERNEL
	help
	  Provide fault-injection framework.
	  For more details, see Documentation/fault-injection/.

config FAILSLAB
	bool "Fault-injection capability for kmalloc"
	depends on FAULT_INJECTION
	depends on SLAB || SLUB
	help
	  Provide fault-injection capability for kmalloc.

config FAIL_PAGE_ALLOC
	bool "Fault-injection capabilitiy for alloc_pages()"
	depends on FAULT_INJECTION
	help
	  Provide fault-injection capability for alloc_pages().

config FAIL_MAKE_REQUEST
	bool "Fault-injection capability for disk IO"
	depends on FAULT_INJECTION && BLOCK
	help
	  Provide fault-injection capability for disk IO.

config FAIL_IO_TIMEOUT
	bool "Fault-injection capability for faking disk interrupts"
	depends on FAULT_INJECTION && BLOCK
	help
	  Provide fault-injection capability on end IO handling. This
	  will make the block layer "forget" an interrupt as configured,
	  thus exercising the error handling.

	  Only works with drivers that use the generic timeout handling,
	  for others it wont do anything.

config FAULT_INJECTION_DEBUG_FS
	bool "Debugfs entries for fault-injection capabilities"
	depends on FAULT_INJECTION && SYSFS && DEBUG_FS
	help
	  Enable configuration of fault-injection capabilities via debugfs.

config FAULT_INJECTION_STACKTRACE_FILTER
	bool "stacktrace filter for fault-injection capabilities"
	depends on FAULT_INJECTION_DEBUG_FS && STACKTRACE_SUPPORT
	depends on !X86_64
	select STACKTRACE
	select FRAME_POINTER if !PPC && !S390 && !MICROBLAZE
	help
	  Provide stacktrace filter for fault-injection capabilities

config LATENCYTOP
	bool "Latency measuring infrastructure"
	depends on HAVE_LATENCYTOP_SUPPORT
	depends on DEBUG_KERNEL
	depends on STACKTRACE_SUPPORT
	depends on PROC_FS
	select FRAME_POINTER if !MIPS && !PPC && !S390 && !MICROBLAZE
	select KALLSYMS
	select KALLSYMS_ALL
	select STACKTRACE
	select SCHEDSTATS
	select SCHED_DEBUG
	help
	  Enable this option if you want to use the LatencyTOP tool
	  to find out which userspace is blocking on what kernel operations.

config SYSCTL_SYSCALL_CHECK
	bool "Sysctl checks"
	depends on SYSCTL
	---help---
	  sys_sysctl uses binary paths that have been found challenging
	  to properly maintain and use. This enables checks that help
	  you to keep things correct.

source mm/Kconfig.debug
source kernel/trace/Kconfig

config PROVIDE_OHCI1394_DMA_INIT
	bool "Remote debugging over FireWire early on boot"
	depends on PCI && X86
	help
	  If you want to debug problems which hang or crash the kernel early
	  on boot and the crashing machine has a FireWire port, you can use
	  this feature to remotely access the memory of the crashed machine
	  over FireWire. This employs remote DMA as part of the OHCI1394
	  specification which is now the standard for FireWire controllers.

	  With remote DMA, you can monitor the printk buffer remotely using
	  firescope and access all memory below 4GB using fireproxy from gdb.
	  Even controlling a kernel debugger is possible using remote DMA.

	  Usage:

	  If ohci1394_dma=early is used as boot parameter, it will initialize
	  all OHCI1394 controllers which are found in the PCI config space.

	  As all changes to the FireWire bus such as enabling and disabling
	  devices cause a bus reset and thereby disable remote DMA for all
	  devices, be sure to have the cable plugged and FireWire enabled on
	  the debugging host before booting the debug target for debugging.

	  This code (~1k) is freed after boot. By then, the firewire stack
	  in charge of the OHCI-1394 controllers should be used instead.

	  See Documentation/debugging-via-ohci1394.txt for more information.

config FIREWIRE_OHCI_REMOTE_DMA
	bool "Remote debugging over FireWire with firewire-ohci"
	depends on FIREWIRE_OHCI
	help
	  This option lets you use the FireWire bus for remote debugging
	  with help of the firewire-ohci driver. It enables unfiltered
	  remote DMA in firewire-ohci.
	  See Documentation/debugging-via-ohci1394.txt for more information.

	  If unsure, say N.

config BUILD_DOCSRC
	bool "Build targets in Documentation/ tree"
	depends on HEADERS_CHECK
	help
	  This option attempts to build objects from the source files in the
	  kernel Documentation/ tree.

	  Say N if you are unsure.

config DYNAMIC_DEBUG
	bool "Enable dynamic printk() support"
	default n
	depends on PRINTK
	depends on DEBUG_FS
	help

	  Compiles debug level messages into the kernel, which would not
	  otherwise be available at runtime. These messages can then be
	  enabled/disabled based on various levels of scope - per source file,
	  function, module, format string, and line number. This mechanism
	  implicitly enables all pr_debug() and dev_dbg() calls. The impact of
	  this compile option is a larger kernel text size of about 2%.

	  Usage:

	  Dynamic debugging is controlled via the 'dynamic_debug/control' file,
	  which is contained in the 'debugfs' filesystem. Thus, the debugfs
	  filesystem must first be mounted before making use of this feature.
	  We refer the control file as: <debugfs>/dynamic_debug/control. This
	  file contains a list of the debug statements that can be enabled. The
	  format for each line of the file is:

		filename:lineno [module]function flags format

	  filename : source file of the debug statement
	  lineno : line number of the debug statement
	  module : module that contains the debug statement
	  function : function that contains the debug statement
          flags : 'p' means the line is turned 'on' for printing
          format : the format used for the debug statement

	  From a live system:

		nullarbor:~ # cat <debugfs>/dynamic_debug/control
		# filename:lineno [module]function flags format
		fs/aio.c:222 [aio]__put_ioctx - "__put_ioctx:\040freeing\040%p\012"
		fs/aio.c:248 [aio]ioctx_alloc - "ENOMEM:\040nr_events\040too\040high\012"
		fs/aio.c:1770 [aio]sys_io_cancel - "calling\040cancel\012"

	  Example usage:

		// enable the message at line 1603 of file svcsock.c
		nullarbor:~ # echo -n 'file svcsock.c line 1603 +p' >
						<debugfs>/dynamic_debug/control

		// enable all the messages in file svcsock.c
		nullarbor:~ # echo -n 'file svcsock.c +p' >
						<debugfs>/dynamic_debug/control

		// enable all the messages in the NFS server module
		nullarbor:~ # echo -n 'module nfsd +p' >
						<debugfs>/dynamic_debug/control

		// enable all 12 messages in the function svc_process()
		nullarbor:~ # echo -n 'func svc_process +p' >
						<debugfs>/dynamic_debug/control

		// disable all 12 messages in the function svc_process()
		nullarbor:~ # echo -n 'func svc_process -p' >
						<debugfs>/dynamic_debug/control

	  See Documentation/dynamic-debug-howto.txt for additional information.

config DMA_API_DEBUG
	bool "Enable debugging of DMA-API usage"
	depends on HAVE_DMA_API_DEBUG
	help
	  Enable this option to debug the use of the DMA API by device drivers.
	  With this option you will be able to detect common bugs in device
	  drivers like double-freeing of DMA mappings or freeing mappings that
	  were never allocated.
	  This option causes a performance degredation.  Use only if you want
	  to debug device drivers. If unsure, say N.

config ATOMIC64_SELFTEST
	bool "Perform an atomic64_t self-test at boot"
	help
	  Enable this option to test the atomic64_t functions at boot.

	  If unsure, say N.

source "samples/Kconfig"

source "lib/Kconfig.kgdb"

source "lib/Kconfig.kmemcheck"
