<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libxml2'>
  <files>
    <file name='DOCBparser'>
     <summary>old DocBook SGML parser</summary>
     <description>interface for a DocBook SGML non-verifying parser This code is DEPRECATED, and should not be used anymore. </description>
     <author>Daniel Veillard </author>
     <deprecated/>
     <exports symbol='docbParserInputPtr' type='typedef'/>
     <exports symbol='docbParserCtxt' type='typedef'/>
     <exports symbol='docbParserCtxtPtr' type='typedef'/>
     <exports symbol='docbParserInput' type='typedef'/>
     <exports symbol='docbDocPtr' type='typedef'/>
     <exports symbol='docbSAXHandler' type='typedef'/>
     <exports symbol='docbSAXHandlerPtr' type='typedef'/>
     <exports symbol='docbFreeParserCtxt' type='function'/>
     <exports symbol='docbParseDoc' type='function'/>
     <exports symbol='docbCreateFileParserCtxt' type='function'/>
     <exports symbol='docbSAXParseFile' type='function'/>
     <exports symbol='docbSAXParseDoc' type='function'/>
     <exports symbol='docbCreatePushParserCtxt' type='function'/>
     <exports symbol='docbEncodeEntities' type='function'/>
     <exports symbol='docbParseFile' type='function'/>
     <exports symbol='docbParseDocument' type='function'/>
     <exports symbol='docbParseChunk' type='function'/>
    </file>
    <file name='HTMLparser'>
     <summary>interface for an HTML 4.0 non-verifying parser</summary>
     <description>this module implements an HTML 4.0 non-verifying parser with API compatible with the XML parser ones. It should be able to parse &quot;real world&quot; HTML, even if severely broken from a specification point of view. </description>
     <author>Daniel Veillard </author>
     <exports symbol='htmlDefaultSubelement' type='macro'/>
     <exports symbol='htmlElementAllowedHereDesc' type='macro'/>
     <exports symbol='htmlRequiredAttrs' type='macro'/>
     <exports symbol='HTML_REQUIRED' type='enum'/>
     <exports symbol='HTML_INVALID' type='enum'/>
     <exports symbol='HTML_PARSE_NONET' type='enum'/>
     <exports symbol='HTML_NA' type='enum'/>
     <exports symbol='HTML_PARSE_COMPACT' type='enum'/>
     <exports symbol='HTML_VALID' type='enum'/>
     <exports symbol='HTML_PARSE_NOBLANKS' type='enum'/>
     <exports symbol='HTML_PARSE_NODEFDTD' type='enum'/>
     <exports symbol='HTML_PARSE_RECOVER' type='enum'/>
     <exports symbol='HTML_DEPRECATED' type='enum'/>
     <exports symbol='HTML_PARSE_NOERROR' type='enum'/>
     <exports symbol='HTML_PARSE_PEDANTIC' type='enum'/>
     <exports symbol='HTML_PARSE_IGNORE_ENC' type='enum'/>
     <exports symbol='HTML_PARSE_NOIMPLIED' type='enum'/>
     <exports symbol='HTML_PARSE_NOWARNING' type='enum'/>
     <exports symbol='htmlParserNodeInfo' type='typedef'/>
     <exports symbol='htmlParserInput' type='typedef'/>
     <exports symbol='htmlParserCtxtPtr' type='typedef'/>
     <exports symbol='htmlEntityDesc' type='typedef'/>
     <exports symbol='htmlDocPtr' type='typedef'/>
     <exports symbol='htmlSAXHandlerPtr' type='typedef'/>
     <exports symbol='htmlStatus' type='typedef'/>
     <exports symbol='htmlNodePtr' type='typedef'/>
     <exports symbol='htmlElemDescPtr' type='typedef'/>
     <exports symbol='htmlElemDesc' type='typedef'/>
     <exports symbol='htmlSAXHandler' type='typedef'/>
     <exports symbol='htmlParserInputPtr' type='typedef'/>
     <exports symbol='htmlParserOption' type='typedef'/>
     <exports symbol='htmlEntityDescPtr' type='typedef'/>
     <exports symbol='htmlParserCtxt' type='typedef'/>
     <exports symbol='_htmlEntityDesc' type='struct'/>
     <exports symbol='_htmlElemDesc' type='struct'/>
     <exports symbol='htmlIsScriptAttribute' type='function'/>
     <exports symbol='htmlHandleOmittedElem' type='function'/>
     <exports symbol='htmlReadFd' type='function'/>
     <exports symbol='htmlReadIO' type='function'/>
     <exports symbol='htmlParseFile' type='function'/>
     <exports symbol='htmlCtxtReadDoc' type='function'/>
     <exports symbol='htmlAutoCloseTag' type='function'/>
     <exports symbol='htmlParseChunk' type='function'/>
     <exports symbol='htmlTagLookup' type='function'/>
     <exports symbol='htmlCreateMemoryParserCtxt' type='function'/>
     <exports symbol='htmlCtxtReset' type='function'/>
     <exports symbol='htmlElementAllowedHere' type='function'/>
     <exports symbol='htmlCtxtReadIO' type='function'/>
     <exports symbol='htmlCreatePushParserCtxt' type='function'/>
     <exports symbol='htmlReadMemory' type='function'/>
     <exports symbol='htmlIsAutoClosed' type='function'/>
     <exports symbol='htmlParseCharRef' type='function'/>
     <exports symbol='htmlReadDoc' type='function'/>
     <exports symbol='htmlEncodeEntities' type='function'/>
     <exports symbol='htmlNodeStatus' type='function'/>
     <exports symbol='htmlAttrAllowed' type='function'/>
     <exports symbol='htmlSAXParseFile' type='function'/>
     <exports symbol='htmlParseEntityRef' type='function'/>
     <exports symbol='htmlElementStatusHere' type='function'/>
     <exports symbol='htmlEntityValueLookup' type='function'/>
     <exports symbol='htmlParseElement' type='function'/>
     <exports symbol='UTF8ToHtml' type='function'/>
     <exports symbol='htmlEntityLookup' type='function'/>
     <exports symbol='htmlFreeParserCtxt' type='function'/>
     <exports symbol='htmlCtxtReadMemory' type='function'/>
     <exports symbol='htmlCtxtReadFd' type='function'/>
     <exports symbol='htmlReadFile' type='function'/>
     <exports symbol='htmlCtxtReadFile' type='function'/>
     <exports symbol='htmlParseDocument' type='function'/>
     <exports symbol='htmlNewParserCtxt' type='function'/>
     <exports symbol='htmlSAXParseDoc' type='function'/>
     <exports symbol='htmlCtxtUseOptions' type='function'/>
     <exports symbol='htmlParseDoc' type='function'/>
    </file>
    <file name='HTMLtree'>
     <summary>specific APIs to process HTML tree, especially serialization</summary>
     <description>this module implements a few function needed to process tree in an HTML specific way. </description>
     <author>Daniel Veillard </author>
     <exports symbol='HTML_ENTITY_REF_NODE' type='macro'/>
     <exports symbol='HTML_COMMENT_NODE' type='macro'/>
     <exports symbol='HTML_PRESERVE_NODE' type='macro'/>
     <exports symbol='HTML_TEXT_NODE' type='macro'/>
     <exports symbol='HTML_PI_NODE' type='macro'/>
     <exports symbol='htmlNodeDumpFileFormat' type='function'/>
     <exports symbol='htmlDocDumpMemory' type='function'/>
     <exports symbol='htmlSaveFile' type='function'/>
     <exports symbol='htmlDocDump' type='function'/>
     <exports symbol='htmlDocDumpMemoryFormat' type='function'/>
     <exports symbol='htmlIsBooleanAttr' type='function'/>
     <exports symbol='htmlSaveFileFormat' type='function'/>
     <exports symbol='htmlNodeDumpFormatOutput' type='function'/>
     <exports symbol='htmlSetMetaEncoding' type='function'/>
     <exports symbol='htmlSaveFileEnc' type='function'/>
     <exports symbol='htmlNodeDumpOutput' type='function'/>
     <exports symbol='htmlNodeDump' type='function'/>
     <exports symbol='htmlNewDoc' type='function'/>
     <exports symbol='htmlGetMetaEncoding' type='function'/>
     <exports symbol='htmlNodeDumpFile' type='function'/>
     <exports symbol='htmlDocContentDumpFormatOutput' type='function'/>
     <exports symbol='htmlNewDocNoDtD' type='function'/>
     <exports symbol='htmlDocContentDumpOutput' type='function'/>
    </file>
    <file name='SAX'>
     <summary>Old SAX version 1 handler, deprecated</summary>
     <description>DEPRECATED set of SAX version 1 interfaces used to build the DOM tree. </description>
     <author>Daniel Veillard </author>
     <deprecated/>
     <exports symbol='comment' type='function'/>
     <exports symbol='checkNamespace' type='function'/>
     <exports symbol='getColumnNumber' type='function'/>
     <exports symbol='entityDecl' type='function'/>
     <exports symbol='attribute' type='function'/>
     <exports symbol='getNamespace' type='function'/>
     <exports symbol='setDocumentLocator' type='function'/>
     <exports symbol='initxmlDefaultSAXHandler' type='function'/>
     <exports symbol='ignorableWhitespace' type='function'/>
     <exports symbol='hasExternalSubset' type='function'/>
     <exports symbol='unparsedEntityDecl' type='function'/>
     <exports symbol='globalNamespace' type='function'/>
     <exports symbol='hasInternalSubset' type='function'/>
     <exports symbol='reference' type='function'/>
     <exports symbol='notationDecl' type='function'/>
     <exports symbol='getSystemId' type='function'/>
     <exports symbol='externalSubset' type='function'/>
     <exports symbol='resolveEntity' type='function'/>
     <exports symbol='startDocument' type='function'/>
     <exports symbol='setNamespace' type='function'/>
     <exports symbol='cdataBlock' type='function'/>
     <exports symbol='getPublicId' type='function'/>
     <exports symbol='inithtmlDefaultSAXHandler' type='function'/>
     <exports symbol='processingInstruction' type='function'/>
     <exports symbol='endElement' type='function'/>
     <exports symbol='namespaceDecl' type='function'/>
     <exports symbol='initdocbDefaultSAXHandler' type='function'/>
     <exports symbol='getEntity' type='function'/>
     <exports symbol='characters' type='function'/>
     <exports symbol='elementDecl' type='function'/>
     <exports symbol='startElement' type='function'/>
     <exports symbol='getParameterEntity' type='function'/>
     <exports symbol='attributeDecl' type='function'/>
     <exports symbol='isStandalone' type='function'/>
     <exports symbol='internalSubset' type='function'/>
     <exports symbol='endDocument' type='function'/>
     <exports symbol='getLineNumber' type='function'/>
    </file>
    <file name='SAX2'>
     <summary>SAX2 parser interface used to build the DOM tree</summary>
     <description>those are the default SAX2 interfaces used by the library when building DOM tree. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlSAX2EndElementNs' type='function'/>
     <exports symbol='xmlSAX2Reference' type='function'/>
     <exports symbol='xmlSAX2ElementDecl' type='function'/>
     <exports symbol='xmlSAX2AttributeDecl' type='function'/>
     <exports symbol='xmlSAX2Comment' type='function'/>
     <exports symbol='xmlSAX2GetColumnNumber' type='function'/>
     <exports symbol='xmlSAX2GetEntity' type='function'/>
     <exports symbol='xmlSAX2UnparsedEntityDecl' type='function'/>
     <exports symbol='xmlSAX2InitDocbDefaultSAXHandler' type='function'/>
     <exports symbol='xmlSAXVersion' type='function'/>
     <exports symbol='xmlSAX2IgnorableWhitespace' type='function'/>
     <exports symbol='xmlSAX2NotationDecl' type='function'/>
     <exports symbol='xmlSAX2StartDocument' type='function'/>
     <exports symbol='xmlSAX2EndElement' type='function'/>
     <exports symbol='xmlSAX2ResolveEntity' type='function'/>
     <exports symbol='xmlSAX2ExternalSubset' type='function'/>
     <exports symbol='xmlSAX2GetPublicId' type='function'/>
     <exports symbol='xmlSAX2IsStandalone' type='function'/>
     <exports symbol='xmlSAX2EndDocument' type='function'/>
     <exports symbol='xmlSAX2ProcessingInstruction' type='function'/>
     <exports symbol='xmlSAX2InternalSubset' type='function'/>
     <exports symbol='xmlSAX2Characters' type='function'/>
     <exports symbol='xmlSAXDefaultVersion' type='function'/>
     <exports symbol='xmlSAX2StartElement' type='function'/>
     <exports symbol='xmlSAX2SetDocumentLocator' type='function'/>
     <exports symbol='xmlSAX2CDataBlock' type='function'/>
     <exports symbol='xmlSAX2StartElementNs' type='function'/>
     <exports symbol='xmlSAX2HasExternalSubset' type='function'/>
     <exports symbol='htmlDefaultSAXHandlerInit' type='function'/>
     <exports symbol='xmlSAX2GetLineNumber' type='function'/>
     <exports symbol='xmlSAX2HasInternalSubset' type='function'/>
     <exports symbol='xmlSAX2InitHtmlDefaultSAXHandler' type='function'/>
     <exports symbol='docbDefaultSAXHandlerInit' type='function'/>
     <exports symbol='xmlDefaultSAXHandlerInit' type='function'/>
     <exports symbol='xmlSAX2InitDefaultSAXHandler' type='function'/>
     <exports symbol='xmlSAX2GetParameterEntity' type='function'/>
     <exports symbol='xmlSAX2GetSystemId' type='function'/>
     <exports symbol='xmlSAX2EntityDecl' type='function'/>
    </file>
    <file name='c14n'>
     <summary>Provide Canonical XML and Exclusive XML Canonicalization</summary>
     <description>the c14n modules provides a  &quot;Canonical XML&quot; implementation</description>
     <author>Aleksey Sanin &lt;aleksey@aleksey.com&gt; </author>
     <exports symbol='XML_C14N_1_1' type='enum'/>
     <exports symbol='XML_C14N_1_0' type='enum'/>
     <exports symbol='XML_C14N_EXCLUSIVE_1_0' type='enum'/>
     <exports symbol='xmlC14NMode' type='typedef'/>
     <exports symbol='xmlC14NExecute' type='function'/>
     <exports symbol='xmlC14NDocSaveTo' type='function'/>
     <exports symbol='xmlC14NIsVisibleCallback' type='function'/>
     <exports symbol='xmlC14NDocSave' type='function'/>
     <exports symbol='xmlC14NDocDumpMemory' type='function'/>
    </file>
    <file name='catalog'>
     <summary>interfaces to the Catalog handling system</summary>
     <description>the catalog module implements the support for XML Catalogs and SGML catalogs </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_CATALOG_PI' type='macro'/>
     <exports symbol='XML_CATALOGS_NAMESPACE' type='macro'/>
     <exports symbol='XML_CATA_ALLOW_NONE' type='enum'/>
     <exports symbol='XML_CATA_PREFER_NONE' type='enum'/>
     <exports symbol='XML_CATA_ALLOW_GLOBAL' type='enum'/>
     <exports symbol='XML_CATA_PREFER_PUBLIC' type='enum'/>
     <exports symbol='XML_CATA_ALLOW_DOCUMENT' type='enum'/>
     <exports symbol='XML_CATA_ALLOW_ALL' type='enum'/>
     <exports symbol='XML_CATA_PREFER_SYSTEM' type='enum'/>
     <exports symbol='xmlCatalogAllow' type='typedef'/>
     <exports symbol='xmlCatalogPrefer' type='typedef'/>
     <exports symbol='xmlCatalog' type='typedef'/>
     <exports symbol='xmlCatalogPtr' type='typedef'/>
     <exports symbol='xmlFreeCatalog' type='function'/>
     <exports symbol='xmlLoadCatalogs' type='function'/>
     <exports symbol='xmlCatalogLocalResolve' type='function'/>
     <exports symbol='xmlACatalogAdd' type='function'/>
     <exports symbol='xmlACatalogResolvePublic' type='function'/>
     <exports symbol='xmlCatalogGetDefaults' type='function'/>
     <exports symbol='xmlACatalogRemove' type='function'/>
     <exports symbol='xmlCatalogSetDefaultPrefer' type='function'/>
     <exports symbol='xmlACatalogResolveURI' type='function'/>
     <exports symbol='xmlCatalogAdd' type='function'/>
     <exports symbol='xmlCatalogResolvePublic' type='function'/>
     <exports symbol='xmlCatalogGetSystem' type='function'/>
     <exports symbol='xmlInitializeCatalog' type='function'/>
     <exports symbol='xmlLoadCatalog' type='function'/>
     <exports symbol='xmlCatalogRemove' type='function'/>
     <exports symbol='xmlCatalogIsEmpty' type='function'/>
     <exports symbol='xmlACatalogDump' type='function'/>
     <exports symbol='xmlCatalogFreeLocal' type='function'/>
     <exports symbol='xmlACatalogResolve' type='function'/>
     <exports symbol='xmlCatalogResolveSystem' type='function'/>
     <exports symbol='xmlLoadSGMLSuperCatalog' type='function'/>
     <exports symbol='xmlCatalogConvert' type='function'/>
     <exports symbol='xmlCatalogGetPublic' type='function'/>
     <exports symbol='xmlLoadACatalog' type='function'/>
     <exports symbol='xmlACatalogResolveSystem' type='function'/>
     <exports symbol='xmlCatalogLocalResolveURI' type='function'/>
     <exports symbol='xmlConvertSGMLCatalog' type='function'/>
     <exports symbol='xmlCatalogAddLocal' type='function'/>
     <exports symbol='xmlNewCatalog' type='function'/>
     <exports symbol='xmlParseCatalogFile' type='function'/>
     <exports symbol='xmlCatalogSetDebug' type='function'/>
     <exports symbol='xmlCatalogResolve' type='function'/>
     <exports symbol='xmlCatalogSetDefaults' type='function'/>
     <exports symbol='xmlCatalogDump' type='function'/>
     <exports symbol='xmlCatalogCleanup' type='function'/>
     <exports symbol='xmlCatalogResolveURI' type='function'/>
    </file>
    <file name='chvalid'>
     <summary>Unicode character range checking</summary>
     <description>this module exports interfaces for the character range validation APIs  This file is automatically generated from the cvs source definition files using the genChRanges.py Python script </description>
     <author>William Brack &lt;wbrack@mmm.com.hk&gt; </author>
     <exports symbol='xmlIsExtender_ch' type='macro'/>
     <exports symbol='xmlIsPubidCharQ' type='macro'/>
     <exports symbol='xmlIsPubidChar_ch' type='macro'/>
     <exports symbol='xmlIsIdeographicQ' type='macro'/>
     <exports symbol='xmlIsExtenderQ' type='macro'/>
     <exports symbol='xmlIsChar_ch' type='macro'/>
     <exports symbol='xmlIsDigitQ' type='macro'/>
     <exports symbol='xmlIsDigit_ch' type='macro'/>
     <exports symbol='xmlIsBaseChar_ch' type='macro'/>
     <exports symbol='xmlIsCombiningQ' type='macro'/>
     <exports symbol='xmlIsBlankQ' type='macro'/>
     <exports symbol='xmlIsCharQ' type='macro'/>
     <exports symbol='xmlIsBaseCharQ' type='macro'/>
     <exports symbol='xmlIsBlank_ch' type='macro'/>
     <exports symbol='xmlChLRange' type='typedef'/>
     <exports symbol='xmlChSRangePtr' type='typedef'/>
     <exports symbol='xmlChLRangePtr' type='typedef'/>
     <exports symbol='xmlChRangeGroupPtr' type='typedef'/>
     <exports symbol='xmlChSRange' type='typedef'/>
     <exports symbol='xmlChRangeGroup' type='typedef'/>
     <exports symbol='_xmlChSRange' type='struct'/>
     <exports symbol='_xmlChLRange' type='struct'/>
     <exports symbol='_xmlChRangeGroup' type='struct'/>
     <exports symbol='xmlIsBaseCharGroup' type='variable'/>
     <exports symbol='xmlIsIdeographicGroup' type='variable'/>
     <exports symbol='xmlIsDigitGroup' type='variable'/>
     <exports symbol='xmlIsExtenderGroup' type='variable'/>
     <exports symbol='xmlIsPubidChar_tab' type='variable'/>
     <exports symbol='xmlIsCharGroup' type='variable'/>
     <exports symbol='xmlIsCombiningGroup' type='variable'/>
     <exports symbol='xmlIsChar' type='function'/>
     <exports symbol='xmlIsDigit' type='function'/>
     <exports symbol='xmlIsBlank' type='function'/>
     <exports symbol='xmlIsIdeographic' type='function'/>
     <exports symbol='xmlCharInRange' type='function'/>
     <exports symbol='xmlIsPubidChar' type='function'/>
     <exports symbol='xmlIsCombining' type='function'/>
     <exports symbol='xmlIsBaseChar' type='function'/>
     <exports symbol='xmlIsExtender' type='function'/>
    </file>
    <file name='debugXML'>
     <summary>Tree debugging APIs</summary>
     <description>Interfaces to a set of routines used for debugging the tree produced by the XML parser. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlShellCtxt' type='typedef'/>
     <exports symbol='xmlShellCtxtPtr' type='typedef'/>
     <exports symbol='_xmlShellCtxt' type='struct'/>
     <exports symbol='xmlDebugDumpAttrList' type='function'/>
     <exports symbol='xmlLsOneNode' type='function'/>
     <exports symbol='xmlShellReadlineFunc' type='function'/>
     <exports symbol='xmlShellSave' type='function'/>
     <exports symbol='xmlBoolToText' type='function'/>
     <exports symbol='xmlShellWrite' type='function'/>
     <exports symbol='xmlShellDu' type='function'/>
     <exports symbol='xmlShellValidate' type='function'/>
     <exports symbol='xmlDebugCheckDocument' type='function'/>
     <exports symbol='xmlShellPrintXPathResult' type='function'/>
     <exports symbol='xmlShellCmd' type='function'/>
     <exports symbol='xmlShellLoad' type='function'/>
     <exports symbol='xmlDebugDumpString' type='function'/>
     <exports symbol='xmlShellBase' type='function'/>
     <exports symbol='xmlShellCat' type='function'/>
     <exports symbol='xmlDebugDumpDTD' type='function'/>
     <exports symbol='xmlDebugDumpNode' type='function'/>
     <exports symbol='xmlDebugDumpEntities' type='function'/>
     <exports symbol='xmlShellPrintNode' type='function'/>
     <exports symbol='xmlShellPwd' type='function'/>
     <exports symbol='xmlDebugDumpNodeList' type='function'/>
     <exports symbol='xmlDebugDumpAttr' type='function'/>
     <exports symbol='xmlDebugDumpDocument' type='function'/>
     <exports symbol='xmlLsCountNode' type='function'/>
     <exports symbol='xmlShellPrintXPathError' type='function'/>
     <exports symbol='xmlShellDir' type='function'/>
     <exports symbol='xmlDebugDumpOneNode' type='function'/>
     <exports symbol='xmlShellList' type='function'/>
     <exports symbol='xmlDebugDumpDocumentHead' type='function'/>
     <exports symbol='xmlShell' type='function'/>
    </file>
    <file name='dict'>
     <summary>string dictionnary</summary>
     <description>dictionary of reusable strings, just used to avoid allocation and freeing operations. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlDict' type='typedef'/>
     <exports symbol='xmlDictPtr' type='typedef'/>
     <exports symbol='xmlDictGetUsage' type='function'/>
     <exports symbol='xmlDictReference' type='function'/>
     <exports symbol='xmlDictCleanup' type='function'/>
     <exports symbol='xmlDictSize' type='function'/>
     <exports symbol='xmlDictExists' type='function'/>
     <exports symbol='xmlDictSetLimit' type='function'/>
     <exports symbol='xmlDictOwns' type='function'/>
     <exports symbol='xmlDictQLookup' type='function'/>
     <exports symbol='xmlInitializeDict' type='function'/>
     <exports symbol='xmlDictCreateSub' type='function'/>
     <exports symbol='xmlDictFree' type='function'/>
     <exports symbol='xmlDictLookup' type='function'/>
     <exports symbol='xmlDictCreate' type='function'/>
    </file>
    <file name='encoding'>
     <summary>interface for the encoding conversion functions</summary>
     <description>interface for the encoding conversion functions needed for XML basic encoding and iconv() support.  Related specs are rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies [ISO-10646]    UTF-8 and UTF-16 in Annexes [ISO-8859-1]   ISO Latin-1 characters codes. [UNICODE]      The Unicode Consortium, &quot;The Unicode Standard -- Worldwide Character Encoding -- Version 1.0&quot;, Addison- Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is described in Unicode Technical Report #4. [US-ASCII]     Coded Character Set--7-bit American Standard Code for Information Interchange, ANSI X3.4-1986. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_CHAR_ENCODING_UCS4LE' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_ERROR' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_5' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_EBCDIC' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_ASCII' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UCS4_2143' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_NONE' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UTF16BE' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_2022_JP' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_SHIFT_JIS' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UCS4BE' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UTF16LE' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UCS4_3412' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_8' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_9' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_6' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_7' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_4' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_EUC_JP' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_2' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_3' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_8859_1' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UTF8' type='enum'/>
     <exports symbol='XML_CHAR_ENCODING_UCS2' type='enum'/>
     <exports symbol='uconv_t' type='typedef'/>
     <exports symbol='xmlCharEncoding' type='typedef'/>
     <exports symbol='xmlCharEncodingHandler' type='typedef'/>
     <exports symbol='xmlCharEncodingHandlerPtr' type='typedef'/>
     <exports symbol='_xmlCharEncodingHandler' type='struct'/>
     <exports symbol='_uconv_t' type='struct'/>
     <exports symbol='xmlDelEncodingAlias' type='function'/>
     <exports symbol='xmlGetEncodingAlias' type='function'/>
     <exports symbol='xmlRegisterCharEncodingHandler' type='function'/>
     <exports symbol='UTF8Toisolat1' type='function'/>
     <exports symbol='xmlInitCharEncodingHandlers' type='function'/>
     <exports symbol='xmlAddEncodingAlias' type='function'/>
     <exports symbol='xmlCleanupEncodingAliases' type='function'/>
     <exports symbol='xmlCharEncOutFunc' type='function'/>
     <exports symbol='xmlParseCharEncoding' type='function'/>
     <exports symbol='xmlCharEncodingInputFunc' type='function'/>
     <exports symbol='xmlCleanupCharEncodingHandlers' type='function'/>
     <exports symbol='xmlNewCharEncodingHandler' type='function'/>
     <exports symbol='xmlCharEncodingOutputFunc' type='function'/>
     <exports symbol='isolat1ToUTF8' type='function'/>
     <exports symbol='xmlFindCharEncodingHandler' type='function'/>
     <exports symbol='xmlCharEncInFunc' type='function'/>
     <exports symbol='xmlGetCharEncodingHandler' type='function'/>
     <exports symbol='xmlCharEncFirstLine' type='function'/>
     <exports symbol='xmlDetectCharEncoding' type='function'/>
     <exports symbol='xmlCharEncCloseFunc' type='function'/>
     <exports symbol='xmlGetCharEncodingName' type='function'/>
    </file>
    <file name='entities'>
     <summary>interface for the XML entities handling</summary>
     <description>this module provides some of the entity API needed for the parser and applications. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_EXTERNAL_GENERAL_PARSED_ENTITY' type='enum'/>
     <exports symbol='XML_EXTERNAL_GENERAL_UNPARSED_ENTITY' type='enum'/>
     <exports symbol='XML_INTERNAL_PREDEFINED_ENTITY' type='enum'/>
     <exports symbol='XML_EXTERNAL_PARAMETER_ENTITY' type='enum'/>
     <exports symbol='XML_INTERNAL_PARAMETER_ENTITY' type='enum'/>
     <exports symbol='XML_INTERNAL_GENERAL_ENTITY' type='enum'/>
     <exports symbol='xmlEntityType' type='typedef'/>
     <exports symbol='xmlEntitiesTable' type='typedef'/>
     <exports symbol='xmlEntitiesTablePtr' type='typedef'/>
     <exports symbol='_xmlEntity' type='struct'/>
     <exports symbol='xmlAddDocEntity' type='function'/>
     <exports symbol='xmlNewEntity' type='function'/>
     <exports symbol='xmlEncodeEntitiesReentrant' type='function'/>
     <exports symbol='xmlGetDocEntity' type='function'/>
     <exports symbol='xmlGetDtdEntity' type='function'/>
     <exports symbol='xmlAddDtdEntity' type='function'/>
     <exports symbol='xmlCopyEntitiesTable' type='function'/>
     <exports symbol='xmlFreeEntitiesTable' type='function'/>
     <exports symbol='xmlGetParameterEntity' type='function'/>
     <exports symbol='xmlDumpEntitiesTable' type='function'/>
     <exports symbol='xmlDumpEntityDecl' type='function'/>
     <exports symbol='xmlCleanupPredefinedEntities' type='function'/>
     <exports symbol='xmlCreateEntitiesTable' type='function'/>
     <exports symbol='xmlEncodeEntities' type='function'/>
     <exports symbol='xmlEncodeSpecialChars' type='function'/>
     <exports symbol='xmlGetPredefinedEntity' type='function'/>
     <exports symbol='xmlInitializePredefinedEntities' type='function'/>
    </file>
    <file name='globals'>
     <summary>interface for all global variables of the library</summary>
     <description>all the global variables and thread handling for those variables is handled by this module.  The bottom of this file is automatically generated by build_glob.py based on the description file global.data </description>
     <author>Gary Pennington &lt;Gary.Pennington@uk.sun.com&gt;, Daniel Veillard </author>
     <exports symbol='xmlGlobalStatePtr' type='typedef'/>
     <exports symbol='xmlGlobalState' type='typedef'/>
     <exports symbol='_xmlGlobalState' type='struct'/>
     <exports symbol='xmlTreeIndentString' type='variable'/>
     <exports symbol='xmlIndentTreeOutput' type='variable'/>
     <exports symbol='xmlDefaultBufferSize' type='variable'/>
     <exports symbol='xmlRegisterNodeDefaultValue' type='variable'/>
     <exports symbol='xmlGetWarningsDefaultValue' type='variable'/>
     <exports symbol='docbDefaultSAXHandler' type='variable'/>
     <exports symbol='xmlGenericErrorContext' type='variable'/>
     <exports symbol='xmlDeregisterNodeDefaultValue' type='variable'/>
     <exports symbol='xmlGenericError' type='variable'/>
     <exports symbol='xmlMalloc' type='variable'/>
     <exports symbol='xmlParserVersion' type='variable'/>
     <exports symbol='xmlStructuredError' type='variable'/>
     <exports symbol='xmlStructuredErrorContext' type='variable'/>
     <exports symbol='xmlDoValidityCheckingDefaultValue' type='variable'/>
     <exports symbol='xmlOutputBufferCreateFilenameValue' type='variable'/>
     <exports symbol='xmlPedanticParserDefaultValue' type='variable'/>
     <exports symbol='oldXMLWDcompatibility' type='variable'/>
     <exports symbol='xmlRealloc' type='variable'/>
     <exports symbol='xmlMemStrdup' type='variable'/>
     <exports symbol='htmlDefaultSAXHandler' type='variable'/>
     <exports symbol='xmlSaveNoEmptyTags' type='variable'/>
     <exports symbol='xmlParserInputBufferCreateFilenameValue' type='variable'/>
     <exports symbol='xmlKeepBlanksDefaultValue' type='variable'/>
     <exports symbol='xmlSubstituteEntitiesDefaultValue' type='variable'/>
     <exports symbol='xmlMallocAtomic' type='variable'/>
     <exports symbol='xmlBufferAllocScheme' type='variable'/>
     <exports symbol='xmlParserDebugEntities' type='variable'/>
     <exports symbol='xmlFree' type='variable'/>
     <exports symbol='xmlLoadExtDtdDefaultValue' type='variable'/>
     <exports symbol='xmlLastError' type='variable'/>
     <exports symbol='xmlLineNumbersDefaultValue' type='variable'/>
     <exports symbol='xmlDefaultSAXHandler' type='variable'/>
     <exports symbol='xmlDefaultSAXLocator' type='variable'/>
     <exports symbol='xmlThrDefSetStructuredErrorFunc' type='function'/>
     <exports symbol='xmlInitializeGlobalState' type='function'/>
     <exports symbol='xmlThrDefBufferAllocScheme' type='function'/>
     <exports symbol='xmlThrDefPedanticParserDefaultValue' type='function'/>
     <exports symbol='xmlRegisterNodeDefault' type='function'/>
     <exports symbol='xmlParserInputBufferCreateFilenameFunc' type='function'/>
     <exports symbol='xmlThrDefOutputBufferCreateFilenameDefault' type='function'/>
     <exports symbol='xmlDeregisterNodeDefault' type='function'/>
     <exports symbol='xmlThrDefDefaultBufferSize' type='function'/>
     <exports symbol='xmlOutputBufferCreateFilenameDefault' type='function'/>
     <exports symbol='xmlThrDefLoadExtDtdDefaultValue' type='function'/>
     <exports symbol='xmlThrDefRegisterNodeDefault' type='function'/>
     <exports symbol='xmlThrDefKeepBlanksDefaultValue' type='function'/>
     <exports symbol='xmlDeregisterNodeFunc' type='function'/>
     <exports symbol='xmlThrDefParserDebugEntities' type='function'/>
     <exports symbol='xmlThrDefParserInputBufferCreateFilenameDefault' type='function'/>
     <exports symbol='xmlThrDefSetGenericErrorFunc' type='function'/>
     <exports symbol='xmlParserInputBufferCreateFilenameDefault' type='function'/>
     <exports symbol='xmlThrDefDoValidityCheckingDefaultValue' type='function'/>
     <exports symbol='xmlCleanupGlobals' type='function'/>
     <exports symbol='xmlThrDefGetWarningsDefaultValue' type='function'/>
     <exports symbol='xmlThrDefDeregisterNodeDefault' type='function'/>
     <exports symbol='xmlThrDefSubstituteEntitiesDefaultValue' type='function'/>
     <exports symbol='xmlRegisterNodeFunc' type='function'/>
     <exports symbol='xmlThrDefSaveNoEmptyTags' type='function'/>
     <exports symbol='xmlThrDefIndentTreeOutput' type='function'/>
     <exports symbol='xmlOutputBufferCreateFilenameFunc' type='function'/>
     <exports symbol='xmlInitGlobals' type='function'/>
     <exports symbol='xmlThrDefLineNumbersDefaultValue' type='function'/>
     <exports symbol='xmlThrDefTreeIndentString' type='function'/>
    </file>
    <file name='hash'>
     <summary>Chained hash tables</summary>
     <description>This module implements the hash table support used in various places in the library. </description>
     <author>Bjorn Reese &lt;bjorn.reese@systematic.dk&gt; </author>
     <exports symbol='XML_CAST_FPTR' type='macro'/>
     <exports symbol='xmlHashTable' type='typedef'/>
     <exports symbol='xmlHashTablePtr' type='typedef'/>
     <exports symbol='xmlHashScanFull' type='function'/>
     <exports symbol='xmlHashScan' type='function'/>
     <exports symbol='xmlHashScannerFull' type='function'/>
     <exports symbol='xmlHashCreateDict' type='function'/>
     <exports symbol='xmlHashAddEntry' type='function'/>
     <exports symbol='xmlHashUpdateEntry' type='function'/>
     <exports symbol='xmlHashQLookup3' type='function'/>
     <exports symbol='xmlHashQLookup2' type='function'/>
     <exports symbol='xmlHashScan3' type='function'/>
     <exports symbol='xmlHashScanner' type='function'/>
     <exports symbol='xmlHashDeallocator' type='function'/>
     <exports symbol='xmlHashCreate' type='function'/>
     <exports symbol='xmlHashFree' type='function'/>
     <exports symbol='xmlHashLookup' type='function'/>
     <exports symbol='xmlHashQLookup' type='function'/>
     <exports symbol='xmlHashUpdateEntry2' type='function'/>
     <exports symbol='xmlHashRemoveEntry2' type='function'/>
     <exports symbol='xmlHashRemoveEntry3' type='function'/>
     <exports symbol='xmlHashCopy' type='function'/>
     <exports symbol='xmlHashScanFull3' type='function'/>
     <exports symbol='xmlHashUpdateEntry3' type='function'/>
     <exports symbol='xmlHashLookup3' type='function'/>
     <exports symbol='xmlHashLookup2' type='function'/>
     <exports symbol='xmlHashRemoveEntry' type='function'/>
     <exports symbol='xmlHashCopier' type='function'/>
     <exports symbol='xmlHashAddEntry2' type='function'/>
     <exports symbol='xmlHashAddEntry3' type='function'/>
     <exports symbol='xmlHashSize' type='function'/>
    </file>
    <file name='list'>
     <summary>lists interfaces</summary>
     <description>this module implement the list support used in various place in the library. </description>
     <author>Gary Pennington &lt;Gary.Pennington@uk.sun.com&gt; </author>
     <exports symbol='xmlLink' type='typedef'/>
     <exports symbol='xmlLinkPtr' type='typedef'/>
     <exports symbol='xmlList' type='typedef'/>
     <exports symbol='xmlListPtr' type='typedef'/>
     <exports symbol='xmlListInsert' type='function'/>
     <exports symbol='xmlListEmpty' type='function'/>
     <exports symbol='xmlListSort' type='function'/>
     <exports symbol='xmlListDeallocator' type='function'/>
     <exports symbol='xmlListMerge' type='function'/>
     <exports symbol='xmlListCreate' type='function'/>
     <exports symbol='xmlListDup' type='function'/>
     <exports symbol='xmlListRemoveLast' type='function'/>
     <exports symbol='xmlListWalk' type='function'/>
     <exports symbol='xmlListRemoveAll' type='function'/>
     <exports symbol='xmlListCopy' type='function'/>
     <exports symbol='xmlListPopFront' type='function'/>
     <exports symbol='xmlListSearch' type='function'/>
     <exports symbol='xmlListWalker' type='function'/>
     <exports symbol='xmlListRemoveFirst' type='function'/>
     <exports symbol='xmlListReverseWalk' type='function'/>
     <exports symbol='xmlLinkGetData' type='function'/>
     <exports symbol='xmlListClear' type='function'/>
     <exports symbol='xmlListAppend' type='function'/>
     <exports symbol='xmlListReverse' type='function'/>
     <exports symbol='xmlListDataCompare' type='function'/>
     <exports symbol='xmlListSize' type='function'/>
     <exports symbol='xmlListPushFront' type='function'/>
     <exports symbol='xmlListEnd' type='function'/>
     <exports symbol='xmlListPopBack' type='function'/>
     <exports symbol='xmlListReverseSearch' type='function'/>
     <exports symbol='xmlListPushBack' type='function'/>
     <exports symbol='xmlListFront' type='function'/>
     <exports symbol='xmlListDelete' type='function'/>
    </file>
    <file name='nanoftp'>
     <summary>minimal FTP implementation</summary>
     <description>minimal FTP implementation allowing to fetch resources like external subset. </description>
     <author>Daniel Veillard </author>
     <exports symbol='INVALID_SOCKET' type='macro'/>
     <exports symbol='SOCKET' type='macro'/>
     <exports symbol='xmlNanoFTPQuit' type='function'/>
     <exports symbol='xmlNanoFTPClose' type='function'/>
     <exports symbol='ftpListCallback' type='function'/>
     <exports symbol='xmlNanoFTPCloseConnection' type='function'/>
     <exports symbol='xmlNanoFTPProxy' type='function'/>
     <exports symbol='xmlNanoFTPUpdateURL' type='function'/>
     <exports symbol='xmlNanoFTPGetConnection' type='function'/>
     <exports symbol='xmlNanoFTPDele' type='function'/>
     <exports symbol='xmlNanoFTPNewCtxt' type='function'/>
     <exports symbol='xmlNanoFTPCheckResponse' type='function'/>
     <exports symbol='xmlNanoFTPScanProxy' type='function'/>
     <exports symbol='ftpDataCallback' type='function'/>
     <exports symbol='xmlNanoFTPGetResponse' type='function'/>
     <exports symbol='xmlNanoFTPCwd' type='function'/>
     <exports symbol='xmlNanoFTPInit' type='function'/>
     <exports symbol='xmlNanoFTPConnectTo' type='function'/>
     <exports symbol='xmlNanoFTPList' type='function'/>
     <exports symbol='xmlNanoFTPOpen' type='function'/>
     <exports symbol='xmlNanoFTPConnect' type='function'/>
     <exports symbol='xmlNanoFTPGetSocket' type='function'/>
     <exports symbol='xmlNanoFTPGet' type='function'/>
     <exports symbol='xmlNanoFTPRead' type='function'/>
     <exports symbol='xmlNanoFTPFreeCtxt' type='function'/>
     <exports symbol='xmlNanoFTPCleanup' type='function'/>
    </file>
    <file name='nanohttp'>
     <summary>minimal HTTP implementation</summary>
     <description>minimal HTTP implementation allowing to fetch resources like external subset. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlNanoHTTPRead' type='function'/>
     <exports symbol='xmlNanoHTTPSave' type='function'/>
     <exports symbol='xmlNanoHTTPRedir' type='function'/>
     <exports symbol='xmlNanoHTTPAuthHeader' type='function'/>
     <exports symbol='xmlNanoHTTPFetch' type='function'/>
     <exports symbol='xmlNanoHTTPContentLength' type='function'/>
     <exports symbol='xmlNanoHTTPMimeType' type='function'/>
     <exports symbol='xmlNanoHTTPClose' type='function'/>
     <exports symbol='xmlNanoHTTPCleanup' type='function'/>
     <exports symbol='xmlNanoHTTPMethod' type='function'/>
     <exports symbol='xmlNanoHTTPInit' type='function'/>
     <exports symbol='xmlNanoHTTPOpen' type='function'/>
     <exports symbol='xmlNanoHTTPOpenRedir' type='function'/>
     <exports symbol='xmlNanoHTTPMethodRedir' type='function'/>
     <exports symbol='xmlNanoHTTPScanProxy' type='function'/>
     <exports symbol='xmlNanoHTTPEncoding' type='function'/>
     <exports symbol='xmlNanoHTTPReturnCode' type='function'/>
    </file>
    <file name='parser'>
     <summary>the core parser module</summary>
     <description>Interfaces, constants and types related to the XML parser </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_COMPLETE_ATTRS' type='macro'/>
     <exports symbol='XML_SKIP_IDS' type='macro'/>
     <exports symbol='XML_SAX2_MAGIC' type='macro'/>
     <exports symbol='XML_DETECT_IDS' type='macro'/>
     <exports symbol='XML_DEFAULT_VERSION' type='macro'/>
     <exports symbol='XML_WITH_NONE' type='enum'/>
     <exports symbol='XML_WITH_SCHEMATRON' type='enum'/>
     <exports symbol='XML_PARSER_ENTITY_DECL' type='enum'/>
     <exports symbol='XML_PARSER_CONTENT' type='enum'/>
     <exports symbol='XML_PARSE_NOBLANKS' type='enum'/>
     <exports symbol='XML_WITH_PATTERN' type='enum'/>
     <exports symbol='XML_PARSE_NODICT' type='enum'/>
     <exports symbol='XML_PARSER_SYSTEM_LITERAL' type='enum'/>
     <exports symbol='XML_WITH_REGEXP' type='enum'/>
     <exports symbol='XML_PARSER_PI' type='enum'/>
     <exports symbol='XML_PARSE_UNKNOWN' type='enum'/>
     <exports symbol='XML_WITH_XPATH' type='enum'/>
     <exports symbol='XML_WITH_HTML' type='enum'/>
     <exports symbol='XML_PARSE_OLDSAX' type='enum'/>
     <exports symbol='XML_WITH_LZMA' type='enum'/>
     <exports symbol='XML_WITH_ICU' type='enum'/>
     <exports symbol='XML_WITH_C14N' type='enum'/>
     <exports symbol='XML_PARSE_PUSH_DOM' type='enum'/>
     <exports symbol='XML_PARSER_PROLOG' type='enum'/>
     <exports symbol='XML_PARSE_NONET' type='enum'/>
     <exports symbol='XML_WITH_HTTP' type='enum'/>
     <exports symbol='XML_PARSER_EPILOG' type='enum'/>
     <exports symbol='XML_PARSER_END_TAG' type='enum'/>
     <exports symbol='XML_WITH_DEBUG' type='enum'/>
     <exports symbol='XML_WITH_READER' type='enum'/>
     <exports symbol='XML_PARSE_DTDVALID' type='enum'/>
     <exports symbol='XML_PARSE_DOM' type='enum'/>
     <exports symbol='XML_PARSER_ATTRIBUTE_VALUE' type='enum'/>
     <exports symbol='XML_PARSE_PUSH_SAX' type='enum'/>
     <exports symbol='XML_WITH_TREE' type='enum'/>
     <exports symbol='XML_PARSE_RECOVER' type='enum'/>
     <exports symbol='XML_WITH_SCHEMAS' type='enum'/>
     <exports symbol='XML_PARSE_PEDANTIC' type='enum'/>
     <exports symbol='XML_PARSER_EOF' type='enum'/>
     <exports symbol='XML_PARSER_CDATA_SECTION' type='enum'/>
     <exports symbol='XML_WITH_LEGACY' type='enum'/>
     <exports symbol='XML_WITH_OUTPUT' type='enum'/>
     <exports symbol='XML_PARSE_XINCLUDE' type='enum'/>
     <exports symbol='XML_PARSE_NOCDATA' type='enum'/>
     <exports symbol='XML_PARSE_NOBASEFIX' type='enum'/>
     <exports symbol='XML_PARSE_BIG_LINES' type='enum'/>
     <exports symbol='XML_WITH_XINCLUDE' type='enum'/>
     <exports symbol='XML_WITH_PUSH' type='enum'/>
     <exports symbol='XML_PARSE_READER' type='enum'/>
     <exports symbol='XML_WITH_THREAD' type='enum'/>
     <exports symbol='XML_PARSE_SAX' type='enum'/>
     <exports symbol='XML_PARSE_NOENT' type='enum'/>
     <exports symbol='XML_PARSER_ENTITY_VALUE' type='enum'/>
     <exports symbol='XML_PARSE_DTDLOAD' type='enum'/>
     <exports symbol='XML_PARSE_DTDATTR' type='enum'/>
     <exports symbol='XML_PARSE_NOWARNING' type='enum'/>
     <exports symbol='XML_PARSE_OLD10' type='enum'/>
     <exports symbol='XML_PARSE_NOERROR' type='enum'/>
     <exports symbol='XML_WITH_ISO8859X' type='enum'/>
     <exports symbol='XML_WITH_EXPR' type='enum'/>
     <exports symbol='XML_PARSE_NSCLEAN' type='enum'/>
     <exports symbol='XML_WITH_UNICODE' type='enum'/>
     <exports symbol='XML_WITH_CATALOG' type='enum'/>
     <exports symbol='XML_WITH_MODULES' type='enum'/>
     <exports symbol='XML_WITH_XPTR' type='enum'/>
     <exports symbol='XML_PARSE_IGNORE_ENC' type='enum'/>
     <exports symbol='XML_PARSE_COMPACT' type='enum'/>
     <exports symbol='XML_PARSE_SAX1' type='enum'/>
     <exports symbol='XML_WITH_ZLIB' type='enum'/>
     <exports symbol='XML_PARSE_NOXINCNODE' type='enum'/>
     <exports symbol='XML_PARSER_DTD' type='enum'/>
     <exports symbol='XML_PARSER_MISC' type='enum'/>
     <exports symbol='XML_PARSER_START' type='enum'/>
     <exports symbol='XML_WITH_DEBUG_MEM' type='enum'/>
     <exports symbol='XML_PARSE_HUGE' type='enum'/>
     <exports symbol='XML_WITH_FTP' type='enum'/>
     <exports symbol='XML_PARSER_START_TAG' type='enum'/>
     <exports symbol='XML_PARSER_IGNORE' type='enum'/>
     <exports symbol='XML_PARSER_COMMENT' type='enum'/>
     <exports symbol='XML_PARSER_PUBLIC_LITERAL' type='enum'/>
     <exports symbol='XML_WITH_ICONV' type='enum'/>
     <exports symbol='XML_WITH_WRITER' type='enum'/>
     <exports symbol='XML_WITH_AUTOMATA' type='enum'/>
     <exports symbol='XML_WITH_DEBUG_RUN' type='enum'/>
     <exports symbol='XML_WITH_SAX1' type='enum'/>
     <exports symbol='XML_WITH_VALID' type='enum'/>
     <exports symbol='xmlParserNodeInfoSeqPtr' type='typedef'/>
     <exports symbol='xmlSAXHandlerV1' type='typedef'/>
     <exports symbol='xmlParserInputState' type='typedef'/>
     <exports symbol='xmlParserNodeInfoPtr' type='typedef'/>
     <exports symbol='xmlParserNodeInfoSeq' type='typedef'/>
     <exports symbol='xmlFeature' type='typedef'/>
     <exports symbol='xmlParserMode' type='typedef'/>
     <exports symbol='xmlParserOption' type='typedef'/>
     <exports symbol='xmlSAXHandlerV1Ptr' type='typedef'/>
     <exports symbol='xmlParserNodeInfo' type='typedef'/>
     <exports symbol='_xmlParserNodeInfo' type='struct'/>
     <exports symbol='_xmlParserCtxt' type='struct'/>
     <exports symbol='_xmlSAXHandlerV1' type='struct'/>
     <exports symbol='_xmlParserInput' type='struct'/>
     <exports symbol='_xmlSAXHandler' type='struct'/>
     <exports symbol='_xmlParserNodeInfoSeq' type='struct'/>
     <exports symbol='_xmlSAXLocator' type='struct'/>
     <exports symbol='xmlSetupParserForBuffer' type='function'/>
     <exports symbol='xmlCtxtReadFile' type='function'/>
     <exports symbol='xmlParseCtxtExternalEntity' type='function'/>
     <exports symbol='attributeDeclSAXFunc' type='function'/>
     <exports symbol='getEntitySAXFunc' type='function'/>
     <exports symbol='startElementSAXFunc' type='function'/>
     <exports symbol='charactersSAXFunc' type='function'/>
     <exports symbol='xmlClearNodeInfoSeq' type='function'/>
     <exports symbol='xmlParseChunk' type='function'/>
     <exports symbol='xmlParseEntity' type='function'/>
     <exports symbol='xmlRecoverFile' type='function'/>
     <exports symbol='xmlCtxtReadDoc' type='function'/>
     <exports symbol='startElementNsSAX2Func' type='function'/>
     <exports symbol='xmlCreateIOParserCtxt' type='function'/>
     <exports symbol='xmlParseInNodeContext' type='function'/>
     <exports symbol='referenceSAXFunc' type='function'/>
     <exports symbol='hasExternalSubsetSAXFunc' type='function'/>
     <exports symbol='xmlSAXParseDoc' type='function'/>
     <exports symbol='xmlReadMemory' type='function'/>
     <exports symbol='xmlParseMemory' type='function'/>
     <exports symbol='xmlNewIOInputStream' type='function'/>
     <exports symbol='processingInstructionSAXFunc' type='function'/>
     <exports symbol='xmlParseBalancedChunkMemoryRecover' type='function'/>
     <exports symbol='xmlInitParser' type='function'/>
     <exports symbol='xmlCreateDocParserCtxt' type='function'/>
     <exports symbol='errorSAXFunc' type='function'/>
     <exports symbol='xmlSAXParseMemory' type='function'/>
     <exports symbol='xmlRecoverMemory' type='function'/>
     <exports symbol='xmlExternalEntityLoader' type='function'/>
     <exports symbol='hasInternalSubsetSAXFunc' type='function'/>
     <exports symbol='cdataBlockSAXFunc' type='function'/>
     <exports symbol='xmlSAXParseFile' type='function'/>
     <exports symbol='xmlParserInputDeallocate' type='function'/>
     <exports symbol='xmlCtxtReadIO' type='function'/>
     <exports symbol='xmlSAXParseMemoryWithData' type='function'/>
     <exports symbol='xmlGetFeature' type='function'/>
     <exports symbol='xmlIOParseDTD' type='function'/>
     <exports symbol='xmlFreeParserCtxt' type='function'/>
     <exports symbol='xmlParseDTD' type='function'/>
     <exports symbol='xmlRecoverDoc' type='function'/>
     <exports symbol='commentSAXFunc' type='function'/>
     <exports symbol='xmlInitParserCtxt' type='function'/>
     <exports symbol='attributeSAXFunc' type='function'/>
     <exports symbol='xmlParserInputGrow' type='function'/>
     <exports symbol='xmlCtxtReadMemory' type='function'/>
     <exports symbol='externalSubsetSAXFunc' type='function'/>
     <exports symbol='resolveEntitySAXFunc' type='function'/>
     <exports symbol='xmlPedanticParserDefault' type='function'/>
     <exports symbol='xmlSAXParseEntity' type='function'/>
     <exports symbol='xmlParseDoc' type='function'/>
     <exports symbol='xmlSAXParseFileWithData' type='function'/>
     <exports symbol='xmlLineNumbersDefault' type='function'/>
     <exports symbol='xmlGetExternalEntityLoader' type='function'/>
     <exports symbol='elementDeclSAXFunc' type='function'/>
     <exports symbol='xmlCtxtUseOptions' type='function'/>
     <exports symbol='xmlCreatePushParserCtxt' type='function'/>
     <exports symbol='xmlParserAddNodeInfo' type='function'/>
     <exports symbol='xmlCtxtReadFd' type='function'/>
     <exports symbol='internalSubsetSAXFunc' type='function'/>
     <exports symbol='xmlNewParserCtxt' type='function'/>
     <exports symbol='endDocumentSAXFunc' type='function'/>
     <exports symbol='xmlParseFile' type='function'/>
     <exports symbol='xmlParseDocument' type='function'/>
     <exports symbol='setDocumentLocatorSAXFunc' type='function'/>
     <exports symbol='getParameterEntitySAXFunc' type='function'/>
     <exports symbol='ignorableWhitespaceSAXFunc' type='function'/>
     <exports symbol='xmlInitNodeInfoSeq' type='function'/>
     <exports symbol='xmlSubstituteEntitiesDefault' type='function'/>
     <exports symbol='endElementSAXFunc' type='function'/>
     <exports symbol='xmlParserFindNodeInfoIndex' type='function'/>
     <exports symbol='xmlByteConsumed' type='function'/>
     <exports symbol='xmlCtxtReset' type='function'/>
     <exports symbol='xmlSetFeature' type='function'/>
     <exports symbol='xmlKeepBlanksDefault' type='function'/>
     <exports symbol='xmlParserInputRead' type='function'/>
     <exports symbol='xmlReadFile' type='function'/>
     <exports symbol='xmlGetFeaturesList' type='function'/>
     <exports symbol='xmlHasFeature' type='function'/>
     <exports symbol='unparsedEntityDeclSAXFunc' type='function'/>
     <exports symbol='xmlSAXUserParseFile' type='function'/>
     <exports symbol='fatalErrorSAXFunc' type='function'/>
     <exports symbol='xmlSAXParseDTD' type='function'/>
     <exports symbol='xmlParserFindNodeInfo' type='function'/>
     <exports symbol='entityDeclSAXFunc' type='function'/>
     <exports symbol='xmlLoadExternalEntity' type='function'/>
     <exports symbol='xmlStopParser' type='function'/>
     <exports symbol='xmlReadFd' type='function'/>
     <exports symbol='xmlParseExtParsedEnt' type='function'/>
     <exports symbol='xmlReadIO' type='function'/>
     <exports symbol='xmlReadDoc' type='function'/>
     <exports symbol='xmlSAXUserParseMemory' type='function'/>
     <exports symbol='xmlParseBalancedChunkMemory' type='function'/>
     <exports symbol='endElementNsSAX2Func' type='function'/>
     <exports symbol='xmlCleanupParser' type='function'/>
     <exports symbol='xmlCtxtResetPush' type='function'/>
     <exports symbol='isStandaloneSAXFunc' type='function'/>
     <exports symbol='startDocumentSAXFunc' type='function'/>
     <exports symbol='xmlClearParserCtxt' type='function'/>
     <exports symbol='xmlParseExternalEntity' type='function'/>
     <exports symbol='notationDeclSAXFunc' type='function'/>
     <exports symbol='warningSAXFunc' type='function'/>
     <exports symbol='xmlSetExternalEntityLoader' type='function'/>
    </file>
    <file name='parserInternals'>
     <summary>internals routines and limits exported by the parser.</summary>
     <description>this module exports a number of internal parsing routines they are not really all intended for applications but can prove useful doing low level processing. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SUBSTITUTE_REF' type='macro'/>
     <exports symbol='IS_BLANK' type='macro'/>
     <exports symbol='IS_BYTE_CHAR' type='macro'/>
     <exports symbol='IS_PUBIDCHAR' type='macro'/>
     <exports symbol='IS_DIGIT_CH' type='macro'/>
     <exports symbol='IS_EXTENDER' type='macro'/>
     <exports symbol='IS_ASCII_DIGIT' type='macro'/>
     <exports symbol='IS_COMBINING_CH' type='macro'/>
     <exports symbol='IS_CHAR' type='macro'/>
     <exports symbol='IS_LETTER' type='macro'/>
     <exports symbol='IS_IDEOGRAPHIC' type='macro'/>
     <exports symbol='MOVETO_STARTTAG' type='macro'/>
     <exports symbol='XML_MAX_NAME_LENGTH' type='macro'/>
     <exports symbol='IS_ASCII_LETTER' type='macro'/>
     <exports symbol='IS_DIGIT' type='macro'/>
     <exports symbol='XML_MAX_DICTIONARY_LIMIT' type='macro'/>
     <exports symbol='XML_SUBSTITUTE_PEREF' type='macro'/>
     <exports symbol='MOVETO_ENDTAG' type='macro'/>
     <exports symbol='SKIP_EOL' type='macro'/>
     <exports symbol='IS_EXTENDER_CH' type='macro'/>
     <exports symbol='IS_BLANK_CH' type='macro'/>
     <exports symbol='IS_LETTER_CH' type='macro'/>
     <exports symbol='XML_MAX_LOOKUP_LIMIT' type='macro'/>
     <exports symbol='XML_MAX_TEXT_LENGTH' type='macro'/>
     <exports symbol='XML_SUBSTITUTE_NONE' type='macro'/>
     <exports symbol='IS_COMBINING' type='macro'/>
     <exports symbol='XML_MAX_NAMELEN' type='macro'/>
     <exports symbol='IS_BASECHAR' type='macro'/>
     <exports symbol='INPUT_CHUNK' type='macro'/>
     <exports symbol='IS_PUBIDCHAR_CH' type='macro'/>
     <exports symbol='IS_CHAR_CH' type='macro'/>
     <exports symbol='XML_SUBSTITUTE_BOTH' type='macro'/>
     <exports symbol='xmlStringTextNoenc' type='variable'/>
     <exports symbol='xmlStringComment' type='variable'/>
     <exports symbol='xmlStringText' type='variable'/>
     <exports symbol='xmlParserMaxDepth' type='variable'/>
     <exports symbol='nodePop' type='function'/>
     <exports symbol='xmlParseNotationDecl' type='function'/>
     <exports symbol='xmlParseExternalSubset' type='function'/>
     <exports symbol='xmlParseMisc' type='function'/>
     <exports symbol='xmlSwitchInputEncoding' type='function'/>
     <exports symbol='xmlNewStringInputStream' type='function'/>
     <exports symbol='xmlParseExternalID' type='function'/>
     <exports symbol='xmlScanName' type='function'/>
     <exports symbol='xmlParseElementDecl' type='function'/>
     <exports symbol='xmlParseMarkupDecl' type='function'/>
     <exports symbol='htmlCreateFileParserCtxt' type='function'/>
     <exports symbol='inputPush' type='function'/>
     <exports symbol='xmlStringLenDecodeEntities' type='function'/>
     <exports symbol='namePop' type='function'/>
     <exports symbol='xmlParseContent' type='function'/>
     <exports symbol='xmlNewInputStream' type='function'/>
     <exports symbol='xmlNamespaceParseQName' type='function'/>
     <exports symbol='xmlNewInputFromFile' type='function'/>
     <exports symbol='xmlParserHandlePEReference' type='function'/>
     <exports symbol='xmlStringDecodeEntities' type='function'/>
     <exports symbol='xmlCreateFileParserCtxt' type='function'/>
     <exports symbol='xmlParseCharRef' type='function'/>
     <exports symbol='xmlParseElement' type='function'/>
     <exports symbol='xmlParseTextDecl' type='function'/>
     <exports symbol='xmlNewEntityInputStream' type='function'/>
     <exports symbol='xmlCopyCharMultiByte' type='function'/>
     <exports symbol='xmlParseElementChildrenContentDecl' type='function'/>
     <exports symbol='xmlParseCharData' type='function'/>
     <exports symbol='xmlParseVersionInfo' type='function'/>
     <exports symbol='xmlParseSDDecl' type='function'/>
     <exports symbol='xmlParseEnumeratedType' type='function'/>
     <exports symbol='xmlHandleEntity' type='function'/>
     <exports symbol='xmlCurrentChar' type='function'/>
     <exports symbol='xmlSkipBlankChars' type='function'/>
     <exports symbol='xmlParseNotationType' type='function'/>
     <exports symbol='xmlParserInputShrink' type='function'/>
     <exports symbol='xmlSetEntityReferenceFunc' type='function'/>
     <exports symbol='xmlFreeInputStream' type='function'/>
     <exports symbol='xmlParsePEReference' type='function'/>
     <exports symbol='xmlCreateURLParserCtxt' type='function'/>
     <exports symbol='xmlIsLetter' type='function'/>
     <exports symbol='xmlCheckLanguageID' type='function'/>
     <exports symbol='xmlNextChar' type='function'/>
     <exports symbol='xmlParseEnumerationType' type='function'/>
     <exports symbol='xmlParseAttributeType' type='function'/>
     <exports symbol='xmlParseDefaultDecl' type='function'/>
     <exports symbol='xmlParseSystemLiteral' type='function'/>
     <exports symbol='xmlParseAttValue' type='function'/>
     <exports symbol='xmlCreateMemoryParserCtxt' type='function'/>
     <exports symbol='xmlParseAttributeListDecl' type='function'/>
     <exports symbol='xmlParseName' type='function'/>
     <exports symbol='xmlParseEncName' type='function'/>
     <exports symbol='nodePush' type='function'/>
     <exports symbol='xmlSwitchEncoding' type='function'/>
     <exports symbol='xmlSwitchToEncoding' type='function'/>
     <exports symbol='xmlParseEntityRef' type='function'/>
     <exports symbol='xmlParseAttribute' type='function'/>
     <exports symbol='xmlParseEndTag' type='function'/>
     <exports symbol='xmlParseEncodingDecl' type='function'/>
     <exports symbol='htmlInitAutoClose' type='function'/>
     <exports symbol='xmlCreateEntityParserCtxt' type='function'/>
     <exports symbol='xmlSplitQName' type='function'/>
     <exports symbol='xmlParserHandleReference' type='function'/>
     <exports symbol='xmlParsePITarget' type='function'/>
     <exports symbol='xmlParseElementContentDecl' type='function'/>
     <exports symbol='inputPop' type='function'/>
     <exports symbol='xmlPopInput' type='function'/>
     <exports symbol='xmlParsePubidLiteral' type='function'/>
     <exports symbol='xmlPushInput' type='function'/>
     <exports symbol='xmlParseEntityValue' type='function'/>
     <exports symbol='xmlDecodeEntities' type='function'/>
     <exports symbol='xmlParseVersionNum' type='function'/>
     <exports symbol='xmlParseXMLDecl' type='function'/>
     <exports symbol='xmlEntityReferenceFunc' type='function'/>
     <exports symbol='xmlParseElementMixedContentDecl' type='function'/>
     <exports symbol='xmlParseQuotedString' type='function'/>
     <exports symbol='xmlNamespaceParseNSDef' type='function'/>
     <exports symbol='xmlParseCDSect' type='function'/>
     <exports symbol='xmlStringCurrentChar' type='function'/>
     <exports symbol='xmlParseComment' type='function'/>
     <exports symbol='xmlErrMemory' type='function'/>
     <exports symbol='xmlNamespaceParseNCName' type='function'/>
     <exports symbol='xmlParseNmtoken' type='function'/>
     <exports symbol='xmlParseReference' type='function'/>
     <exports symbol='namePush' type='function'/>
     <exports symbol='xmlParseNamespace' type='function'/>
     <exports symbol='xmlCopyChar' type='function'/>
     <exports symbol='xmlParsePI' type='function'/>
     <exports symbol='xmlParseDocTypeDecl' type='function'/>
     <exports symbol='xmlParseStartTag' type='function'/>
     <exports symbol='xmlParseEntityDecl' type='function'/>
    </file>
    <file name='pattern'>
     <summary>pattern expression handling</summary>
     <description>allows to compile and test pattern expressions for nodes either in a tree or based on a parser state. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_PATTERN_DEFAULT' type='enum'/>
     <exports symbol='XML_PATTERN_XSFIELD' type='enum'/>
     <exports symbol='XML_PATTERN_XSSEL' type='enum'/>
     <exports symbol='XML_PATTERN_XPATH' type='enum'/>
     <exports symbol='xmlStreamCtxtPtr' type='typedef'/>
     <exports symbol='xmlPatternFlags' type='typedef'/>
     <exports symbol='xmlStreamCtxt' type='typedef'/>
     <exports symbol='xmlPattern' type='typedef'/>
     <exports symbol='xmlPatternPtr' type='typedef'/>
     <exports symbol='xmlPatternMinDepth' type='function'/>
     <exports symbol='xmlPatternGetStreamCtxt' type='function'/>
     <exports symbol='xmlPatternFromRoot' type='function'/>
     <exports symbol='xmlFreePatternList' type='function'/>
     <exports symbol='xmlPatternStreamable' type='function'/>
     <exports symbol='xmlStreamPushAttr' type='function'/>
     <exports symbol='xmlPatternMatch' type='function'/>
     <exports symbol='xmlStreamWantsAnyNode' type='function'/>
     <exports symbol='xmlStreamPop' type='function'/>
     <exports symbol='xmlFreePattern' type='function'/>
     <exports symbol='xmlStreamPush' type='function'/>
     <exports symbol='xmlPatternMaxDepth' type='function'/>
     <exports symbol='xmlPatterncompile' type='function'/>
     <exports symbol='xmlStreamPushNode' type='function'/>
     <exports symbol='xmlFreeStreamCtxt' type='function'/>
    </file>
    <file name='relaxng'>
     <summary>implementation of the Relax-NG validation</summary>
     <description>implementation of the Relax-NG validation </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_RELAXNG_ERR_DUPID' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_VALELEM' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ATTRVALID' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_LISTELEM' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_LISTEXTRA' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ATTRNONS' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_EXTRADATA' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMNONS' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMEXTRANS' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_DATATYPE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_TYPECMP' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_VALUE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_NOGRAMMAR' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_INTERSEQ' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_LACKDATA' type='enum'/>
     <exports symbol='XML_RELAXNGP_FREE_DOC' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ATTRNAME' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMNOTEMPTY' type='enum'/>
     <exports symbol='XML_RELAXNG_OK' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_INTERNODATA' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ATTRWRONGNS' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_EXTRACONTENT' type='enum'/>
     <exports symbol='XML_RELAXNGP_NONE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMWRONG' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_LISTEMPTY' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ATTREXTRANS' type='enum'/>
     <exports symbol='XML_RELAXNGP_CRNG' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_TEXTWRONG' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_INVALIDATTR' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMWRONGNS' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_CONTENTVALID' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_TYPEVAL' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_LIST' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_TYPE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_NOELEM' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_MEMORY' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_ELEMNAME' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_DATAELEM' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_NODEFINE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_NOSTATE' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_INTEREXTRA' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_INTERNAL' type='enum'/>
     <exports symbol='XML_RELAXNG_ERR_NOTELEM' type='enum'/>
     <exports symbol='xmlRelaxNG' type='typedef'/>
     <exports symbol='xmlRelaxNGPtr' type='typedef'/>
     <exports symbol='xmlRelaxNGValidErr' type='typedef'/>
     <exports symbol='xmlRelaxNGParserCtxt' type='typedef'/>
     <exports symbol='xmlRelaxNGParserCtxtPtr' type='typedef'/>
     <exports symbol='xmlRelaxNGParserFlag' type='typedef'/>
     <exports symbol='xmlRelaxNGValidCtxt' type='typedef'/>
     <exports symbol='xmlRelaxNGValidCtxtPtr' type='typedef'/>
     <exports symbol='xmlRelaxNGFreeValidCtxt' type='function'/>
     <exports symbol='xmlRelaxNGNewDocParserCtxt' type='function'/>
     <exports symbol='xmlRelaxNGSetValidErrors' type='function'/>
     <exports symbol='xmlRelaxNGNewParserCtxt' type='function'/>
     <exports symbol='xmlRelaxNGGetParserErrors' type='function'/>
     <exports symbol='xmlRelaxNGValidatePopElement' type='function'/>
     <exports symbol='xmlRelaxNGNewValidCtxt' type='function'/>
     <exports symbol='xmlRelaxNGNewMemParserCtxt' type='function'/>
     <exports symbol='xmlRelaxNGDump' type='function'/>
     <exports symbol='xmlRelaxNGSetParserErrors' type='function'/>
     <exports symbol='xmlRelaxNGParse' type='function'/>
     <exports symbol='xmlRelaxNGSetParserStructuredErrors' type='function'/>
     <exports symbol='xmlRelaxNGValidateFullElement' type='function'/>
     <exports symbol='xmlRelaxNGValidityErrorFunc' type='function'/>
     <exports symbol='xmlRelaxNGValidatePushElement' type='function'/>
     <exports symbol='xmlRelaxNGFree' type='function'/>
     <exports symbol='xmlRelaxNGValidateDoc' type='function'/>
     <exports symbol='xmlRelaxNGSetValidStructuredErrors' type='function'/>
     <exports symbol='xmlRelaxNGFreeParserCtxt' type='function'/>
     <exports symbol='xmlRelaxNGGetValidErrors' type='function'/>
     <exports symbol='xmlRelaxNGInitTypes' type='function'/>
     <exports symbol='xmlRelaxNGDumpTree' type='function'/>
     <exports symbol='xmlRelaxNGCleanupTypes' type='function'/>
     <exports symbol='xmlRelaxNGValidatePushCData' type='function'/>
     <exports symbol='xmlRelaxParserSetFlag' type='function'/>
     <exports symbol='xmlRelaxNGValidityWarningFunc' type='function'/>
    </file>
    <file name='schemasInternals'>
     <summary>internal interfaces for XML Schemas</summary>
     <description>internal interfaces for the XML Schemas handling and schema validity checking The Schemas development is a Work In Progress. Some of those interfaces are not garanteed to be API or ABI stable ! </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_FINAL_DEFAULT_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FIXUP_1' type='macro'/>
     <exports symbol='XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_CIRCULAR' type='macro'/>
     <exports symbol='XML_SCHEMAS_QUALIF_ATTR' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_USE_REQUIRED' type='macro'/>
     <exports symbol='XML_SCHEMAS_FACET_COLLAPSE' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_VARIETY_UNION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANY_STRICT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_INTERNAL_RESOLVED' type='macro'/>
     <exports symbol='XML_SCHEMAS_QUALIF_ELEM' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_VARIETY_LIST' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_INTERNAL_CHECKED' type='macro'/>
     <exports symbol='XML_SCHEMAS_INCLUDING_CONVERT_NS' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_INTERNAL_RESOLVED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_USE_PROHIBITED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_NILLABLE' type='macro'/>
     <exports symbol='XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTRGROUP_REDEFINED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_BLOCK_DEFAULT' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FINAL_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_REDEFINED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_FIXED' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_VARIETY_ATOMIC' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FINAL_LIST' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_USE_OPTIONAL' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_NSDEFAULT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_WHITESPACE_REPLACE' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_BLOCK_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_STRICT' type='macro'/>
     <exports symbol='XML_SCHEMAS_FACET_UNKNOWN' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTRGROUP_MARKED' type='macro'/>
     <exports symbol='XML_SCHEMAS_FACET_PRESERVE' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_BLOCK_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_GLOBAL' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_SKIP' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANYATTR_LAX' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_GLOBAL' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_ABSTRACT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_MIXED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTR_FIXED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_INTERNAL_RESOLVED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANY_SKIP' type='macro'/>
     <exports symbol='XML_SCHEMAS_FINAL_DEFAULT_LIST' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_VARIETY_ABSENT' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_FINAL_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_WILDCARD_COMPLETE' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_NSDEFAULT' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_GLOBAL' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_TOPLEVEL' type='macro'/>
     <exports symbol='XML_SCHEMAS_ANY_LAX' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FINAL_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_HAS_FACETS' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_FINAL_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_NORMVALUENEEDED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_FINAL_ABSENT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_BLOCK_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_INTERNAL_INVALID' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTRGROUP_HAS_REFS' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_ABSTRACT' type='macro'/>
     <exports symbol='XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FINAL_UNION' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FINAL_DEFAULT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_FACETSNEEDVALUE' type='macro'/>
     <exports symbol='XML_SCHEMAS_FINAL_DEFAULT_UNION' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_BLOCK_RESTRICTION' type='macro'/>
     <exports symbol='XML_SCHEMAS_FACET_REPLACE' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_DEFAULT' type='macro'/>
     <exports symbol='XML_SCHEMAS_TYPE_MARKED' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_BLOCK_ABSENT' type='macro'/>
     <exports symbol='XML_SCHEMAS_ATTRGROUP_GLOBAL' type='macro'/>
     <exports symbol='XML_SCHEMAS_ELEM_REF' type='macro'/>
     <exports symbol='XML_SCHEMA_EXTRA_QNAMEREF' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_EXTENSION' type='enum'/>
     <exports symbol='XML_SCHEMAS_NMTOKEN' type='enum'/>
     <exports symbol='XML_SCHEMAS_ID' type='enum'/>
     <exports symbol='XML_SCHEMAS_TIME' type='enum'/>
     <exports symbol='XML_SCHEMAS_UBYTE' type='enum'/>
     <exports symbol='XML_SCHEMAS_DATETIME' type='enum'/>
     <exports symbol='XML_SCHEMAS_NNINTEGER' type='enum'/>
     <exports symbol='XML_SCHEMAS_HEXBINARY' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_UNION' type='enum'/>
     <exports symbol='XML_SCHEMAS_UNKNOWN' type='enum'/>
     <exports symbol='XML_SCHEMAS_UINT' type='enum'/>
     <exports symbol='XML_SCHEMAS_NPINTEGER' type='enum'/>
     <exports symbol='XML_SCHEMAS_GMONTHDAY' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MAXEXCLUSIVE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ULONG' type='enum'/>
     <exports symbol='XML_SCHEMAS_PINTEGER' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_CHOICE' type='enum'/>
     <exports symbol='XML_SCHEMAS_DECIMAL' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_UR' type='enum'/>
     <exports symbol='XML_SCHEMAS_DOUBLE' type='enum'/>
     <exports symbol='XML_SCHEMAS_NINTEGER' type='enum'/>
     <exports symbol='XML_SCHEMAS_NORMSTRING' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_PARTICLE' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_SIMPLE' type='enum'/>
     <exports symbol='XML_SCHEMAS_NCNAME' type='enum'/>
     <exports symbol='XML_SCHEMAS_LONG' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ANY_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_SCHEMAS_BOOLEAN' type='enum'/>
     <exports symbol='XML_SCHEMAS_ENTITY' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_GROUP' type='enum'/>
     <exports symbol='XML_SCHEMAS_GYEARMONTH' type='enum'/>
     <exports symbol='XML_SCHEMAS_BASE64BINARY' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_FRACTIONDIGITS' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_WHITESPACE' type='enum'/>
     <exports symbol='XML_SCHEMAS_IDREF' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_TOTALDIGITS' type='enum'/>
     <exports symbol='XML_SCHEMAS_QNAME' type='enum'/>
     <exports symbol='XML_SCHEMAS_TOKEN' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_BASIC' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_ENUMERATION' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_UNKNOWN' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MININCLUSIVE' type='enum'/>
     <exports symbol='XML_SCHEMAS_GMONTH' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_ELEMENTS' type='enum'/>
     <exports symbol='XML_SCHEMAS_GYEAR' type='enum'/>
     <exports symbol='XML_SCHEMA_EXTRA_ATTR_USE_PROHIB' type='enum'/>
     <exports symbol='XML_SCHEMAS_BYTE' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ALL' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_IDC_KEYREF' type='enum'/>
     <exports symbol='XML_SCHEMAS_NOTATION' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MAXINCLUSIVE' type='enum'/>
     <exports symbol='XML_SCHEMAS_NAME' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_LIST' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ATTRIBUTE_USE' type='enum'/>
     <exports symbol='XML_SCHEMAS_GDAY' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ANY' type='enum'/>
     <exports symbol='XML_SCHEMAS_ANYURI' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_COMPLEX' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ATTRIBUTEGROUP' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_BASIC' type='enum'/>
     <exports symbol='XML_SCHEMAS_IDREFS' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_IDC_UNIQUE' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_LENGTH' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_SIMPLE' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_PATTERN' type='enum'/>
     <exports symbol='XML_SCHEMAS_SHORT' type='enum'/>
     <exports symbol='XML_SCHEMAS_LANGUAGE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ANYSIMPLETYPE' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_MIXED' type='enum'/>
     <exports symbol='XML_SCHEMAS_ANYTYPE' type='enum'/>
     <exports symbol='XML_SCHEMAS_DURATION' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_FACET' type='enum'/>
     <exports symbol='XML_SCHEMAS_NMTOKENS' type='enum'/>
     <exports symbol='XML_SCHEMAS_USHORT' type='enum'/>
     <exports symbol='XML_SCHEMAS_INTEGER' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_COMPLEX_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MINEXCLUSIVE' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_IDC_KEY' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_SIMPLE_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAS_FLOAT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ENTITIES' type='enum'/>
     <exports symbol='XML_SCHEMAS_DATE' type='enum'/>
     <exports symbol='XML_SCHEMAS_STRING' type='enum'/>
     <exports symbol='XML_SCHEMAS_INT' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_NOTATION' type='enum'/>
     <exports symbol='XML_SCHEMA_CONTENT_ANY' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MINLENGTH' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_RESTRICTION' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_SEQUENCE' type='enum'/>
     <exports symbol='XML_SCHEMA_TYPE_ELEMENT' type='enum'/>
     <exports symbol='XML_SCHEMA_FACET_MAXLENGTH' type='enum'/>
     <exports symbol='xmlSchemaAttributeGroupPtr' type='typedef'/>
     <exports symbol='xmlSchemaElementPtr' type='typedef'/>
     <exports symbol='xmlSchemaFacetLinkPtr' type='typedef'/>
     <exports symbol='xmlSchemaVal' type='typedef'/>
     <exports symbol='xmlSchemaAttributeLinkPtr' type='typedef'/>
     <exports symbol='xmlSchemaType' type='typedef'/>
     <exports symbol='xmlSchemaAnnot' type='typedef'/>
     <exports symbol='xmlSchemaAnnotPtr' type='typedef'/>
     <exports symbol='xmlSchemaElement' type='typedef'/>
     <exports symbol='xmlSchemaWildcard' type='typedef'/>
     <exports symbol='xmlSchemaWildcardPtr' type='typedef'/>
     <exports symbol='xmlSchemaFacetPtr' type='typedef'/>
     <exports symbol='xmlSchemaTypeLink' type='typedef'/>
     <exports symbol='xmlSchemaAttributeLink' type='typedef'/>
     <exports symbol='xmlSchemaValPtr' type='typedef'/>
     <exports symbol='xmlSchemaFacetLink' type='typedef'/>
     <exports symbol='xmlSchemaWildcardNsPtr' type='typedef'/>
     <exports symbol='xmlSchemaAttributeGroup' type='typedef'/>
     <exports symbol='xmlSchemaTypeLinkPtr' type='typedef'/>
     <exports symbol='xmlSchemaWildcardNs' type='typedef'/>
     <exports symbol='xmlSchemaAttributePtr' type='typedef'/>
     <exports symbol='xmlSchemaNotationPtr' type='typedef'/>
     <exports symbol='xmlSchemaValType' type='typedef'/>
     <exports symbol='xmlSchemaTypePtr' type='typedef'/>
     <exports symbol='xmlSchemaNotation' type='typedef'/>
     <exports symbol='xmlSchemaFacet' type='typedef'/>
     <exports symbol='xmlSchemaContentType' type='typedef'/>
     <exports symbol='xmlSchemaTypeType' type='typedef'/>
     <exports symbol='xmlSchemaAttribute' type='typedef'/>
     <exports symbol='_xmlSchemaWildcardNs' type='struct'/>
     <exports symbol='_xmlSchemaNotation' type='struct'/>
     <exports symbol='_xmlSchemaAttribute' type='struct'/>
     <exports symbol='_xmlSchemaType' type='struct'/>
     <exports symbol='_xmlSchemaAttributeGroup' type='struct'/>
     <exports symbol='_xmlSchemaFacetLink' type='struct'/>
     <exports symbol='_xmlSchemaElement' type='struct'/>
     <exports symbol='_xmlSchema' type='struct'/>
     <exports symbol='_xmlSchemaAttributeLink' type='struct'/>
     <exports symbol='_xmlSchemaFacet' type='struct'/>
     <exports symbol='_xmlSchemaWildcard' type='struct'/>
     <exports symbol='_xmlSchemaTypeLink' type='struct'/>
     <exports symbol='_xmlSchemaAnnot' type='struct'/>
     <exports symbol='xmlSchemaFreeType' type='function'/>
     <exports symbol='xmlSchemaFreeWildcard' type='function'/>
    </file>
    <file name='schematron'>
     <summary>XML Schemastron implementation</summary>
     <description>interface to the XML Schematron validity checking. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SCHEMATRON_OUT_IO' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_BUFFER' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_FILE' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_XML' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_TEXT' type='enum'/>
     <exports symbol='XML_SCHEMATRON_OUT_QUIET' type='enum'/>
     <exports symbol='xmlSchematronValidCtxt' type='typedef'/>
     <exports symbol='xmlSchematronValidOptions' type='typedef'/>
     <exports symbol='xmlSchematronPtr' type='typedef'/>
     <exports symbol='xmlSchematronParserCtxt' type='typedef'/>
     <exports symbol='xmlSchematron' type='typedef'/>
     <exports symbol='xmlSchematronValidCtxtPtr' type='typedef'/>
     <exports symbol='xmlSchematronParserCtxtPtr' type='typedef'/>
     <exports symbol='xmlSchematronValidateDoc' type='function'/>
     <exports symbol='xmlSchematronFreeParserCtxt' type='function'/>
     <exports symbol='xmlSchematronNewMemParserCtxt' type='function'/>
     <exports symbol='xmlSchematronValidityErrorFunc' type='function'/>
     <exports symbol='xmlSchematronNewParserCtxt' type='function'/>
     <exports symbol='xmlSchematronValidityWarningFunc' type='function'/>
     <exports symbol='xmlSchematronFree' type='function'/>
     <exports symbol='xmlSchematronSetValidStructuredErrors' type='function'/>
     <exports symbol='xmlSchematronFreeValidCtxt' type='function'/>
     <exports symbol='xmlSchematronParse' type='function'/>
     <exports symbol='xmlSchematronNewDocParserCtxt' type='function'/>
     <exports symbol='xmlSchematronNewValidCtxt' type='function'/>
    </file>
    <file name='threads'>
     <summary>interfaces for thread handling</summary>
     <description>set of generic threading related routines should work with pthreads, Windows native or TLS threads </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlMutex' type='typedef'/>
     <exports symbol='xmlRMutex' type='typedef'/>
     <exports symbol='xmlRMutexPtr' type='typedef'/>
     <exports symbol='xmlMutexPtr' type='typedef'/>
     <exports symbol='xmlFreeRMutex' type='function'/>
     <exports symbol='xmlGetThreadId' type='function'/>
     <exports symbol='xmlMutexUnlock' type='function'/>
     <exports symbol='xmlCleanupThreads' type='function'/>
     <exports symbol='xmlLockLibrary' type='function'/>
     <exports symbol='xmlNewRMutex' type='function'/>
     <exports symbol='xmlMutexLock' type='function'/>
     <exports symbol='xmlIsMainThread' type='function'/>
     <exports symbol='xmlRMutexUnlock' type='function'/>
     <exports symbol='xmlGetGlobalState' type='function'/>
     <exports symbol='xmlNewMutex' type='function'/>
     <exports symbol='xmlDllMain' type='function'/>
     <exports symbol='xmlFreeMutex' type='function'/>
     <exports symbol='xmlUnlockLibrary' type='function'/>
     <exports symbol='xmlInitThreads' type='function'/>
     <exports symbol='xmlRMutexLock' type='function'/>
    </file>
    <file name='tree'>
     <summary>interfaces for tree manipulation</summary>
     <description>this module describes the structures found in an tree resulting from an XML or HTML parsing, as well as the API provided for various processing on that tree </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_LOCAL_NAMESPACE' type='macro'/>
     <exports symbol='BASE_BUFFER_SIZE' type='macro'/>
     <exports symbol='XML_XML_ID' type='macro'/>
     <exports symbol='xmlRootNode' type='macro'/>
     <exports symbol='XML_GET_LINE' type='macro'/>
     <exports symbol='XML_GET_CONTENT' type='macro'/>
     <exports symbol='xmlChildrenNode' type='macro'/>
     <exports symbol='XML_XML_NAMESPACE' type='macro'/>
     <exports symbol='LIBXML2_NEW_BUFFER' type='macro'/>
     <exports symbol='XML_ATTRIBUTE_IMPLIED' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_ELEMENT' type='enum'/>
     <exports symbol='XML_ENTITY_REF_NODE' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_IDREFS' type='enum'/>
     <exports symbol='XML_BUFFER_ALLOC_DOUBLEIT' type='enum'/>
     <exports symbol='XML_XINCLUDE_END' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_NODE' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_NMTOKENS' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_IDREF' type='enum'/>
     <exports symbol='XML_ELEMENT_TYPE_ELEMENT' type='enum'/>
     <exports symbol='XML_TEXT_NODE' type='enum'/>
     <exports symbol='XML_CDATA_SECTION_NODE' type='enum'/>
     <exports symbol='XML_ELEMENT_NODE' type='enum'/>
     <exports symbol='XML_ELEMENT_DECL' type='enum'/>
     <exports symbol='XML_DOC_USERBUILT' type='enum'/>
     <exports symbol='XML_DOC_INTERNAL' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_REQUIRED' type='enum'/>
     <exports symbol='XML_DOCUMENT_FRAG_NODE' type='enum'/>
     <exports symbol='XML_DOC_DTDVALID' type='enum'/>
     <exports symbol='XML_ELEMENT_TYPE_ANY' type='enum'/>
     <exports symbol='XML_DOC_NSVALID' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_ONCE' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_PCDATA' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_FIXED' type='enum'/>
     <exports symbol='XML_DOCUMENT_TYPE_NODE' type='enum'/>
     <exports symbol='XML_DOC_HTML' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_OPT' type='enum'/>
     <exports symbol='XML_NAMESPACE_DECL' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_NOTATION' type='enum'/>
     <exports symbol='XML_ELEMENT_TYPE_MIXED' type='enum'/>
     <exports symbol='XML_XINCLUDE_START' type='enum'/>
     <exports symbol='XML_BUFFER_ALLOC_HYBRID' type='enum'/>
     <exports symbol='XML_DOC_XINCLUDE' type='enum'/>
     <exports symbol='XML_BUFFER_ALLOC_EXACT' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_ENTITIES' type='enum'/>
     <exports symbol='XML_BUFFER_ALLOC_IMMUTABLE' type='enum'/>
     <exports symbol='XML_NOTATION_NODE' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_SEQ' type='enum'/>
     <exports symbol='XML_ELEMENT_TYPE_EMPTY' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_ENUMERATION' type='enum'/>
     <exports symbol='XML_DOC_OLD10' type='enum'/>
     <exports symbol='XML_HTML_DOCUMENT_NODE' type='enum'/>
     <exports symbol='XML_ELEMENT_TYPE_UNDEFINED' type='enum'/>
     <exports symbol='XML_DOCUMENT_NODE' type='enum'/>
     <exports symbol='XML_DOCB_DOCUMENT_NODE' type='enum'/>
     <exports symbol='XML_COMMENT_NODE' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_NONE' type='enum'/>
     <exports symbol='XML_DTD_NODE' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_OR' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_NMTOKEN' type='enum'/>
     <exports symbol='XML_PI_NODE' type='enum'/>
     <exports symbol='XML_BUFFER_ALLOC_IO' type='enum'/>
     <exports symbol='XML_ENTITY_NODE' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_ENTITY' type='enum'/>
     <exports symbol='XML_DOC_WELLFORMED' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_DECL' type='enum'/>
     <exports symbol='XML_ENTITY_DECL' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_ID' type='enum'/>
     <exports symbol='XML_ATTRIBUTE_CDATA' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_MULT' type='enum'/>
     <exports symbol='XML_ELEMENT_CONTENT_PLUS' type='enum'/>
     <exports symbol='xmlNs' type='typedef'/>
     <exports symbol='xmlElementContent' type='typedef'/>
     <exports symbol='xmlEnumerationPtr' type='typedef'/>
     <exports symbol='xmlBuffer' type='typedef'/>
     <exports symbol='xmlParserInputPtr' type='typedef'/>
     <exports symbol='xmlSAXLocatorPtr' type='typedef'/>
     <exports symbol='xmlParserInput' type='typedef'/>
     <exports symbol='xmlElement' type='typedef'/>
     <exports symbol='xmlNsType' type='typedef'/>
     <exports symbol='xmlBufferAllocationScheme' type='typedef'/>
     <exports symbol='xmlNode' type='typedef'/>
     <exports symbol='xmlDocPtr' type='typedef'/>
     <exports symbol='xmlBufferPtr' type='typedef'/>
     <exports symbol='xmlDOMWrapCtxtPtr' type='typedef'/>
     <exports symbol='xmlRefPtr' type='typedef'/>
     <exports symbol='xmlParserInputBuffer' type='typedef'/>
     <exports symbol='xmlRef' type='typedef'/>
     <exports symbol='xmlDOMWrapCtxt' type='typedef'/>
     <exports symbol='xmlNodePtr' type='typedef'/>
     <exports symbol='xmlParserCtxt' type='typedef'/>
     <exports symbol='xmlDtdPtr' type='typedef'/>
     <exports symbol='xmlAttributeDefault' type='typedef'/>
     <exports symbol='xmlBuf' type='typedef'/>
     <exports symbol='xmlNotation' type='typedef'/>
     <exports symbol='xmlElementType' type='typedef'/>
     <exports symbol='xmlEntity' type='typedef'/>
     <exports symbol='xmlAttr' type='typedef'/>
     <exports symbol='xmlAttributePtr' type='typedef'/>
     <exports symbol='xmlElementTypeVal' type='typedef'/>
     <exports symbol='xmlNotationPtr' type='typedef'/>
     <exports symbol='xmlElementPtr' type='typedef'/>
     <exports symbol='xmlBufPtr' type='typedef'/>
     <exports symbol='xmlElementContentOccur' type='typedef'/>
     <exports symbol='xmlAttrPtr' type='typedef'/>
     <exports symbol='xmlDoc' type='typedef'/>
     <exports symbol='xmlID' type='typedef'/>
     <exports symbol='xmlParserCtxtPtr' type='typedef'/>
     <exports symbol='xmlEntityPtr' type='typedef'/>
     <exports symbol='xmlEnumeration' type='typedef'/>
     <exports symbol='xmlAttributeType' type='typedef'/>
     <exports symbol='xmlNsPtr' type='typedef'/>
     <exports symbol='xmlParserInputBufferPtr' type='typedef'/>
     <exports symbol='xmlSAXHandler' type='typedef'/>
     <exports symbol='xmlOutputBuffer' type='typedef'/>
     <exports symbol='xmlSAXLocator' type='typedef'/>
     <exports symbol='xmlElementContentPtr' type='typedef'/>
     <exports symbol='xmlElementContentType' type='typedef'/>
     <exports symbol='xmlDocProperties' type='typedef'/>
     <exports symbol='xmlIDPtr' type='typedef'/>
     <exports symbol='xmlDtd' type='typedef'/>
     <exports symbol='xmlAttribute' type='typedef'/>
     <exports symbol='xmlOutputBufferPtr' type='typedef'/>
     <exports symbol='xmlSAXHandlerPtr' type='typedef'/>
     <exports symbol='_xmlBuffer' type='struct'/>
     <exports symbol='_xmlAttribute' type='struct'/>
     <exports symbol='_xmlEnumeration' type='struct'/>
     <exports symbol='_xmlNs' type='struct'/>
     <exports symbol='_xmlNode' type='struct'/>
     <exports symbol='_xmlDoc' type='struct'/>
     <exports symbol='_xmlElement' type='struct'/>
     <exports symbol='_xmlID' type='struct'/>
     <exports symbol='_xmlNotation' type='struct'/>
     <exports symbol='_xmlDtd' type='struct'/>
     <exports symbol='_xmlRef' type='struct'/>
     <exports symbol='_xmlAttr' type='struct'/>
     <exports symbol='_xmlDOMWrapCtxt' type='struct'/>
     <exports symbol='_xmlElementContent' type='struct'/>
     <exports symbol='xmlDocCopyNode' type='function'/>
     <exports symbol='xmlNewDocRawNode' type='function'/>
     <exports symbol='xmlBufContent' type='function'/>
     <exports symbol='xmlNewNsPropEatName' type='function'/>
     <exports symbol='xmlStringGetNodeList' type='function'/>
     <exports symbol='xmlNewCDataBlock' type='function'/>
     <exports symbol='xmlBufferWriteCHAR' type='function'/>
     <exports symbol='xmlNodeGetBase' type='function'/>
     <exports symbol='xmlBufferEmpty' type='function'/>
     <exports symbol='xmlBuildQName' type='function'/>
     <exports symbol='xmlValidateNMToken' type='function'/>
     <exports symbol='xmlSaveFormatFileEnc' type='function'/>
     <exports symbol='xmlAddSibling' type='function'/>
     <exports symbol='xmlBufferCreate' type='function'/>
     <exports symbol='xmlNewDocFragment' type='function'/>
     <exports symbol='xmlDocGetRootElement' type='function'/>
     <exports symbol='xmlGetProp' type='function'/>
     <exports symbol='xmlValidateName' type='function'/>
     <exports symbol='xmlBufEnd' type='function'/>
     <exports symbol='xmlValidateQName' type='function'/>
     <exports symbol='xmlHasNsProp' type='function'/>
     <exports symbol='xmlAddPrevSibling' type='function'/>
     <exports symbol='xmlBufferAddHead' type='function'/>
     <exports symbol='xmlNewPI' type='function'/>
     <exports symbol='xmlDocDumpFormatMemoryEnc' type='function'/>
     <exports symbol='xmlSetProp' type='function'/>
     <exports symbol='xmlChildElementCount' type='function'/>
     <exports symbol='xmlElemDump' type='function'/>
     <exports symbol='xmlSaveFormatFileTo' type='function'/>
     <exports symbol='xmlGetIntSubset' type='function'/>
     <exports symbol='xmlNodeBufGetContent' type='function'/>
     <exports symbol='xmlNextElementSibling' type='function'/>
     <exports symbol='xmlBufferWriteChar' type='function'/>
     <exports symbol='xmlBufferFree' type='function'/>
     <exports symbol='xmlDOMWrapCloneNode' type='function'/>
     <exports symbol='xmlNewNode' type='function'/>
     <exports symbol='xmlSaveFileTo' type='function'/>
     <exports symbol='xmlNewTextLen' type='function'/>
     <exports symbol='xmlNewTextChild' type='function'/>
     <exports symbol='xmlNodeSetContent' type='function'/>
     <exports symbol='xmlBufferAdd' type='function'/>
     <exports symbol='xmlNodeDumpOutput' type='function'/>
     <exports symbol='xmlCopyNamespace' type='function'/>
     <exports symbol='xmlSearchNsByHref' type='function'/>
     <exports symbol='xmlAddChild' type='function'/>
     <exports symbol='xmlReconciliateNs' type='function'/>
     <exports symbol='xmlValidateNCName' type='function'/>
     <exports symbol='xmlNewDocComment' type='function'/>
     <exports symbol='xmlGetCompressMode' type='function'/>
     <exports symbol='xmlNodeDump' type='function'/>
     <exports symbol='xmlBufferCreateSize' type='function'/>
     <exports symbol='xmlNodeListGetString' type='function'/>
     <exports symbol='xmlSetCompressMode' type='function'/>
     <exports symbol='xmlSetTreeDoc' type='function'/>
     <exports symbol='xmlDOMWrapAdoptNode' type='function'/>
     <exports symbol='xmlCopyNodeList' type='function'/>
     <exports symbol='xmlNewDocNodeEatName' type='function'/>
     <exports symbol='xmlAddChildList' type='function'/>
     <exports symbol='xmlGetNodePath' type='function'/>
     <exports symbol='xmlFreePropList' type='function'/>
     <exports symbol='xmlNodeAddContent' type='function'/>
     <exports symbol='xmlUnsetNsProp' type='function'/>
     <exports symbol='xmlFirstElementChild' type='function'/>
     <exports symbol='xmlAddNextSibling' type='function'/>
     <exports symbol='xmlIsBlankNode' type='function'/>
     <exports symbol='xmlNewGlobalNs' type='function'/>
     <exports symbol='xmlBufferDump' type='function'/>
     <exports symbol='xmlNodeGetContent' type='function'/>
     <exports symbol='xmlCopyDoc' type='function'/>
     <exports symbol='xmlDOMWrapNewCtxt' type='function'/>
     <exports symbol='xmlDocDumpMemoryEnc' type='function'/>
     <exports symbol='xmlBufGetNodeContent' type='function'/>
     <exports symbol='xmlTextMerge' type='function'/>
     <exports symbol='xmlDocDumpMemory' type='function'/>
     <exports symbol='xmlNewDocPI' type='function'/>
     <exports symbol='xmlFreeNs' type='function'/>
     <exports symbol='xmlDocDump' type='function'/>
     <exports symbol='xmlFreeProp' type='function'/>
     <exports symbol='xmlGetNoNsProp' type='function'/>
     <exports symbol='xmlSplitQName2' type='function'/>
     <exports symbol='xmlNewProp' type='function'/>
     <exports symbol='xmlTextConcat' type='function'/>
     <exports symbol='xmlNodeGetSpacePreserve' type='function'/>
     <exports symbol='xmlBufferShrink' type='function'/>
     <exports symbol='xmlPreviousElementSibling' type='function'/>
     <exports symbol='xmlNodeSetContentLen' type='function'/>
     <exports symbol='xmlNodeAddContentLen' type='function'/>
     <exports symbol='xmlBufferWriteQuotedString' type='function'/>
     <exports symbol='xmlCopyProp' type='function'/>
     <exports symbol='xmlReplaceNode' type='function'/>
     <exports symbol='xmlSetDocCompressMode' type='function'/>
     <exports symbol='xmlCopyNode' type='function'/>
     <exports symbol='xmlUnlinkNode' type='function'/>
     <exports symbol='xmlSplitQName3' type='function'/>
     <exports symbol='xmlDOMWrapAcquireNsFunction' type='function'/>
     <exports symbol='xmlBufUse' type='function'/>
     <exports symbol='xmlDocSetRootElement' type='function'/>
     <exports symbol='xmlGetLineNo' type='function'/>
     <exports symbol='xmlBufferContent' type='function'/>
     <exports symbol='xmlRemoveProp' type='function'/>
     <exports symbol='xmlLastElementChild' type='function'/>
     <exports symbol='xmlNodeGetLang' type='function'/>
     <exports symbol='xmlGetDocCompressMode' type='function'/>
     <exports symbol='xmlBufNodeDump' type='function'/>
     <exports symbol='xmlGetNsProp' type='function'/>
     <exports symbol='xmlNewDocProp' type='function'/>
     <exports symbol='xmlFreeNode' type='function'/>
     <exports symbol='xmlNewNsProp' type='function'/>
     <exports symbol='xmlDOMWrapFreeCtxt' type='function'/>
     <exports symbol='xmlBufferDetach' type='function'/>
     <exports symbol='xmlBufferSetAllocationScheme' type='function'/>
     <exports symbol='xmlNewChild' type='function'/>
     <exports symbol='xmlSearchNs' type='function'/>
     <exports symbol='xmlStringLenGetNodeList' type='function'/>
     <exports symbol='xmlSaveFormatFile' type='function'/>
     <exports symbol='xmlCopyPropList' type='function'/>
     <exports symbol='xmlDocFormatDump' type='function'/>
     <exports symbol='xmlNodeSetSpacePreserve' type='function'/>
     <exports symbol='xmlHasProp' type='function'/>
     <exports symbol='xmlBufferCat' type='function'/>
     <exports symbol='xmlCreateIntSubset' type='function'/>
     <exports symbol='xmlNewDoc' type='function'/>
     <exports symbol='xmlNewCharRef' type='function'/>
     <exports symbol='xmlCopyNamespaceList' type='function'/>
     <exports symbol='xmlNewNodeEatName' type='function'/>
     <exports symbol='xmlBufferResize' type='function'/>
     <exports symbol='xmlNodeSetBase' type='function'/>
     <exports symbol='xmlNewComment' type='function'/>
     <exports symbol='xmlBufferLength' type='function'/>
     <exports symbol='xmlNewText' type='function'/>
     <exports symbol='xmlUnsetProp' type='function'/>
     <exports symbol='xmlGetBufferAllocationScheme' type='function'/>
     <exports symbol='xmlSaveFile' type='function'/>
     <exports symbol='xmlDocCopyNodeList' type='function'/>
     <exports symbol='xmlSetNs' type='function'/>
     <exports symbol='xmlNewNs' type='function'/>
     <exports symbol='xmlDOMWrapRemoveNode' type='function'/>
     <exports symbol='xmlAttrSerializeTxtContent' type='function'/>
     <exports symbol='xmlCopyDtd' type='function'/>
     <exports symbol='xmlNewDocText' type='function'/>
     <exports symbol='xmlNodeListGetRawString' type='function'/>
     <exports symbol='xmlBufferCreateStatic' type='function'/>
     <exports symbol='xmlNewReference' type='function'/>
     <exports symbol='xmlDOMWrapReconcileNamespaces' type='function'/>
     <exports symbol='xmlBufferCCat' type='function'/>
     <exports symbol='xmlGetNsList' type='function'/>
     <exports symbol='xmlBufferGrow' type='function'/>
     <exports symbol='xmlNodeIsText' type='function'/>
     <exports symbol='xmlSetBufferAllocationScheme' type='function'/>
     <exports symbol='xmlIsXHTML' type='function'/>
     <exports symbol='xmlNodeSetLang' type='function'/>
     <exports symbol='xmlFreeDtd' type='function'/>
     <exports symbol='xmlFreeNodeList' type='function'/>
     <exports symbol='xmlFreeDoc' type='function'/>
     <exports symbol='xmlBufShrink' type='function'/>
     <exports symbol='xmlNewDocNode' type='function'/>
     <exports symbol='xmlSaveFileEnc' type='function'/>
     <exports symbol='xmlSetNsProp' type='function'/>
     <exports symbol='xmlDocDumpFormatMemory' type='function'/>
     <exports symbol='xmlSetListDoc' type='function'/>
     <exports symbol='xmlNodeSetName' type='function'/>
     <exports symbol='xmlNewDocTextLen' type='function'/>
     <exports symbol='xmlNewDtd' type='function'/>
     <exports symbol='xmlFreeNsList' type='function'/>
     <exports symbol='xmlGetLastChild' type='function'/>
    </file>
    <file name='uri'>
     <summary>library of generic URI related routines</summary>
     <description>library of generic URI related routines Implements RFC 2396 </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlURI' type='typedef'/>
     <exports symbol='xmlURIPtr' type='typedef'/>
     <exports symbol='_xmlURI' type='struct'/>
     <exports symbol='xmlNormalizeURIPath' type='function'/>
     <exports symbol='xmlPrintURI' type='function'/>
     <exports symbol='xmlParseURIRaw' type='function'/>
     <exports symbol='xmlURIUnescapeString' type='function'/>
     <exports symbol='xmlParseURI' type='function'/>
     <exports symbol='xmlCreateURI' type='function'/>
     <exports symbol='xmlURIEscapeStr' type='function'/>
     <exports symbol='xmlPathToURI' type='function'/>
     <exports symbol='xmlCanonicPath' type='function'/>
     <exports symbol='xmlFreeURI' type='function'/>
     <exports symbol='xmlParseURIReference' type='function'/>
     <exports symbol='xmlBuildRelativeURI' type='function'/>
     <exports symbol='xmlSaveUri' type='function'/>
     <exports symbol='xmlURIEscape' type='function'/>
     <exports symbol='xmlBuildURI' type='function'/>
    </file>
    <file name='valid'>
     <summary>The DTD validation</summary>
     <description>API for the DTD handling and the validity checking </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_CTXT_FINISH_DTD_0' type='macro'/>
     <exports symbol='XML_CTXT_FINISH_DTD_1' type='macro'/>
     <exports symbol='xmlElementTable' type='typedef'/>
     <exports symbol='xmlValidStatePtr' type='typedef'/>
     <exports symbol='xmlIDTablePtr' type='typedef'/>
     <exports symbol='xmlNotationTablePtr' type='typedef'/>
     <exports symbol='xmlValidCtxt' type='typedef'/>
     <exports symbol='xmlElementTablePtr' type='typedef'/>
     <exports symbol='xmlRefTablePtr' type='typedef'/>
     <exports symbol='xmlNotationTable' type='typedef'/>
     <exports symbol='xmlRefTable' type='typedef'/>
     <exports symbol='xmlValidState' type='typedef'/>
     <exports symbol='xmlAttributeTable' type='typedef'/>
     <exports symbol='xmlAttributeTablePtr' type='typedef'/>
     <exports symbol='xmlIDTable' type='typedef'/>
     <exports symbol='xmlValidCtxtPtr' type='typedef'/>
     <exports symbol='_xmlValidCtxt' type='struct'/>
     <exports symbol='xmlFreeNotationTable' type='function'/>
     <exports symbol='xmlValidateNameValue' type='function'/>
     <exports symbol='xmlSnprintfElementContent' type='function'/>
     <exports symbol='xmlAddRef' type='function'/>
     <exports symbol='xmlDumpAttributeDecl' type='function'/>
     <exports symbol='xmlValidateDocumentFinal' type='function'/>
     <exports symbol='xmlValidateDtdFinal' type='function'/>
     <exports symbol='xmlDumpAttributeTable' type='function'/>
     <exports symbol='xmlCreateEnumeration' type='function'/>
     <exports symbol='xmlValidateOneAttribute' type='function'/>
     <exports symbol='xmlValidGetValidElements' type='function'/>
     <exports symbol='xmlIsMixedElement' type='function'/>
     <exports symbol='xmlDumpNotationDecl' type='function'/>
     <exports symbol='xmlIsID' type='function'/>
     <exports symbol='xmlGetDtdQAttrDesc' type='function'/>
     <exports symbol='xmlNewDocElementContent' type='function'/>
     <exports symbol='xmlFreeAttributeTable' type='function'/>
     <exports symbol='xmlValidityErrorFunc' type='function'/>
     <exports symbol='xmlValidateAttributeDecl' type='function'/>
     <exports symbol='xmlGetDtdQElementDesc' type='function'/>
     <exports symbol='xmlCopyNotationTable' type='function'/>
     <exports symbol='xmlValidateDocument' type='function'/>
     <exports symbol='xmlValidGetPotentialChildren' type='function'/>
     <exports symbol='xmlAddNotationDecl' type='function'/>
     <exports symbol='xmlValidateElementDecl' type='function'/>
     <exports symbol='xmlAddAttributeDecl' type='function'/>
     <exports symbol='xmlGetID' type='function'/>
     <exports symbol='xmlCopyElementTable' type='function'/>
     <exports symbol='xmlGetRefs' type='function'/>
     <exports symbol='xmlSprintfElementContent' type='function'/>
     <exports symbol='xmlValidateOneElement' type='function'/>
     <exports symbol='xmlValidateNmtokenValue' type='function'/>
     <exports symbol='xmlDumpElementTable' type='function'/>
     <exports symbol='xmlValidCtxtNormalizeAttributeValue' type='function'/>
     <exports symbol='xmlDumpElementDecl' type='function'/>
     <exports symbol='xmlFreeElementContent' type='function'/>
     <exports symbol='xmlValidateOneNamespace' type='function'/>
     <exports symbol='xmlValidatePushElement' type='function'/>
     <exports symbol='xmlIsRef' type='function'/>
     <exports symbol='xmlCopyDocElementContent' type='function'/>
     <exports symbol='xmlAddID' type='function'/>
     <exports symbol='xmlFreeRefTable' type='function'/>
     <exports symbol='xmlValidateNamesValue' type='function'/>
     <exports symbol='xmlRemoveID' type='function'/>
     <exports symbol='xmlFreeElementTable' type='function'/>
     <exports symbol='xmlFreeIDTable' type='function'/>
     <exports symbol='xmlFreeValidCtxt' type='function'/>
     <exports symbol='xmlCopyAttributeTable' type='function'/>
     <exports symbol='xmlCopyElementContent' type='function'/>
     <exports symbol='xmlValidateAttributeValue' type='function'/>
     <exports symbol='xmlRemoveRef' type='function'/>
     <exports symbol='xmlValidityWarningFunc' type='function'/>
     <exports symbol='xmlValidatePopElement' type='function'/>
     <exports symbol='xmlFreeEnumeration' type='function'/>
     <exports symbol='xmlCopyEnumeration' type='function'/>
     <exports symbol='xmlGetDtdAttrDesc' type='function'/>
     <exports symbol='xmlValidateDtd' type='function'/>
     <exports symbol='xmlNewValidCtxt' type='function'/>
     <exports symbol='xmlDumpNotationTable' type='function'/>
     <exports symbol='xmlAddElementDecl' type='function'/>
     <exports symbol='xmlValidNormalizeAttributeValue' type='function'/>
     <exports symbol='xmlValidBuildContentModel' type='function'/>
     <exports symbol='xmlValidateElement' type='function'/>
     <exports symbol='xmlValidateNotationUse' type='function'/>
     <exports symbol='xmlValidateRoot' type='function'/>
     <exports symbol='xmlValidateNotationDecl' type='function'/>
     <exports symbol='xmlNewElementContent' type='function'/>
     <exports symbol='xmlGetDtdElementDesc' type='function'/>
     <exports symbol='xmlGetDtdNotationDesc' type='function'/>
     <exports symbol='xmlValidatePushCData' type='function'/>
     <exports symbol='xmlValidateNmtokensValue' type='function'/>
     <exports symbol='xmlFreeDocElementContent' type='function'/>
    </file>
    <file name='xinclude'>
     <summary>implementation of XInclude</summary>
     <description>API to handle XInclude processing, implements the World Wide Web Consortium Last Call Working Draft 10 November 2003</description>
     <author>Daniel Veillard </author>
     <exports symbol='XINCLUDE_PARSE_TEXT' type='macro'/>
     <exports symbol='XINCLUDE_PARSE_XPOINTER' type='macro'/>
     <exports symbol='XINCLUDE_HREF' type='macro'/>
     <exports symbol='XINCLUDE_FALLBACK' type='macro'/>
     <exports symbol='XINCLUDE_NS' type='macro'/>
     <exports symbol='XINCLUDE_PARSE' type='macro'/>
     <exports symbol='XINCLUDE_NODE' type='macro'/>
     <exports symbol='XINCLUDE_PARSE_XML' type='macro'/>
     <exports symbol='XINCLUDE_PARSE_ENCODING' type='macro'/>
     <exports symbol='XINCLUDE_OLD_NS' type='macro'/>
     <exports symbol='xmlXIncludeCtxt' type='typedef'/>
     <exports symbol='xmlXIncludeCtxtPtr' type='typedef'/>
     <exports symbol='xmlXIncludeProcessTreeFlagsData' type='function'/>
     <exports symbol='xmlXIncludeProcessFlagsData' type='function'/>
     <exports symbol='xmlXIncludeProcessFlags' type='function'/>
     <exports symbol='xmlXIncludeProcessTree' type='function'/>
     <exports symbol='xmlXIncludeProcessNode' type='function'/>
     <exports symbol='xmlXIncludeFreeContext' type='function'/>
     <exports symbol='xmlXIncludeSetFlags' type='function'/>
     <exports symbol='xmlXIncludeProcess' type='function'/>
     <exports symbol='xmlXIncludeNewContext' type='function'/>
     <exports symbol='xmlXIncludeProcessTreeFlags' type='function'/>
    </file>
    <file name='xlink'>
     <summary>unfinished XLink detection module</summary>
     <description>unfinished XLink detection module </description>
     <author>Daniel Veillard </author>
     <exports symbol='XLINK_ACTUATE_NONE' type='enum'/>
     <exports symbol='XLINK_SHOW_NEW' type='enum'/>
     <exports symbol='XLINK_ACTUATE_AUTO' type='enum'/>
     <exports symbol='XLINK_TYPE_NONE' type='enum'/>
     <exports symbol='XLINK_SHOW_REPLACE' type='enum'/>
     <exports symbol='XLINK_ACTUATE_ONREQUEST' type='enum'/>
     <exports symbol='XLINK_TYPE_EXTENDED' type='enum'/>
     <exports symbol='XLINK_TYPE_EXTENDED_SET' type='enum'/>
     <exports symbol='XLINK_SHOW_NONE' type='enum'/>
     <exports symbol='XLINK_SHOW_EMBED' type='enum'/>
     <exports symbol='XLINK_TYPE_SIMPLE' type='enum'/>
     <exports symbol='xlinkTitle' type='typedef'/>
     <exports symbol='xlinkShow' type='typedef'/>
     <exports symbol='xlinkHRef' type='typedef'/>
     <exports symbol='xlinkActuate' type='typedef'/>
     <exports symbol='xlinkHandler' type='typedef'/>
     <exports symbol='xlinkRole' type='typedef'/>
     <exports symbol='xlinkHandlerPtr' type='typedef'/>
     <exports symbol='xlinkType' type='typedef'/>
     <exports symbol='_xlinkHandler' type='struct'/>
     <exports symbol='xlinkSetDefaultDetect' type='function'/>
     <exports symbol='xlinkSetDefaultHandler' type='function'/>
     <exports symbol='xlinkExtendedLinkFunk' type='function'/>
     <exports symbol='xlinkExtendedLinkSetFunk' type='function'/>
     <exports symbol='xlinkSimpleLinkFunk' type='function'/>
     <exports symbol='xlinkNodeDetectFunc' type='function'/>
     <exports symbol='xlinkGetDefaultHandler' type='function'/>
     <exports symbol='xlinkIsLink' type='function'/>
     <exports symbol='xlinkGetDefaultDetect' type='function'/>
    </file>
    <file name='xmlIO'>
     <summary>interface for the I/O interfaces used by the parser</summary>
     <description>interface for the I/O interfaces used by the parser </description>
     <author>Daniel Veillard </author>
     <exports symbol='_xmlParserInputBuffer' type='struct'/>
     <exports symbol='_xmlOutputBuffer' type='struct'/>
     <exports symbol='xmlIOHTTPRead' type='function'/>
     <exports symbol='xmlInputMatchCallback' type='function'/>
     <exports symbol='xmlRegisterDefaultOutputCallbacks' type='function'/>
     <exports symbol='xmlFileClose' type='function'/>
     <exports symbol='xmlOutputMatchCallback' type='function'/>
     <exports symbol='xmlParserInputBufferPush' type='function'/>
     <exports symbol='xmlIOFTPRead' type='function'/>
     <exports symbol='xmlRegisterHTTPPostCallbacks' type='function'/>
     <exports symbol='xmlIOFTPOpen' type='function'/>
     <exports symbol='xmlIOFTPClose' type='function'/>
     <exports symbol='xmlFileOpen' type='function'/>
     <exports symbol='xmlOutputBufferCreateFile' type='function'/>
     <exports symbol='xmlCheckFilename' type='function'/>
     <exports symbol='xmlOutputOpenCallback' type='function'/>
     <exports symbol='xmlParserInputBufferCreateFilename' type='function'/>
     <exports symbol='xmlOutputBufferClose' type='function'/>
     <exports symbol='xmlAllocParserInputBuffer' type='function'/>
     <exports symbol='xmlOutputBufferCreateIO' type='function'/>
     <exports symbol='xmlOutputWriteCallback' type='function'/>
     <exports symbol='xmlOutputBufferFlush' type='function'/>
     <exports symbol='xmlCheckHTTPInput' type='function'/>
     <exports symbol='xmlRegisterOutputCallbacks' type='function'/>
     <exports symbol='xmlParserInputBufferCreateMem' type='function'/>
     <exports symbol='xmlIOFTPMatch' type='function'/>
     <exports symbol='xmlRegisterInputCallbacks' type='function'/>
     <exports symbol='xmlFreeParserInputBuffer' type='function'/>
     <exports symbol='xmlRegisterDefaultInputCallbacks' type='function'/>
     <exports symbol='xmlParserInputBufferGrow' type='function'/>
     <exports symbol='xmlOutputCloseCallback' type='function'/>
     <exports symbol='xmlAllocOutputBuffer' type='function'/>
     <exports symbol='xmlNoNetExternalEntityLoader' type='function'/>
     <exports symbol='xmlOutputBufferCreateBuffer' type='function'/>
     <exports symbol='xmlIOHTTPMatch' type='function'/>
     <exports symbol='xmlIOHTTPOpen' type='function'/>
     <exports symbol='xmlParserInputBufferCreateIO' type='function'/>
     <exports symbol='xmlOutputBufferCreateFd' type='function'/>
     <exports symbol='xmlNormalizeWindowsPath' type='function'/>
     <exports symbol='xmlInputReadCallback' type='function'/>
     <exports symbol='xmlParserInputBufferCreateStatic' type='function'/>
     <exports symbol='xmlOutputBufferGetContent' type='function'/>
     <exports symbol='xmlIOHTTPClose' type='function'/>
     <exports symbol='xmlOutputBufferWriteEscape' type='function'/>
     <exports symbol='xmlOutputBufferCreateFilename' type='function'/>
     <exports symbol='xmlOutputBufferGetSize' type='function'/>
     <exports symbol='xmlCleanupOutputCallbacks' type='function'/>
     <exports symbol='xmlInputOpenCallback' type='function'/>
     <exports symbol='xmlParserInputBufferRead' type='function'/>
     <exports symbol='xmlOutputBufferWriteString' type='function'/>
     <exports symbol='xmlFileMatch' type='function'/>
     <exports symbol='xmlPopInputCallbacks' type='function'/>
     <exports symbol='xmlFileRead' type='function'/>
     <exports symbol='xmlParserInputBufferCreateFile' type='function'/>
     <exports symbol='xmlParserGetDirectory' type='function'/>
     <exports symbol='xmlOutputBufferWrite' type='function'/>
     <exports symbol='xmlCleanupInputCallbacks' type='function'/>
     <exports symbol='xmlInputCloseCallback' type='function'/>
     <exports symbol='xmlIOHTTPOpenW' type='function'/>
     <exports symbol='xmlParserInputBufferCreateFd' type='function'/>
    </file>
    <file name='xmlautomata'>
     <summary>API to build regexp automata</summary>
     <description>the API to build regexp automata </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlAutomataStatePtr' type='typedef'/>
     <exports symbol='xmlAutomata' type='typedef'/>
     <exports symbol='xmlAutomataPtr' type='typedef'/>
     <exports symbol='xmlAutomataState' type='typedef'/>
     <exports symbol='xmlFreeAutomata' type='function'/>
     <exports symbol='xmlAutomataNewCounter' type='function'/>
     <exports symbol='xmlAutomataGetInitState' type='function'/>
     <exports symbol='xmlAutomataNewTransition2' type='function'/>
     <exports symbol='xmlAutomataNewState' type='function'/>
     <exports symbol='xmlAutomataNewCountTrans' type='function'/>
     <exports symbol='xmlAutomataNewOnceTrans2' type='function'/>
     <exports symbol='xmlAutomataNewAllTrans' type='function'/>
     <exports symbol='xmlAutomataNewCountedTrans' type='function'/>
     <exports symbol='xmlAutomataNewCounterTrans' type='function'/>
     <exports symbol='xmlAutomataCompile' type='function'/>
     <exports symbol='xmlAutomataNewNegTrans' type='function'/>
     <exports symbol='xmlAutomataNewEpsilon' type='function'/>
     <exports symbol='xmlAutomataNewCountTrans2' type='function'/>
     <exports symbol='xmlNewAutomata' type='function'/>
     <exports symbol='xmlAutomataSetFinalState' type='function'/>
     <exports symbol='xmlAutomataNewOnceTrans' type='function'/>
     <exports symbol='xmlAutomataNewTransition' type='function'/>
     <exports symbol='xmlAutomataIsDeterminist' type='function'/>
    </file>
    <file name='xmlerror'>
     <summary>error handling</summary>
     <description>the API used to report errors </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_DTD_ATTRIBUTE_VALUE' type='enum'/>
     <exports symbol='XML_RNGP_PARAM_NAME_MISSING' type='enum'/>
     <exports symbol='XML_RNGP_PARENTREF_NO_PARENT' type='enum'/>
     <exports symbol='XML_IO_EISCONN' type='enum'/>
     <exports symbol='XML_RNGP_VALUE_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI' type='enum'/>
     <exports symbol='XML_SCHEMAP_ELEM_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_CHECK_NOT_DTD' type='enum'/>
     <exports symbol='XML_SCHEMAP_S4S_ATTR_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT' type='enum'/>
     <exports symbol='XML_SCHEMAV_VALUE' type='enum'/>
     <exports symbol='XML_XPATH_UNKNOWN_FUNC_ERROR' type='enum'/>
     <exports symbol='XML_ERR_DOCUMENT_START' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_TEXT' type='enum'/>
     <exports symbol='XML_SCHEMAP_AG_PROPS_CORRECT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_2_1' type='enum'/>
     <exports symbol='XML_DTD_NOT_STANDALONE' type='enum'/>
     <exports symbol='XML_HTTP_USE_IP' type='enum'/>
     <exports symbol='XML_ERR_XMLDECL_NOT_STARTED' type='enum'/>
     <exports symbol='XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAV_ELEMENT_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD' type='enum'/>
     <exports symbol='XML_ERR_LT_IN_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_XINCLUDE_ENTITY_DEF_MISMATCH' type='enum'/>
     <exports symbol='XML_SAVE_NOT_UTF8' type='enum'/>
     <exports symbol='XML_ERR_GT_REQUIRED' type='enum'/>
     <exports symbol='XML_XPTR_EXTRA_OBJECTS' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_ATTR_USE' type='enum'/>
     <exports symbol='XML_IO_UNKNOWN' type='enum'/>
     <exports symbol='XML_RNGP_INTERLEAVE_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION' type='enum'/>
     <exports symbol='XML_IO_ECHILD' type='enum'/>
     <exports symbol='XML_RNGP_NAME_MISSING' type='enum'/>
     <exports symbol='XML_ERR_CONDSEC_NOT_STARTED' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_SIMPLE_TYPE_2' type='enum'/>
     <exports symbol='XML_IO_EINTR' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_SIMPLE_TYPE_1' type='enum'/>
     <exports symbol='XML_RNGP_XMLNS_NAME' type='enum'/>
     <exports symbol='XML_RNGP_ATTRIBUTE_NOOP' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_GROUP' type='enum'/>
     <exports symbol='XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI' type='enum'/>
     <exports symbol='XML_ERR_CHARREF_IN_EPILOG' type='enum'/>
     <exports symbol='XML_DTD_ID_SUBSET' type='enum'/>
     <exports symbol='XML_SCHEMAP_FAILED_BUILD_IMPORT' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD' type='enum'/>
     <exports symbol='XML_XPTR_CHILDSEQ_START' type='enum'/>
     <exports symbol='XML_ERR_EXT_SUBSET_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_FROM_DTD' type='enum'/>
     <exports symbol='XML_CHECK_NOT_ATTR' type='enum'/>
     <exports symbol='XML_DTD_ATTRIBUTE_DEFAULT' type='enum'/>
     <exports symbol='XML_FROM_MODULE' type='enum'/>
     <exports symbol='XML_SCHEMAV_EXTRACONTENT' type='enum'/>
     <exports symbol='XML_RNGP_ELEM_CONTENT_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_WARN_UNLOCATED_SCHEMA' type='enum'/>
     <exports symbol='XML_IO_EMLINK' type='enum'/>
     <exports symbol='XML_ERR_NMTOKEN_REQUIRED' type='enum'/>
     <exports symbol='XML_RNGP_ANYNAME_ATTR_ANCESTOR' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_3_1' type='enum'/>
     <exports symbol='XML_ERR_PI_NOT_STARTED' type='enum'/>
     <exports symbol='XML_RNGP_START_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_3_2' type='enum'/>
     <exports symbol='XML_RNGP_GROUP_ATTR_CONFLICT' type='enum'/>
     <exports symbol='XML_RNGP_EMPTY' type='enum'/>
     <exports symbol='XML_ERR_DOCUMENT_EMPTY' type='enum'/>
     <exports symbol='XML_XINCLUDE_RECURSION' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_RESOLVE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_FACET_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAP_RESTRICTION_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_I18N_NO_OUTPUT' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_ERR_STANDALONE_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_ATTR' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_LOOP' type='enum'/>
     <exports symbol='XML_IO_EINPROGRESS' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_NOTATION' type='enum'/>
     <exports symbol='XML_HTML_STRUCURE_ERROR' type='enum'/>
     <exports symbol='XML_DTD_INVALID_DEFAULT' type='enum'/>
     <exports symbol='XML_FROM_SCHEMATRONV' type='enum'/>
     <exports symbol='XML_DTD_EMPTY_NOTATION' type='enum'/>
     <exports symbol='XML_RNGP_ELEMENT_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED' type='enum'/>
     <exports symbol='XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI' type='enum'/>
     <exports symbol='XML_RNGP_INVALID_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_1_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD' type='enum'/>
     <exports symbol='XML_ERR_PEREF_AT_EOF' type='enum'/>
     <exports symbol='XML_DTD_NOT_EMPTY' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_LIST' type='enum'/>
     <exports symbol='XML_ERR_LT_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_AU_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_ERR_ATTLIST_NOT_STARTED' type='enum'/>
     <exports symbol='XML_ERR_PCDATA_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAV_INTERNAL' type='enum'/>
     <exports symbol='XML_ERR_STRING_NOT_CLOSED' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_IN_DTD' type='enum'/>
     <exports symbol='XML_XPATH_VARIABLE_REF_ERROR' type='enum'/>
     <exports symbol='XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME' type='enum'/>
     <exports symbol='XML_IO_ECANCELED' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTSIMPLE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID' type='enum'/>
     <exports symbol='XML_IO_EADDRINUSE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_LIST_CHILD' type='enum'/>
     <exports symbol='XML_DTD_UNKNOWN_ID' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1' type='enum'/>
     <exports symbol='XML_IO_EDOM' type='enum'/>
     <exports symbol='XML_CHECK_NOT_ELEM_DECL' type='enum'/>
     <exports symbol='XML_RNGP_DEFINE_CREATE_FAILED' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ELEMENT_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ELEMENT_2_1' type='enum'/>
     <exports symbol='XML_RNGP_INVALID_URI' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_LIST' type='enum'/>
     <exports symbol='XML_RNGP_EXCEPT_NO_CONTENT' type='enum'/>
     <exports symbol='XML_RNGP_EXTERNALREF_EMTPY' type='enum'/>
     <exports symbol='XML_ERR_SPACE_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MAXLENGTH_VALID' type='enum'/>
     <exports symbol='XML_DTD_DIFFERENT_PREFIX' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTDETERMINIST' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAV_MISSING' type='enum'/>
     <exports symbol='XML_IO_EFAULT' type='enum'/>
     <exports symbol='XML_XINCLUDE_XPTR_FAILED' type='enum'/>
     <exports symbol='XML_FROM_FTP' type='enum'/>
     <exports symbol='XML_RNGP_PARENTREF_CREATE_FAILED' type='enum'/>
     <exports symbol='XML_ERR_RESERVED_XML_NAME' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_3_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_3_1' type='enum'/>
     <exports symbol='XML_IO_EBADMSG' type='enum'/>
     <exports symbol='XML_XPTR_RESOURCE_ERROR' type='enum'/>
     <exports symbol='XML_RNGP_ATTR_CONFLICT' type='enum'/>
     <exports symbol='XML_DTD_ELEM_REDEFINED' type='enum'/>
     <exports symbol='XML_XINCLUDE_UNKNOWN_ENCODING' type='enum'/>
     <exports symbol='XML_CATALOG_PREFER_VALUE' type='enum'/>
     <exports symbol='XML_ERR_PEREF_SEMICOL_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_1_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_TYPE_AND_SUBTYPE' type='enum'/>
     <exports symbol='XML_SCHEMAP_NO_XMLNS' type='enum'/>
     <exports symbol='XML_IO_ENOTDIR' type='enum'/>
     <exports symbol='XML_SAVE_CHAR_INVALID' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_NO_NAME' type='enum'/>
     <exports symbol='XML_DTD_ID_FIXED' type='enum'/>
     <exports symbol='XML_SCHEMAP_A_PROPS_CORRECT_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_A_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_WAR_NS_COLUMN' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_VALID_DEFAULT_2_1' type='enum'/>
     <exports symbol='XML_ERR_EXTRA_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_GROUP' type='enum'/>
     <exports symbol='XML_ERR_LITERAL_NOT_STARTED' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_REF_AND_SUBTYPE' type='enum'/>
     <exports symbol='XML_RNGP_ELEM_TEXT_CONFLICT' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_TYPE_1' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_CHAR_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3' type='enum'/>
     <exports symbol='XML_CHECK_NO_DICT' type='enum'/>
     <exports symbol='XML_XINCLUDE_XPTR_RESULT' type='enum'/>
     <exports symbol='XML_IO_ENXIO' type='enum'/>
     <exports symbol='XML_XINCLUDE_FRAGMENT_ID' type='enum'/>
     <exports symbol='XML_FROM_HTTP' type='enum'/>
     <exports symbol='XML_DTD_NOTATION_REDEFINED' type='enum'/>
     <exports symbol='XML_WAR_LANG_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_AU_PROPS_CORRECT' type='enum'/>
     <exports symbol='XML_ERR_SEPARATOR_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED' type='enum'/>
     <exports symbol='XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE' type='enum'/>
     <exports symbol='XML_RNGP_ATTRIBUTE_CONTENT' type='enum'/>
     <exports symbol='XML_DTD_XMLID_TYPE' type='enum'/>
     <exports symbol='XML_RNGP_INTERLEAVE_ADD' type='enum'/>
     <exports symbol='XML_DTD_ATTRIBUTE_REDEFINED' type='enum'/>
     <exports symbol='XML_RNGP_UNKNOWN_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_ERR_UNDECLARED_ENTITY' type='enum'/>
     <exports symbol='XML_ERR_PUBID_REQUIRED' type='enum'/>
     <exports symbol='XML_IO_ENOTSOCK' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_GROUP' type='enum'/>
     <exports symbol='XML_RNGP_NOTALLOWED_NOT_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ATTRIBUTE_4' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ATTRIBUTE_3' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ATTRIBUTE_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ATTRIBUTE_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_PREFIX_UNDEFINED' type='enum'/>
     <exports symbol='XML_RNGP_PAT_ATTR_ELEM' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_4_3' type='enum'/>
     <exports symbol='XML_FTP_ACCNT' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_4_1' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_DATA' type='enum'/>
     <exports symbol='XML_IO_ENOENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2' type='enum'/>
     <exports symbol='XML_FROM_C14N' type='enum'/>
     <exports symbol='XML_IO_EIO' type='enum'/>
     <exports symbol='XML_DTD_NOT_PCDATA' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_ATTR_COMBINATION' type='enum'/>
     <exports symbol='XML_RNGP_PARAM_FORBIDDEN' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD' type='enum'/>
     <exports symbol='XML_FROM_WRITER' type='enum'/>
     <exports symbol='XML_ERR_UNSUPPORTED_ENCODING' type='enum'/>
     <exports symbol='XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_IN_PROLOG' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_IDC' type='enum'/>
     <exports symbol='XML_IO_ENOTTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_WARN_SKIP_SCHEMA' type='enum'/>
     <exports symbol='XML_DTD_UNKNOWN_NOTATION' type='enum'/>
     <exports symbol='XML_FROM_DATATYPE' type='enum'/>
     <exports symbol='XML_ERR_WARNING' type='enum'/>
     <exports symbol='XML_SCHEMAP_ATTRFORMDEFAULT_VALUE' type='enum'/>
     <exports symbol='XML_IO_EISDIR' type='enum'/>
     <exports symbol='XML_XINCLUDE_MULTIPLE_ROOT' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_UNION_CHILD' type='enum'/>
     <exports symbol='XML_XPATH_MEMORY_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOROOT' type='enum'/>
     <exports symbol='XML_SCHEMAP_WARN_ATTR_REDECL_PROH' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_3_2_1' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_3_2_2' type='enum'/>
     <exports symbol='XML_XPATH_UNCLOSED_ERROR' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_NOTATION' type='enum'/>
     <exports symbol='XML_CHECK_NO_NEXT' type='enum'/>
     <exports symbol='XML_CHECK_NOT_ATTR_DECL' type='enum'/>
     <exports symbol='XML_CHECK_NO_PARENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_TOTALDIGITS_VALID' type='enum'/>
     <exports symbol='XML_IO_ENOLCK' type='enum'/>
     <exports symbol='XML_XINCLUDE_DEPRECATED_NS' type='enum'/>
     <exports symbol='XML_RNGP_CHOICE_EMPTY' type='enum'/>
     <exports symbol='XML_ERR_LITERAL_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_SEMICOL_MISSING' type='enum'/>
     <exports symbol='XML_DTD_MULTIPLE_ID' type='enum'/>
     <exports symbol='XML_FROM_XPATH' type='enum'/>
     <exports symbol='XML_TREE_INVALID_DEC' type='enum'/>
     <exports symbol='XML_SCHEMAP_EXTENSION_NO_BASE' type='enum'/>
     <exports symbol='XML_SCHEMAP_E_PROPS_CORRECT_5' type='enum'/>
     <exports symbol='XML_SCHEMAP_E_PROPS_CORRECT_4' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_DOCTYPE' type='enum'/>
     <exports symbol='XML_SCHEMAP_E_PROPS_CORRECT_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_E_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP' type='enum'/>
     <exports symbol='XML_SCHEMAP_NO_XSI' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_SIMPLE_TYPE_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_1' type='enum'/>
     <exports symbol='XML_CHECK_NO_NAME' type='enum'/>
     <exports symbol='XML_ERR_CONDSEC_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_PI' type='enum'/>
     <exports symbol='XML_ERR_EQUAL_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_WHITE_SPACE' type='enum'/>
     <exports symbol='XML_DTD_UNKNOWN_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_1_2' type='enum'/>
     <exports symbol='XML_RNGP_INTERLEAVE_CREATE_FAILED' type='enum'/>
     <exports symbol='XML_IO_EAGAIN' type='enum'/>
     <exports symbol='XML_ERR_NOTATION_NOT_STARTED' type='enum'/>
     <exports symbol='XML_DTD_ENTITY_TYPE' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_SIMPLE_TYPE_4' type='enum'/>
     <exports symbol='XML_RNGP_GRAMMAR_CONTENT' type='enum'/>
     <exports symbol='XML_FTP_URL_SYNTAX' type='enum'/>
     <exports symbol='XML_ERR_NONE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD' type='enum'/>
     <exports symbol='XML_XPATH_NUMBER_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_FACET_TYPE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_ONEMORE' type='enum'/>
     <exports symbol='XML_ERR_CONDSEC_INVALID' type='enum'/>
     <exports symbol='XML_XINCLUDE_INCLUDE_IN_INCLUDE' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_IN_EPILOG' type='enum'/>
     <exports symbol='XML_RNGP_GRAMMAR_MISSING' type='enum'/>
     <exports symbol='XML_RNGP_GRAMMAR_NO_START' type='enum'/>
     <exports symbol='XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_INTERLEAVE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ELEMENT_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_REF' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_EMPTY' type='enum'/>
     <exports symbol='XML_FROM_I18N' type='enum'/>
     <exports symbol='XML_DTD_MISSING_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_IO_EMFILE' type='enum'/>
     <exports symbol='XML_RNGP_EMPTY_NOT_EMPTY' type='enum'/>
     <exports symbol='XML_ERR_VERSION_MISSING' type='enum'/>
     <exports symbol='XML_IO_NO_INPUT' type='enum'/>
     <exports symbol='XML_NS_ERR_UNDEFINED_NAMESPACE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MINLENGTH_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_WILDCARD' type='enum'/>
     <exports symbol='XML_IO_WRITE' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_PE_INTERNAL' type='enum'/>
     <exports symbol='XML_DTD_XMLID_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_DERIVED_OK_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_DERIVED_OK_2_1' type='enum'/>
     <exports symbol='XML_CHECK_NOT_NS_DECL' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_ELEM' type='enum'/>
     <exports symbol='XML_IO_NETWORK_ATTEMPT' type='enum'/>
     <exports symbol='XML_MODULE_CLOSE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_EMPTY' type='enum'/>
     <exports symbol='XML_ERR_ATTLIST_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_XINCLUDE_TEXT_FRAGMENT' type='enum'/>
     <exports symbol='XML_C14N_RELATIVE_NAMESPACE' type='enum'/>
     <exports symbol='XML_SCHEMAP_FAILED_LOAD' type='enum'/>
     <exports symbol='XML_ERR_ATTRIBUTE_WITHOUT_VALUE' type='enum'/>
     <exports symbol='XML_ERR_NAME_TOO_LONG' type='enum'/>
     <exports symbol='XML_XPTR_SYNTAX_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_TYPE' type='enum'/>
     <exports symbol='XML_CHECK_WRONG_DOC' type='enum'/>
     <exports symbol='XML_NS_ERR_XML_NAMESPACE' type='enum'/>
     <exports symbol='XML_ERR_DOCTYPE_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_XINCLUDE_PARSE_VALUE' type='enum'/>
     <exports symbol='XML_RNGP_NSNAME_NO_NS' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_IMPORT_2_2' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_ELEMENT' type='enum'/>
     <exports symbol='XML_RNGP_PARENTREF_NAME_INVALID' type='enum'/>
     <exports symbol='XML_NS_ERR_QNAME' type='enum'/>
     <exports symbol='XML_DTD_NOTATION_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_ST_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_ST_PROPS_CORRECT_3' type='enum'/>
     <exports symbol='XML_I18N_NO_NAME' type='enum'/>
     <exports symbol='XML_SCHEMAP_ST_PROPS_CORRECT_1' type='enum'/>
     <exports symbol='XML_RNGP_EXCEPT_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_CT_EXTENDS_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ALL_CHILD' type='enum'/>
     <exports symbol='XML_DTD_MIXED_CORRUPT' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_BOUNDARY' type='enum'/>
     <exports symbol='XML_SCHEMAP_ELEMFORMDEFAULT_VALUE' type='enum'/>
     <exports symbol='XML_I18N_EXCESS_HANDLER' type='enum'/>
     <exports symbol='XML_RNGP_DATA_CONTENT' type='enum'/>
     <exports symbol='XML_ERR_STRING_NOT_STARTED' type='enum'/>
     <exports symbol='XML_RNGP_EXCEPT_MULTIPLE' type='enum'/>
     <exports symbol='XML_IO_EDEADLK' type='enum'/>
     <exports symbol='XML_ERR_ATTRIBUTE_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE' type='enum'/>
     <exports symbol='XML_IO_EINVAL' type='enum'/>
     <exports symbol='XML_IO_ENAMETOOLONG' type='enum'/>
     <exports symbol='XML_RNGP_EXTERNAL_REF_FAILURE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_TEXT' type='enum'/>
     <exports symbol='XML_CHECK_NO_DOC' type='enum'/>
     <exports symbol='XML_DTD_INVALID_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_PATTERN_VALID' type='enum'/>
     <exports symbol='XML_RNGP_TYPE_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1' type='enum'/>
     <exports symbol='XML_ERR_TAG_NAME_MISMATCH' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3' type='enum'/>
     <exports symbol='XML_ERR_ENCODING_NAME' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5' type='enum'/>
     <exports symbol='XML_SCHEMAV_MISC' type='enum'/>
     <exports symbol='XML_IO_ECONNREFUSED' type='enum'/>
     <exports symbol='XML_ERR_XMLDECL_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_SCHEMAP_P_PROPS_CORRECT_1' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_ENTITYREF' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_2_2_1' type='enum'/>
     <exports symbol='XML_XINCLUDE_BUILD_FAILED' type='enum'/>
     <exports symbol='XML_ERR_PEREF_NO_NAME' type='enum'/>
     <exports symbol='XML_ERR_ENTITYREF_AT_EOF' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOATTR_NOREF' type='enum'/>
     <exports symbol='XML_RNGP_ATTRIBUTE_CHILDREN' type='enum'/>
     <exports symbol='XML_XPATH_UNDEF_PREFIX_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_1' type='enum'/>
     <exports symbol='XML_SAVE_NO_DOCTYPE' type='enum'/>
     <exports symbol='XML_ERR_PEREF_IN_EPILOG' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_4' type='enum'/>
     <exports symbol='XML_SCHEMAP_CT_PROPS_CORRECT_4' type='enum'/>
     <exports symbol='XML_ERR_URI_FRAGMENT' type='enum'/>
     <exports symbol='XML_IO_ESPIPE' type='enum'/>
     <exports symbol='XML_DTD_NO_DOC' type='enum'/>
     <exports symbol='XML_SCHEMAP_CT_PROPS_CORRECT_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOT_SCHEMA' type='enum'/>
     <exports symbol='XML_FROM_SCHEMASV' type='enum'/>
     <exports symbol='XML_FROM_SCHEMASP' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_3_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_VALID_DEFAULT_1' type='enum'/>
     <exports symbol='XML_ERR_MIXED_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_DTD_STANDALONE_WHITE_SPACE' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_FACET' type='enum'/>
     <exports symbol='XML_IO_ENOTEMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAV_WRONGELEM' type='enum'/>
     <exports symbol='XML_RNGP_TYPE_NOT_FOUND' type='enum'/>
     <exports symbol='XML_IO_BUFFER_FULL' type='enum'/>
     <exports symbol='XML_SCHEMAP_E_PROPS_CORRECT_6' type='enum'/>
     <exports symbol='XML_DTD_CONTENT_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_MEMBER_TYPE' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOROOT' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_6' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_TYPE' type='enum'/>
     <exports symbol='XML_ERR_CDATA_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_TYPE_3_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_TYPE_3_1_1' type='enum'/>
     <exports symbol='XML_CHECK_NS_ANCESTOR' type='enum'/>
     <exports symbol='XML_ERR_DOCUMENT_END' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_NOT_STARTED' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ENUMERATION_VALID' type='enum'/>
     <exports symbol='XML_ERR_CHARREF_IN_PROLOG' type='enum'/>
     <exports symbol='XML_RNGP_INVALID_DEFINE_NAME' type='enum'/>
     <exports symbol='XML_SAVE_UNKNOWN_ENCODING' type='enum'/>
     <exports symbol='XML_ERR_CONDSEC_INVALID_KEYWORD' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_7' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTYPE' type='enum'/>
     <exports symbol='XML_ERR_NO_MEMORY' type='enum'/>
     <exports symbol='XML_FROM_IO' type='enum'/>
     <exports symbol='XML_HTML_UNKNOWN_TAG' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_ATTR_NAME' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_ATTR' type='enum'/>
     <exports symbol='XML_CHECK_WRONG_NAME' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTEMPTY' type='enum'/>
     <exports symbol='XML_IO_EROFS' type='enum'/>
     <exports symbol='XML_IO_EXDEV' type='enum'/>
     <exports symbol='XML_XINCLUDE_NO_FALLBACK' type='enum'/>
     <exports symbol='XML_RNGP_URI_FRAGMENT' type='enum'/>
     <exports symbol='XML_FROM_MEMORY' type='enum'/>
     <exports symbol='XML_ERR_MISSING_ENCODING' type='enum'/>
     <exports symbol='XML_RNGP_ELEMENT_CONTENT' type='enum'/>
     <exports symbol='XML_RNGP_UNKNOWN_TYPE_LIB' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOT_DETERMINISTIC' type='enum'/>
     <exports symbol='XML_XPATH_EXPRESSION_OK' type='enum'/>
     <exports symbol='XML_HTTP_UNKNOWN_HOST' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_DTD_NO_DTD' type='enum'/>
     <exports symbol='XML_RNGP_PAT_ONEMORE_GROUP_ATTR' type='enum'/>
     <exports symbol='XML_ERR_VALUE_REQUIRED' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_TEXT' type='enum'/>
     <exports symbol='XML_RNGP_URI_NOT_ABSOLUTE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNION_NOT_EXPRESSIBLE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_ATTR' type='enum'/>
     <exports symbol='XML_FTP_PASV_ANSWER' type='enum'/>
     <exports symbol='XML_ERR_VERSION_MISMATCH' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_BOOLEAN' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_4_2' type='enum'/>
     <exports symbol='XML_DTD_ELEM_DEFAULT_NAMESPACE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_4' type='enum'/>
     <exports symbol='XML_SCHEMAP_REGEXP_INVALID' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_1' type='enum'/>
     <exports symbol='XML_C14N_CREATE_STACK' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_2_1' type='enum'/>
     <exports symbol='XML_FROM_RELAXNGV' type='enum'/>
     <exports symbol='XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME' type='enum'/>
     <exports symbol='XML_CHECK_ENTITY_TYPE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CONSTRUCT' type='enum'/>
     <exports symbol='XML_RNGP_EXTERNALREF_RECURSE' type='enum'/>
     <exports symbol='XML_RNGP_CHOICE_CONTENT' type='enum'/>
     <exports symbol='XML_RNGP_UNKNOWN_COMBINE' type='enum'/>
     <exports symbol='XML_RNGP_START_EMPTY' type='enum'/>
     <exports symbol='XML_IO_ENCODER' type='enum'/>
     <exports symbol='XML_WAR_NS_URI' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES' type='enum'/>
     <exports symbol='XML_SCHEMAP_ATTRGRP_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_IS_EXTERNAL' type='enum'/>
     <exports symbol='XML_WAR_UNDECLARED_ENTITY' type='enum'/>
     <exports symbol='XML_SCHEMAV_ATTRUNKNOWN' type='enum'/>
     <exports symbol='XML_IO_ENODEV' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_REF' type='enum'/>
     <exports symbol='XML_FROM_PARSER' type='enum'/>
     <exports symbol='XML_C14N_CREATE_CTXT' type='enum'/>
     <exports symbol='XML_XINCLUDE_TEXT_DOCUMENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_PREFIX' type='enum'/>
     <exports symbol='XML_XINCLUDE_FALLBACKS_IN_INCLUDE' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_TYPE' type='enum'/>
     <exports symbol='XML_CHECK_NS_SCOPE' type='enum'/>
     <exports symbol='XML_IO_FLUSH' type='enum'/>
     <exports symbol='XML_CATALOG_ENTRY_BROKEN' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_CTXT_POSITION' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_LENGTH_VALID' type='enum'/>
     <exports symbol='XML_DTD_STANDALONE_DEFAULTED' type='enum'/>
     <exports symbol='XML_DTD_UNKNOWN_ELEM' type='enum'/>
     <exports symbol='XML_WAR_SPACE_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_FACET_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOTATION_NO_NAME' type='enum'/>
     <exports symbol='XML_XPATH_START_LITERAL_ERROR' type='enum'/>
     <exports symbol='XML_ERR_ELEMCONTENT_NOT_STARTED' type='enum'/>
     <exports symbol='XML_RNGP_INCLUDE_FAILURE' type='enum'/>
     <exports symbol='XML_ERR_COMMENT_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2' type='enum'/>
     <exports symbol='XML_BUF_OVERFLOW' type='enum'/>
     <exports symbol='XML_IO_EMSGSIZE' type='enum'/>
     <exports symbol='XML_FROM_CATALOG' type='enum'/>
     <exports symbol='XML_SCHEMAV_ATTRINVALID' type='enum'/>
     <exports symbol='XML_NS_ERR_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_2' type='enum'/>
     <exports symbol='XML_FROM_HTML' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_MAXOCCURS' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD' type='enum'/>
     <exports symbol='XML_RNGP_ELEMENT_NAME' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_VALUE' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_ARITY' type='enum'/>
     <exports symbol='XML_RNGP_ERROR_TYPE_LIB' type='enum'/>
     <exports symbol='XML_XPTR_EVAL_FAILED' type='enum'/>
     <exports symbol='XML_DTD_NO_ROOT' type='enum'/>
     <exports symbol='XML_SCHEMAP_IMPORT_REDEFINE_NSNAME' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ATTR_CHILD' type='enum'/>
     <exports symbol='XML_ERR_UNKNOWN_ENCODING' type='enum'/>
     <exports symbol='XML_RNGP_REF_NO_NAME' type='enum'/>
     <exports symbol='XML_C14N_UNKNOW_NODE' type='enum'/>
     <exports symbol='XML_SCHEMAP_REF_AND_SUBTYPE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR' type='enum'/>
     <exports symbol='XML_C14N_INVALID_NODE' type='enum'/>
     <exports symbol='XML_RNGP_TEXT_EXPECTED' type='enum'/>
     <exports symbol='XML_XPATH_UNDEF_VARIABLE_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOROLLBACK' type='enum'/>
     <exports symbol='XML_SCHEMAV_FACET' type='enum'/>
     <exports symbol='XML_ERR_INVALID_DEC_CHARREF' type='enum'/>
     <exports symbol='XML_RNGP_NEED_COMBINE' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTTOPLEVEL' type='enum'/>
     <exports symbol='XML_CATALOG_MISSING_ATTR' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_LIST' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_TYPE_2' type='enum'/>
     <exports symbol='XML_RNGP_EXCEPT_EMPTY' type='enum'/>
     <exports symbol='XML_XPATH_UNFINISHED_LITERAL_ERROR' type='enum'/>
     <exports symbol='XML_RNGP_INTERLEAVE_NO_CONTENT' type='enum'/>
     <exports symbol='XML_ERR_INVALID_HEX_CHARREF' type='enum'/>
     <exports symbol='XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_ERR_CHARREF_IN_DTD' type='enum'/>
     <exports symbol='XML_IO_ENFILE' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_IS_PARAMETER' type='enum'/>
     <exports symbol='XML_I18N_CONV_FAILED' type='enum'/>
     <exports symbol='XML_CHECK_WRONG_PARENT' type='enum'/>
     <exports symbol='XML_RNGP_PARENTREF_NO_NAME' type='enum'/>
     <exports symbol='XML_IO_EPERM' type='enum'/>
     <exports symbol='XML_IO_ENETUNREACH' type='enum'/>
     <exports symbol='XML_ERR_CHARREF_AT_EOF' type='enum'/>
     <exports symbol='XML_IO_ENOMEM' type='enum'/>
     <exports symbol='XML_IO_ENOSPC' type='enum'/>
     <exports symbol='XML_FROM_NONE' type='enum'/>
     <exports symbol='XML_RNGP_TYPE_VALUE' type='enum'/>
     <exports symbol='XML_FROM_REGEXP' type='enum'/>
     <exports symbol='XML_RNGP_DEF_CHOICE_AND_INTERLEAVE' type='enum'/>
     <exports symbol='XML_TREE_UNTERMINATED_ENTITY' type='enum'/>
     <exports symbol='XML_ERR_URI_REQUIRED' type='enum'/>
     <exports symbol='XML_FROM_TREE' type='enum'/>
     <exports symbol='XML_ERR_EXT_ENTITY_STANDALONE' type='enum'/>
     <exports symbol='XML_TREE_INVALID_HEX' type='enum'/>
     <exports symbol='XML_C14N_REQUIRES_UTF8' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_PROCESSING' type='enum'/>
     <exports symbol='XML_FROM_XINCLUDE' type='enum'/>
     <exports symbol='XML_SCHEMAP_CVC_SIMPLE_TYPE' type='enum'/>
     <exports symbol='XML_RNGP_GRAMMAR_EMPTY' type='enum'/>
     <exports symbol='XML_CHECK_NOT_NCNAME' type='enum'/>
     <exports symbol='XML_RNGP_ELEMENT_NO_CONTENT' type='enum'/>
     <exports symbol='XML_XINCLUDE_NO_HREF' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_OPERAND' type='enum'/>
     <exports symbol='XML_IO_ENOEXEC' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_REF' type='enum'/>
     <exports symbol='XML_XINCLUDE_HREF_URI' type='enum'/>
     <exports symbol='XML_SCHEMAP_FAILED_PARSE' type='enum'/>
     <exports symbol='XML_RNGP_HREF_ERROR' type='enum'/>
     <exports symbol='XML_ERR_ATTRIBUTE_NOT_STARTED' type='enum'/>
     <exports symbol='XML_SCHEMAP_ATTR_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_ELEMENT_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE' type='enum'/>
     <exports symbol='XML_MODULE_OPEN' type='enum'/>
     <exports symbol='XML_ERR_ENTITY_CHAR_ERROR' type='enum'/>
     <exports symbol='XML_DTD_UNKNOWN_ENTITY' type='enum'/>
     <exports symbol='XML_RNGP_PARSE_ERROR' type='enum'/>
     <exports symbol='XML_ERR_NOTATION_PROCESSING' type='enum'/>
     <exports symbol='XML_RNGP_XML_NS' type='enum'/>
     <exports symbol='XML_ERR_MISPLACED_CDATA_END' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_ONEMORE' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_CT_EXTENDS_1_1' type='enum'/>
     <exports symbol='XML_RNGP_REF_CREATE_FAILED' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_CT_EXTENDS_1_3' type='enum'/>
     <exports symbol='XML_DTD_ROOT_NAME' type='enum'/>
     <exports symbol='XML_RNGP_REF_NOT_EMPTY' type='enum'/>
     <exports symbol='XML_CHECK_NO_HREF' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_CHOICE_CHILD' type='enum'/>
     <exports symbol='XML_RNGP_ELEM_CONTENT_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAV_HAVEDEFAULT' type='enum'/>
     <exports symbol='XML_I18N_NO_HANDLER' type='enum'/>
     <exports symbol='XML_RNGP_MISSING_HREF' type='enum'/>
     <exports symbol='XML_ERR_PI_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_ERR_UNKNOWN_VERSION' type='enum'/>
     <exports symbol='XML_FROM_RELAXNGP' type='enum'/>
     <exports symbol='XML_FROM_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAP_S4S_ATTR_INVALID_VALUE' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_TEXT' type='enum'/>
     <exports symbol='XML_ERR_NO_DTD' type='enum'/>
     <exports symbol='XML_RNGP_START_CHOICE_AND_INTERLEAVE' type='enum'/>
     <exports symbol='XML_FROM_XSLT' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_ATTR' type='enum'/>
     <exports symbol='XML_IO_EACCES' type='enum'/>
     <exports symbol='XML_ERR_NOTATION_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_SCHEMATRONV_ASSERT' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_INVALIDATTR' type='enum'/>
     <exports symbol='XML_SCHEMAP_RECURSIVE' type='enum'/>
     <exports symbol='XML_HTTP_URL_SYNTAX' type='enum'/>
     <exports symbol='XML_SCHEMAP_GROUP_NONAME_NOREF' type='enum'/>
     <exports symbol='XML_DTD_DUP_TOKEN' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4' type='enum'/>
     <exports symbol='XML_SCHEMAP_S4S_ELEM_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_1_1' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_FRAGMENT' type='enum'/>
     <exports symbol='XML_DTD_LOAD_ERROR' type='enum'/>
     <exports symbol='XML_CHECK_UNKNOWN_NODE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_NOTATION_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAP_C_PROPS_CORRECT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_CT_1' type='enum'/>
     <exports symbol='XML_RNGP_EMPTY_CONTENT' type='enum'/>
     <exports symbol='XML_IO_EALREADY' type='enum'/>
     <exports symbol='XML_IO_ERANGE' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1' type='enum'/>
     <exports symbol='XML_IO_ENOSYS' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOTHING_TO_PARSE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_CTXT_SIZE' type='enum'/>
     <exports symbol='XML_CHECK_NO_ELEM' type='enum'/>
     <exports symbol='XML_XPATH_EXPR_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI' type='enum'/>
     <exports symbol='XML_RNGP_DEFINE_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_ENTITY' type='enum'/>
     <exports symbol='XML_CHECK_NAME_NOT_NULL' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_MINOCCURS' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ALL_LIMITED' type='enum'/>
     <exports symbol='XML_SCHEMATRONV_REPORT' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID' type='enum'/>
     <exports symbol='XML_IO_EPIPE' type='enum'/>
     <exports symbol='XML_SCHEMAP_NOTYPE_NOREF' type='enum'/>
     <exports symbol='XML_RNGP_ATTRIBUTE_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3' type='enum'/>
     <exports symbol='XML_IO_LOAD_ERROR' type='enum'/>
     <exports symbol='XML_CHECK_NOT_ENTITY_DECL' type='enum'/>
     <exports symbol='XML_RNGP_CREATE_FAILURE' type='enum'/>
     <exports symbol='XML_IO_EBADF' type='enum'/>
     <exports symbol='XML_RNGP_PREFIX_UNDEFINED' type='enum'/>
     <exports symbol='XML_ERR_HYPHEN_IN_COMMENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE' type='enum'/>
     <exports symbol='XML_RNGP_INCLUDE_EMPTY' type='enum'/>
     <exports symbol='XML_RNGP_PARENTREF_NOT_EMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAP_FACET_NO_VALUE' type='enum'/>
     <exports symbol='XML_XPTR_SUB_RESOURCE_ERROR' type='enum'/>
     <exports symbol='XML_ERR_NOT_STANDALONE' type='enum'/>
     <exports symbol='XML_RNGP_START_MISSING' type='enum'/>
     <exports symbol='XML_DTD_NO_PREFIX' type='enum'/>
     <exports symbol='XML_CATALOG_RECURSION' type='enum'/>
     <exports symbol='XML_RNGP_UNKNOWN_CONSTRUCT' type='enum'/>
     <exports symbol='XML_ERR_UNPARSED_ENTITY' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_IMPORT_CHILD' type='enum'/>
     <exports symbol='XML_FTP_EPSV_ANSWER' type='enum'/>
     <exports symbol='XML_CHECK_NOT_UTF8' type='enum'/>
     <exports symbol='XML_ERR_FATAL' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_1' type='enum'/>
     <exports symbol='XML_DTD_ID_REDEFINED' type='enum'/>
     <exports symbol='XML_XPATH_ENCODING_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_INCLUDE' type='enum'/>
     <exports symbol='XML_RNGP_NSNAME_ATTR_ANCESTOR' type='enum'/>
     <exports symbol='XML_SCHEMAP_SRC_REDEFINE' type='enum'/>
     <exports symbol='XML_RNGP_REF_CYCLE' type='enum'/>
     <exports symbol='XML_RNGP_PAT_ATTR_ATTR' type='enum'/>
     <exports symbol='XML_XPTR_UNKNOWN_SCHEME' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_FACET_VALUE' type='enum'/>
     <exports symbol='XML_FROM_CHECK' type='enum'/>
     <exports symbol='XML_SCHEMAV_ELEMCONT' type='enum'/>
     <exports symbol='XML_SCHEMAP_REF_AND_CONTENT' type='enum'/>
     <exports symbol='XML_RNGP_PAT_START_INTERLEAVE' type='enum'/>
     <exports symbol='XML_DTD_CONTENT_NOT_DETERMINIST' type='enum'/>
     <exports symbol='XML_DTD_NO_ELEM_NAME' type='enum'/>
     <exports symbol='XML_CHECK_NO_PREV' type='enum'/>
     <exports symbol='XML_RNGP_VALUE_NO_CONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD' type='enum'/>
     <exports symbol='XML_TREE_NOT_UTF8' type='enum'/>
     <exports symbol='XML_IO_EAFNOSUPPORT' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1' type='enum'/>
     <exports symbol='XML_CATALOG_NOT_CATALOG' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4' type='enum'/>
     <exports symbol='XML_IO_EFBIG' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_COMMENT' type='enum'/>
     <exports symbol='XML_RNGP_REF_NAME_INVALID' type='enum'/>
     <exports symbol='XML_ERR_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1' type='enum'/>
     <exports symbol='XML_DTD_ELEM_NAMESPACE' type='enum'/>
     <exports symbol='XML_CHECK_OUTSIDE_DICT' type='enum'/>
     <exports symbol='XML_SCHEMAP_P_PROPS_CORRECT_2_1' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_2_2_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_ELT_5_2_2_2_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_P_PROPS_CORRECT_2_2' type='enum'/>
     <exports symbol='XML_WAR_CATALOG_PI' type='enum'/>
     <exports symbol='XML_REGEXP_COMPILE_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_MININCLUSIVE_VALID' type='enum'/>
     <exports symbol='XML_SCHEMAV_ISABSTRACT' type='enum'/>
     <exports symbol='XML_RNGP_DEFINE_MISSING' type='enum'/>
     <exports symbol='XML_ERR_NS_DECL_ERROR' type='enum'/>
     <exports symbol='XML_ERR_INTERNAL_ERROR' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1' type='enum'/>
     <exports symbol='XML_ERR_ELEMCONTENT_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_FROM_NAMESPACE' type='enum'/>
     <exports symbol='XML_IO_EBUSY' type='enum'/>
     <exports symbol='XML_RNGP_INCLUDE_RECURSE' type='enum'/>
     <exports symbol='XML_ERR_INVALID_URI' type='enum'/>
     <exports symbol='XML_IO_ESRCH' type='enum'/>
     <exports symbol='XML_FROM_XPOINTER' type='enum'/>
     <exports symbol='XML_FROM_BUFFER' type='enum'/>
     <exports symbol='XML_ERR_PEREF_IN_PROLOG' type='enum'/>
     <exports symbol='XML_RNGP_TEXT_HAS_CHILD' type='enum'/>
     <exports symbol='XML_SCHEMAV_NOTNILLABLE' type='enum'/>
     <exports symbol='XML_SCHEMAP_ELEM_DEFAULT_FIXED' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_ELEMENT' type='enum'/>
     <exports symbol='XML_RNGP_REF_NO_DEF' type='enum'/>
     <exports symbol='XML_ERR_NOT_WELL_BALANCED' type='enum'/>
     <exports symbol='XML_SCHEMAP_CT_PROPS_CORRECT_5' type='enum'/>
     <exports symbol='XML_ERR_INVALID_CHARREF' type='enum'/>
     <exports symbol='XML_SCHEMAP_CT_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_ERR_INVALID_CHAR' type='enum'/>
     <exports symbol='XML_RNGP_FOREIGN_ELEMENT' type='enum'/>
     <exports symbol='XML_SCHEMAP_DEF_AND_PREFIX' type='enum'/>
     <exports symbol='XML_ERR_MIXED_NOT_STARTED' type='enum'/>
     <exports symbol='XML_ERR_USER_STOP' type='enum'/>
     <exports symbol='XML_CHECK_FOUND_CDATA' type='enum'/>
     <exports symbol='XML_SCHEMAP_INTERNAL' type='enum'/>
     <exports symbol='XML_SCHEMAV_INVALIDELEM' type='enum'/>
     <exports symbol='XML_ERR_INVALID_ENCODING' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_AU' type='enum'/>
     <exports symbol='XML_CHECK_WRONG_NEXT' type='enum'/>
     <exports symbol='XML_ERR_TAG_NOT_FINISHED' type='enum'/>
     <exports symbol='XML_ERR_LTSLASH_REQUIRED' type='enum'/>
     <exports symbol='XML_SCHEMAP_REDEFINED_ATTRGROUP' type='enum'/>
     <exports symbol='XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH' type='enum'/>
     <exports symbol='XML_ERR_PEREF_IN_INT_SUBSET' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_BASE_TYPE' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_ELEM_CHILD' type='enum'/>
     <exports symbol='XML_WAR_UNKNOWN_VERSION' type='enum'/>
     <exports symbol='XML_DTD_CONTENT_MODEL' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1' type='enum'/>
     <exports symbol='XML_ERR_OK' type='enum'/>
     <exports symbol='XML_NS_ERR_COLON' type='enum'/>
     <exports symbol='XML_WAR_ENTITY_REDEFINED' type='enum'/>
     <exports symbol='XML_ERR_ATTRIBUTE_REDEFINED' type='enum'/>
     <exports symbol='XML_SCHEMAP_SIMPLETYPE_NONAME' type='enum'/>
     <exports symbol='XML_SCHEMAP_UNKNOWN_GROUP_CHILD' type='enum'/>
     <exports symbol='XML_IO_ENOTSUP' type='enum'/>
     <exports symbol='XML_WAR_NS_URI_RELATIVE' type='enum'/>
     <exports symbol='XML_NS_ERR_ATTRIBUTE_REDEFINED' type='enum'/>
     <exports symbol='XML_ERR_NAME_REQUIRED' type='enum'/>
     <exports symbol='XML_IO_ETIMEDOUT' type='enum'/>
     <exports symbol='XML_SCHEMAP_INVALID_ENUM' type='enum'/>
     <exports symbol='XML_RNGP_DEFINE_NAME_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2' type='enum'/>
     <exports symbol='XML_RNGP_EMPTY_CONSTRUCT' type='enum'/>
     <exports symbol='XML_RNGP_FORBIDDEN_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_FROM_OUTPUT' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1' type='enum'/>
     <exports symbol='XML_CHECK_WRONG_PREV' type='enum'/>
     <exports symbol='XML_IO_EEXIST' type='enum'/>
     <exports symbol='XML_SCHEMAP_MG_PROPS_CORRECT_2' type='enum'/>
     <exports symbol='XML_SCHEMAP_MG_PROPS_CORRECT_1' type='enum'/>
     <exports symbol='XML_FROM_URI' type='enum'/>
     <exports symbol='XML_RNGP_PAT_LIST_ELEM' type='enum'/>
     <exports symbol='XML_SCHEMAV_UNDECLAREDELEM' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3' type='enum'/>
     <exports symbol='XML_SCHEMAP_CT_PROPS_CORRECT_3' type='enum'/>
     <exports symbol='XML_XINCLUDE_INVALID_CHAR' type='enum'/>
     <exports symbol='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4' type='enum'/>
     <exports symbol='XML_XPATH_INVALID_PREDICATE_ERROR' type='enum'/>
     <exports symbol='xmlErrorPtr' type='typedef'/>
     <exports symbol='xmlErrorLevel' type='typedef'/>
     <exports symbol='xmlParserErrors' type='typedef'/>
     <exports symbol='xmlErrorDomain' type='typedef'/>
     <exports symbol='xmlError' type='typedef'/>
     <exports symbol='_xmlError' type='struct'/>
     <exports symbol='xmlParserValidityError' type='function'/>
     <exports symbol='xmlGenericErrorFunc' type='function'/>
     <exports symbol='xmlSetGenericErrorFunc' type='function'/>
     <exports symbol='xmlParserPrintFileInfo' type='function'/>
     <exports symbol='xmlCtxtResetLastError' type='function'/>
     <exports symbol='xmlResetLastError' type='function'/>
     <exports symbol='initGenericErrorDefaultFunc' type='function'/>
     <exports symbol='xmlCopyError' type='function'/>
     <exports symbol='xmlParserValidityWarning' type='function'/>
     <exports symbol='xmlParserPrintFileContext' type='function'/>
     <exports symbol='xmlParserError' type='function'/>
     <exports symbol='xmlParserWarning' type='function'/>
     <exports symbol='xmlStructuredErrorFunc' type='function'/>
     <exports symbol='xmlSetStructuredErrorFunc' type='function'/>
     <exports symbol='xmlResetError' type='function'/>
     <exports symbol='xmlGetLastError' type='function'/>
     <exports symbol='xmlCtxtGetLastError' type='function'/>
    </file>
    <file name='xmlexports'>
     <summary>macros for marking symbols as exportable/importable.</summary>
     <description>macros for marking symbols as exportable/importable. </description>
     <author>Igor Zlatovic &lt;igor@zlatkovic.com&gt; </author>
     <exports symbol='_REENTRANT' type='macro'/>
     <exports symbol='XMLCDECL' type='macro'/>
     <exports symbol='XMLPUBVAR' type='macro'/>
     <exports symbol='LIBXML_DLL_IMPORT' type='macro'/>
     <exports symbol='XMLCALL' type='macro'/>
     <exports symbol='XMLPUBFUN' type='macro'/>
    </file>
    <file name='xmlmemory'>
     <summary>interface for the memory allocator</summary>
     <description>provides interfaces for the memory allocator, including debugging capabilities. </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlRealloc' type='macro'/>
     <exports symbol='xmlMalloc' type='macro'/>
     <exports symbol='xmlMallocAtomic' type='macro'/>
     <exports symbol='DEBUG_MEMORY' type='macro'/>
     <exports symbol='xmlMemStrdup' type='macro'/>
     <exports symbol='xmlMemRealloc' type='function'/>
     <exports symbol='xmlInitMemory' type='function'/>
     <exports symbol='xmlMemFree' type='function'/>
     <exports symbol='xmlMemMalloc' type='function'/>
     <exports symbol='xmlMemDisplayLast' type='function'/>
     <exports symbol='xmlMemGet' type='function'/>
     <exports symbol='xmlMemoryDump' type='function'/>
     <exports symbol='xmlMallocLoc' type='function'/>
     <exports symbol='xmlMemDisplay' type='function'/>
     <exports symbol='xmlMemBlocks' type='function'/>
     <exports symbol='xmlGcMemGet' type='function'/>
     <exports symbol='xmlStrdupFunc' type='function'/>
     <exports symbol='xmlFreeFunc' type='function'/>
     <exports symbol='xmlMemShow' type='function'/>
     <exports symbol='xmlMallocAtomicLoc' type='function'/>
     <exports symbol='xmlReallocLoc' type='function'/>
     <exports symbol='xmlCleanupMemory' type='function'/>
     <exports symbol='xmlMemUsed' type='function'/>
     <exports symbol='xmlMemSetup' type='function'/>
     <exports symbol='xmlReallocFunc' type='function'/>
     <exports symbol='xmlMallocFunc' type='function'/>
     <exports symbol='xmlGcMemSetup' type='function'/>
     <exports symbol='xmlMemoryStrdup' type='function'/>
     <exports symbol='xmlMemStrdupLoc' type='function'/>
    </file>
    <file name='xmlmodule'>
     <summary>dynamic module loading</summary>
     <description>basic API for dynamic module loading, used by libexslt added in 2.6.17 </description>
     <author>Joel W. Reed </author>
     <exports symbol='XML_MODULE_LAZY' type='enum'/>
     <exports symbol='XML_MODULE_LOCAL' type='enum'/>
     <exports symbol='xmlModule' type='typedef'/>
     <exports symbol='xmlModulePtr' type='typedef'/>
     <exports symbol='xmlModuleOption' type='typedef'/>
     <exports symbol='xmlModuleFree' type='function'/>
     <exports symbol='xmlModuleSymbol' type='function'/>
     <exports symbol='xmlModuleOpen' type='function'/>
     <exports symbol='xmlModuleClose' type='function'/>
    </file>
    <file name='xmlreader'>
     <summary>the XMLReader implementation</summary>
     <description>API of the XML streaming API based on C# interfaces. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_READER_TYPE_DOCUMENT_FRAGMENT' type='enum'/>
     <exports symbol='XML_PARSER_SEVERITY_ERROR' type='enum'/>
     <exports symbol='XML_READER_TYPE_ELEMENT' type='enum'/>
     <exports symbol='XML_READER_TYPE_TEXT' type='enum'/>
     <exports symbol='XML_READER_TYPE_XML_DECLARATION' type='enum'/>
     <exports symbol='XML_READER_TYPE_NONE' type='enum'/>
     <exports symbol='XML_PARSER_SEVERITY_VALIDITY_ERROR' type='enum'/>
     <exports symbol='XML_READER_TYPE_PROCESSING_INSTRUCTION' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_ERROR' type='enum'/>
     <exports symbol='XML_READER_TYPE_ATTRIBUTE' type='enum'/>
     <exports symbol='XML_PARSER_SEVERITY_WARNING' type='enum'/>
     <exports symbol='XML_READER_TYPE_DOCUMENT' type='enum'/>
     <exports symbol='XML_READER_TYPE_DOCUMENT_TYPE' type='enum'/>
     <exports symbol='XML_READER_TYPE_END_ELEMENT' type='enum'/>
     <exports symbol='XML_READER_TYPE_WHITESPACE' type='enum'/>
     <exports symbol='XML_READER_TYPE_NOTATION' type='enum'/>
     <exports symbol='XML_PARSER_SUBST_ENTITIES' type='enum'/>
     <exports symbol='XML_READER_TYPE_ENTITY_REFERENCE' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_INITIAL' type='enum'/>
     <exports symbol='XML_READER_TYPE_COMMENT' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_CLOSED' type='enum'/>
     <exports symbol='XML_PARSER_DEFAULTATTRS' type='enum'/>
     <exports symbol='XML_READER_TYPE_ENTITY' type='enum'/>
     <exports symbol='XML_READER_TYPE_SIGNIFICANT_WHITESPACE' type='enum'/>
     <exports symbol='XML_READER_TYPE_END_ENTITY' type='enum'/>
     <exports symbol='XML_PARSER_VALIDATE' type='enum'/>
     <exports symbol='XML_PARSER_SEVERITY_VALIDITY_WARNING' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_READING' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_EOF' type='enum'/>
     <exports symbol='XML_READER_TYPE_CDATA' type='enum'/>
     <exports symbol='XML_PARSER_LOADDTD' type='enum'/>
     <exports symbol='XML_TEXTREADER_MODE_INTERACTIVE' type='enum'/>
     <exports symbol='xmlTextReaderPtr' type='typedef'/>
     <exports symbol='xmlParserSeverities' type='typedef'/>
     <exports symbol='xmlParserProperties' type='typedef'/>
     <exports symbol='xmlTextReaderMode' type='typedef'/>
     <exports symbol='xmlTextReader' type='typedef'/>
     <exports symbol='xmlTextReaderLocatorPtr' type='typedef'/>
     <exports symbol='xmlReaderTypes' type='typedef'/>
     <exports symbol='xmlNewTextReaderFilename' type='function'/>
     <exports symbol='xmlTextReaderHasAttributes' type='function'/>
     <exports symbol='xmlTextReaderReadState' type='function'/>
     <exports symbol='xmlReaderForFile' type='function'/>
     <exports symbol='xmlTextReaderConstNamespaceUri' type='function'/>
     <exports symbol='xmlTextReaderCurrentDoc' type='function'/>
     <exports symbol='xmlTextReaderGetParserLineNumber' type='function'/>
     <exports symbol='xmlTextReaderExpand' type='function'/>
     <exports symbol='xmlTextReaderXmlLang' type='function'/>
     <exports symbol='xmlReaderForDoc' type='function'/>
     <exports symbol='xmlReaderNewIO' type='function'/>
     <exports symbol='xmlTextReaderClose' type='function'/>
     <exports symbol='xmlTextReaderReadInnerXml' type='function'/>
     <exports symbol='xmlTextReaderConstEncoding' type='function'/>
     <exports symbol='xmlTextReaderNormalization' type='function'/>
     <exports symbol='xmlTextReaderGetParserProp' type='function'/>
     <exports symbol='xmlTextReaderMoveToAttribute' type='function'/>
     <exports symbol='xmlTextReaderQuoteChar' type='function'/>
     <exports symbol='xmlTextReaderSetSchema' type='function'/>
     <exports symbol='xmlTextReaderValue' type='function'/>
     <exports symbol='xmlTextReaderIsValid' type='function'/>
     <exports symbol='xmlTextReaderMoveToFirstAttribute' type='function'/>
     <exports symbol='xmlTextReaderGetParserColumnNumber' type='function'/>
     <exports symbol='xmlTextReaderConstValue' type='function'/>
     <exports symbol='xmlNewTextReader' type='function'/>
     <exports symbol='xmlTextReaderGetAttributeNo' type='function'/>
     <exports symbol='xmlTextReaderGetAttributeNs' type='function'/>
     <exports symbol='xmlTextReaderConstName' type='function'/>
     <exports symbol='xmlTextReaderConstString' type='function'/>
     <exports symbol='xmlTextReaderConstXmlVersion' type='function'/>
     <exports symbol='xmlTextReaderDepth' type='function'/>
     <exports symbol='xmlTextReaderReadString' type='function'/>
     <exports symbol='xmlTextReaderIsDefault' type='function'/>
     <exports symbol='xmlTextReaderMoveToNextAttribute' type='function'/>
     <exports symbol='xmlReaderNewWalker' type='function'/>
     <exports symbol='xmlTextReaderConstPrefix' type='function'/>
     <exports symbol='xmlReaderWalker' type='function'/>
     <exports symbol='xmlTextReaderConstLocalName' type='function'/>
     <exports symbol='xmlTextReaderNodeType' type='function'/>
     <exports symbol='xmlFreeTextReader' type='function'/>
     <exports symbol='xmlTextReaderName' type='function'/>
     <exports symbol='xmlTextReaderRead' type='function'/>
     <exports symbol='xmlTextReaderIsEmptyElement' type='function'/>
     <exports symbol='xmlReaderNewMemory' type='function'/>
     <exports symbol='xmlTextReaderSchemaValidateCtxt' type='function'/>
     <exports symbol='xmlTextReaderHasValue' type='function'/>
     <exports symbol='xmlTextReaderConstBaseUri' type='function'/>
     <exports symbol='xmlTextReaderBaseUri' type='function'/>
     <exports symbol='xmlTextReaderMoveToAttributeNo' type='function'/>
     <exports symbol='xmlTextReaderLocatorLineNumber' type='function'/>
     <exports symbol='xmlTextReaderMoveToAttributeNs' type='function'/>
     <exports symbol='xmlTextReaderNext' type='function'/>
     <exports symbol='xmlTextReaderAttributeCount' type='function'/>
     <exports symbol='xmlTextReaderLookupNamespace' type='function'/>
     <exports symbol='xmlTextReaderMoveToElement' type='function'/>
     <exports symbol='xmlReaderForIO' type='function'/>
     <exports symbol='xmlTextReaderReadOuterXml' type='function'/>
     <exports symbol='xmlTextReaderRelaxNGValidateCtxt' type='function'/>
     <exports symbol='xmlTextReaderPrefix' type='function'/>
     <exports symbol='xmlTextReaderReadAttributeValue' type='function'/>
     <exports symbol='xmlTextReaderNextSibling' type='function'/>
     <exports symbol='xmlTextReaderErrorFunc' type='function'/>
     <exports symbol='xmlReaderForFd' type='function'/>
     <exports symbol='xmlTextReaderGetAttribute' type='function'/>
     <exports symbol='xmlTextReaderLocalName' type='function'/>
     <exports symbol='xmlTextReaderPreserve' type='function'/>
     <exports symbol='xmlTextReaderCurrentNode' type='function'/>
     <exports symbol='xmlTextReaderSetParserProp' type='function'/>
     <exports symbol='xmlTextReaderGetRemainder' type='function'/>
     <exports symbol='xmlTextReaderSetErrorHandler' type='function'/>
     <exports symbol='xmlTextReaderIsNamespaceDecl' type='function'/>
     <exports symbol='xmlReaderNewDoc' type='function'/>
     <exports symbol='xmlTextReaderPreservePattern' type='function'/>
     <exports symbol='xmlTextReaderConstXmlLang' type='function'/>
     <exports symbol='xmlTextReaderGetErrorHandler' type='function'/>
     <exports symbol='xmlTextReaderSetStructuredErrorHandler' type='function'/>
     <exports symbol='xmlReaderNewFile' type='function'/>
     <exports symbol='xmlTextReaderRelaxNGSetSchema' type='function'/>
     <exports symbol='xmlReaderNewFd' type='function'/>
     <exports symbol='xmlTextReaderRelaxNGValidate' type='function'/>
     <exports symbol='xmlReaderForMemory' type='function'/>
     <exports symbol='xmlTextReaderSetup' type='function'/>
     <exports symbol='xmlTextReaderByteConsumed' type='function'/>
     <exports symbol='xmlTextReaderLocatorBaseURI' type='function'/>
     <exports symbol='xmlTextReaderNamespaceUri' type='function'/>
     <exports symbol='xmlTextReaderSchemaValidate' type='function'/>
     <exports symbol='xmlTextReaderStandalone' type='function'/>
    </file>
    <file name='xmlregexp'>
     <summary>regular expressions handling</summary>
     <description>basic API for libxml regular expressions handling used for XML Schemas and validation. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_EXP_COUNT' type='enum'/>
     <exports symbol='XML_EXP_EMPTY' type='enum'/>
     <exports symbol='XML_EXP_SEQ' type='enum'/>
     <exports symbol='XML_EXP_ATOM' type='enum'/>
     <exports symbol='XML_EXP_OR' type='enum'/>
     <exports symbol='XML_EXP_FORBID' type='enum'/>
     <exports symbol='xmlRegExecCtxtPtr' type='typedef'/>
     <exports symbol='xmlExpCtxt' type='typedef'/>
     <exports symbol='xmlExpNodePtr' type='typedef'/>
     <exports symbol='xmlExpCtxtPtr' type='typedef'/>
     <exports symbol='xmlExpNodeType' type='typedef'/>
     <exports symbol='xmlRegExecCtxt' type='typedef'/>
     <exports symbol='xmlExpNode' type='typedef'/>
     <exports symbol='xmlRegexp' type='typedef'/>
     <exports symbol='xmlRegexpPtr' type='typedef'/>
     <exports symbol='forbiddenExp' type='variable'/>
     <exports symbol='emptyExp' type='variable'/>
     <exports symbol='xmlRegExecCallbacks' type='function'/>
     <exports symbol='xmlRegNewExecCtxt' type='function'/>
     <exports symbol='xmlExpNewOr' type='function'/>
     <exports symbol='xmlRegFreeRegexp' type='function'/>
     <exports symbol='xmlExpRef' type='function'/>
     <exports symbol='xmlRegexpIsDeterminist' type='function'/>
     <exports symbol='xmlRegExecErrInfo' type='function'/>
     <exports symbol='xmlRegFreeExecCtxt' type='function'/>
     <exports symbol='xmlExpCtxtNbCons' type='function'/>
     <exports symbol='xmlExpSubsume' type='function'/>
     <exports symbol='xmlRegExecPushString2' type='function'/>
     <exports symbol='xmlRegExecNextValues' type='function'/>
     <exports symbol='xmlExpExpDerive' type='function'/>
     <exports symbol='xmlExpIsNillable' type='function'/>
     <exports symbol='xmlExpFreeCtxt' type='function'/>
     <exports symbol='xmlExpDump' type='function'/>
     <exports symbol='xmlExpNewSeq' type='function'/>
     <exports symbol='xmlExpFree' type='function'/>
     <exports symbol='xmlExpNewRange' type='function'/>
     <exports symbol='xmlRegexpCompile' type='function'/>
     <exports symbol='xmlExpNewAtom' type='function'/>
     <exports symbol='xmlRegexpExec' type='function'/>
     <exports symbol='xmlRegExecPushString' type='function'/>
     <exports symbol='xmlExpGetStart' type='function'/>
     <exports symbol='xmlExpParse' type='function'/>
     <exports symbol='xmlExpNewCtxt' type='function'/>
     <exports symbol='xmlExpGetLanguage' type='function'/>
     <exports symbol='xmlExpStringDerive' type='function'/>
     <exports symbol='xmlExpCtxtNbNodes' type='function'/>
     <exports symbol='xmlExpMaxToken' type='function'/>
     <exports symbol='xmlRegexpPrint' type='function'/>
    </file>
    <file name='xmlsave'>
     <summary>the XML document serializer</summary>
     <description>API to save document or subtree of document </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SAVE_XHTML' type='enum'/>
     <exports symbol='XML_SAVE_AS_XML' type='enum'/>
     <exports symbol='XML_SAVE_NO_EMPTY' type='enum'/>
     <exports symbol='XML_SAVE_NO_XHTML' type='enum'/>
     <exports symbol='XML_SAVE_NO_DECL' type='enum'/>
     <exports symbol='XML_SAVE_AS_HTML' type='enum'/>
     <exports symbol='XML_SAVE_FORMAT' type='enum'/>
     <exports symbol='XML_SAVE_WSNONSIG' type='enum'/>
     <exports symbol='xmlSaveOption' type='typedef'/>
     <exports symbol='xmlSaveCtxt' type='typedef'/>
     <exports symbol='xmlSaveCtxtPtr' type='typedef'/>
     <exports symbol='xmlSaveToIO' type='function'/>
     <exports symbol='xmlSaveToFd' type='function'/>
     <exports symbol='xmlSaveClose' type='function'/>
     <exports symbol='xmlSaveSetAttrEscape' type='function'/>
     <exports symbol='xmlSaveToBuffer' type='function'/>
     <exports symbol='xmlSaveToFilename' type='function'/>
     <exports symbol='xmlSaveFlush' type='function'/>
     <exports symbol='xmlSaveDoc' type='function'/>
     <exports symbol='xmlSaveSetEscape' type='function'/>
     <exports symbol='xmlSaveTree' type='function'/>
    </file>
    <file name='xmlschemas'>
     <summary>incomplete XML Schemas structure implementation</summary>
     <description>interface to the XML Schemas handling and schema validity checking, it is incomplete right now. </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SCHEMAS_ERR_NOTNILLABLE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_OK' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOROOT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_XXX' type='enum'/>
     <exports symbol='XML_SCHEMA_VAL_VC_I_CREATE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_ISABSTRACT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_ATTRUNKNOWN' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_WRONGELEM' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOTDETERMINIST' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_INTERNAL' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_MISSING' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_INVALIDATTR' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_CONSTRUCT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_FACET' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOTYPE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_VALUE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOROLLBACK' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOTTOPLEVEL' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOTEMPTY' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_INVALIDELEM' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_ATTRINVALID' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_EXTRACONTENT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_NOTSIMPLE' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_UNDECLAREDELEM' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_HAVEDEFAULT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_ELEMCONT' type='enum'/>
     <exports symbol='XML_SCHEMAS_ERR_' type='enum'/>
     <exports symbol='xmlSchemaPtr' type='typedef'/>
     <exports symbol='xmlSchemaParserCtxt' type='typedef'/>
     <exports symbol='xmlSchemaValidOption' type='typedef'/>
     <exports symbol='xmlSchemaSAXPlugPtr' type='typedef'/>
     <exports symbol='xmlSchemaSAXPlugStruct' type='typedef'/>
     <exports symbol='xmlSchemaValidCtxtPtr' type='typedef'/>
     <exports symbol='xmlSchemaParserCtxtPtr' type='typedef'/>
     <exports symbol='xmlSchema' type='typedef'/>
     <exports symbol='xmlSchemaValidError' type='typedef'/>
     <exports symbol='xmlSchemaValidCtxt' type='typedef'/>
     <exports symbol='xmlSchemaNewDocParserCtxt' type='function'/>
     <exports symbol='xmlSchemaSAXUnplug' type='function'/>
     <exports symbol='xmlSchemaParse' type='function'/>
     <exports symbol='xmlSchemaFreeParserCtxt' type='function'/>
     <exports symbol='xmlSchemaValidateSetFilename' type='function'/>
     <exports symbol='xmlSchemaNewParserCtxt' type='function'/>
     <exports symbol='xmlSchemaIsValid' type='function'/>
     <exports symbol='xmlSchemaValidityErrorFunc' type='function'/>
     <exports symbol='xmlSchemaSAXPlug' type='function'/>
     <exports symbol='xmlSchemaValidateStream' type='function'/>
     <exports symbol='xmlSchemaGetParserErrors' type='function'/>
     <exports symbol='xmlSchemaValidateSetLocator' type='function'/>
     <exports symbol='xmlSchemaValidateOneElement' type='function'/>
     <exports symbol='xmlSchemaSetValidStructuredErrors' type='function'/>
     <exports symbol='xmlSchemaSetValidErrors' type='function'/>
     <exports symbol='xmlSchemaValidCtxtGetOptions' type='function'/>
     <exports symbol='xmlSchemaValidateFile' type='function'/>
     <exports symbol='xmlSchemaValidateDoc' type='function'/>
     <exports symbol='xmlSchemaFree' type='function'/>
     <exports symbol='xmlSchemaNewMemParserCtxt' type='function'/>
     <exports symbol='xmlSchemaValidityLocatorFunc' type='function'/>
     <exports symbol='xmlSchemaGetValidErrors' type='function'/>
     <exports symbol='xmlSchemaSetValidOptions' type='function'/>
     <exports symbol='xmlSchemaSetParserErrors' type='function'/>
     <exports symbol='xmlSchemaValidityWarningFunc' type='function'/>
     <exports symbol='xmlSchemaDump' type='function'/>
     <exports symbol='xmlSchemaFreeValidCtxt' type='function'/>
     <exports symbol='xmlSchemaValidCtxtGetParserCtxt' type='function'/>
     <exports symbol='xmlSchemaSetParserStructuredErrors' type='function'/>
     <exports symbol='xmlSchemaNewValidCtxt' type='function'/>
    </file>
    <file name='xmlschemastypes'>
     <summary>implementation of XML Schema Datatypes</summary>
     <description>module providing the XML Schema Datatypes implementation both definition and validity checking </description>
     <author>Daniel Veillard </author>
     <exports symbol='XML_SCHEMA_WHITESPACE_UNKNOWN' type='enum'/>
     <exports symbol='XML_SCHEMA_WHITESPACE_COLLAPSE' type='enum'/>
     <exports symbol='XML_SCHEMA_WHITESPACE_REPLACE' type='enum'/>
     <exports symbol='XML_SCHEMA_WHITESPACE_PRESERVE' type='enum'/>
     <exports symbol='xmlSchemaWhitespaceValueType' type='typedef'/>
     <exports symbol='xmlSchemaValPredefTypeNode' type='function'/>
     <exports symbol='xmlSchemaGetCanonValueWhtsp' type='function'/>
     <exports symbol='xmlSchemaValidateLengthFacetWhtsp' type='function'/>
     <exports symbol='xmlSchemaIsBuiltInTypeFacet' type='function'/>
     <exports symbol='xmlSchemaGetCanonValue' type='function'/>
     <exports symbol='xmlSchemaGetBuiltInListSimpleTypeItemType' type='function'/>
     <exports symbol='xmlSchemaCompareValuesWhtsp' type='function'/>
     <exports symbol='xmlSchemaValueGetAsBoolean' type='function'/>
     <exports symbol='xmlSchemaCollapseString' type='function'/>
     <exports symbol='xmlSchemaValPredefTypeNodeNoNorm' type='function'/>
     <exports symbol='xmlSchemaValidateFacet' type='function'/>
     <exports symbol='xmlSchemaNewFacet' type='function'/>
     <exports symbol='xmlSchemaValueAppend' type='function'/>
     <exports symbol='xmlSchemaCompareValues' type='function'/>
     <exports symbol='xmlSchemaValidateLengthFacet' type='function'/>
     <exports symbol='xmlSchemaGetValType' type='function'/>
     <exports symbol='xmlSchemaGetPredefinedType' type='function'/>
     <exports symbol='xmlSchemaValidatePredefinedType' type='function'/>
     <exports symbol='xmlSchemaFreeFacet' type='function'/>
     <exports symbol='xmlSchemaValidateListSimpleTypeFacet' type='function'/>
     <exports symbol='xmlSchemaGetFacetValueAsULong' type='function'/>
     <exports symbol='xmlSchemaFreeValue' type='function'/>
     <exports symbol='xmlSchemaValueGetNext' type='function'/>
     <exports symbol='xmlSchemaValueGetAsString' type='function'/>
     <exports symbol='xmlSchemaCopyValue' type='function'/>
     <exports symbol='xmlSchemaNewNOTATIONValue' type='function'/>
     <exports symbol='xmlSchemaNewQNameValue' type='function'/>
     <exports symbol='xmlSchemaCleanupTypes' type='function'/>
     <exports symbol='xmlSchemaWhiteSpaceReplace' type='function'/>
     <exports symbol='xmlSchemaNewStringValue' type='function'/>
     <exports symbol='xmlSchemaGetBuiltInType' type='function'/>
     <exports symbol='xmlSchemaInitTypes' type='function'/>
     <exports symbol='xmlSchemaValidateFacetWhtsp' type='function'/>
     <exports symbol='xmlSchemaCheckFacet' type='function'/>
    </file>
    <file name='xmlstring'>
     <summary>set of routines to process strings</summary>
     <description>type and interfaces needed for the internal string handling of the library, especially UTF8 processing. </description>
     <author>Daniel Veillard </author>
     <exports symbol='BAD_CAST' type='macro'/>
     <exports symbol='xmlChar' type='typedef'/>
     <exports symbol='xmlStrcmp' type='function'/>
     <exports symbol='xmlCharStrndup' type='function'/>
     <exports symbol='xmlStrcasestr' type='function'/>
     <exports symbol='xmlStrcat' type='function'/>
     <exports symbol='xmlStrPrintf' type='function'/>
     <exports symbol='xmlStrstr' type='function'/>
     <exports symbol='xmlUTF8Size' type='function'/>
     <exports symbol='xmlStrQEqual' type='function'/>
     <exports symbol='xmlStrncatNew' type='function'/>
     <exports symbol='xmlUTF8Strpos' type='function'/>
     <exports symbol='xmlStrdup' type='function'/>
     <exports symbol='xmlCharStrdup' type='function'/>
     <exports symbol='xmlStrchr' type='function'/>
     <exports symbol='xmlStrlen' type='function'/>
     <exports symbol='xmlStrncmp' type='function'/>
     <exports symbol='xmlStrsub' type='function'/>
     <exports symbol='xmlStrncat' type='function'/>
     <exports symbol='xmlGetUTF8Char' type='function'/>
     <exports symbol='xmlStrcasecmp' type='function'/>
     <exports symbol='xmlStrndup' type='function'/>
     <exports symbol='xmlStrVPrintf' type='function'/>
     <exports symbol='xmlUTF8Strsize' type='function'/>
     <exports symbol='xmlCheckUTF8' type='function'/>
     <exports symbol='xmlStrncasecmp' type='function'/>
     <exports symbol='xmlUTF8Strlen' type='function'/>
     <exports symbol='xmlUTF8Strsub' type='function'/>
     <exports symbol='xmlStrEqual' type='function'/>
     <exports symbol='xmlUTF8Charcmp' type='function'/>
     <exports symbol='xmlUTF8Strndup' type='function'/>
     <exports symbol='xmlUTF8Strloc' type='function'/>
    </file>
    <file name='xmlunicode'>
     <summary>Unicode character APIs</summary>
     <description>API for the Unicode character APIs  This file is automatically generated from the UCS description files of the Unicode Character Database</description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlUCSIsBlockElements' type='function'/>
     <exports symbol='xmlUCSIsBopomofo' type='function'/>
     <exports symbol='xmlUCSIsDingbats' type='function'/>
     <exports symbol='xmlUCSIsSuperscriptsandSubscripts' type='function'/>
     <exports symbol='xmlUCSIsCombiningHalfMarks' type='function'/>
     <exports symbol='xmlUCSIsTibetan' type='function'/>
     <exports symbol='xmlUCSIsYiRadicals' type='function'/>
     <exports symbol='xmlUCSIsCombiningMarksforSymbols' type='function'/>
     <exports symbol='xmlUCSIsHangulSyllables' type='function'/>
     <exports symbol='xmlUCSIsBasicLatin' type='function'/>
     <exports symbol='xmlUCSIsCatSc' type='function'/>
     <exports symbol='xmlUCSIsCatSo' type='function'/>
     <exports symbol='xmlUCSIsLimbu' type='function'/>
     <exports symbol='xmlUCSIsCatSm' type='function'/>
     <exports symbol='xmlUCSIsCatSk' type='function'/>
     <exports symbol='xmlUCSIsKhmerSymbols' type='function'/>
     <exports symbol='xmlUCSIsMongolian' type='function'/>
     <exports symbol='xmlUCSIsMalayalam' type='function'/>
     <exports symbol='xmlUCSIsMathematicalAlphanumericSymbols' type='function'/>
     <exports symbol='xmlUCSIsThaana' type='function'/>
     <exports symbol='xmlUCSIsMyanmar' type='function'/>
     <exports symbol='xmlUCSIsTags' type='function'/>
     <exports symbol='xmlUCSIsCJKCompatibilityIdeographs' type='function'/>
     <exports symbol='xmlUCSIsTelugu' type='function'/>
     <exports symbol='xmlUCSIsLowSurrogates' type='function'/>
     <exports symbol='xmlUCSIsOsmanya' type='function'/>
     <exports symbol='xmlUCSIsSyriac' type='function'/>
     <exports symbol='xmlUCSIsEthiopic' type='function'/>
     <exports symbol='xmlUCSIsBoxDrawing' type='function'/>
     <exports symbol='xmlUCSIsGreekExtended' type='function'/>
     <exports symbol='xmlUCSIsGreekandCoptic' type='function'/>
     <exports symbol='xmlUCSIsKannada' type='function'/>
     <exports symbol='xmlUCSIsByzantineMusicalSymbols' type='function'/>
     <exports symbol='xmlUCSIsEnclosedCJKLettersandMonths' type='function'/>
     <exports symbol='xmlUCSIsCJKCompatibilityForms' type='function'/>
     <exports symbol='xmlUCSIsCatCs' type='function'/>
     <exports symbol='xmlUCSIsCJKRadicalsSupplement' type='function'/>
     <exports symbol='xmlUCSIsCatCf' type='function'/>
     <exports symbol='xmlUCSIsSmallFormVariants' type='function'/>
     <exports symbol='xmlUCSIsHangulCompatibilityJamo' type='function'/>
     <exports symbol='xmlUCSIsCatCc' type='function'/>
     <exports symbol='xmlUCSIsCatCo' type='function'/>
     <exports symbol='xmlUCSIsCherokee' type='function'/>
     <exports symbol='xmlUCSIsGothic' type='function'/>
     <exports symbol='xmlUCSIsKhmer' type='function'/>
     <exports symbol='xmlUCSIsCombiningDiacriticalMarksforSymbols' type='function'/>
     <exports symbol='xmlUCSIsOgham' type='function'/>
     <exports symbol='xmlUCSIsOriya' type='function'/>
     <exports symbol='xmlUCSIsLinearBIdeograms' type='function'/>
     <exports symbol='xmlUCSIsBlock' type='function'/>
     <exports symbol='xmlUCSIsBopomofoExtended' type='function'/>
     <exports symbol='xmlUCSIsHangulJamo' type='function'/>
     <exports symbol='xmlUCSIsTagbanwa' type='function'/>
     <exports symbol='xmlUCSIsGeneralPunctuation' type='function'/>
     <exports symbol='xmlUCSIsCyrillic' type='function'/>
     <exports symbol='xmlUCSIsArrows' type='function'/>
     <exports symbol='xmlUCSIsControlPictures' type='function'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographs' type='function'/>
     <exports symbol='xmlUCSIsCatNl' type='function'/>
     <exports symbol='xmlUCSIsCatNo' type='function'/>
     <exports symbol='xmlUCSIsYijingHexagramSymbols' type='function'/>
     <exports symbol='xmlUCSIsVariationSelectorsSupplement' type='function'/>
     <exports symbol='xmlUCSIsBengali' type='function'/>
     <exports symbol='xmlUCSIsPrivateUse' type='function'/>
     <exports symbol='xmlUCSIsMusicalSymbols' type='function'/>
     <exports symbol='xmlUCSIsMiscellaneousSymbols' type='function'/>
     <exports symbol='xmlUCSIsCJKCompatibility' type='function'/>
     <exports symbol='xmlUCSIsAegeanNumbers' type='function'/>
     <exports symbol='xmlUCSIsDevanagari' type='function'/>
     <exports symbol='xmlUCSIsSupplementalArrowsA' type='function'/>
     <exports symbol='xmlUCSIsSupplementalArrowsB' type='function'/>
     <exports symbol='xmlUCSIsNumberForms' type='function'/>
     <exports symbol='xmlUCSIsSpacingModifierLetters' type='function'/>
     <exports symbol='xmlUCSIsOpticalCharacterRecognition' type='function'/>
     <exports symbol='xmlUCSIsCatPc' type='function'/>
     <exports symbol='xmlUCSIsCatPf' type='function'/>
     <exports symbol='xmlUCSIsCyrillicSupplement' type='function'/>
     <exports symbol='xmlUCSIsCatPd' type='function'/>
     <exports symbol='xmlUCSIsCatPi' type='function'/>
     <exports symbol='xmlUCSIsCatPo' type='function'/>
     <exports symbol='xmlUCSIsHighPrivateUseSurrogates' type='function'/>
     <exports symbol='xmlUCSIsLatinExtendedAdditional' type='function'/>
     <exports symbol='xmlUCSIsCatPs' type='function'/>
     <exports symbol='xmlUCSIsHighSurrogates' type='function'/>
     <exports symbol='xmlUCSIsLao' type='function'/>
     <exports symbol='xmlUCSIsBraillePatterns' type='function'/>
     <exports symbol='xmlUCSIsDeseret' type='function'/>
     <exports symbol='xmlUCSIsEnclosedAlphanumerics' type='function'/>
     <exports symbol='xmlUCSIsCombiningDiacriticalMarks' type='function'/>
     <exports symbol='xmlUCSIsIdeographicDescriptionCharacters' type='function'/>
     <exports symbol='xmlUCSIsPrivateUseArea' type='function'/>
     <exports symbol='xmlUCSIsCat' type='function'/>
     <exports symbol='xmlUCSIsCatLu' type='function'/>
     <exports symbol='xmlUCSIsCatLt' type='function'/>
     <exports symbol='xmlUCSIsYiSyllables' type='function'/>
     <exports symbol='xmlUCSIsShavian' type='function'/>
     <exports symbol='xmlUCSIsCatLo' type='function'/>
     <exports symbol='xmlUCSIsCatLm' type='function'/>
     <exports symbol='xmlUCSIsCatLl' type='function'/>
     <exports symbol='xmlUCSIsMiscellaneousTechnical' type='function'/>
     <exports symbol='xmlUCSIsUgaritic' type='function'/>
     <exports symbol='xmlUCSIsCJKCompatibilityIdeographsSupplement' type='function'/>
     <exports symbol='xmlUCSIsCypriotSyllabary' type='function'/>
     <exports symbol='xmlUCSIsTamil' type='function'/>
     <exports symbol='xmlUCSIsCatC' type='function'/>
     <exports symbol='xmlUCSIsCatN' type='function'/>
     <exports symbol='xmlUCSIsCatL' type='function'/>
     <exports symbol='xmlUCSIsCatM' type='function'/>
     <exports symbol='xmlUCSIsUnifiedCanadianAboriginalSyllabics' type='function'/>
     <exports symbol='xmlUCSIsCatS' type='function'/>
     <exports symbol='xmlUCSIsCatP' type='function'/>
     <exports symbol='xmlUCSIsSinhala' type='function'/>
     <exports symbol='xmlUCSIsGeorgian' type='function'/>
     <exports symbol='xmlUCSIsCatZ' type='function'/>
     <exports symbol='xmlUCSIsIPAExtensions' type='function'/>
     <exports symbol='xmlUCSIsKangxiRadicals' type='function'/>
     <exports symbol='xmlUCSIsGreek' type='function'/>
     <exports symbol='xmlUCSIsCatPe' type='function'/>
     <exports symbol='xmlUCSIsHanunoo' type='function'/>
     <exports symbol='xmlUCSIsArmenian' type='function'/>
     <exports symbol='xmlUCSIsSupplementaryPrivateUseAreaB' type='function'/>
     <exports symbol='xmlUCSIsSupplementaryPrivateUseAreaA' type='function'/>
     <exports symbol='xmlUCSIsKatakanaPhoneticExtensions' type='function'/>
     <exports symbol='xmlUCSIsLetterlikeSymbols' type='function'/>
     <exports symbol='xmlUCSIsPhoneticExtensions' type='function'/>
     <exports symbol='xmlUCSIsArabic' type='function'/>
     <exports symbol='xmlUCSIsHebrew' type='function'/>
     <exports symbol='xmlUCSIsOldItalic' type='function'/>
     <exports symbol='xmlUCSIsArabicPresentationFormsA' type='function'/>
     <exports symbol='xmlUCSIsCatZp' type='function'/>
     <exports symbol='xmlUCSIsCatZs' type='function'/>
     <exports symbol='xmlUCSIsArabicPresentationFormsB' type='function'/>
     <exports symbol='xmlUCSIsGeometricShapes' type='function'/>
     <exports symbol='xmlUCSIsCatZl' type='function'/>
     <exports symbol='xmlUCSIsTagalog' type='function'/>
     <exports symbol='xmlUCSIsSpecials' type='function'/>
     <exports symbol='xmlUCSIsGujarati' type='function'/>
     <exports symbol='xmlUCSIsKatakana' type='function'/>
     <exports symbol='xmlUCSIsHalfwidthandFullwidthForms' type='function'/>
     <exports symbol='xmlUCSIsLatinExtendedB' type='function'/>
     <exports symbol='xmlUCSIsLatinExtendedA' type='function'/>
     <exports symbol='xmlUCSIsBuhid' type='function'/>
     <exports symbol='xmlUCSIsMiscellaneousSymbolsandArrows' type='function'/>
     <exports symbol='xmlUCSIsTaiLe' type='function'/>
     <exports symbol='xmlUCSIsCJKSymbolsandPunctuation' type='function'/>
     <exports symbol='xmlUCSIsTaiXuanJingSymbols' type='function'/>
     <exports symbol='xmlUCSIsGurmukhi' type='function'/>
     <exports symbol='xmlUCSIsMathematicalOperators' type='function'/>
     <exports symbol='xmlUCSIsAlphabeticPresentationForms' type='function'/>
     <exports symbol='xmlUCSIsCurrencySymbols' type='function'/>
     <exports symbol='xmlUCSIsSupplementalMathematicalOperators' type='function'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographsExtensionA' type='function'/>
     <exports symbol='xmlUCSIsKanbun' type='function'/>
     <exports symbol='xmlUCSIsCJKUnifiedIdeographsExtensionB' type='function'/>
     <exports symbol='xmlUCSIsThai' type='function'/>
     <exports symbol='xmlUCSIsRunic' type='function'/>
     <exports symbol='xmlUCSIsCatNd' type='function'/>
     <exports symbol='xmlUCSIsLatin1Supplement' type='function'/>
     <exports symbol='xmlUCSIsLinearBSyllabary' type='function'/>
     <exports symbol='xmlUCSIsHiragana' type='function'/>
     <exports symbol='xmlUCSIsMiscellaneousMathematicalSymbolsB' type='function'/>
     <exports symbol='xmlUCSIsMiscellaneousMathematicalSymbolsA' type='function'/>
     <exports symbol='xmlUCSIsCatMn' type='function'/>
     <exports symbol='xmlUCSIsVariationSelectors' type='function'/>
     <exports symbol='xmlUCSIsCatMc' type='function'/>
     <exports symbol='xmlUCSIsCatMe' type='function'/>
    </file>
    <file name='xmlversion'>
     <summary>compile-time version informations</summary>
     <description>compile-time version informations for the XML library </description>
     <author>Daniel Veillard </author>
     <exports symbol='LIBXML_VERSION_EXTRA' type='macro'/>
     <exports symbol='LIBXML_MODULES_ENABLED' type='macro'/>
     <exports symbol='LIBXML_LEGACY_ENABLED' type='macro'/>
     <exports symbol='LIBXML_LZMA_ENABLED' type='macro'/>
     <exports symbol='LIBXML_READER_ENABLED' type='macro'/>
     <exports symbol='LIBXML_THREAD_ENABLED' type='macro'/>
     <exports symbol='LIBXML_DOTTED_VERSION' type='macro'/>
     <exports symbol='LIBXML_ISO8859X_ENABLED' type='macro'/>
     <exports symbol='LIBXML_DEBUG_ENABLED' type='macro'/>
     <exports symbol='LIBXML_XINCLUDE_ENABLED' type='macro'/>
     <exports symbol='ATTRIBUTE_UNUSED' type='macro'/>
     <exports symbol='LIBXML_DOCB_ENABLED' type='macro'/>
     <exports symbol='LIBXML_PUSH_ENABLED' type='macro'/>
     <exports symbol='LIBXML_SAX1_ENABLED' type='macro'/>
     <exports symbol='WITHOUT_TRIO' type='macro'/>
     <exports symbol='LIBXML_SCHEMATRON_ENABLED' type='macro'/>
     <exports symbol='LIBXML_HTTP_ENABLED' type='macro'/>
     <exports symbol='LIBXML_OUTPUT_ENABLED' type='macro'/>
     <exports symbol='WITH_TRIO' type='macro'/>
     <exports symbol='LIBXML_DEBUG_RUNTIME' type='macro'/>
     <exports symbol='LIBXML_VERSION' type='macro'/>
     <exports symbol='LIBXML_XPTR_ENABLED' type='macro'/>
     <exports symbol='LIBXML_VERSION_STRING' type='macro'/>
     <exports symbol='LIBXML_CATALOG_ENABLED' type='macro'/>
     <exports symbol='LIBXML_ATTR_ALLOC_SIZE' type='macro'/>
     <exports symbol='LIBXML_REGEXP_ENABLED' type='macro'/>
     <exports symbol='LIBXML_ICU_ENABLED' type='macro'/>
     <exports symbol='LIBXML_MODULE_EXTENSION' type='macro'/>
     <exports symbol='LIBXML_ICONV_ENABLED' type='macro'/>
     <exports symbol='LIBXML_HTML_ENABLED' type='macro'/>
     <exports symbol='LIBXML_UNICODE_ENABLED' type='macro'/>
     <exports symbol='LIBXML_FTP_ENABLED' type='macro'/>
     <exports symbol='LIBXML_AUTOMATA_ENABLED' type='macro'/>
     <exports symbol='LIBXML_ZLIB_ENABLED' type='macro'/>
     <exports symbol='LIBXML_WRITER_ENABLED' type='macro'/>
     <exports symbol='LIBXML_C14N_ENABLED' type='macro'/>
     <exports symbol='LIBXML_SCHEMAS_ENABLED' type='macro'/>
     <exports symbol='DEBUG_MEMORY_LOCATION' type='macro'/>
     <exports symbol='LIBXML_ATTR_FORMAT' type='macro'/>
     <exports symbol='LIBXML_TEST_VERSION' type='macro'/>
     <exports symbol='LIBXML_THREAD_ALLOC_ENABLED' type='macro'/>
     <exports symbol='LIBXML_XPATH_ENABLED' type='macro'/>
     <exports symbol='LIBXML_PATTERN_ENABLED' type='macro'/>
     <exports symbol='LIBXML_VALID_ENABLED' type='macro'/>
     <exports symbol='LIBXML_TREE_ENABLED' type='macro'/>
     <exports symbol='LIBXML_EXPR_ENABLED' type='macro'/>
     <exports symbol='xmlCheckVersion' type='function'/>
    </file>
    <file name='xmlwriter'>
     <summary>text writing API for XML</summary>
     <description>text writing API for XML </description>
     <author>Alfred Mickautsch &lt;alfred@mickautsch.de&gt; </author>
     <exports symbol='xmlTextWriterWriteProcessingInstruction' type='macro'/>
     <exports symbol='xmlTextWriterWriteDocType' type='macro'/>
     <exports symbol='xmlTextWriter' type='typedef'/>
     <exports symbol='xmlTextWriterPtr' type='typedef'/>
     <exports symbol='xmlTextWriterStartDocument' type='function'/>
     <exports symbol='xmlTextWriterEndPI' type='function'/>
     <exports symbol='xmlTextWriterWriteBase64' type='function'/>
     <exports symbol='xmlTextWriterSetIndentString' type='function'/>
     <exports symbol='xmlTextWriterStartAttribute' type='function'/>
     <exports symbol='xmlTextWriterEndComment' type='function'/>
     <exports symbol='xmlTextWriterWriteRawLen' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDExternalEntityContents' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatCDATA' type='function'/>
     <exports symbol='xmlTextWriterStartAttributeNS' type='function'/>
     <exports symbol='xmlNewTextWriterPushParser' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatAttributeNS' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatPI' type='function'/>
     <exports symbol='xmlTextWriterWriteBinHex' type='function'/>
     <exports symbol='xmlTextWriterEndAttribute' type='function'/>
     <exports symbol='xmlTextWriterSetIndent' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatPI' type='function'/>
     <exports symbol='xmlTextWriterEndDocument' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDAttlist' type='function'/>
     <exports symbol='xmlTextWriterStartComment' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatDTD' type='function'/>
     <exports symbol='xmlTextWriterEndCDATA' type='function'/>
     <exports symbol='xmlTextWriterStartElementNS' type='function'/>
     <exports symbol='xmlTextWriterEndDTDEntity' type='function'/>
     <exports symbol='xmlNewTextWriter' type='function'/>
     <exports symbol='xmlFreeTextWriter' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatDTDAttlist' type='function'/>
     <exports symbol='xmlTextWriterStartPI' type='function'/>
     <exports symbol='xmlTextWriterStartElement' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDExternalEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatRaw' type='function'/>
     <exports symbol='xmlTextWriterWriteCDATA' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatDTDInternalEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatAttribute' type='function'/>
     <exports symbol='xmlTextWriterEndDTDElement' type='function'/>
     <exports symbol='xmlTextWriterEndDTD' type='function'/>
     <exports symbol='xmlTextWriterWriteElement' type='function'/>
     <exports symbol='xmlTextWriterEndElement' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatComment' type='function'/>
     <exports symbol='xmlTextWriterStartCDATA' type='function'/>
     <exports symbol='xmlNewTextWriterFilename' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatElement' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatComment' type='function'/>
     <exports symbol='xmlTextWriterWriteAttributeNS' type='function'/>
     <exports symbol='xmlTextWriterWritePI' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatDTDInternalEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatString' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDInternalEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatElementNS' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDNotation' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatElement' type='function'/>
     <exports symbol='xmlTextWriterSetQuoteChar' type='function'/>
     <exports symbol='xmlTextWriterWriteString' type='function'/>
     <exports symbol='xmlTextWriterWriteElementNS' type='function'/>
     <exports symbol='xmlTextWriterFullEndElement' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatAttributeNS' type='function'/>
     <exports symbol='xmlTextWriterFlush' type='function'/>
     <exports symbol='xmlTextWriterStartDTD' type='function'/>
     <exports symbol='xmlTextWriterWriteAttribute' type='function'/>
     <exports symbol='xmlNewTextWriterDoc' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatDTDElement' type='function'/>
     <exports symbol='xmlTextWriterEndDTDAttlist' type='function'/>
     <exports symbol='xmlNewTextWriterTree' type='function'/>
     <exports symbol='xmlNewTextWriterMemory' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatCDATA' type='function'/>
     <exports symbol='xmlTextWriterStartDTDAttlist' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatString' type='function'/>
     <exports symbol='xmlTextWriterWriteComment' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatRaw' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatDTD' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatDTDAttlist' type='function'/>
     <exports symbol='xmlTextWriterWriteRaw' type='function'/>
     <exports symbol='xmlTextWriterWriteDTDElement' type='function'/>
     <exports symbol='xmlTextWriterWriteDTD' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatAttribute' type='function'/>
     <exports symbol='xmlTextWriterStartDTDEntity' type='function'/>
     <exports symbol='xmlTextWriterWriteVFormatDTDElement' type='function'/>
     <exports symbol='xmlTextWriterStartDTDElement' type='function'/>
     <exports symbol='xmlTextWriterWriteFormatElementNS' type='function'/>
    </file>
    <file name='xpath'>
     <summary>XML Path Language implementation</summary>
     <description>API for the XML Path Language implementation  XML Path Language implementation XPath is a language for addressing parts of an XML document, designed to be used by both XSLT and XPointer</description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlXPathNodeSetGetLength' type='macro'/>
     <exports symbol='XML_XPATH_CHECKNS' type='macro'/>
     <exports symbol='XML_XPATH_NOVAR' type='macro'/>
     <exports symbol='xmlXPathNodeSetItem' type='macro'/>
     <exports symbol='xmlXPathNodeSetIsEmpty' type='macro'/>
     <exports symbol='XPATH_NUMBER_ERROR' type='enum'/>
     <exports symbol='XPATH_BOOLEAN' type='enum'/>
     <exports symbol='XPATH_START_LITERAL_ERROR' type='enum'/>
     <exports symbol='XPATH_UNCLOSED_ERROR' type='enum'/>
     <exports symbol='XPATH_INVALID_CHAR_ERROR' type='enum'/>
     <exports symbol='XPATH_UNDEF_VARIABLE_ERROR' type='enum'/>
     <exports symbol='XPATH_EXPRESSION_OK' type='enum'/>
     <exports symbol='XPATH_NODESET' type='enum'/>
     <exports symbol='XPTR_SUB_RESOURCE_ERROR' type='enum'/>
     <exports symbol='XPATH_VARIABLE_REF_ERROR' type='enum'/>
     <exports symbol='XPATH_ENCODING_ERROR' type='enum'/>
     <exports symbol='XPTR_RESOURCE_ERROR' type='enum'/>
     <exports symbol='XPATH_NUMBER' type='enum'/>
     <exports symbol='XPATH_POINT' type='enum'/>
     <exports symbol='XPATH_USERS' type='enum'/>
     <exports symbol='XPATH_UNDEF_PREFIX_ERROR' type='enum'/>
     <exports symbol='XPATH_UNKNOWN_FUNC_ERROR' type='enum'/>
     <exports symbol='XPATH_INVALID_CTXT_SIZE' type='enum'/>
     <exports symbol='XPATH_RANGE' type='enum'/>
     <exports symbol='XPTR_SYNTAX_ERROR' type='enum'/>
     <exports symbol='XPATH_LOCATIONSET' type='enum'/>
     <exports symbol='XPATH_INVALID_CTXT' type='enum'/>
     <exports symbol='XPATH_INVALID_ARITY' type='enum'/>
     <exports symbol='XPATH_STRING' type='enum'/>
     <exports symbol='XPATH_INVALID_PREDICATE_ERROR' type='enum'/>
     <exports symbol='XPATH_XSLT_TREE' type='enum'/>
     <exports symbol='XPATH_EXPR_ERROR' type='enum'/>
     <exports symbol='XPATH_FORBID_VARIABLE_ERROR' type='enum'/>
     <exports symbol='XPATH_INVALID_TYPE' type='enum'/>
     <exports symbol='XPATH_INVALID_CTXT_POSITION' type='enum'/>
     <exports symbol='XPATH_UNDEFINED' type='enum'/>
     <exports symbol='XPATH_MEMORY_ERROR' type='enum'/>
     <exports symbol='XPATH_UNFINISHED_LITERAL_ERROR' type='enum'/>
     <exports symbol='XPATH_STACK_ERROR' type='enum'/>
     <exports symbol='XPATH_INVALID_OPERAND' type='enum'/>
     <exports symbol='xmlXPathObjectType' type='typedef'/>
     <exports symbol='xmlXPathVariablePtr' type='typedef'/>
     <exports symbol='xmlXPathContext' type='typedef'/>
     <exports symbol='xmlXPathError' type='typedef'/>
     <exports symbol='xmlXPathFunct' type='typedef'/>
     <exports symbol='xmlXPathTypePtr' type='typedef'/>
     <exports symbol='xmlXPathType' type='typedef'/>
     <exports symbol='xmlNodeSetPtr' type='typedef'/>
     <exports symbol='xmlXPathFuncPtr' type='typedef'/>
     <exports symbol='xmlXPathCompExprPtr' type='typedef'/>
     <exports symbol='xmlXPathObject' type='typedef'/>
     <exports symbol='xmlXPathCompExpr' type='typedef'/>
     <exports symbol='xmlXPathContextPtr' type='typedef'/>
     <exports symbol='xmlXPathParserContextPtr' type='typedef'/>
     <exports symbol='xmlNodeSet' type='typedef'/>
     <exports symbol='xmlXPathVariable' type='typedef'/>
     <exports symbol='xmlXPathObjectPtr' type='typedef'/>
     <exports symbol='xmlXPathAxis' type='typedef'/>
     <exports symbol='xmlXPathAxisPtr' type='typedef'/>
     <exports symbol='xmlXPathParserContext' type='typedef'/>
     <exports symbol='_xmlXPathFunct' type='struct'/>
     <exports symbol='_xmlXPathVariable' type='struct'/>
     <exports symbol='_xmlXPathParserContext' type='struct'/>
     <exports symbol='_xmlXPathType' type='struct'/>
     <exports symbol='_xmlXPathObject' type='struct'/>
     <exports symbol='_xmlXPathContext' type='struct'/>
     <exports symbol='_xmlXPathAxis' type='struct'/>
     <exports symbol='_xmlNodeSet' type='struct'/>
     <exports symbol='xmlXPathNAN' type='variable'/>
     <exports symbol='xmlXPathPINF' type='variable'/>
     <exports symbol='xmlXPathNINF' type='variable'/>
     <exports symbol='xmlXPathCastNodeSetToBoolean' type='function'/>
     <exports symbol='xmlXPathFuncLookupFunc' type='function'/>
     <exports symbol='xmlXPathNodeEval' type='function'/>
     <exports symbol='xmlXPathCastNodeToString' type='function'/>
     <exports symbol='xmlXPathIsNaN' type='function'/>
     <exports symbol='xmlXPathContextSetCache' type='function'/>
     <exports symbol='xmlXPathConvertString' type='function'/>
     <exports symbol='xmlXPathCompiledEvalToBoolean' type='function'/>
     <exports symbol='xmlXPathIsInf' type='function'/>
     <exports symbol='xmlXPathOrderDocElems' type='function'/>
     <exports symbol='xmlXPathNodeSetCreate' type='function'/>
     <exports symbol='xmlXPathCastBooleanToNumber' type='function'/>
     <exports symbol='xmlXPathCastNodeToNumber' type='function'/>
     <exports symbol='xmlXPathCastStringToNumber' type='function'/>
     <exports symbol='xmlXPathAxisFunc' type='function'/>
     <exports symbol='xmlXPathCastToNumber' type='function'/>
     <exports symbol='xmlXPathCastStringToBoolean' type='function'/>
     <exports symbol='xmlXPathCastNumberToString' type='function'/>
     <exports symbol='xmlXPathVariableLookupFunc' type='function'/>
     <exports symbol='xmlXPathFreeObject' type='function'/>
     <exports symbol='xmlXPathEvalPredicate' type='function'/>
     <exports symbol='xmlXPathFreeContext' type='function'/>
     <exports symbol='xmlXPathObjectCopy' type='function'/>
     <exports symbol='xmlXPathFreeNodeSetList' type='function'/>
     <exports symbol='xmlXPathEval' type='function'/>
     <exports symbol='xmlXPathCastNodeSetToString' type='function'/>
     <exports symbol='xmlXPathCompiledEval' type='function'/>
     <exports symbol='xmlXPathEvalExpression' type='function'/>
     <exports symbol='xmlXPathInit' type='function'/>
     <exports symbol='xmlXPathConvertBoolean' type='function'/>
     <exports symbol='xmlXPathConvertFunc' type='function'/>
     <exports symbol='xmlXPathFunction' type='function'/>
     <exports symbol='xmlXPathCmpNodes' type='function'/>
     <exports symbol='xmlXPathCastToString' type='function'/>
     <exports symbol='xmlXPathCtxtCompile' type='function'/>
     <exports symbol='xmlXPathEvalFunc' type='function'/>
     <exports symbol='xmlXPathCastBooleanToString' type='function'/>
     <exports symbol='xmlXPathSetContextNode' type='function'/>
     <exports symbol='xmlXPathCastNumberToBoolean' type='function'/>
     <exports symbol='xmlXPathFreeNodeSet' type='function'/>
     <exports symbol='xmlXPathFreeCompExpr' type='function'/>
     <exports symbol='xmlXPathNewContext' type='function'/>
     <exports symbol='xmlXPathConvertNumber' type='function'/>
     <exports symbol='xmlXPathCompile' type='function'/>
     <exports symbol='xmlXPathCastNodeSetToNumber' type='function'/>
     <exports symbol='xmlXPathCastToBoolean' type='function'/>
    </file>
    <file name='xpathInternals'>
     <summary>internal interfaces for XML Path Language implementation</summary>
     <description>internal interfaces for XML Path Language implementation used to build new modules on top of XPath like XPointer and XSLT </description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlXPathStackIsExternal' type='macro'/>
     <exports symbol='xmlXPathReturnEmptyString' type='macro'/>
     <exports symbol='XP_ERROR0' type='macro'/>
     <exports symbol='xmlXPathSetTypeError' type='macro'/>
     <exports symbol='xmlXPathReturnEmptyNodeSet' type='macro'/>
     <exports symbol='xmlXPathReturnTrue' type='macro'/>
     <exports symbol='xmlXPathReturnBoolean' type='macro'/>
     <exports symbol='xmlXPathGetContextNode' type='macro'/>
     <exports symbol='CAST_TO_NUMBER' type='macro'/>
     <exports symbol='CHECK_ARITY' type='macro'/>
     <exports symbol='CHECK_TYPE0' type='macro'/>
     <exports symbol='CAST_TO_STRING' type='macro'/>
     <exports symbol='xmlXPathReturnExternal' type='macro'/>
     <exports symbol='xmlXPathStackIsNodeSet' type='macro'/>
     <exports symbol='xmlXPathCheckError' type='macro'/>
     <exports symbol='xmlXPathSetError' type='macro'/>
     <exports symbol='CHECK_ERROR' type='macro'/>
     <exports symbol='xmlXPathReturnString' type='macro'/>
     <exports symbol='CAST_TO_BOOLEAN' type='macro'/>
     <exports symbol='xmlXPathSetArityError' type='macro'/>
     <exports symbol='CHECK_TYPE' type='macro'/>
     <exports symbol='xmlXPathReturnFalse' type='macro'/>
     <exports symbol='xmlXPathReturnNumber' type='macro'/>
     <exports symbol='CHECK_ERROR0' type='macro'/>
     <exports symbol='xmlXPathGetDocument' type='macro'/>
     <exports symbol='xmlXPathGetError' type='macro'/>
     <exports symbol='XP_ERROR' type='macro'/>
     <exports symbol='xmlXPathEmptyNodeSet' type='macro'/>
     <exports symbol='xmlXPathReturnNodeSet' type='macro'/>
     <exports symbol='xmlXPathNodeSetMerge' type='function'/>
     <exports symbol='xmlXPathNumberFunction' type='function'/>
     <exports symbol='xmlXPathNsLookup' type='function'/>
     <exports symbol='xmlXPathNewNodeSet' type='function'/>
     <exports symbol='xmlXPathNextAncestorOrSelf' type='function'/>
     <exports symbol='xmlXPathNodeSetRemove' type='function'/>
     <exports symbol='xmlXPathNewNodeSetList' type='function'/>
     <exports symbol='xmlXPathPopBoolean' type='function'/>
     <exports symbol='xmlXPathNewString' type='function'/>
     <exports symbol='xmlXPathNodeLeadingSorted' type='function'/>
     <exports symbol='xmlXPathNextChild' type='function'/>
     <exports symbol='xmlXPathNextFollowingSibling' type='function'/>
     <exports symbol='xmlXPathPopString' type='function'/>
     <exports symbol='xmlXPathNamespaceURIFunction' type='function'/>
     <exports symbol='xmlXPathCompareValues' type='function'/>
     <exports symbol='xmlXPathConcatFunction' type='function'/>
     <exports symbol='xmlXPathNodeSetContains' type='function'/>
     <exports symbol='xmlXPatherror' type='function'/>
     <exports symbol='xmlXPathNextAncestor' type='function'/>
     <exports symbol='xmlXPathBooleanFunction' type='function'/>
     <exports symbol='xmlXPathRoot' type='function'/>
     <exports symbol='xmlXPathRegisteredNsCleanup' type='function'/>
     <exports symbol='xmlXPathIsNodeType' type='function'/>
     <exports symbol='xmlXPathNextFollowing' type='function'/>
     <exports symbol='xmlXPathAddValues' type='function'/>
     <exports symbol='xmlXPathRegisterVariable' type='function'/>
     <exports symbol='valuePop' type='function'/>
     <exports symbol='xmlXPathCeilingFunction' type='function'/>
     <exports symbol='xmlXPathIntersection' type='function'/>
     <exports symbol='xmlXPathContainsFunction' type='function'/>
     <exports symbol='xmlXPathNodeSetSort' type='function'/>
     <exports symbol='xmlXPathStartsWithFunction' type='function'/>
     <exports symbol='xmlXPathNodeLeading' type='function'/>
     <exports symbol='xmlXPathSumFunction' type='function'/>
     <exports symbol='xmlXPathNotEqualValues' type='function'/>
     <exports symbol='xmlXPathEvaluatePredicateResult' type='function'/>
     <exports symbol='xmlXPathErr' type='function'/>
     <exports symbol='xmlXPathNextPreceding' type='function'/>
     <exports symbol='xmlXPathFunctionLookupNS' type='function'/>
     <exports symbol='xmlXPathRegisteredFuncsCleanup' type='function'/>
     <exports symbol='xmlXPathRegisterAllFunctions' type='function'/>
     <exports symbol='xmlXPathFunctionLookup' type='function'/>
     <exports symbol='xmlXPathPositionFunction' type='function'/>
     <exports symbol='xmlXPathSubstringBeforeFunction' type='function'/>
     <exports symbol='xmlXPathRegisteredVariablesCleanup' type='function'/>
     <exports symbol='xmlXPathNewFloat' type='function'/>
     <exports symbol='xmlXPathRegisterNs' type='function'/>
     <exports symbol='xmlXPathNextParent' type='function'/>
     <exports symbol='xmlXPathNodeSetFreeNs' type='function'/>
     <exports symbol='xmlXPathHasSameNodes' type='function'/>
     <exports symbol='xmlXPathDistinctSorted' type='function'/>
     <exports symbol='valuePush' type='function'/>
     <exports symbol='xmlXPathSubstringFunction' type='function'/>
     <exports symbol='xmlXPathStringFunction' type='function'/>
     <exports symbol='xmlXPathFloorFunction' type='function'/>
     <exports symbol='xmlXPathIdFunction' type='function'/>
     <exports symbol='xmlXPathLastFunction' type='function'/>
     <exports symbol='xmlXPathStringLengthFunction' type='function'/>
     <exports symbol='xmlXPathNextSelf' type='function'/>
     <exports symbol='xmlXPathDebugDumpCompExpr' type='function'/>
     <exports symbol='xmlXPathFalseFunction' type='function'/>
     <exports symbol='xmlXPathValueFlipSign' type='function'/>
     <exports symbol='xmlXPathTranslateFunction' type='function'/>
     <exports symbol='xmlXPathRegisterFuncLookup' type='function'/>
     <exports symbol='xmlXPathPopNumber' type='function'/>
     <exports symbol='xmlXPathRoundFunction' type='function'/>
     <exports symbol='xmlXPathPopNodeSet' type='function'/>
     <exports symbol='xmlXPathCountFunction' type='function'/>
     <exports symbol='xmlXPathParseNCName' type='function'/>
     <exports symbol='xmlXPathTrueFunction' type='function'/>
     <exports symbol='xmlXPathNewBoolean' type='function'/>
     <exports symbol='xmlXPathSubValues' type='function'/>
     <exports symbol='xmlXPathEqualValues' type='function'/>
     <exports symbol='xmlXPathTrailingSorted' type='function'/>
     <exports symbol='xmlXPathMultValues' type='function'/>
     <exports symbol='xmlXPathModValues' type='function'/>
     <exports symbol='xmlXPathNewParserContext' type='function'/>
     <exports symbol='xmlXPathWrapNodeSet' type='function'/>
     <exports symbol='xmlXPathWrapString' type='function'/>
     <exports symbol='xmlXPathLangFunction' type='function'/>
     <exports symbol='xmlXPathRegisterFuncNS' type='function'/>
     <exports symbol='xmlXPathNodeSetAddNs' type='function'/>
     <exports symbol='xmlXPathLocalNameFunction' type='function'/>
     <exports symbol='xmlXPathDifference' type='function'/>
     <exports symbol='xmlXPathLeadingSorted' type='function'/>
     <exports symbol='xmlXPathNextPrecedingSibling' type='function'/>
     <exports symbol='xmlXPathPopExternal' type='function'/>
     <exports symbol='xmlXPathNormalizeFunction' type='function'/>
     <exports symbol='xmlXPathRegisterVariableLookup' type='function'/>
     <exports symbol='xmlXPathNodeSetDel' type='function'/>
     <exports symbol='xmlXPathNodeTrailingSorted' type='function'/>
     <exports symbol='xmlXPathNewCString' type='function'/>
     <exports symbol='xmlXPathRegisterFunc' type='function'/>
     <exports symbol='xmlXPathSubstringAfterFunction' type='function'/>
     <exports symbol='xmlXPathNextDescendant' type='function'/>
     <exports symbol='xmlXPathNextNamespace' type='function'/>
     <exports symbol='xmlXPathWrapCString' type='function'/>
     <exports symbol='xmlXPathFreeParserContext' type='function'/>
     <exports symbol='xmlXPathNodeTrailing' type='function'/>
     <exports symbol='xmlXPathNodeSetAdd' type='function'/>
     <exports symbol='xmlXPathNodeSetAddUnique' type='function'/>
     <exports symbol='xmlXPathNewValueTree' type='function'/>
     <exports symbol='xmlXPathDistinct' type='function'/>
     <exports symbol='xmlXPathVariableLookup' type='function'/>
     <exports symbol='xmlXPathNotFunction' type='function'/>
     <exports symbol='xmlXPathStringEvalNumber' type='function'/>
     <exports symbol='xmlXPathNextDescendantOrSelf' type='function'/>
     <exports symbol='xmlXPathWrapExternal' type='function'/>
     <exports symbol='xmlXPathNextAttribute' type='function'/>
     <exports symbol='xmlXPathDivValues' type='function'/>
     <exports symbol='xmlXPathVariableLookupNS' type='function'/>
     <exports symbol='xmlXPathRegisterVariableNS' type='function'/>
     <exports symbol='xmlXPathTrailing' type='function'/>
     <exports symbol='xmlXPathEvalExpr' type='function'/>
     <exports symbol='xmlXPathDebugDumpObject' type='function'/>
     <exports symbol='xmlXPathLeading' type='function'/>
     <exports symbol='xmlXPathParseName' type='function'/>
    </file>
    <file name='xpointer'>
     <summary>API to handle XML Pointers</summary>
     <description>API to handle XML Pointers Base implementation was made accordingly to W3C Candidate Recommendation 7 June 2000</description>
     <author>Daniel Veillard </author>
     <exports symbol='xmlLocationSet' type='typedef'/>
     <exports symbol='xmlLocationSetPtr' type='typedef'/>
     <exports symbol='_xmlLocationSet' type='struct'/>
     <exports symbol='xmlXPtrNewRange' type='function'/>
     <exports symbol='xmlXPtrFreeLocationSet' type='function'/>
     <exports symbol='xmlXPtrWrapLocationSet' type='function'/>
     <exports symbol='xmlXPtrBuildNodeList' type='function'/>
     <exports symbol='xmlXPtrEval' type='function'/>
     <exports symbol='xmlXPtrNewRangeNodes' type='function'/>
     <exports symbol='xmlXPtrLocationSetAdd' type='function'/>
     <exports symbol='xmlXPtrRangeToFunction' type='function'/>
     <exports symbol='xmlXPtrNewCollapsedRange' type='function'/>
     <exports symbol='xmlXPtrNewRangePoints' type='function'/>
     <exports symbol='xmlXPtrNewLocationSetNodeSet' type='function'/>
     <exports symbol='xmlXPtrNewRangePointNode' type='function'/>
     <exports symbol='xmlXPtrLocationSetCreate' type='function'/>
     <exports symbol='xmlXPtrNewRangeNodeObject' type='function'/>
     <exports symbol='xmlXPtrNewContext' type='function'/>
     <exports symbol='xmlXPtrLocationSetRemove' type='function'/>
     <exports symbol='xmlXPtrNewRangeNodePoint' type='function'/>
     <exports symbol='xmlXPtrLocationSetDel' type='function'/>
     <exports symbol='xmlXPtrLocationSetMerge' type='function'/>
     <exports symbol='xmlXPtrEvalRangePredicate' type='function'/>
     <exports symbol='xmlXPtrNewLocationSetNodes' type='function'/>
    </file>
  </files>
  <symbols>
    <macro name='ATTRIBUTE_UNUSED' file='xmlversion'>
      <info>Macro used to signal to GCC unused function parameters</info>
    </macro>
    <macro name='BAD_CAST' file='xmlstring'>
      <info>Macro to cast a string to an xmlChar * when one know its safe.</info>
    </macro>
    <macro name='BASE_BUFFER_SIZE' file='tree'>
      <info>default buffer size 4000.</info>
    </macro>
    <macro name='CAST_TO_BOOLEAN' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a boolean.</info>
    </macro>
    <macro name='CAST_TO_NUMBER' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a number.</info>
    </macro>
    <macro name='CAST_TO_STRING' file='xpathInternals'>
      <info>Macro to try to cast the value on the top of the XPath stack to a string.</info>
    </macro>
    <macro name='CHECK_ARITY' file='xpathInternals'>
      <info>Macro to check that the number of args passed to an XPath function matches.</info>
      <arg name='x' info='the number of expected args'/>
    </macro>
    <macro name='CHECK_ERROR' file='xpathInternals'>
      <info>Macro to return from the function if an XPath error was detected.</info>
    </macro>
    <macro name='CHECK_ERROR0' file='xpathInternals'>
      <info>Macro to return 0 from the function if an XPath error was detected.</info>
    </macro>
    <macro name='CHECK_TYPE' file='xpathInternals'>
      <info>Macro to check that the value on top of the XPath stack is of a given type.</info>
      <arg name='typeval' info='the XPath type'/>
    </macro>
    <macro name='CHECK_TYPE0' file='xpathInternals'>
      <info>Macro to check that the value on top of the XPath stack is of a given type. Return(0) in case of failure</info>
      <arg name='typeval' info='the XPath type'/>
    </macro>
    <macro name='DEBUG_MEMORY' file='xmlmemory'>
      <info>DEBUG_MEMORY replaces the allocator with a collect and debug shell to the libc allocator. DEBUG_MEMORY should only be activated when debugging libxml i.e. if libxml has been configured with --with-debug-mem too. #define DEBUG_MEMORY_FREED #define DEBUG_MEMORY_LOCATION</info>
    </macro>
    <macro name='DEBUG_MEMORY_LOCATION' file='xmlversion'>
      <info>Whether the memory debugging is configured in</info>
    </macro>
    <macro name='HTML_COMMENT_NODE' file='HTMLtree'>
      <info>Macro. A comment in a HTML document is really implemented the same way as a comment in an XML document.</info>
    </macro>
    <macro name='HTML_ENTITY_REF_NODE' file='HTMLtree'>
      <info>Macro. An entity reference in a HTML document is really implemented the same way as an entity reference in an XML document.</info>
    </macro>
    <macro name='HTML_PI_NODE' file='HTMLtree'>
      <info>Macro. A processing instruction in a HTML document is really implemented the same way as a processing instruction in an XML document.</info>
    </macro>
    <macro name='HTML_PRESERVE_NODE' file='HTMLtree'>
      <info>Macro. A preserved node in a HTML document is really implemented the same way as a CDATA section in an XML document.</info>
    </macro>
    <macro name='HTML_TEXT_NODE' file='HTMLtree'>
      <info>Macro. A text node in a HTML document is really implemented the same way as a text node in an XML document.</info>
    </macro>
    <macro name='INPUT_CHUNK' file='parserInternals'>
      <info>The parser tries to always have that amount of input ready. One of the point is providing context when reporting errors.</info>
    </macro>
    <macro name='INVALID_SOCKET' file='nanoftp'>
      <info>macro used to provide portability of code to windows sockets the value to be used when the socket is not valid</info>
    </macro>
    <macro name='IS_ASCII_DIGIT' file='parserInternals'>
      <info>Macro to check [0-9]</info>
      <arg name='c' info='an xmlChar value'/>
    </macro>
    <macro name='IS_ASCII_LETTER' file='parserInternals'>
      <info>Macro to check [a-zA-Z]</info>
      <arg name='c' info='an xmlChar value'/>
    </macro>
    <macro name='IS_BASECHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [85] BaseChar ::= ... long list see REC ...</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_BLANK' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [3] S ::= (#x20 | #x9 | #xD | #xA)+</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_BLANK_CH' file='parserInternals'>
      <info>Behaviour same as IS_BLANK</info>
      <arg name='c' info='an xmlChar value (normally unsigned char)'/>
    </macro>
    <macro name='IS_BYTE_CHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [2] Char ::= #x9 | #xA | #xD | [#x20...] any byte character in the accepted range</info>
      <arg name='c' info='an byte value (int)'/>
    </macro>
    <macro name='IS_CHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_CHAR_CH' file='parserInternals'>
      <info>Behaves like IS_CHAR on single-byte value</info>
      <arg name='c' info='an xmlChar (usually an unsigned char)'/>
    </macro>
    <macro name='IS_COMBINING' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [87] CombiningChar ::= ... long list see REC ...</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_COMBINING_CH' file='parserInternals'>
      <info>Always false (all combining chars &gt; 0xff)</info>
      <arg name='c' info='an xmlChar (usually an unsigned char)'/>
    </macro>
    <macro name='IS_DIGIT' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:  [88] Digit ::= ... long list see REC ...</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_DIGIT_CH' file='parserInternals'>
      <info>Behaves like IS_DIGIT but with a single byte argument</info>
      <arg name='c' info='an xmlChar value (usually an unsigned char)'/>
    </macro>
    <macro name='IS_EXTENDER' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:   [89] Extender ::= #x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] | [#x309D-#x309E] | [#x30FC-#x30FE]</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_EXTENDER_CH' file='parserInternals'>
      <info>Behaves like IS_EXTENDER but with a single-byte argument</info>
      <arg name='c' info='an xmlChar value (usually an unsigned char)'/>
    </macro>
    <macro name='IS_IDEOGRAPHIC' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:   [86] Ideographic ::= [#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_LETTER' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:   [84] Letter ::= BaseChar | Ideographic</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_LETTER_CH' file='parserInternals'>
      <info>Macro behaves like IS_LETTER, but only check base chars</info>
      <arg name='c' info='an xmlChar value (normally unsigned char)'/>
    </macro>
    <macro name='IS_PUBIDCHAR' file='parserInternals'>
      <info>Macro to check the following production in the XML spec:   [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-&apos;()+,./:=?;!*#@$_%]</info>
      <arg name='c' info='an UNICODE value (int)'/>
    </macro>
    <macro name='IS_PUBIDCHAR_CH' file='parserInternals'>
      <info>Same as IS_PUBIDCHAR but for single-byte value</info>
      <arg name='c' info='an xmlChar value (normally unsigned char)'/>
    </macro>
    <macro name='LIBXML2_NEW_BUFFER' file='tree'>
      <info>Macro used to express that the API use the new buffers for xmlParserInputBuffer and xmlOutputBuffer. The change was introduced in 2.9.0.</info>
    </macro>
    <macro name='LIBXML_ATTR_ALLOC_SIZE' file='xmlversion'>
      <info>Macro used to indicate to GCC this is an allocator function</info>
    </macro>
    <macro name='LIBXML_ATTR_FORMAT' file='xmlversion'>
      <info>Macro used to indicate to GCC the parameter are printf like</info>
    </macro>
    <macro name='LIBXML_AUTOMATA_ENABLED' file='xmlversion'>
      <info>Whether the automata interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_C14N_ENABLED' file='xmlversion'>
      <info>Whether the Canonicalization support is configured in</info>
    </macro>
    <macro name='LIBXML_CATALOG_ENABLED' file='xmlversion'>
      <info>Whether the Catalog support is configured in</info>
    </macro>
    <macro name='LIBXML_DEBUG_ENABLED' file='xmlversion'>
      <info>Whether Debugging module is configured in</info>
    </macro>
    <macro name='LIBXML_DEBUG_RUNTIME' file='xmlversion'>
      <info>Whether the runtime debugging is configured in</info>
    </macro>
    <macro name='LIBXML_DLL_IMPORT' file='xmlexports'>
    </macro>
    <macro name='LIBXML_DOCB_ENABLED' file='xmlversion'>
      <info>Whether the SGML Docbook support is configured in</info>
    </macro>
    <macro name='LIBXML_DOTTED_VERSION' file='xmlversion'>
      <info>the version string like &quot;1.2.3&quot;</info>
    </macro>
    <macro name='LIBXML_EXPR_ENABLED' file='xmlversion'>
      <info>Whether the formal expressions interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_FTP_ENABLED' file='xmlversion'>
      <info>Whether the FTP support is configured in</info>
    </macro>
    <macro name='LIBXML_HTML_ENABLED' file='xmlversion'>
      <info>Whether the HTML support is configured in</info>
    </macro>
    <macro name='LIBXML_HTTP_ENABLED' file='xmlversion'>
      <info>Whether the HTTP support is configured in</info>
    </macro>
    <macro name='LIBXML_ICONV_ENABLED' file='xmlversion'>
      <info>Whether iconv support is available</info>
    </macro>
    <macro name='LIBXML_ICU_ENABLED' file='xmlversion'>
      <info>Whether icu support is available</info>
    </macro>
    <macro name='LIBXML_ISO8859X_ENABLED' file='xmlversion'>
      <info>Whether ISO-8859-* support is made available in case iconv is not</info>
    </macro>
    <macro name='LIBXML_LEGACY_ENABLED' file='xmlversion'>
      <info>Whether the deprecated APIs are compiled in for compatibility</info>
    </macro>
    <macro name='LIBXML_LZMA_ENABLED' file='xmlversion'>
      <info>Whether the Lzma support is compiled in</info>
    </macro>
    <macro name='LIBXML_MODULES_ENABLED' file='xmlversion'>
      <info>Whether the module interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_MODULE_EXTENSION' file='xmlversion'>
      <info>the string suffix used by dynamic modules (usually shared libraries)</info>
    </macro>
    <macro name='LIBXML_OUTPUT_ENABLED' file='xmlversion'>
      <info>Whether the serialization/saving support is configured in</info>
    </macro>
    <macro name='LIBXML_PATTERN_ENABLED' file='xmlversion'>
      <info>Whether the xmlPattern node selection interface is configured in</info>
    </macro>
    <macro name='LIBXML_PUSH_ENABLED' file='xmlversion'>
      <info>Whether the push parsing interfaces are configured in</info>
    </macro>
    <macro name='LIBXML_READER_ENABLED' file='xmlversion'>
      <info>Whether the xmlReader parsing interface is configured in</info>
    </macro>
    <macro name='LIBXML_REGEXP_ENABLED' file='xmlversion'>
      <info>Whether the regular expressions interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_SAX1_ENABLED' file='xmlversion'>
      <info>Whether the older SAX1 interface is configured in</info>
    </macro>
    <macro name='LIBXML_SCHEMAS_ENABLED' file='xmlversion'>
      <info>Whether the Schemas validation interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_SCHEMATRON_ENABLED' file='xmlversion'>
      <info>Whether the Schematron validation interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_TEST_VERSION' file='xmlversion'>
      <info>Macro to check that the libxml version in use is compatible with the version the software has been compiled against</info>
    </macro>
    <macro name='LIBXML_THREAD_ALLOC_ENABLED' file='xmlversion'>
      <info>Whether the allocation hooks are per-thread</info>
    </macro>
    <macro name='LIBXML_THREAD_ENABLED' file='xmlversion'>
      <info>Whether the thread support is configured in</info>
    </macro>
    <macro name='LIBXML_TREE_ENABLED' file='xmlversion'>
      <info>Whether the DOM like tree manipulation API support is configured in</info>
    </macro>
    <macro name='LIBXML_UNICODE_ENABLED' file='xmlversion'>
      <info>Whether the Unicode related interfaces are compiled in</info>
    </macro>
    <macro name='LIBXML_VALID_ENABLED' file='xmlversion'>
      <info>Whether the DTD validation support is configured in</info>
    </macro>
    <macro name='LIBXML_VERSION' file='xmlversion'>
      <info>the version number: 1.2.3 value is 10203</info>
    </macro>
    <macro name='LIBXML_VERSION_EXTRA' file='xmlversion'>
      <info>extra version information, used to show a CVS compilation</info>
    </macro>
    <macro name='LIBXML_VERSION_STRING' file='xmlversion'>
      <info>the version number string, 1.2.3 value is &quot;10203&quot;</info>
    </macro>
    <macro name='LIBXML_WRITER_ENABLED' file='xmlversion'>
      <info>Whether the xmlWriter saving interface is configured in</info>
    </macro>
    <macro name='LIBXML_XINCLUDE_ENABLED' file='xmlversion'>
      <info>Whether XInclude is configured in</info>
    </macro>
    <macro name='LIBXML_XPATH_ENABLED' file='xmlversion'>
      <info>Whether XPath is configured in</info>
    </macro>
    <macro name='LIBXML_XPTR_ENABLED' file='xmlversion'>
      <info>Whether XPointer is configured in</info>
    </macro>
    <macro name='LIBXML_ZLIB_ENABLED' file='xmlversion'>
      <info>Whether the Zlib support is compiled in</info>
    </macro>
    <macro name='MOVETO_ENDTAG' file='parserInternals'>
      <info>Skips to the next &apos;&gt;&apos; char.</info>
      <arg name='p' info='and UTF8 string pointer'/>
    </macro>
    <macro name='MOVETO_STARTTAG' file='parserInternals'>
      <info>Skips to the next &apos;&lt;&apos; char.</info>
      <arg name='p' info='and UTF8 string pointer'/>
    </macro>
    <macro name='SKIP_EOL' file='parserInternals'>
      <info>Skips the end of line chars.</info>
      <arg name='p' info='and UTF8 string pointer'/>
    </macro>
    <macro name='SOCKET' file='nanoftp'>
      <info>macro used to provide portability of code to windows sockets</info>
    </macro>
    <macro name='WITHOUT_TRIO' file='xmlversion'>
      <info>defined if the trio support should not be configured in</info>
    </macro>
    <macro name='WITH_TRIO' file='xmlversion'>
      <info>defined if the trio support need to be configured in</info>
    </macro>
    <macro name='XINCLUDE_FALLBACK' file='xinclude'>
      <info>Macro defining &quot;fallback&quot;</info>
    </macro>
    <macro name='XINCLUDE_HREF' file='xinclude'>
      <info>Macro defining &quot;href&quot;</info>
    </macro>
    <macro name='XINCLUDE_NODE' file='xinclude'>
      <info>Macro defining &quot;include&quot;</info>
    </macro>
    <macro name='XINCLUDE_NS' file='xinclude'>
      <info>Macro defining the Xinclude namespace: http://www.w3.org/2003/XInclude</info>
    </macro>
    <macro name='XINCLUDE_OLD_NS' file='xinclude'>
      <info>Macro defining the draft Xinclude namespace: http://www.w3.org/2001/XInclude</info>
    </macro>
    <macro name='XINCLUDE_PARSE' file='xinclude'>
      <info>Macro defining &quot;parse&quot;</info>
    </macro>
    <macro name='XINCLUDE_PARSE_ENCODING' file='xinclude'>
      <info>Macro defining &quot;encoding&quot;</info>
    </macro>
    <macro name='XINCLUDE_PARSE_TEXT' file='xinclude'>
      <info>Macro defining &quot;text&quot;</info>
    </macro>
    <macro name='XINCLUDE_PARSE_XML' file='xinclude'>
      <info>Macro defining &quot;xml&quot;</info>
    </macro>
    <macro name='XINCLUDE_PARSE_XPOINTER' file='xinclude'>
      <info>Macro defining &quot;xpointer&quot;</info>
    </macro>
    <macro name='XMLCALL' file='xmlexports'>
    </macro>
    <macro name='XMLCDECL' file='xmlexports'>
    </macro>
    <macro name='XMLPUBFUN' file='xmlexports'>
    </macro>
    <macro name='XMLPUBVAR' file='xmlexports'>
    </macro>
    <macro name='XML_CAST_FPTR' file='hash'>
      <info>Macro to do a casting from an object pointer to a function pointer without encountering a warning from gcc  #define XML_CAST_FPTR(fptr) (*(void **)(&amp;fptr)) This macro violated ISO C aliasing rules (gcc4 on s390 broke) so it is disabled now</info>
      <arg name='fptr' info='pointer to a function'/>
    </macro>
    <macro name='XML_CATALOGS_NAMESPACE' file='catalog'>
      <info>The namespace for the XML Catalogs elements.</info>
    </macro>
    <macro name='XML_CATALOG_PI' file='catalog'>
      <info>The specific XML Catalog Processing Instuction name.</info>
    </macro>
    <macro name='XML_COMPLETE_ATTRS' file='parser'>
      <info>Bit in the loadsubset context field to tell to do complete the elements attributes lists with the ones defaulted from the DTDs. Use it to initialize xmlLoadExtDtdDefaultValue.</info>
    </macro>
    <macro name='XML_CTXT_FINISH_DTD_0' file='valid'>
      <info>Special value for finishDtd field when embedded in an xmlParserCtxt</info>
    </macro>
    <macro name='XML_CTXT_FINISH_DTD_1' file='valid'>
      <info>Special value for finishDtd field when embedded in an xmlParserCtxt</info>
    </macro>
    <macro name='XML_DEFAULT_VERSION' file='parser'>
      <info>The default version of XML used: 1.0</info>
    </macro>
    <macro name='XML_DETECT_IDS' file='parser'>
      <info>Bit in the loadsubset context field to tell to do ID/REFs lookups. Use it to initialize xmlLoadExtDtdDefaultValue.</info>
    </macro>
    <macro name='XML_GET_CONTENT' file='tree'>
      <info>Macro to extract the content pointer of a node.</info>
    </macro>
    <macro name='XML_GET_LINE' file='tree'>
      <info>Macro to extract the line number of an element node.</info>
    </macro>
    <macro name='XML_LOCAL_NAMESPACE' file='tree'>
      <info>A namespace declaration node.</info>
    </macro>
    <macro name='XML_MAX_DICTIONARY_LIMIT' file='parserInternals'>
      <info>Maximum size allowed by the parser for a dictionary by default This is not a limitation of the parser but a safety boundary feature, use XML_PARSE_HUGE option to override it. Introduced in 2.9.0</info>
    </macro>
    <macro name='XML_MAX_LOOKUP_LIMIT' file='parserInternals'>
      <info>Maximum size allowed by the parser for ahead lookup This is an upper boundary enforced by the parser to avoid bad behaviour on &quot;unfriendly&apos; content Introduced in 2.9.0</info>
    </macro>
    <macro name='XML_MAX_NAMELEN' file='parserInternals'>
      <info>Identifiers can be longer, but this will be more costly at runtime.</info>
    </macro>
    <macro name='XML_MAX_NAME_LENGTH' file='parserInternals'>
      <info>Maximum size allowed for a markup identitier This is not a limitation of the parser but a safety boundary feature, use XML_PARSE_HUGE option to override it. Note that with the use of parsing dictionaries overriding the limit may result in more runtime memory usage in face of &quot;unfriendly&apos; content Introduced in 2.9.0</info>
    </macro>
    <macro name='XML_MAX_TEXT_LENGTH' file='parserInternals'>
      <info>Maximum size allowed for a single text node when building a tree. This is not a limitation of the parser but a safety boundary feature, use XML_PARSE_HUGE option to override it. Introduced in 2.9.0</info>
    </macro>
    <macro name='XML_SAX2_MAGIC' file='parser'>
      <info>Special constant found in SAX2 blocks initialized fields</info>
    </macro>
    <macro name='XML_SCHEMAS_ANYATTR_LAX' file='schemasInternals'>
      <info>Ignore validation non definition on attributes Obsolete, not used anymore.</info>
    </macro>
    <macro name='XML_SCHEMAS_ANYATTR_SKIP' file='schemasInternals'>
      <info>Skip unknown attribute from validation Obsolete, not used anymore.</info>
    </macro>
    <macro name='XML_SCHEMAS_ANYATTR_STRICT' file='schemasInternals'>
      <info>Apply strict validation rules on attributes Obsolete, not used anymore.</info>
    </macro>
    <macro name='XML_SCHEMAS_ANY_LAX' file='schemasInternals'>
      <info>Used by wildcards. Validate if type found, don&apos;t worry if not found</info>
    </macro>
    <macro name='XML_SCHEMAS_ANY_SKIP' file='schemasInternals'>
      <info>Skip unknown attribute from validation</info>
    </macro>
    <macro name='XML_SCHEMAS_ANY_STRICT' file='schemasInternals'>
      <info>Used by wildcards. Apply strict validation rules</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTRGROUP_GLOBAL' file='schemasInternals'>
      <info>The attribute wildcard has been already builded.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTRGROUP_HAS_REFS' file='schemasInternals'>
      <info>Whether this attr. group contains attr. group references.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTRGROUP_MARKED' file='schemasInternals'>
      <info>Marks the attr group as marked; used for circular checks.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTRGROUP_REDEFINED' file='schemasInternals'>
      <info>The attr group was redefined.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED' file='schemasInternals'>
      <info>The attribute wildcard has been already builded.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_FIXED' file='schemasInternals'>
      <info>the attribute has a fixed value</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_GLOBAL' file='schemasInternals'>
      <info>allow elements in no namespace</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_INTERNAL_RESOLVED' file='schemasInternals'>
      <info>this is set when the &quot;type&quot; and &quot;ref&quot; references have been resolved.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_NSDEFAULT' file='schemasInternals'>
      <info>allow elements in no namespace</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_USE_OPTIONAL' file='schemasInternals'>
      <info>The attribute is optional.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_USE_PROHIBITED' file='schemasInternals'>
      <info>Used by wildcards. The attribute is prohibited.</info>
    </macro>
    <macro name='XML_SCHEMAS_ATTR_USE_REQUIRED' file='schemasInternals'>
      <info>The attribute is required.</info>
    </macro>
    <macro name='XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION' file='schemasInternals'>
      <info>the schema has &quot;extension&quot; in the set of blockDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION' file='schemasInternals'>
      <info>the schema has &quot;restriction&quot; in the set of blockDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION' file='schemasInternals'>
      <info>the schema has &quot;substitution&quot; in the set of blockDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_ABSTRACT' file='schemasInternals'>
      <info>the element is abstract</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_BLOCK_ABSENT' file='schemasInternals'>
      <info>the &quot;block&quot; attribute is absent</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_BLOCK_EXTENSION' file='schemasInternals'>
      <info>disallowed substitutions are absent</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_BLOCK_RESTRICTION' file='schemasInternals'>
      <info>disallowed substitutions: &quot;restriction&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION' file='schemasInternals'>
      <info>disallowed substitutions: &quot;substituion&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_CIRCULAR' file='schemasInternals'>
      <info>a helper flag for the search of circular references.</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_DEFAULT' file='schemasInternals'>
      <info>the element has a default value</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_FINAL_ABSENT' file='schemasInternals'>
      <info>substitution group exclusions are absent</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_FINAL_EXTENSION' file='schemasInternals'>
      <info>substitution group exclusions: &quot;extension&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_FINAL_RESTRICTION' file='schemasInternals'>
      <info>substitution group exclusions: &quot;restriction&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_FIXED' file='schemasInternals'>
      <info>the element has a fixed value</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_GLOBAL' file='schemasInternals'>
      <info>the element is global</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_INTERNAL_CHECKED' file='schemasInternals'>
      <info>this is set when the elem decl has been checked against all constraints</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_INTERNAL_RESOLVED' file='schemasInternals'>
      <info>this is set when &quot;type&quot;, &quot;ref&quot;, &quot;substitutionGroup&quot; references have been resolved.</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_NILLABLE' file='schemasInternals'>
      <info>the element is nillable</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_NSDEFAULT' file='schemasInternals'>
      <info>allow elements in no namespace Obsolete, not used anymore.</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_REF' file='schemasInternals'>
      <info>the element is a reference to a type</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD' file='schemasInternals'>
      <info>the declaration is a substitution group head</info>
    </macro>
    <macro name='XML_SCHEMAS_ELEM_TOPLEVEL' file='schemasInternals'>
      <info>the element is top level obsolete: use XML_SCHEMAS_ELEM_GLOBAL instead</info>
    </macro>
    <macro name='XML_SCHEMAS_FACET_COLLAPSE' file='schemasInternals'>
      <info>collapse the types of the facet</info>
    </macro>
    <macro name='XML_SCHEMAS_FACET_PRESERVE' file='schemasInternals'>
      <info>preserve the type of the facet</info>
    </macro>
    <macro name='XML_SCHEMAS_FACET_REPLACE' file='schemasInternals'>
      <info>replace the type of the facet</info>
    </macro>
    <macro name='XML_SCHEMAS_FACET_UNKNOWN' file='schemasInternals'>
      <info>unknown facet handling</info>
    </macro>
    <macro name='XML_SCHEMAS_FINAL_DEFAULT_EXTENSION' file='schemasInternals'>
      <info>the schema has &quot;extension&quot; in the set of finalDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_FINAL_DEFAULT_LIST' file='schemasInternals'>
      <info>the cshema has &quot;list&quot; in the set of finalDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION' file='schemasInternals'>
      <info>the schema has &quot;restriction&quot; in the set of finalDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_FINAL_DEFAULT_UNION' file='schemasInternals'>
      <info>the schema has &quot;union&quot; in the set of finalDefault.</info>
    </macro>
    <macro name='XML_SCHEMAS_INCLUDING_CONVERT_NS' file='schemasInternals'>
      <info>the schema is currently including an other schema with no target namespace.</info>
    </macro>
    <macro name='XML_SCHEMAS_QUALIF_ATTR' file='schemasInternals'>
      <info>Reflects attributeFormDefault == qualified in an XML schema document.</info>
    </macro>
    <macro name='XML_SCHEMAS_QUALIF_ELEM' file='schemasInternals'>
      <info>Reflects elementFormDefault == qualified in an XML schema document.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_ABSTRACT' file='schemasInternals'>
      <info>the simple/complexType is abstract.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_BLOCK_DEFAULT' file='schemasInternals'>
      <info>the complexType did not specify &apos;block&apos; so use the default of the &lt;schema&gt; item.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_BLOCK_EXTENSION' file='schemasInternals'>
      <info>the complexType has a &apos;block&apos; of &quot;extension&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_BLOCK_RESTRICTION' file='schemasInternals'>
      <info>the complexType has a &apos;block&apos; of &quot;restriction&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE' file='schemasInternals'>
      <info>Marks the item as a builtin primitive.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION' file='schemasInternals'>
      <info>the simple or complex type has a derivation method of &quot;extension&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION' file='schemasInternals'>
      <info>the simple or complex type has a derivation method of &quot;restriction&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FACETSNEEDVALUE' file='schemasInternals'>
      <info>indicates if the facets need a computed value</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FINAL_DEFAULT' file='schemasInternals'>
      <info>the simpleType has a final of &quot;default&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FINAL_EXTENSION' file='schemasInternals'>
      <info>the complexType has a final of &quot;extension&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FINAL_LIST' file='schemasInternals'>
      <info>the simpleType has a final of &quot;list&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FINAL_RESTRICTION' file='schemasInternals'>
      <info>the simpleType/complexType has a final of &quot;restriction&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FINAL_UNION' file='schemasInternals'>
      <info>the simpleType has a final of &quot;union&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_FIXUP_1' file='schemasInternals'>
      <info>First stage of fixup was done.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_GLOBAL' file='schemasInternals'>
      <info>the type is global</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_HAS_FACETS' file='schemasInternals'>
      <info>has facets</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_INTERNAL_INVALID' file='schemasInternals'>
      <info>indicates that the type is invalid</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_INTERNAL_RESOLVED' file='schemasInternals'>
      <info>indicates that the type was typefixed</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_MARKED' file='schemasInternals'>
      <info>Marks the item as marked; used for circular checks.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_MIXED' file='schemasInternals'>
      <info>the element content type is mixed</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_NORMVALUENEEDED' file='schemasInternals'>
      <info>indicates if the facets (pattern) need a normalized value</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD' file='schemasInternals'>
      <info>the complexType owns an attribute wildcard, i.e. it can be freed by the complexType</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_REDEFINED' file='schemasInternals'>
      <info>The type was redefined.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_VARIETY_ABSENT' file='schemasInternals'>
      <info>the simpleType has a variety of &quot;absent&quot;. TODO: Actually not necessary :-/, since if none of the variety flags occur then it&apos;s automatically absent.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_VARIETY_ATOMIC' file='schemasInternals'>
      <info>the simpleType has a variety of &quot;union&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_VARIETY_LIST' file='schemasInternals'>
      <info>the simpleType has a variety of &quot;list&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_VARIETY_UNION' file='schemasInternals'>
      <info>the simpleType has a variety of &quot;union&quot;.</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE' file='schemasInternals'>
      <info>a whitespace-facet value of &quot;collapse&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE' file='schemasInternals'>
      <info>a whitespace-facet value of &quot;preserve&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_TYPE_WHITESPACE_REPLACE' file='schemasInternals'>
      <info>a whitespace-facet value of &quot;replace&quot;</info>
    </macro>
    <macro name='XML_SCHEMAS_WILDCARD_COMPLETE' file='schemasInternals'>
      <info>If the wildcard is complete.</info>
    </macro>
    <macro name='XML_SKIP_IDS' file='parser'>
      <info>Bit in the loadsubset context field to tell to not do ID/REFs registration. Used to initialize xmlLoadExtDtdDefaultValue in some special cases.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_BOTH' file='parserInternals'>
      <info>Both general and parameter entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_NONE' file='parserInternals'>
      <info>If no entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_PEREF' file='parserInternals'>
      <info>Whether parameter entities need to be substituted.</info>
    </macro>
    <macro name='XML_SUBSTITUTE_REF' file='parserInternals'>
      <info>Whether general entities need to be substituted.</info>
    </macro>
    <macro name='XML_XML_ID' file='tree'>
      <info>This is the name for the special xml:id attribute</info>
    </macro>
    <macro name='XML_XML_NAMESPACE' file='tree'>
      <info>This is the namespace for the special xml: prefix predefined in the XML Namespace specification.</info>
    </macro>
    <macro name='XML_XPATH_CHECKNS' file='xpath'>
      <info>check namespaces at compilation</info>
    </macro>
    <macro name='XML_XPATH_NOVAR' file='xpath'>
      <info>forbid variables in expression</info>
    </macro>
    <macro name='XP_ERROR' file='xpathInternals'>
      <info>Macro to raise an XPath error and return.</info>
      <arg name='X' info='the error code'/>
    </macro>
    <macro name='XP_ERROR0' file='xpathInternals'>
      <info>Macro to raise an XPath error and return 0.</info>
      <arg name='X' info='the error code'/>
    </macro>
    <macro name='_REENTRANT' file='xmlexports'>
    </macro>
    <macro name='htmlDefaultSubelement' file='HTMLparser'>
      <info>Returns the default subelement for this element</info>
      <arg name='elt' info='HTML element'/>
    </macro>
    <macro name='htmlElementAllowedHereDesc' file='HTMLparser'>
      <info>Checks whether an HTML element description may be a direct child of the specified element.  Returns 1 if allowed; 0 otherwise.</info>
      <arg name='parent' info='HTML parent element'/>
      <arg name='elt' info='HTML element'/>
    </macro>
    <macro name='htmlRequiredAttrs' file='HTMLparser'>
      <info>Returns the attributes required for the specified element.</info>
      <arg name='elt' info='HTML element'/>
    </macro>
    <macro name='xmlChildrenNode' file='tree'>
      <info>Macro for compatibility naming layer with libxml1. Maps to &quot;children.&quot;</info>
    </macro>
    <macro name='xmlIsBaseCharQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsBaseChar_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsBlankQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsBlank_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsCharQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsChar_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsCombiningQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsDigitQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsDigit_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsExtenderQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsExtender_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsIdeographicQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsPubidCharQ' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlIsPubidChar_ch' file='chvalid'>
      <info>Automatically generated by genChRanges.py</info>
      <arg name='c' info='char to validate'/>
    </macro>
    <macro name='xmlRootNode' file='tree'>
      <info>Macro for compatibility naming layer with libxml1. Maps to &quot;children&quot;.</info>
    </macro>
    <macro name='xmlTextWriterWriteDocType' file='xmlwriter'>
      <info>this macro maps to xmlTextWriterWriteDTD</info>
    </macro>
    <macro name='xmlTextWriterWriteProcessingInstruction' file='xmlwriter'>
      <info>This macro maps to xmlTextWriterWritePI</info>
    </macro>
    <macro name='xmlXPathCheckError' file='xpathInternals'>
      <info>Check if an XPath error was raised.  Returns true if an error has been raised, false otherwise.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathEmptyNodeSet' file='xpathInternals'>
      <info>Empties a node-set.</info>
      <arg name='ns' info='a node-set'/>
    </macro>
    <macro name='xmlXPathGetContextNode' file='xpathInternals'>
      <info>Get the context node of an XPath context.  Returns the context node.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathGetDocument' file='xpathInternals'>
      <info>Get the document of an XPath context.  Returns the context document.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathGetError' file='xpathInternals'>
      <info>Get the error code of an XPath context.  Returns the context error.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathNodeSetGetLength' file='xpath'>
      <info>Implement a functionality similar to the DOM NodeList.length.  Returns the number of nodes in the node-set.</info>
      <arg name='ns' info='a node-set'/>
    </macro>
    <macro name='xmlXPathNodeSetIsEmpty' file='xpath'>
      <info>Checks whether @ns is empty or not.  Returns %TRUE if @ns is an empty node-set.</info>
      <arg name='ns' info='a node-set'/>
    </macro>
    <macro name='xmlXPathNodeSetItem' file='xpath'>
      <info>Implements a functionality similar to the DOM NodeList.item().  Returns the xmlNodePtr at the given @index in @ns or NULL if @index is out of range (0 to length-1)</info>
      <arg name='ns' info='a node-set'/>
      <arg name='index' info='index of a node in the set'/>
    </macro>
    <macro name='xmlXPathReturnBoolean' file='xpathInternals'>
      <info>Pushes the boolean @val on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='val' info='a boolean'/>
    </macro>
    <macro name='xmlXPathReturnEmptyNodeSet' file='xpathInternals'>
      <info>Pushes an empty node-set on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathReturnEmptyString' file='xpathInternals'>
      <info>Pushes an empty string on the stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathReturnExternal' file='xpathInternals'>
      <info>Pushes user data on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='val' info='user data'/>
    </macro>
    <macro name='xmlXPathReturnFalse' file='xpathInternals'>
      <info>Pushes false on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathReturnNodeSet' file='xpathInternals'>
      <info>Pushes the node-set @ns on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='ns' info='a node-set'/>
    </macro>
    <macro name='xmlXPathReturnNumber' file='xpathInternals'>
      <info>Pushes the double @val on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='val' info='a double'/>
    </macro>
    <macro name='xmlXPathReturnString' file='xpathInternals'>
      <info>Pushes the string @str on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='str' info='a string'/>
    </macro>
    <macro name='xmlXPathReturnTrue' file='xpathInternals'>
      <info>Pushes true on the context stack.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathSetArityError' file='xpathInternals'>
      <info>Raises an XPATH_INVALID_ARITY error.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathSetError' file='xpathInternals'>
      <info>Raises an error.</info>
      <arg name='ctxt' info='an XPath parser context'/>
      <arg name='err' info='an xmlXPathError code'/>
    </macro>
    <macro name='xmlXPathSetTypeError' file='xpathInternals'>
      <info>Raises an XPATH_INVALID_TYPE error.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathStackIsExternal' file='xpathInternals'>
      <info>Checks if the current value on the XPath stack is an external object.  Returns true if the current object on the stack is an external object.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <macro name='xmlXPathStackIsNodeSet' file='xpathInternals'>
      <info>Check if the current value on the XPath stack is a node set or an XSLT value tree.  Returns true if the current object on the stack is a node-set.</info>
      <arg name='ctxt' info='an XPath parser context'/>
    </macro>
    <enum name='HTML_DEPRECATED' file='HTMLparser' value='2' type='htmlStatus'/>
    <enum name='HTML_INVALID' file='HTMLparser' value='1' type='htmlStatus'/>
    <enum name='HTML_NA' file='HTMLparser' value='0' type='htmlStatus' info='something we don&apos;t check at all'/>
    <enum name='HTML_PARSE_COMPACT' file='HTMLparser' value='65536' type='htmlParserOption' info='compact small text nodes'/>
    <enum name='HTML_PARSE_IGNORE_ENC' file='HTMLparser' value='2097152' type='htmlParserOption' info=' ignore internal document encoding hint'/>
    <enum name='HTML_PARSE_NOBLANKS' file='HTMLparser' value='256' type='htmlParserOption' info='remove blank nodes'/>
    <enum name='HTML_PARSE_NODEFDTD' file='HTMLparser' value='4' type='htmlParserOption' info='do not default a doctype if not found'/>
    <enum name='HTML_PARSE_NOERROR' file='HTMLparser' value='32' type='htmlParserOption' info='suppress error reports'/>
    <enum name='HTML_PARSE_NOIMPLIED' file='HTMLparser' value='8192' type='htmlParserOption' info='Do not add implied html/body... elements'/>
    <enum name='HTML_PARSE_NONET' file='HTMLparser' value='2048' type='htmlParserOption' info='Forbid network access'/>
    <enum name='HTML_PARSE_NOWARNING' file='HTMLparser' value='64' type='htmlParserOption' info='suppress warning reports'/>
    <enum name='HTML_PARSE_PEDANTIC' file='HTMLparser' value='128' type='htmlParserOption' info='pedantic error reporting'/>
    <enum name='HTML_PARSE_RECOVER' file='HTMLparser' value='1' type='htmlParserOption' info='Relaxed parsing'/>
    <enum name='HTML_REQUIRED' file='HTMLparser' value='12' type='htmlStatus' info=' VALID bit set so ( &amp; HTML_VALID ) is TRUE'/>
    <enum name='HTML_VALID' file='HTMLparser' value='4' type='htmlStatus'/>
    <enum name='XLINK_ACTUATE_AUTO' file='xlink' value='1' type='xlinkActuate'/>
    <enum name='XLINK_ACTUATE_NONE' file='xlink' value='0' type='xlinkActuate'/>
    <enum name='XLINK_ACTUATE_ONREQUEST' file='xlink' value='2' type='xlinkActuate'/>
    <enum name='XLINK_SHOW_EMBED' file='xlink' value='2' type='xlinkShow'/>
    <enum name='XLINK_SHOW_NEW' file='xlink' value='1' type='xlinkShow'/>
    <enum name='XLINK_SHOW_NONE' file='xlink' value='0' type='xlinkShow'/>
    <enum name='XLINK_SHOW_REPLACE' file='xlink' value='3' type='xlinkShow'/>
    <enum name='XLINK_TYPE_EXTENDED' file='xlink' value='2' type='xlinkType'/>
    <enum name='XLINK_TYPE_EXTENDED_SET' file='xlink' value='3' type='xlinkType'/>
    <enum name='XLINK_TYPE_NONE' file='xlink' value='0' type='xlinkType'/>
    <enum name='XLINK_TYPE_SIMPLE' file='xlink' value='1' type='xlinkType'/>
    <enum name='XML_ATTRIBUTE_CDATA' file='tree' value='1' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_DECL' file='tree' value='16' type='xmlElementType'/>
    <enum name='XML_ATTRIBUTE_ENTITIES' file='tree' value='6' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_ENTITY' file='tree' value='5' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_ENUMERATION' file='tree' value='9' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_FIXED' file='tree' value='4' type='xmlAttributeDefault'/>
    <enum name='XML_ATTRIBUTE_ID' file='tree' value='2' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_IDREF' file='tree' value='3' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_IDREFS' file='tree' value='4' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_IMPLIED' file='tree' value='3' type='xmlAttributeDefault'/>
    <enum name='XML_ATTRIBUTE_NMTOKEN' file='tree' value='7' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_NMTOKENS' file='tree' value='8' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_NODE' file='tree' value='2' type='xmlElementType'/>
    <enum name='XML_ATTRIBUTE_NONE' file='tree' value='1' type='xmlAttributeDefault'/>
    <enum name='XML_ATTRIBUTE_NOTATION' file='tree' value='10' type='xmlAttributeType'/>
    <enum name='XML_ATTRIBUTE_REQUIRED' file='tree' value='2' type='xmlAttributeDefault'/>
    <enum name='XML_BUFFER_ALLOC_DOUBLEIT' file='tree' value='1' type='xmlBufferAllocationScheme' info='double each time one need to grow'/>
    <enum name='XML_BUFFER_ALLOC_EXACT' file='tree' value='2' type='xmlBufferAllocationScheme' info='grow only to the minimal size'/>
    <enum name='XML_BUFFER_ALLOC_HYBRID' file='tree' value='5' type='xmlBufferAllocationScheme' info=' exact up to a threshold, and doubleit thereafter'/>
    <enum name='XML_BUFFER_ALLOC_IMMUTABLE' file='tree' value='3' type='xmlBufferAllocationScheme' info='immutable buffer'/>
    <enum name='XML_BUFFER_ALLOC_IO' file='tree' value='4' type='xmlBufferAllocationScheme' info='special allocation scheme used for I/O'/>
    <enum name='XML_BUF_OVERFLOW' file='xmlerror' value='7000' type='xmlParserErrors'/>
    <enum name='XML_C14N_1_0' file='c14n' value='0' type='xmlC14NMode' info='Origianal C14N 1.0 spec'/>
    <enum name='XML_C14N_1_1' file='c14n' value='2' type='xmlC14NMode' info=' C14N 1.1 spec'/>
    <enum name='XML_C14N_CREATE_CTXT' file='xmlerror' value='1950' type='xmlParserErrors'/>
    <enum name='XML_C14N_CREATE_STACK' file='xmlerror' value='1952' type='xmlParserErrors' info='1952'/>
    <enum name='XML_C14N_EXCLUSIVE_1_0' file='c14n' value='1' type='xmlC14NMode' info='Exclusive C14N 1.0 spec'/>
    <enum name='XML_C14N_INVALID_NODE' file='xmlerror' value='1953' type='xmlParserErrors' info='1953'/>
    <enum name='XML_C14N_RELATIVE_NAMESPACE' file='xmlerror' value='1955' type='xmlParserErrors' info='1955'/>
    <enum name='XML_C14N_REQUIRES_UTF8' file='xmlerror' value='1951' type='xmlParserErrors' info='1951'/>
    <enum name='XML_C14N_UNKNOW_NODE' file='xmlerror' value='1954' type='xmlParserErrors' info='1954'/>
    <enum name='XML_CATALOG_ENTRY_BROKEN' file='xmlerror' value='1651' type='xmlParserErrors' info='1651'/>
    <enum name='XML_CATALOG_MISSING_ATTR' file='xmlerror' value='1650' type='xmlParserErrors'/>
    <enum name='XML_CATALOG_NOT_CATALOG' file='xmlerror' value='1653' type='xmlParserErrors' info='1653'/>
    <enum name='XML_CATALOG_PREFER_VALUE' file='xmlerror' value='1652' type='xmlParserErrors' info='1652'/>
    <enum name='XML_CATALOG_RECURSION' file='xmlerror' value='1654' type='xmlParserErrors' info='1654'/>
    <enum name='XML_CATA_ALLOW_ALL' file='catalog' value='3' type='xmlCatalogAllow'/>
    <enum name='XML_CATA_ALLOW_DOCUMENT' file='catalog' value='2' type='xmlCatalogAllow'/>
    <enum name='XML_CATA_ALLOW_GLOBAL' file='catalog' value='1' type='xmlCatalogAllow'/>
    <enum name='XML_CATA_ALLOW_NONE' file='catalog' value='0' type='xmlCatalogAllow'/>
    <enum name='XML_CATA_PREFER_NONE' file='catalog' value='0' type='xmlCatalogPrefer'/>
    <enum name='XML_CATA_PREFER_PUBLIC' file='catalog' value='1' type='xmlCatalogPrefer'/>
    <enum name='XML_CATA_PREFER_SYSTEM' file='catalog' value='2' type='xmlCatalogPrefer'/>
    <enum name='XML_CDATA_SECTION_NODE' file='tree' value='4' type='xmlElementType'/>
    <enum name='XML_CHAR_ENCODING_2022_JP' file='encoding' value='19' type='xmlCharEncoding' info='ISO-2022-JP'/>
    <enum name='XML_CHAR_ENCODING_8859_1' file='encoding' value='10' type='xmlCharEncoding' info='ISO-8859-1 ISO Latin 1'/>
    <enum name='XML_CHAR_ENCODING_8859_2' file='encoding' value='11' type='xmlCharEncoding' info='ISO-8859-2 ISO Latin 2'/>
    <enum name='XML_CHAR_ENCODING_8859_3' file='encoding' value='12' type='xmlCharEncoding' info='ISO-8859-3'/>
    <enum name='XML_CHAR_ENCODING_8859_4' file='encoding' value='13' type='xmlCharEncoding' info='ISO-8859-4'/>
    <enum name='XML_CHAR_ENCODING_8859_5' file='encoding' value='14' type='xmlCharEncoding' info='ISO-8859-5'/>
    <enum name='XML_CHAR_ENCODING_8859_6' file='encoding' value='15' type='xmlCharEncoding' info='ISO-8859-6'/>
    <enum name='XML_CHAR_ENCODING_8859_7' file='encoding' value='16' type='xmlCharEncoding' info='ISO-8859-7'/>
    <enum name='XML_CHAR_ENCODING_8859_8' file='encoding' value='17' type='xmlCharEncoding' info='ISO-8859-8'/>
    <enum name='XML_CHAR_ENCODING_8859_9' file='encoding' value='18' type='xmlCharEncoding' info='ISO-8859-9'/>
    <enum name='XML_CHAR_ENCODING_ASCII' file='encoding' value='22' type='xmlCharEncoding' info=' pure ASCII'/>
    <enum name='XML_CHAR_ENCODING_EBCDIC' file='encoding' value='6' type='xmlCharEncoding' info='EBCDIC uh!'/>
    <enum name='XML_CHAR_ENCODING_ERROR' file='encoding' value='-1' type='xmlCharEncoding' info='No char encoding detected'/>
    <enum name='XML_CHAR_ENCODING_EUC_JP' file='encoding' value='21' type='xmlCharEncoding' info='EUC-JP'/>
    <enum name='XML_CHAR_ENCODING_NONE' file='encoding' value='0' type='xmlCharEncoding' info='No char encoding detected'/>
    <enum name='XML_CHAR_ENCODING_SHIFT_JIS' file='encoding' value='20' type='xmlCharEncoding' info='Shift_JIS'/>
    <enum name='XML_CHAR_ENCODING_UCS2' file='encoding' value='9' type='xmlCharEncoding' info='UCS-2'/>
    <enum name='XML_CHAR_ENCODING_UCS4BE' file='encoding' value='5' type='xmlCharEncoding' info='UCS-4 big endian'/>
    <enum name='XML_CHAR_ENCODING_UCS4LE' file='encoding' value='4' type='xmlCharEncoding' info='UCS-4 little endian'/>
    <enum name='XML_CHAR_ENCODING_UCS4_2143' file='encoding' value='7' type='xmlCharEncoding' info='UCS-4 unusual ordering'/>
    <enum name='XML_CHAR_ENCODING_UCS4_3412' file='encoding' value='8' type='xmlCharEncoding' info='UCS-4 unusual ordering'/>
    <enum name='XML_CHAR_ENCODING_UTF16BE' file='encoding' value='3' type='xmlCharEncoding' info='UTF-16 big endian'/>
    <enum name='XML_CHAR_ENCODING_UTF16LE' file='encoding' value='2' type='xmlCharEncoding' info='UTF-16 little endian'/>
    <enum name='XML_CHAR_ENCODING_UTF8' file='encoding' value='1' type='xmlCharEncoding' info='UTF-8'/>
    <enum name='XML_CHECK_ENTITY_TYPE' file='xmlerror' value='5012' type='xmlParserErrors' info='5012'/>
    <enum name='XML_CHECK_FOUND_ATTRIBUTE' file='xmlerror' value='5001' type='xmlParserErrors' info='5001'/>
    <enum name='XML_CHECK_FOUND_CDATA' file='xmlerror' value='5003' type='xmlParserErrors' info='5003'/>
    <enum name='XML_CHECK_FOUND_COMMENT' file='xmlerror' value='5007' type='xmlParserErrors' info='5007'/>
    <enum name='XML_CHECK_FOUND_DOCTYPE' file='xmlerror' value='5008' type='xmlParserErrors' info='5008'/>
    <enum name='XML_CHECK_FOUND_ELEMENT' file='xmlerror' value='5000' type='xmlParserErrors'/>
    <enum name='XML_CHECK_FOUND_ENTITY' file='xmlerror' value='5005' type='xmlParserErrors' info='5005'/>
    <enum name='XML_CHECK_FOUND_ENTITYREF' file='xmlerror' value='5004' type='xmlParserErrors' info='5004'/>
    <enum name='XML_CHECK_FOUND_FRAGMENT' file='xmlerror' value='5009' type='xmlParserErrors' info='5009'/>
    <enum name='XML_CHECK_FOUND_NOTATION' file='xmlerror' value='5010' type='xmlParserErrors' info='5010'/>
    <enum name='XML_CHECK_FOUND_PI' file='xmlerror' value='5006' type='xmlParserErrors' info='5006'/>
    <enum name='XML_CHECK_FOUND_TEXT' file='xmlerror' value='5002' type='xmlParserErrors' info='5002'/>
    <enum name='XML_CHECK_NAME_NOT_NULL' file='xmlerror' value='5037' type='xmlParserErrors' info='5037'/>
    <enum name='XML_CHECK_NOT_ATTR' file='xmlerror' value='5023' type='xmlParserErrors' info='5023'/>
    <enum name='XML_CHECK_NOT_ATTR_DECL' file='xmlerror' value='5024' type='xmlParserErrors' info='5024'/>
    <enum name='XML_CHECK_NOT_DTD' file='xmlerror' value='5022' type='xmlParserErrors' info='5022'/>
    <enum name='XML_CHECK_NOT_ELEM_DECL' file='xmlerror' value='5025' type='xmlParserErrors' info='5025'/>
    <enum name='XML_CHECK_NOT_ENTITY_DECL' file='xmlerror' value='5026' type='xmlParserErrors' info='5026'/>
    <enum name='XML_CHECK_NOT_NCNAME' file='xmlerror' value='5034' type='xmlParserErrors' info='5034'/>
    <enum name='XML_CHECK_NOT_NS_DECL' file='xmlerror' value='5027' type='xmlParserErrors' info='5027'/>
    <enum name='XML_CHECK_NOT_UTF8' file='xmlerror' value='5032' type='xmlParserErrors' info='5032'/>
    <enum name='XML_CHECK_NO_DICT' file='xmlerror' value='5033' type='xmlParserErrors' info='5033'/>
    <enum name='XML_CHECK_NO_DOC' file='xmlerror' value='5014' type='xmlParserErrors' info='5014'/>
    <enum name='XML_CHECK_NO_ELEM' file='xmlerror' value='5016' type='xmlParserErrors' info='5016'/>
    <enum name='XML_CHECK_NO_HREF' file='xmlerror' value='5028' type='xmlParserErrors' info='5028'/>
    <enum name='XML_CHECK_NO_NAME' file='xmlerror' value='5015' type='xmlParserErrors' info='5015'/>
    <enum name='XML_CHECK_NO_NEXT' file='xmlerror' value='5020' type='xmlParserErrors' info='5020'/>
    <enum name='XML_CHECK_NO_PARENT' file='xmlerror' value='5013' type='xmlParserErrors' info='5013'/>
    <enum name='XML_CHECK_NO_PREV' file='xmlerror' value='5018' type='xmlParserErrors' info='5018'/>
    <enum name='XML_CHECK_NS_ANCESTOR' file='xmlerror' value='5031' type='xmlParserErrors' info='5031'/>
    <enum name='XML_CHECK_NS_SCOPE' file='xmlerror' value='5030' type='xmlParserErrors' info='5030'/>
    <enum name='XML_CHECK_OUTSIDE_DICT' file='xmlerror' value='5035' type='xmlParserErrors' info='5035'/>
    <enum name='XML_CHECK_UNKNOWN_NODE' file='xmlerror' value='5011' type='xmlParserErrors' info='5011'/>
    <enum name='XML_CHECK_WRONG_DOC' file='xmlerror' value='5017' type='xmlParserErrors' info='5017'/>
    <enum name='XML_CHECK_WRONG_NAME' file='xmlerror' value='5036' type='xmlParserErrors' info='5036'/>
    <enum name='XML_CHECK_WRONG_NEXT' file='xmlerror' value='5021' type='xmlParserErrors' info='5021'/>
    <enum name='XML_CHECK_WRONG_PARENT' file='xmlerror' value='5029' type='xmlParserErrors' info='5029'/>
    <enum name='XML_CHECK_WRONG_PREV' file='xmlerror' value='5019' type='xmlParserErrors' info='5019'/>
    <enum name='XML_COMMENT_NODE' file='tree' value='8' type='xmlElementType'/>
    <enum name='XML_DOCB_DOCUMENT_NODE' file='tree' value='21' type='xmlElementType'/>
    <enum name='XML_DOCUMENT_FRAG_NODE' file='tree' value='11' type='xmlElementType'/>
    <enum name='XML_DOCUMENT_NODE' file='tree' value='9' type='xmlElementType'/>
    <enum name='XML_DOCUMENT_TYPE_NODE' file='tree' value='10' type='xmlElementType'/>
    <enum name='XML_DOC_DTDVALID' file='tree' value='8' type='xmlDocProperties' info='DTD validation was successful'/>
    <enum name='XML_DOC_HTML' file='tree' value='128' type='xmlDocProperties' info=' parsed or built HTML document'/>
    <enum name='XML_DOC_INTERNAL' file='tree' value='64' type='xmlDocProperties' info='built for internal processing'/>
    <enum name='XML_DOC_NSVALID' file='tree' value='2' type='xmlDocProperties' info='document is Namespace valid'/>
    <enum name='XML_DOC_OLD10' file='tree' value='4' type='xmlDocProperties' info='parsed with old XML-1.0 parser'/>
    <enum name='XML_DOC_USERBUILT' file='tree' value='32' type='xmlDocProperties' info='Document was built using the API
and not by parsing an instance'/>
    <enum name='XML_DOC_WELLFORMED' file='tree' value='1' type='xmlDocProperties' info='document is XML well formed'/>
    <enum name='XML_DOC_XINCLUDE' file='tree' value='16' type='xmlDocProperties' info='XInclude substitution was done'/>
    <enum name='XML_DTD_ATTRIBUTE_DEFAULT' file='xmlerror' value='500' type='xmlParserErrors'/>
    <enum name='XML_DTD_ATTRIBUTE_REDEFINED' file='xmlerror' value='501' type='xmlParserErrors' info='501'/>
    <enum name='XML_DTD_ATTRIBUTE_VALUE' file='xmlerror' value='502' type='xmlParserErrors' info='502'/>
    <enum name='XML_DTD_CONTENT_ERROR' file='xmlerror' value='503' type='xmlParserErrors' info='503'/>
    <enum name='XML_DTD_CONTENT_MODEL' file='xmlerror' value='504' type='xmlParserErrors' info='504'/>
    <enum name='XML_DTD_CONTENT_NOT_DETERMINIST' file='xmlerror' value='505' type='xmlParserErrors' info='505'/>
    <enum name='XML_DTD_DIFFERENT_PREFIX' file='xmlerror' value='506' type='xmlParserErrors' info='506'/>
    <enum name='XML_DTD_DUP_TOKEN' file='xmlerror' value='541' type='xmlParserErrors' info='541'/>
    <enum name='XML_DTD_ELEM_DEFAULT_NAMESPACE' file='xmlerror' value='507' type='xmlParserErrors' info='507'/>
    <enum name='XML_DTD_ELEM_NAMESPACE' file='xmlerror' value='508' type='xmlParserErrors' info='508'/>
    <enum name='XML_DTD_ELEM_REDEFINED' file='xmlerror' value='509' type='xmlParserErrors' info='509'/>
    <enum name='XML_DTD_EMPTY_NOTATION' file='xmlerror' value='510' type='xmlParserErrors' info='510'/>
    <enum name='XML_DTD_ENTITY_TYPE' file='xmlerror' value='511' type='xmlParserErrors' info='511'/>
    <enum name='XML_DTD_ID_FIXED' file='xmlerror' value='512' type='xmlParserErrors' info='512'/>
    <enum name='XML_DTD_ID_REDEFINED' file='xmlerror' value='513' type='xmlParserErrors' info='513'/>
    <enum name='XML_DTD_ID_SUBSET' file='xmlerror' value='514' type='xmlParserErrors' info='514'/>
    <enum name='XML_DTD_INVALID_CHILD' file='xmlerror' value='515' type='xmlParserErrors' info='515'/>
    <enum name='XML_DTD_INVALID_DEFAULT' file='xmlerror' value='516' type='xmlParserErrors' info='516'/>
    <enum name='XML_DTD_LOAD_ERROR' file='xmlerror' value='517' type='xmlParserErrors' info='517'/>
    <enum name='XML_DTD_MISSING_ATTRIBUTE' file='xmlerror' value='518' type='xmlParserErrors' info='518'/>
    <enum name='XML_DTD_MIXED_CORRUPT' file='xmlerror' value='519' type='xmlParserErrors' info='519'/>
    <enum name='XML_DTD_MULTIPLE_ID' file='xmlerror' value='520' type='xmlParserErrors' info='520'/>
    <enum name='XML_DTD_NODE' file='tree' value='14' type='xmlElementType'/>
    <enum name='XML_DTD_NOTATION_REDEFINED' file='xmlerror' value='526' type='xmlParserErrors' info='526'/>
    <enum name='XML_DTD_NOTATION_VALUE' file='xmlerror' value='527' type='xmlParserErrors' info='527'/>
    <enum name='XML_DTD_NOT_EMPTY' file='xmlerror' value='528' type='xmlParserErrors' info='528'/>
    <enum name='XML_DTD_NOT_PCDATA' file='xmlerror' value='529' type='xmlParserErrors' info='529'/>
    <enum name='XML_DTD_NOT_STANDALONE' file='xmlerror' value='530' type='xmlParserErrors' info='530'/>
    <enum name='XML_DTD_NO_DOC' file='xmlerror' value='521' type='xmlParserErrors' info='521'/>
    <enum name='XML_DTD_NO_DTD' file='xmlerror' value='522' type='xmlParserErrors' info='522'/>
    <enum name='XML_DTD_NO_ELEM_NAME' file='xmlerror' value='523' type='xmlParserErrors' info='523'/>
    <enum name='XML_DTD_NO_PREFIX' file='xmlerror' value='524' type='xmlParserErrors' info='524'/>
    <enum name='XML_DTD_NO_ROOT' file='xmlerror' value='525' type='xmlParserErrors' info='525'/>
    <enum name='XML_DTD_ROOT_NAME' file='xmlerror' value='531' type='xmlParserErrors' info='531'/>
    <enum name='XML_DTD_STANDALONE_DEFAULTED' file='xmlerror' value='538' type='xmlParserErrors' info='538'/>
    <enum name='XML_DTD_STANDALONE_WHITE_SPACE' file='xmlerror' value='532' type='xmlParserErrors' info='532'/>
    <enum name='XML_DTD_UNKNOWN_ATTRIBUTE' file='xmlerror' value='533' type='xmlParserErrors' info='533'/>
    <enum name='XML_DTD_UNKNOWN_ELEM' file='xmlerror' value='534' type='xmlParserErrors' info='534'/>
    <enum name='XML_DTD_UNKNOWN_ENTITY' file='xmlerror' value='535' type='xmlParserErrors' info='535'/>
    <enum name='XML_DTD_UNKNOWN_ID' file='xmlerror' value='536' type='xmlParserErrors' info='536'/>
    <enum name='XML_DTD_UNKNOWN_NOTATION' file='xmlerror' value='537' type='xmlParserErrors' info='537'/>
    <enum name='XML_DTD_XMLID_TYPE' file='xmlerror' value='540' type='xmlParserErrors' info='540'/>
    <enum name='XML_DTD_XMLID_VALUE' file='xmlerror' value='539' type='xmlParserErrors' info='539'/>
    <enum name='XML_ELEMENT_CONTENT_ELEMENT' file='tree' value='2' type='xmlElementContentType'/>
    <enum name='XML_ELEMENT_CONTENT_MULT' file='tree' value='3' type='xmlElementContentOccur'/>
    <enum name='XML_ELEMENT_CONTENT_ONCE' file='tree' value='1' type='xmlElementContentOccur'/>
    <enum name='XML_ELEMENT_CONTENT_OPT' file='tree' value='2' type='xmlElementContentOccur'/>
    <enum name='XML_ELEMENT_CONTENT_OR' file='tree' value='4' type='xmlElementContentType'/>
    <enum name='XML_ELEMENT_CONTENT_PCDATA' file='tree' value='1' type='xmlElementContentType'/>
    <enum name='XML_ELEMENT_CONTENT_PLUS' file='tree' value='4' type='xmlElementContentOccur'/>
    <enum name='XML_ELEMENT_CONTENT_SEQ' file='tree' value='3' type='xmlElementContentType'/>
    <enum name='XML_ELEMENT_DECL' file='tree' value='15' type='xmlElementType'/>
    <enum name='XML_ELEMENT_NODE' file='tree' value='1' type='xmlElementType'/>
    <enum name='XML_ELEMENT_TYPE_ANY' file='tree' value='2' type='xmlElementTypeVal'/>
    <enum name='XML_ELEMENT_TYPE_ELEMENT' file='tree' value='4' type='xmlElementTypeVal'/>
    <enum name='XML_ELEMENT_TYPE_EMPTY' file='tree' value='1' type='xmlElementTypeVal'/>
    <enum name='XML_ELEMENT_TYPE_MIXED' file='tree' value='3' type='xmlElementTypeVal'/>
    <enum name='XML_ELEMENT_TYPE_UNDEFINED' file='tree' value='0' type='xmlElementTypeVal'/>
    <enum name='XML_ENTITY_DECL' file='tree' value='17' type='xmlElementType'/>
    <enum name='XML_ENTITY_NODE' file='tree' value='6' type='xmlElementType'/>
    <enum name='XML_ENTITY_REF_NODE' file='tree' value='5' type='xmlElementType'/>
    <enum name='XML_ERR_ATTLIST_NOT_FINISHED' file='xmlerror' value='51' type='xmlParserErrors' info='51'/>
    <enum name='XML_ERR_ATTLIST_NOT_STARTED' file='xmlerror' value='50' type='xmlParserErrors' info='50'/>
    <enum name='XML_ERR_ATTRIBUTE_NOT_FINISHED' file='xmlerror' value='40' type='xmlParserErrors' info='40'/>
    <enum name='XML_ERR_ATTRIBUTE_NOT_STARTED' file='xmlerror' value='39' type='xmlParserErrors' info='39'/>
    <enum name='XML_ERR_ATTRIBUTE_REDEFINED' file='xmlerror' value='42' type='xmlParserErrors' info='42'/>
    <enum name='XML_ERR_ATTRIBUTE_WITHOUT_VALUE' file='xmlerror' value='41' type='xmlParserErrors' info='41'/>
    <enum name='XML_ERR_CDATA_NOT_FINISHED' file='xmlerror' value='63' type='xmlParserErrors' info='63'/>
    <enum name='XML_ERR_CHARREF_AT_EOF' file='xmlerror' value='10' type='xmlParserErrors' info='10'/>
    <enum name='XML_ERR_CHARREF_IN_DTD' file='xmlerror' value='13' type='xmlParserErrors' info='13'/>
    <enum name='XML_ERR_CHARREF_IN_EPILOG' file='xmlerror' value='12' type='xmlParserErrors' info='12'/>
    <enum name='XML_ERR_CHARREF_IN_PROLOG' file='xmlerror' value='11' type='xmlParserErrors' info='11'/>
    <enum name='XML_ERR_COMMENT_NOT_FINISHED' file='xmlerror' value='45' type='xmlParserErrors' info='45'/>
    <enum name='XML_ERR_CONDSEC_INVALID' file='xmlerror' value='83' type='xmlParserErrors' info='83'/>
    <enum name='XML_ERR_CONDSEC_INVALID_KEYWORD' file='xmlerror' value='95' type='xmlParserErrors' info='95'/>
    <enum name='XML_ERR_CONDSEC_NOT_FINISHED' file='xmlerror' value='59' type='xmlParserErrors' info='59'/>
    <enum name='XML_ERR_CONDSEC_NOT_STARTED' file='xmlerror' value='58' type='xmlParserErrors' info='58'/>
    <enum name='XML_ERR_DOCTYPE_NOT_FINISHED' file='xmlerror' value='61' type='xmlParserErrors' info='61'/>
    <enum name='XML_ERR_DOCUMENT_EMPTY' file='xmlerror' value='4' type='xmlParserErrors' info='4'/>
    <enum name='XML_ERR_DOCUMENT_END' file='xmlerror' value='5' type='xmlParserErrors' info='5'/>
    <enum name='XML_ERR_DOCUMENT_START' file='xmlerror' value='3' type='xmlParserErrors' info='3'/>
    <enum name='XML_ERR_ELEMCONTENT_NOT_FINISHED' file='xmlerror' value='55' type='xmlParserErrors' info='55'/>
    <enum name='XML_ERR_ELEMCONTENT_NOT_STARTED' file='xmlerror' value='54' type='xmlParserErrors' info='54'/>
    <enum name='XML_ERR_ENCODING_NAME' file='xmlerror' value='79' type='xmlParserErrors' info='79'/>
    <enum name='XML_ERR_ENTITYREF_AT_EOF' file='xmlerror' value='14' type='xmlParserErrors' info='14'/>
    <enum name='XML_ERR_ENTITYREF_IN_DTD' file='xmlerror' value='17' type='xmlParserErrors' info='17'/>
    <enum name='XML_ERR_ENTITYREF_IN_EPILOG' file='xmlerror' value='16' type='xmlParserErrors' info='16'/>
    <enum name='XML_ERR_ENTITYREF_IN_PROLOG' file='xmlerror' value='15' type='xmlParserErrors' info='15'/>
    <enum name='XML_ERR_ENTITYREF_NO_NAME' file='xmlerror' value='22' type='xmlParserErrors' info='22'/>
    <enum name='XML_ERR_ENTITYREF_SEMICOL_MISSING' file='xmlerror' value='23' type='xmlParserErrors' info='23'/>
    <enum name='XML_ERR_ENTITY_BOUNDARY' file='xmlerror' value='90' type='xmlParserErrors' info='90'/>
    <enum name='XML_ERR_ENTITY_CHAR_ERROR' file='xmlerror' value='87' type='xmlParserErrors' info='87'/>
    <enum name='XML_ERR_ENTITY_IS_EXTERNAL' file='xmlerror' value='29' type='xmlParserErrors' info='29'/>
    <enum name='XML_ERR_ENTITY_IS_PARAMETER' file='xmlerror' value='30' type='xmlParserErrors' info='30'/>
    <enum name='XML_ERR_ENTITY_LOOP' file='xmlerror' value='89' type='xmlParserErrors' info='89'/>
    <enum name='XML_ERR_ENTITY_NOT_FINISHED' file='xmlerror' value='37' type='xmlParserErrors' info='37'/>
    <enum name='XML_ERR_ENTITY_NOT_STARTED' file='xmlerror' value='36' type='xmlParserErrors' info='36'/>
    <enum name='XML_ERR_ENTITY_PE_INTERNAL' file='xmlerror' value='88' type='xmlParserErrors' info='88'/>
    <enum name='XML_ERR_ENTITY_PROCESSING' file='xmlerror' value='104' type='xmlParserErrors' info='104'/>
    <enum name='XML_ERR_EQUAL_REQUIRED' file='xmlerror' value='75' type='xmlParserErrors' info='75'/>
    <enum name='XML_ERR_ERROR' file='xmlerror' value='2' type='xmlErrorLevel' info='A recoverable error'/>
    <enum name='XML_ERR_EXTRA_CONTENT' file='xmlerror' value='86' type='xmlParserErrors' info='86'/>
    <enum name='XML_ERR_EXT_ENTITY_STANDALONE' file='xmlerror' value='82' type='xmlParserErrors' info='82'/>
    <enum name='XML_ERR_EXT_SUBSET_NOT_FINISHED' file='xmlerror' value='60' type='xmlParserErrors' info='60'/>
    <enum name='XML_ERR_FATAL' file='xmlerror' value='3' type='xmlErrorLevel' info=' A fatal error'/>
    <enum name='XML_ERR_GT_REQUIRED' file='xmlerror' value='73' type='xmlParserErrors' info='73'/>
    <enum name='XML_ERR_HYPHEN_IN_COMMENT' file='xmlerror' value='80' type='xmlParserErrors' info='80'/>
    <enum name='XML_ERR_INTERNAL_ERROR' file='xmlerror' value='1' type='xmlParserErrors' info='1'/>
    <enum name='XML_ERR_INVALID_CHAR' file='xmlerror' value='9' type='xmlParserErrors' info='9'/>
    <enum name='XML_ERR_INVALID_CHARREF' file='xmlerror' value='8' type='xmlParserErrors' info='8'/>
    <enum name='XML_ERR_INVALID_DEC_CHARREF' file='xmlerror' value='7' type='xmlParserErrors' info='7'/>
    <enum name='XML_ERR_INVALID_ENCODING' file='xmlerror' value='81' type='xmlParserErrors' info='81'/>
    <enum name='XML_ERR_INVALID_HEX_CHARREF' file='xmlerror' value='6' type='xmlParserErrors' info='6'/>
    <enum name='XML_ERR_INVALID_URI' file='xmlerror' value='91' type='xmlParserErrors' info='91'/>
    <enum name='XML_ERR_LITERAL_NOT_FINISHED' file='xmlerror' value='44' type='xmlParserErrors' info='44'/>
    <enum name='XML_ERR_LITERAL_NOT_STARTED' file='xmlerror' value='43' type='xmlParserErrors' info='43'/>
    <enum name='XML_ERR_LTSLASH_REQUIRED' file='xmlerror' value='74' type='xmlParserErrors' info='74'/>
    <enum name='XML_ERR_LT_IN_ATTRIBUTE' file='xmlerror' value='38' type='xmlParserErrors' info='38'/>
    <enum name='XML_ERR_LT_REQUIRED' file='xmlerror' value='72' type='xmlParserErrors' info='72'/>
    <enum name='XML_ERR_MISPLACED_CDATA_END' file='xmlerror' value='62' type='xmlParserErrors' info='62'/>
    <enum name='XML_ERR_MISSING_ENCODING' file='xmlerror' value='101' type='xmlParserErrors' info='101'/>
    <enum name='XML_ERR_MIXED_NOT_FINISHED' file='xmlerror' value='53' type='xmlParserErrors' info='53'/>
    <enum name='XML_ERR_MIXED_NOT_STARTED' file='xmlerror' value='52' type='xmlParserErrors' info='52'/>
    <enum name='XML_ERR_NAME_REQUIRED' file='xmlerror' value='68' type='xmlParserErrors' info='68'/>
    <enum name='XML_ERR_NAME_TOO_LONG' file='xmlerror' value='110' type='xmlParserErrors' info='110'/>
    <enum name='XML_ERR_NMTOKEN_REQUIRED' file='xmlerror' value='67' type='xmlParserErrors' info='67'/>
    <enum name='XML_ERR_NONE' file='xmlerror' value='0' type='xmlErrorLevel'/>
    <enum name='XML_ERR_NOTATION_NOT_FINISHED' file='xmlerror' value='49' type='xmlParserErrors' info='49'/>
    <enum name='XML_ERR_NOTATION_NOT_STARTED' file='xmlerror' value='48' type='xmlParserErrors' info='48'/>
    <enum name='XML_ERR_NOTATION_PROCESSING' file='xmlerror' value='105' type='xmlParserErrors' info='105'/>
    <enum name='XML_ERR_NOT_STANDALONE' file='xmlerror' value='103' type='xmlParserErrors' info='103'/>
    <enum name='XML_ERR_NOT_WELL_BALANCED' file='xmlerror' value='85' type='xmlParserErrors' info='85'/>
    <enum name='XML_ERR_NO_DTD' file='xmlerror' value='94' type='xmlParserErrors' info='94'/>
    <enum name='XML_ERR_NO_MEMORY' file='xmlerror' value='2' type='xmlParserErrors' info='2'/>
    <enum name='XML_ERR_NS_DECL_ERROR' file='xmlerror' value='35' type='xmlParserErrors' info='35'/>
    <enum name='XML_ERR_OK' file='xmlerror' value='0' type='xmlParserErrors'/>
    <enum name='XML_ERR_PCDATA_REQUIRED' file='xmlerror' value='69' type='xmlParserErrors' info='69'/>
    <enum name='XML_ERR_PEREF_AT_EOF' file='xmlerror' value='18' type='xmlParserErrors' info='18'/>
    <enum name='XML_ERR_PEREF_IN_EPILOG' file='xmlerror' value='20' type='xmlParserErrors' info='20'/>
    <enum name='XML_ERR_PEREF_IN_INT_SUBSET' file='xmlerror' value='21' type='xmlParserErrors' info='21'/>
    <enum name='XML_ERR_PEREF_IN_PROLOG' file='xmlerror' value='19' type='xmlParserErrors' info='19'/>
    <enum name='XML_ERR_PEREF_NO_NAME' file='xmlerror' value='24' type='xmlParserErrors' info='24'/>
    <enum name='XML_ERR_PEREF_SEMICOL_MISSING' file='xmlerror' value='25' type='xmlParserErrors' info='25'/>
    <enum name='XML_ERR_PI_NOT_FINISHED' file='xmlerror' value='47' type='xmlParserErrors' info='47'/>
    <enum name='XML_ERR_PI_NOT_STARTED' file='xmlerror' value='46' type='xmlParserErrors' info='46'/>
    <enum name='XML_ERR_PUBID_REQUIRED' file='xmlerror' value='71' type='xmlParserErrors' info='71'/>
    <enum name='XML_ERR_RESERVED_XML_NAME' file='xmlerror' value='64' type='xmlParserErrors' info='64'/>
    <enum name='XML_ERR_SEPARATOR_REQUIRED' file='xmlerror' value='66' type='xmlParserErrors' info='66'/>
    <enum name='XML_ERR_SPACE_REQUIRED' file='xmlerror' value='65' type='xmlParserErrors' info='65'/>
    <enum name='XML_ERR_STANDALONE_VALUE' file='xmlerror' value='78' type='xmlParserErrors' info='78'/>
    <enum name='XML_ERR_STRING_NOT_CLOSED' file='xmlerror' value='34' type='xmlParserErrors' info='34'/>
    <enum name='XML_ERR_STRING_NOT_STARTED' file='xmlerror' value='33' type='xmlParserErrors' info='33'/>
    <enum name='XML_ERR_TAG_NAME_MISMATCH' file='xmlerror' value='76' type='xmlParserErrors' info='76'/>
    <enum name='XML_ERR_TAG_NOT_FINISHED' file='xmlerror' value='77' type='xmlParserErrors' info='77'/>
    <enum name='XML_ERR_UNDECLARED_ENTITY' file='xmlerror' value='26' type='xmlParserErrors' info='26'/>
    <enum name='XML_ERR_UNKNOWN_ENCODING' file='xmlerror' value='31' type='xmlParserErrors' info='31'/>
    <enum name='XML_ERR_UNKNOWN_VERSION' file='xmlerror' value='108' type='xmlParserErrors' info='108'/>
    <enum name='XML_ERR_UNPARSED_ENTITY' file='xmlerror' value='28' type='xmlParserErrors' info='28'/>
    <enum name='XML_ERR_UNSUPPORTED_ENCODING' file='xmlerror' value='32' type='xmlParserErrors' info='32'/>
    <enum name='XML_ERR_URI_FRAGMENT' file='xmlerror' value='92' type='xmlParserErrors' info='92'/>
    <enum name='XML_ERR_URI_REQUIRED' file='xmlerror' value='70' type='xmlParserErrors' info='70'/>
    <enum name='XML_ERR_USER_STOP' file='xmlerror' value='111' type='xmlParserErrors' info='111'/>
    <enum name='XML_ERR_VALUE_REQUIRED' file='xmlerror' value='84' type='xmlParserErrors' info='84'/>
    <enum name='XML_ERR_VERSION_MISMATCH' file='xmlerror' value='109' type='xmlParserErrors' info='109'/>
    <enum name='XML_ERR_VERSION_MISSING' file='xmlerror' value='96' type='xmlParserErrors' info='96'/>
    <enum name='XML_ERR_WARNING' file='xmlerror' value='1' type='xmlErrorLevel' info='A simple warning'/>
    <enum name='XML_ERR_XMLDECL_NOT_FINISHED' file='xmlerror' value='57' type='xmlParserErrors' info='57'/>
    <enum name='XML_ERR_XMLDECL_NOT_STARTED' file='xmlerror' value='56' type='xmlParserErrors' info='56'/>
    <enum name='XML_EXP_ATOM' file='xmlregexp' value='2' type='xmlExpNodeType'/>
    <enum name='XML_EXP_COUNT' file='xmlregexp' value='5' type='xmlExpNodeType'/>
    <enum name='XML_EXP_EMPTY' file='xmlregexp' value='0' type='xmlExpNodeType'/>
    <enum name='XML_EXP_FORBID' file='xmlregexp' value='1' type='xmlExpNodeType'/>
    <enum name='XML_EXP_OR' file='xmlregexp' value='4' type='xmlExpNodeType'/>
    <enum name='XML_EXP_SEQ' file='xmlregexp' value='3' type='xmlExpNodeType'/>
    <enum name='XML_EXTERNAL_GENERAL_PARSED_ENTITY' file='entities' value='2' type='xmlEntityType'/>
    <enum name='XML_EXTERNAL_GENERAL_UNPARSED_ENTITY' file='entities' value='3' type='xmlEntityType'/>
    <enum name='XML_EXTERNAL_PARAMETER_ENTITY' file='entities' value='5' type='xmlEntityType'/>
    <enum name='XML_FROM_BUFFER' file='xmlerror' value='29' type='xmlErrorDomain' info='The buffers module'/>
    <enum name='XML_FROM_C14N' file='xmlerror' value='21' type='xmlErrorDomain' info='The Canonicalization module'/>
    <enum name='XML_FROM_CATALOG' file='xmlerror' value='20' type='xmlErrorDomain' info='The Catalog module'/>
    <enum name='XML_FROM_CHECK' file='xmlerror' value='24' type='xmlErrorDomain' info='The error checking module'/>
    <enum name='XML_FROM_DATATYPE' file='xmlerror' value='15' type='xmlErrorDomain' info='The W3C XML Schemas Datatype module'/>
    <enum name='XML_FROM_DTD' file='xmlerror' value='4' type='xmlErrorDomain' info='The XML DTD validation with parser contex'/>
    <enum name='XML_FROM_FTP' file='xmlerror' value='9' type='xmlErrorDomain' info='The FTP module'/>
    <enum name='XML_FROM_HTML' file='xmlerror' value='5' type='xmlErrorDomain' info='The HTML parser'/>
    <enum name='XML_FROM_HTTP' file='xmlerror' value='10' type='xmlErrorDomain' info='The HTTP module'/>
    <enum name='XML_FROM_I18N' file='xmlerror' value='27' type='xmlErrorDomain' info='The module handling character conversion'/>
    <enum name='XML_FROM_IO' file='xmlerror' value='8' type='xmlErrorDomain' info='The Input/Output stack'/>
    <enum name='XML_FROM_MEMORY' file='xmlerror' value='6' type='xmlErrorDomain' info='The memory allocator'/>
    <enum name='XML_FROM_MODULE' file='xmlerror' value='26' type='xmlErrorDomain' info='The dynamically loaded module modul'/>
    <enum name='XML_FROM_NAMESPACE' file='xmlerror' value='3' type='xmlErrorDomain' info='The XML Namespace module'/>
    <enum name='XML_FROM_NONE' file='xmlerror' value='0' type='xmlErrorDomain'/>
    <enum name='XML_FROM_OUTPUT' file='xmlerror' value='7' type='xmlErrorDomain' info='The serialization code'/>
    <enum name='XML_FROM_PARSER' file='xmlerror' value='1' type='xmlErrorDomain' info='The XML parser'/>
    <enum name='XML_FROM_REGEXP' file='xmlerror' value='14' type='xmlErrorDomain' info='The regular expressions module'/>
    <enum name='XML_FROM_RELAXNGP' file='xmlerror' value='18' type='xmlErrorDomain' info='The Relax-NG parser module'/>
    <enum name='XML_FROM_RELAXNGV' file='xmlerror' value='19' type='xmlErrorDomain' info='The Relax-NG validator module'/>
    <enum name='XML_FROM_SCHEMASP' file='xmlerror' value='16' type='xmlErrorDomain' info='The W3C XML Schemas parser module'/>
    <enum name='XML_FROM_SCHEMASV' file='xmlerror' value='17' type='xmlErrorDomain' info='The W3C XML Schemas validation module'/>
    <enum name='XML_FROM_SCHEMATRONV' file='xmlerror' value='28' type='xmlErrorDomain' info='The Schematron validator module'/>
    <enum name='XML_FROM_TREE' file='xmlerror' value='2' type='xmlErrorDomain' info='The tree module'/>
    <enum name='XML_FROM_URI' file='xmlerror' value='30' type='xmlErrorDomain' info=' The URI module'/>
    <enum name='XML_FROM_VALID' file='xmlerror' value='23' type='xmlErrorDomain' info='The XML DTD validation with valid context'/>
    <enum name='XML_FROM_WRITER' file='xmlerror' value='25' type='xmlErrorDomain' info='The xmlwriter module'/>
    <enum name='XML_FROM_XINCLUDE' file='xmlerror' value='11' type='xmlErrorDomain' info='The XInclude processing'/>
    <enum name='XML_FROM_XPATH' file='xmlerror' value='12' type='xmlErrorDomain' info='The XPath module'/>
    <enum name='XML_FROM_XPOINTER' file='xmlerror' value='13' type='xmlErrorDomain' info='The XPointer module'/>
    <enum name='XML_FROM_XSLT' file='xmlerror' value='22' type='xmlErrorDomain' info='The XSLT engine from libxslt'/>
    <enum name='XML_FTP_ACCNT' file='xmlerror' value='2002' type='xmlParserErrors' info='2002'/>
    <enum name='XML_FTP_EPSV_ANSWER' file='xmlerror' value='2001' type='xmlParserErrors' info='2001'/>
    <enum name='XML_FTP_PASV_ANSWER' file='xmlerror' value='2000' type='xmlParserErrors'/>
    <enum name='XML_FTP_URL_SYNTAX' file='xmlerror' value='2003' type='xmlParserErrors' info='2003'/>
    <enum name='XML_HTML_DOCUMENT_NODE' file='tree' value='13' type='xmlElementType'/>
    <enum name='XML_HTML_STRUCURE_ERROR' file='xmlerror' value='800' type='xmlParserErrors'/>
    <enum name='XML_HTML_UNKNOWN_TAG' file='xmlerror' value='801' type='xmlParserErrors' info='801'/>
    <enum name='XML_HTTP_UNKNOWN_HOST' file='xmlerror' value='2022' type='xmlParserErrors' info='2022'/>
    <enum name='XML_HTTP_URL_SYNTAX' file='xmlerror' value='2020' type='xmlParserErrors'/>
    <enum name='XML_HTTP_USE_IP' file='xmlerror' value='2021' type='xmlParserErrors' info='2021'/>
    <enum name='XML_I18N_CONV_FAILED' file='xmlerror' value='6003' type='xmlParserErrors' info='6003'/>
    <enum name='XML_I18N_EXCESS_HANDLER' file='xmlerror' value='6002' type='xmlParserErrors' info='6002'/>
    <enum name='XML_I18N_NO_HANDLER' file='xmlerror' value='6001' type='xmlParserErrors' info='6001'/>
    <enum name='XML_I18N_NO_NAME' file='xmlerror' value='6000' type='xmlParserErrors'/>
    <enum name='XML_I18N_NO_OUTPUT' file='xmlerror' value='6004' type='xmlParserErrors' info='6004'/>
    <enum name='XML_INTERNAL_GENERAL_ENTITY' file='entities' value='1' type='xmlEntityType'/>
    <enum name='XML_INTERNAL_PARAMETER_ENTITY' file='entities' value='4' type='xmlEntityType'/>
    <enum name='XML_INTERNAL_PREDEFINED_ENTITY' file='entities' value='6' type='xmlEntityType'/>
    <enum name='XML_IO_BUFFER_FULL' file='xmlerror' value='1548' type='xmlParserErrors' info='1548'/>
    <enum name='XML_IO_EACCES' file='xmlerror' value='1501' type='xmlParserErrors' info='1501'/>
    <enum name='XML_IO_EADDRINUSE' file='xmlerror' value='1554' type='xmlParserErrors' info='1554'/>
    <enum name='XML_IO_EAFNOSUPPORT' file='xmlerror' value='1556' type='xmlParserErrors' info='1556'/>
    <enum name='XML_IO_EAGAIN' file='xmlerror' value='1502' type='xmlParserErrors' info='1502'/>
    <enum name='XML_IO_EALREADY' file='xmlerror' value='1555' type='xmlParserErrors' info='1555'/>
    <enum name='XML_IO_EBADF' file='xmlerror' value='1503' type='xmlParserErrors' info='1503'/>
    <enum name='XML_IO_EBADMSG' file='xmlerror' value='1504' type='xmlParserErrors' info='1504'/>
    <enum name='XML_IO_EBUSY' file='xmlerror' value='1505' type='xmlParserErrors' info='1505'/>
    <enum name='XML_IO_ECANCELED' file='xmlerror' value='1506' type='xmlParserErrors' info='1506'/>
    <enum name='XML_IO_ECHILD' file='xmlerror' value='1507' type='xmlParserErrors' info='1507'/>
    <enum name='XML_IO_ECONNREFUSED' file='xmlerror' value='1552' type='xmlParserErrors' info='1552'/>
    <enum name='XML_IO_EDEADLK' file='xmlerror' value='1508' type='xmlParserErrors' info='1508'/>
    <enum name='XML_IO_EDOM' file='xmlerror' value='1509' type='xmlParserErrors' info='1509'/>
    <enum name='XML_IO_EEXIST' file='xmlerror' value='1510' type='xmlParserErrors' info='1510'/>
    <enum name='XML_IO_EFAULT' file='xmlerror' value='1511' type='xmlParserErrors' info='1511'/>
    <enum name='XML_IO_EFBIG' file='xmlerror' value='1512' type='xmlParserErrors' info='1512'/>
    <enum name='XML_IO_EINPROGRESS' file='xmlerror' value='1513' type='xmlParserErrors' info='1513'/>
    <enum name='XML_IO_EINTR' file='xmlerror' value='1514' type='xmlParserErrors' info='1514'/>
    <enum name='XML_IO_EINVAL' file='xmlerror' value='1515' type='xmlParserErrors' info='1515'/>
    <enum name='XML_IO_EIO' file='xmlerror' value='1516' type='xmlParserErrors' info='1516'/>
    <enum name='XML_IO_EISCONN' file='xmlerror' value='1551' type='xmlParserErrors' info='1551'/>
    <enum name='XML_IO_EISDIR' file='xmlerror' value='1517' type='xmlParserErrors' info='1517'/>
    <enum name='XML_IO_EMFILE' file='xmlerror' value='1518' type='xmlParserErrors' info='1518'/>
    <enum name='XML_IO_EMLINK' file='xmlerror' value='1519' type='xmlParserErrors' info='1519'/>
    <enum name='XML_IO_EMSGSIZE' file='xmlerror' value='1520' type='xmlParserErrors' info='1520'/>
    <enum name='XML_IO_ENAMETOOLONG' file='xmlerror' value='1521' type='xmlParserErrors' info='1521'/>
    <enum name='XML_IO_ENCODER' file='xmlerror' value='1544' type='xmlParserErrors' info='1544'/>
    <enum name='XML_IO_ENETUNREACH' file='xmlerror' value='1553' type='xmlParserErrors' info='1553'/>
    <enum name='XML_IO_ENFILE' file='xmlerror' value='1522' type='xmlParserErrors' info='1522'/>
    <enum name='XML_IO_ENODEV' file='xmlerror' value='1523' type='xmlParserErrors' info='1523'/>
    <enum name='XML_IO_ENOENT' file='xmlerror' value='1524' type='xmlParserErrors' info='1524'/>
    <enum name='XML_IO_ENOEXEC' file='xmlerror' value='1525' type='xmlParserErrors' info='1525'/>
    <enum name='XML_IO_ENOLCK' file='xmlerror' value='1526' type='xmlParserErrors' info='1526'/>
    <enum name='XML_IO_ENOMEM' file='xmlerror' value='1527' type='xmlParserErrors' info='1527'/>
    <enum name='XML_IO_ENOSPC' file='xmlerror' value='1528' type='xmlParserErrors' info='1528'/>
    <enum name='XML_IO_ENOSYS' file='xmlerror' value='1529' type='xmlParserErrors' info='1529'/>
    <enum name='XML_IO_ENOTDIR' file='xmlerror' value='1530' type='xmlParserErrors' info='1530'/>
    <enum name='XML_IO_ENOTEMPTY' file='xmlerror' value='1531' type='xmlParserErrors' info='1531'/>
    <enum name='XML_IO_ENOTSOCK' file='xmlerror' value='1550' type='xmlParserErrors' info='1550'/>
    <enum name='XML_IO_ENOTSUP' file='xmlerror' value='1532' type='xmlParserErrors' info='1532'/>
    <enum name='XML_IO_ENOTTY' file='xmlerror' value='1533' type='xmlParserErrors' info='1533'/>
    <enum name='XML_IO_ENXIO' file='xmlerror' value='1534' type='xmlParserErrors' info='1534'/>
    <enum name='XML_IO_EPERM' file='xmlerror' value='1535' type='xmlParserErrors' info='1535'/>
    <enum name='XML_IO_EPIPE' file='xmlerror' value='1536' type='xmlParserErrors' info='1536'/>
    <enum name='XML_IO_ERANGE' file='xmlerror' value='1537' type='xmlParserErrors' info='1537'/>
    <enum name='XML_IO_EROFS' file='xmlerror' value='1538' type='xmlParserErrors' info='1538'/>
    <enum name='XML_IO_ESPIPE' file='xmlerror' value='1539' type='xmlParserErrors' info='1539'/>
    <enum name='XML_IO_ESRCH' file='xmlerror' value='1540' type='xmlParserErrors' info='1540'/>
    <enum name='XML_IO_ETIMEDOUT' file='xmlerror' value='1541' type='xmlParserErrors' info='1541'/>
    <enum name='XML_IO_EXDEV' file='xmlerror' value='1542' type='xmlParserErrors' info='1542'/>
    <enum name='XML_IO_FLUSH' file='xmlerror' value='1545' type='xmlParserErrors' info='1545'/>
    <enum name='XML_IO_LOAD_ERROR' file='xmlerror' value='1549' type='xmlParserErrors' info='1549'/>
    <enum name='XML_IO_NETWORK_ATTEMPT' file='xmlerror' value='1543' type='xmlParserErrors' info='1543'/>
    <enum name='XML_IO_NO_INPUT' file='xmlerror' value='1547' type='xmlParserErrors' info='1547'/>
    <enum name='XML_IO_UNKNOWN' file='xmlerror' value='1500' type='xmlParserErrors'/>
    <enum name='XML_IO_WRITE' file='xmlerror' value='1546' type='xmlParserErrors' info='1546'/>
    <enum name='XML_MODULE_CLOSE' file='xmlerror' value='4901' type='xmlParserErrors' info='4901'/>
    <enum name='XML_MODULE_LAZY' file='xmlmodule' value='1' type='xmlModuleOption' info='lazy binding'/>
    <enum name='XML_MODULE_LOCAL' file='xmlmodule' value='2' type='xmlModuleOption' info=' local binding'/>
    <enum name='XML_MODULE_OPEN' file='xmlerror' value='4900' type='xmlParserErrors' info='4900'/>
    <enum name='XML_NAMESPACE_DECL' file='tree' value='18' type='xmlElementType'/>
    <enum name='XML_NOTATION_NODE' file='tree' value='12' type='xmlElementType'/>
    <enum name='XML_NS_ERR_ATTRIBUTE_REDEFINED' file='xmlerror' value='203' type='xmlParserErrors' info='203'/>
    <enum name='XML_NS_ERR_COLON' file='xmlerror' value='205' type='xmlParserErrors' info='205'/>
    <enum name='XML_NS_ERR_EMPTY' file='xmlerror' value='204' type='xmlParserErrors' info='204'/>
    <enum name='XML_NS_ERR_QNAME' file='xmlerror' value='202' type='xmlParserErrors' info='202'/>
    <enum name='XML_NS_ERR_UNDEFINED_NAMESPACE' file='xmlerror' value='201' type='xmlParserErrors' info='201'/>
    <enum name='XML_NS_ERR_XML_NAMESPACE' file='xmlerror' value='200' type='xmlParserErrors'/>
    <enum name='XML_PARSER_ATTRIBUTE_VALUE' file='parser' value='12' type='xmlParserInputState' info='within an attribute value'/>
    <enum name='XML_PARSER_CDATA_SECTION' file='parser' value='8' type='xmlParserInputState' info='within a CDATA section'/>
    <enum name='XML_PARSER_COMMENT' file='parser' value='5' type='xmlParserInputState' info='within a comment'/>
    <enum name='XML_PARSER_CONTENT' file='parser' value='7' type='xmlParserInputState' info='within the content'/>
    <enum name='XML_PARSER_DEFAULTATTRS' file='xmlreader' value='2' type='xmlParserProperties'/>
    <enum name='XML_PARSER_DTD' file='parser' value='3' type='xmlParserInputState' info='within some DTD content'/>
    <enum name='XML_PARSER_END_TAG' file='parser' value='9' type='xmlParserInputState' info='within a closing tag'/>
    <enum name='XML_PARSER_ENTITY_DECL' file='parser' value='10' type='xmlParserInputState' info='within an entity declaration'/>
    <enum name='XML_PARSER_ENTITY_VALUE' file='parser' value='11' type='xmlParserInputState' info='within an entity value in a decl'/>
    <enum name='XML_PARSER_EOF' file='parser' value='-1' type='xmlParserInputState' info='nothing is to be parsed'/>
    <enum name='XML_PARSER_EPILOG' file='parser' value='14' type='xmlParserInputState' info='the Misc* after the last end tag'/>
    <enum name='XML_PARSER_IGNORE' file='parser' value='15' type='xmlParserInputState' info='within an IGNORED section'/>
    <enum name='XML_PARSER_LOADDTD' file='xmlreader' value='1' type='xmlParserProperties'/>
    <enum name='XML_PARSER_MISC' file='parser' value='1' type='xmlParserInputState' info='Misc* before int subset'/>
    <enum name='XML_PARSER_PI' file='parser' value='2' type='xmlParserInputState' info='Within a processing instruction'/>
    <enum name='XML_PARSER_PROLOG' file='parser' value='4' type='xmlParserInputState' info='Misc* after internal subset'/>
    <enum name='XML_PARSER_PUBLIC_LITERAL' file='parser' value='16' type='xmlParserInputState' info=' within a PUBLIC value'/>
    <enum name='XML_PARSER_SEVERITY_ERROR' file='xmlreader' value='4' type='xmlParserSeverities'/>
    <enum name='XML_PARSER_SEVERITY_VALIDITY_ERROR' file='xmlreader' value='2' type='xmlParserSeverities'/>
    <enum name='XML_PARSER_SEVERITY_VALIDITY_WARNING' file='xmlreader' value='1' type='xmlParserSeverities'/>
    <enum name='XML_PARSER_SEVERITY_WARNING' file='xmlreader' value='3' type='xmlParserSeverities'/>
    <enum name='XML_PARSER_START' file='parser' value='0' type='xmlParserInputState' info='nothing has been parsed'/>
    <enum name='XML_PARSER_START_TAG' file='parser' value='6' type='xmlParserInputState' info='within a start tag'/>
    <enum name='XML_PARSER_SUBST_ENTITIES' file='xmlreader' value='4' type='xmlParserProperties'/>
    <enum name='XML_PARSER_SYSTEM_LITERAL' file='parser' value='13' type='xmlParserInputState' info='within a SYSTEM value'/>
    <enum name='XML_PARSER_VALIDATE' file='xmlreader' value='3' type='xmlParserProperties'/>
    <enum name='XML_PARSE_BIG_LINES' file='parser' value='4194304' type='xmlParserOption' info=' Store big lines numbers in text PSVI field'/>
    <enum name='XML_PARSE_COMPACT' file='parser' value='65536' type='xmlParserOption' info='compact small text nodes; no modification of
the tree allowed afterwards (will possibly
crash if you try to modify the tree)'/>
    <enum name='XML_PARSE_DOM' file='parser' value='1' type='xmlParserMode'/>
    <enum name='XML_PARSE_DTDATTR' file='parser' value='8' type='xmlParserOption' info='default DTD attributes'/>
    <enum name='XML_PARSE_DTDLOAD' file='parser' value='4' type='xmlParserOption' info='load the external subset'/>
    <enum name='XML_PARSE_DTDVALID' file='parser' value='16' type='xmlParserOption' info='validate with the DTD'/>
    <enum name='XML_PARSE_HUGE' file='parser' value='524288' type='xmlParserOption' info='relax any hardcoded limit from the parser'/>
    <enum name='XML_PARSE_IGNORE_ENC' file='parser' value='2097152' type='xmlParserOption' info='ignore internal document encoding hint'/>
    <enum name='XML_PARSE_NOBASEFIX' file='parser' value='262144' type='xmlParserOption' info='do not fixup XINCLUDE xml:base uris'/>
    <enum name='XML_PARSE_NOBLANKS' file='parser' value='256' type='xmlParserOption' info='remove blank nodes'/>
    <enum name='XML_PARSE_NOCDATA' file='parser' value='16384' type='xmlParserOption' info='merge CDATA as text nodes'/>
    <enum name='XML_PARSE_NODICT' file='parser' value='4096' type='xmlParserOption' info='Do not reuse the context dictionnary'/>
    <enum name='XML_PARSE_NOENT' file='parser' value='2' type='xmlParserOption' info='substitute entities'/>
    <enum name='XML_PARSE_NOERROR' file='parser' value='32' type='xmlParserOption' info='suppress error reports'/>
    <enum name='XML_PARSE_NONET' file='parser' value='2048' type='xmlParserOption' info='Forbid network access'/>
    <enum name='XML_PARSE_NOWARNING' file='parser' value='64' type='xmlParserOption' info='suppress warning reports'/>
    <enum name='XML_PARSE_NOXINCNODE' file='parser' value='32768' type='xmlParserOption' info='do not generate XINCLUDE START/END nodes'/>
    <enum name='XML_PARSE_NSCLEAN' file='parser' value='8192' type='xmlParserOption' info='remove redundant namespaces declarations'/>
    <enum name='XML_PARSE_OLD10' file='parser' value='131072' type='xmlParserOption' info='parse using XML-1.0 before update 5'/>
    <enum name='XML_PARSE_OLDSAX' file='parser' value='1048576' type='xmlParserOption' info='parse using SAX2 interface before 2.7.0'/>
    <enum name='XML_PARSE_PEDANTIC' file='parser' value='128' type='xmlParserOption' info='pedantic error reporting'/>
    <enum name='XML_PARSE_PUSH_DOM' file='parser' value='3' type='xmlParserMode'/>
    <enum name='XML_PARSE_PUSH_SAX' file='parser' value='4' type='xmlParserMode'/>
    <enum name='XML_PARSE_READER' file='parser' value='5' type='xmlParserMode'/>
    <enum name='XML_PARSE_RECOVER' file='parser' value='1' type='xmlParserOption' info='recover on errors'/>
    <enum name='XML_PARSE_SAX' file='parser' value='2' type='xmlParserMode'/>
    <enum name='XML_PARSE_SAX1' file='parser' value='512' type='xmlParserOption' info='use the SAX1 interface internally'/>
    <enum name='XML_PARSE_UNKNOWN' file='parser' value='0' type='xmlParserMode'/>
    <enum name='XML_PARSE_XINCLUDE' file='parser' value='1024' type='xmlParserOption' info='Implement XInclude substitition'/>
    <enum name='XML_PATTERN_DEFAULT' file='pattern' value='0' type='xmlPatternFlags' info='simple pattern match'/>
    <enum name='XML_PATTERN_XPATH' file='pattern' value='1' type='xmlPatternFlags' info='standard XPath pattern'/>
    <enum name='XML_PATTERN_XSFIELD' file='pattern' value='4' type='xmlPatternFlags' info=' XPath subset for schema field'/>
    <enum name='XML_PATTERN_XSSEL' file='pattern' value='2' type='xmlPatternFlags' info='XPath subset for schema selector'/>
    <enum name='XML_PI_NODE' file='tree' value='7' type='xmlElementType'/>
    <enum name='XML_READER_TYPE_ATTRIBUTE' file='xmlreader' value='2' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_CDATA' file='xmlreader' value='4' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_COMMENT' file='xmlreader' value='8' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_DOCUMENT' file='xmlreader' value='9' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_DOCUMENT_FRAGMENT' file='xmlreader' value='11' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_DOCUMENT_TYPE' file='xmlreader' value='10' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_ELEMENT' file='xmlreader' value='1' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_END_ELEMENT' file='xmlreader' value='15' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_END_ENTITY' file='xmlreader' value='16' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_ENTITY' file='xmlreader' value='6' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_ENTITY_REFERENCE' file='xmlreader' value='5' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_NONE' file='xmlreader' value='0' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_NOTATION' file='xmlreader' value='12' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_PROCESSING_INSTRUCTION' file='xmlreader' value='7' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_SIGNIFICANT_WHITESPACE' file='xmlreader' value='14' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_TEXT' file='xmlreader' value='3' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_WHITESPACE' file='xmlreader' value='13' type='xmlReaderTypes'/>
    <enum name='XML_READER_TYPE_XML_DECLARATION' file='xmlreader' value='17' type='xmlReaderTypes'/>
    <enum name='XML_REGEXP_COMPILE_ERROR' file='xmlerror' value='1450' type='xmlParserErrors'/>
    <enum name='XML_RELAXNGP_CRNG' file='relaxng' value='2' type='xmlRelaxNGParserFlag'/>
    <enum name='XML_RELAXNGP_FREE_DOC' file='relaxng' value='1' type='xmlRelaxNGParserFlag'/>
    <enum name='XML_RELAXNGP_NONE' file='relaxng' value='0' type='xmlRelaxNGParserFlag'/>
    <enum name='XML_RELAXNG_ERR_ATTREXTRANS' file='relaxng' value='20' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ATTRNAME' file='relaxng' value='14' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ATTRNONS' file='relaxng' value='16' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ATTRVALID' file='relaxng' value='24' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ATTRWRONGNS' file='relaxng' value='18' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_CONTENTVALID' file='relaxng' value='25' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_DATAELEM' file='relaxng' value='28' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_DATATYPE' file='relaxng' value='31' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_DUPID' file='relaxng' value='4' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMEXTRANS' file='relaxng' value='19' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMNAME' file='relaxng' value='13' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMNONS' file='relaxng' value='15' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMNOTEMPTY' file='relaxng' value='21' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMWRONG' file='relaxng' value='38' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_ELEMWRONGNS' file='relaxng' value='17' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_EXTRACONTENT' file='relaxng' value='26' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_EXTRADATA' file='relaxng' value='35' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_INTEREXTRA' file='relaxng' value='12' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_INTERNAL' file='relaxng' value='37' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_INTERNODATA' file='relaxng' value='10' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_INTERSEQ' file='relaxng' value='11' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_INVALIDATTR' file='relaxng' value='27' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_LACKDATA' file='relaxng' value='36' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_LIST' file='relaxng' value='33' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_LISTELEM' file='relaxng' value='30' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_LISTEMPTY' file='relaxng' value='9' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_LISTEXTRA' file='relaxng' value='8' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_MEMORY' file='relaxng' value='1' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_NODEFINE' file='relaxng' value='7' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_NOELEM' file='relaxng' value='22' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_NOGRAMMAR' file='relaxng' value='34' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_NOSTATE' file='relaxng' value='6' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_NOTELEM' file='relaxng' value='23' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_TEXTWRONG' file='relaxng' value='39' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_TYPE' file='relaxng' value='2' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_TYPECMP' file='relaxng' value='5' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_TYPEVAL' file='relaxng' value='3' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_VALELEM' file='relaxng' value='29' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_ERR_VALUE' file='relaxng' value='32' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RELAXNG_OK' file='relaxng' value='0' type='xmlRelaxNGValidErr'/>
    <enum name='XML_RNGP_ANYNAME_ATTR_ANCESTOR' file='xmlerror' value='1000' type='xmlParserErrors'/>
    <enum name='XML_RNGP_ATTRIBUTE_CHILDREN' file='xmlerror' value='1002' type='xmlParserErrors' info='1002'/>
    <enum name='XML_RNGP_ATTRIBUTE_CONTENT' file='xmlerror' value='1003' type='xmlParserErrors' info='1003'/>
    <enum name='XML_RNGP_ATTRIBUTE_EMPTY' file='xmlerror' value='1004' type='xmlParserErrors' info='1004'/>
    <enum name='XML_RNGP_ATTRIBUTE_NOOP' file='xmlerror' value='1005' type='xmlParserErrors' info='1005'/>
    <enum name='XML_RNGP_ATTR_CONFLICT' file='xmlerror' value='1001' type='xmlParserErrors' info='1001'/>
    <enum name='XML_RNGP_CHOICE_CONTENT' file='xmlerror' value='1006' type='xmlParserErrors' info='1006'/>
    <enum name='XML_RNGP_CHOICE_EMPTY' file='xmlerror' value='1007' type='xmlParserErrors' info='1007'/>
    <enum name='XML_RNGP_CREATE_FAILURE' file='xmlerror' value='1008' type='xmlParserErrors' info='1008'/>
    <enum name='XML_RNGP_DATA_CONTENT' file='xmlerror' value='1009' type='xmlParserErrors' info='1009'/>
    <enum name='XML_RNGP_DEFINE_CREATE_FAILED' file='xmlerror' value='1011' type='xmlParserErrors' info='1011'/>
    <enum name='XML_RNGP_DEFINE_EMPTY' file='xmlerror' value='1012' type='xmlParserErrors' info='1012'/>
    <enum name='XML_RNGP_DEFINE_MISSING' file='xmlerror' value='1013' type='xmlParserErrors' info='1013'/>
    <enum name='XML_RNGP_DEFINE_NAME_MISSING' file='xmlerror' value='1014' type='xmlParserErrors' info='1014'/>
    <enum name='XML_RNGP_DEF_CHOICE_AND_INTERLEAVE' file='xmlerror' value='1010' type='xmlParserErrors' info='1010'/>
    <enum name='XML_RNGP_ELEMENT_CONTENT' file='xmlerror' value='1018' type='xmlParserErrors' info='1018'/>
    <enum name='XML_RNGP_ELEMENT_EMPTY' file='xmlerror' value='1017' type='xmlParserErrors' info='1017'/>
    <enum name='XML_RNGP_ELEMENT_NAME' file='xmlerror' value='1019' type='xmlParserErrors' info='1019'/>
    <enum name='XML_RNGP_ELEMENT_NO_CONTENT' file='xmlerror' value='1020' type='xmlParserErrors' info='1020'/>
    <enum name='XML_RNGP_ELEM_CONTENT_EMPTY' file='xmlerror' value='1015' type='xmlParserErrors' info='1015'/>
    <enum name='XML_RNGP_ELEM_CONTENT_ERROR' file='xmlerror' value='1016' type='xmlParserErrors' info='1016'/>
    <enum name='XML_RNGP_ELEM_TEXT_CONFLICT' file='xmlerror' value='1021' type='xmlParserErrors' info='1021'/>
    <enum name='XML_RNGP_EMPTY' file='xmlerror' value='1022' type='xmlParserErrors' info='1022'/>
    <enum name='XML_RNGP_EMPTY_CONSTRUCT' file='xmlerror' value='1023' type='xmlParserErrors' info='1023'/>
    <enum name='XML_RNGP_EMPTY_CONTENT' file='xmlerror' value='1024' type='xmlParserErrors' info='1024'/>
    <enum name='XML_RNGP_EMPTY_NOT_EMPTY' file='xmlerror' value='1025' type='xmlParserErrors' info='1025'/>
    <enum name='XML_RNGP_ERROR_TYPE_LIB' file='xmlerror' value='1026' type='xmlParserErrors' info='1026'/>
    <enum name='XML_RNGP_EXCEPT_EMPTY' file='xmlerror' value='1027' type='xmlParserErrors' info='1027'/>
    <enum name='XML_RNGP_EXCEPT_MISSING' file='xmlerror' value='1028' type='xmlParserErrors' info='1028'/>
    <enum name='XML_RNGP_EXCEPT_MULTIPLE' file='xmlerror' value='1029' type='xmlParserErrors' info='1029'/>
    <enum name='XML_RNGP_EXCEPT_NO_CONTENT' file='xmlerror' value='1030' type='xmlParserErrors' info='1030'/>
    <enum name='XML_RNGP_EXTERNALREF_EMTPY' file='xmlerror' value='1031' type='xmlParserErrors' info='1031'/>
    <enum name='XML_RNGP_EXTERNALREF_RECURSE' file='xmlerror' value='1033' type='xmlParserErrors' info='1033'/>
    <enum name='XML_RNGP_EXTERNAL_REF_FAILURE' file='xmlerror' value='1032' type='xmlParserErrors' info='1032'/>
    <enum name='XML_RNGP_FORBIDDEN_ATTRIBUTE' file='xmlerror' value='1034' type='xmlParserErrors' info='1034'/>
    <enum name='XML_RNGP_FOREIGN_ELEMENT' file='xmlerror' value='1035' type='xmlParserErrors' info='1035'/>
    <enum name='XML_RNGP_GRAMMAR_CONTENT' file='xmlerror' value='1036' type='xmlParserErrors' info='1036'/>
    <enum name='XML_RNGP_GRAMMAR_EMPTY' file='xmlerror' value='1037' type='xmlParserErrors' info='1037'/>
    <enum name='XML_RNGP_GRAMMAR_MISSING' file='xmlerror' value='1038' type='xmlParserErrors' info='1038'/>
    <enum name='XML_RNGP_GRAMMAR_NO_START' file='xmlerror' value='1039' type='xmlParserErrors' info='1039'/>
    <enum name='XML_RNGP_GROUP_ATTR_CONFLICT' file='xmlerror' value='1040' type='xmlParserErrors' info='1040'/>
    <enum name='XML_RNGP_HREF_ERROR' file='xmlerror' value='1041' type='xmlParserErrors' info='1041'/>
    <enum name='XML_RNGP_INCLUDE_EMPTY' file='xmlerror' value='1042' type='xmlParserErrors' info='1042'/>
    <enum name='XML_RNGP_INCLUDE_FAILURE' file='xmlerror' value='1043' type='xmlParserErrors' info='1043'/>
    <enum name='XML_RNGP_INCLUDE_RECURSE' file='xmlerror' value='1044' type='xmlParserErrors' info='1044'/>
    <enum name='XML_RNGP_INTERLEAVE_ADD' file='xmlerror' value='1045' type='xmlParserErrors' info='1045'/>
    <enum name='XML_RNGP_INTERLEAVE_CREATE_FAILED' file='xmlerror' value='1046' type='xmlParserErrors' info='1046'/>
    <enum name='XML_RNGP_INTERLEAVE_EMPTY' file='xmlerror' value='1047' type='xmlParserErrors' info='1047'/>
    <enum name='XML_RNGP_INTERLEAVE_NO_CONTENT' file='xmlerror' value='1048' type='xmlParserErrors' info='1048'/>
    <enum name='XML_RNGP_INVALID_DEFINE_NAME' file='xmlerror' value='1049' type='xmlParserErrors' info='1049'/>
    <enum name='XML_RNGP_INVALID_URI' file='xmlerror' value='1050' type='xmlParserErrors' info='1050'/>
    <enum name='XML_RNGP_INVALID_VALUE' file='xmlerror' value='1051' type='xmlParserErrors' info='1051'/>
    <enum name='XML_RNGP_MISSING_HREF' file='xmlerror' value='1052' type='xmlParserErrors' info='1052'/>
    <enum name='XML_RNGP_NAME_MISSING' file='xmlerror' value='1053' type='xmlParserErrors' info='1053'/>
    <enum name='XML_RNGP_NEED_COMBINE' file='xmlerror' value='1054' type='xmlParserErrors' info='1054'/>
    <enum name='XML_RNGP_NOTALLOWED_NOT_EMPTY' file='xmlerror' value='1055' type='xmlParserErrors' info='1055'/>
    <enum name='XML_RNGP_NSNAME_ATTR_ANCESTOR' file='xmlerror' value='1056' type='xmlParserErrors' info='1056'/>
    <enum name='XML_RNGP_NSNAME_NO_NS' file='xmlerror' value='1057' type='xmlParserErrors' info='1057'/>
    <enum name='XML_RNGP_PARAM_FORBIDDEN' file='xmlerror' value='1058' type='xmlParserErrors' info='1058'/>
    <enum name='XML_RNGP_PARAM_NAME_MISSING' file='xmlerror' value='1059' type='xmlParserErrors' info='1059'/>
    <enum name='XML_RNGP_PARENTREF_CREATE_FAILED' file='xmlerror' value='1060' type='xmlParserErrors' info='1060'/>
    <enum name='XML_RNGP_PARENTREF_NAME_INVALID' file='xmlerror' value='1061' type='xmlParserErrors' info='1061'/>
    <enum name='XML_RNGP_PARENTREF_NOT_EMPTY' file='xmlerror' value='1064' type='xmlParserErrors' info='1064'/>
    <enum name='XML_RNGP_PARENTREF_NO_NAME' file='xmlerror' value='1062' type='xmlParserErrors' info='1062'/>
    <enum name='XML_RNGP_PARENTREF_NO_PARENT' file='xmlerror' value='1063' type='xmlParserErrors' info='1063'/>
    <enum name='XML_RNGP_PARSE_ERROR' file='xmlerror' value='1065' type='xmlParserErrors' info='1065'/>
    <enum name='XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME' file='xmlerror' value='1066' type='xmlParserErrors' info='1066'/>
    <enum name='XML_RNGP_PAT_ATTR_ATTR' file='xmlerror' value='1067' type='xmlParserErrors' info='1067'/>
    <enum name='XML_RNGP_PAT_ATTR_ELEM' file='xmlerror' value='1068' type='xmlParserErrors' info='1068'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_ATTR' file='xmlerror' value='1069' type='xmlParserErrors' info='1069'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_ELEM' file='xmlerror' value='1070' type='xmlParserErrors' info='1070'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_EMPTY' file='xmlerror' value='1071' type='xmlParserErrors' info='1071'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_GROUP' file='xmlerror' value='1072' type='xmlParserErrors' info='1072'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE' file='xmlerror' value='1073' type='xmlParserErrors' info='1073'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_LIST' file='xmlerror' value='1074' type='xmlParserErrors' info='1074'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_ONEMORE' file='xmlerror' value='1075' type='xmlParserErrors' info='1075'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_REF' file='xmlerror' value='1076' type='xmlParserErrors' info='1076'/>
    <enum name='XML_RNGP_PAT_DATA_EXCEPT_TEXT' file='xmlerror' value='1077' type='xmlParserErrors' info='1077'/>
    <enum name='XML_RNGP_PAT_LIST_ATTR' file='xmlerror' value='1078' type='xmlParserErrors' info='1078'/>
    <enum name='XML_RNGP_PAT_LIST_ELEM' file='xmlerror' value='1079' type='xmlParserErrors' info='1079'/>
    <enum name='XML_RNGP_PAT_LIST_INTERLEAVE' file='xmlerror' value='1080' type='xmlParserErrors' info='1080'/>
    <enum name='XML_RNGP_PAT_LIST_LIST' file='xmlerror' value='1081' type='xmlParserErrors' info='1081'/>
    <enum name='XML_RNGP_PAT_LIST_REF' file='xmlerror' value='1082' type='xmlParserErrors' info='1082'/>
    <enum name='XML_RNGP_PAT_LIST_TEXT' file='xmlerror' value='1083' type='xmlParserErrors' info='1083'/>
    <enum name='XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME' file='xmlerror' value='1084' type='xmlParserErrors' info='1084'/>
    <enum name='XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME' file='xmlerror' value='1085' type='xmlParserErrors' info='1085'/>
    <enum name='XML_RNGP_PAT_ONEMORE_GROUP_ATTR' file='xmlerror' value='1086' type='xmlParserErrors' info='1086'/>
    <enum name='XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR' file='xmlerror' value='1087' type='xmlParserErrors' info='1087'/>
    <enum name='XML_RNGP_PAT_START_ATTR' file='xmlerror' value='1088' type='xmlParserErrors' info='1088'/>
    <enum name='XML_RNGP_PAT_START_DATA' file='xmlerror' value='1089' type='xmlParserErrors' info='1089'/>
    <enum name='XML_RNGP_PAT_START_EMPTY' file='xmlerror' value='1090' type='xmlParserErrors' info='1090'/>
    <enum name='XML_RNGP_PAT_START_GROUP' file='xmlerror' value='1091' type='xmlParserErrors' info='1091'/>
    <enum name='XML_RNGP_PAT_START_INTERLEAVE' file='xmlerror' value='1092' type='xmlParserErrors' info='1092'/>
    <enum name='XML_RNGP_PAT_START_LIST' file='xmlerror' value='1093' type='xmlParserErrors' info='1093'/>
    <enum name='XML_RNGP_PAT_START_ONEMORE' file='xmlerror' value='1094' type='xmlParserErrors' info='1094'/>
    <enum name='XML_RNGP_PAT_START_TEXT' file='xmlerror' value='1095' type='xmlParserErrors' info='1095'/>
    <enum name='XML_RNGP_PAT_START_VALUE' file='xmlerror' value='1096' type='xmlParserErrors' info='1096'/>
    <enum name='XML_RNGP_PREFIX_UNDEFINED' file='xmlerror' value='1097' type='xmlParserErrors' info='1097'/>
    <enum name='XML_RNGP_REF_CREATE_FAILED' file='xmlerror' value='1098' type='xmlParserErrors' info='1098'/>
    <enum name='XML_RNGP_REF_CYCLE' file='xmlerror' value='1099' type='xmlParserErrors' info='1099'/>
    <enum name='XML_RNGP_REF_NAME_INVALID' file='xmlerror' value='1100' type='xmlParserErrors' info='1100'/>
    <enum name='XML_RNGP_REF_NOT_EMPTY' file='xmlerror' value='1103' type='xmlParserErrors' info='1103'/>
    <enum name='XML_RNGP_REF_NO_DEF' file='xmlerror' value='1101' type='xmlParserErrors' info='1101'/>
    <enum name='XML_RNGP_REF_NO_NAME' file='xmlerror' value='1102' type='xmlParserErrors' info='1102'/>
    <enum name='XML_RNGP_START_CHOICE_AND_INTERLEAVE' file='xmlerror' value='1104' type='xmlParserErrors' info='1104'/>
    <enum name='XML_RNGP_START_CONTENT' file='xmlerror' value='1105' type='xmlParserErrors' info='1105'/>
    <enum name='XML_RNGP_START_EMPTY' file='xmlerror' value='1106' type='xmlParserErrors' info='1106'/>
    <enum name='XML_RNGP_START_MISSING' file='xmlerror' value='1107' type='xmlParserErrors' info='1107'/>
    <enum name='XML_RNGP_TEXT_EXPECTED' file='xmlerror' value='1108' type='xmlParserErrors' info='1108'/>
    <enum name='XML_RNGP_TEXT_HAS_CHILD' file='xmlerror' value='1109' type='xmlParserErrors' info='1109'/>
    <enum name='XML_RNGP_TYPE_MISSING' file='xmlerror' value='1110' type='xmlParserErrors' info='1110'/>
    <enum name='XML_RNGP_TYPE_NOT_FOUND' file='xmlerror' value='1111' type='xmlParserErrors' info='1111'/>
    <enum name='XML_RNGP_TYPE_VALUE' file='xmlerror' value='1112' type='xmlParserErrors' info='1112'/>
    <enum name='XML_RNGP_UNKNOWN_ATTRIBUTE' file='xmlerror' value='1113' type='xmlParserErrors' info='1113'/>
    <enum name='XML_RNGP_UNKNOWN_COMBINE' file='xmlerror' value='1114' type='xmlParserErrors' info='1114'/>
    <enum name='XML_RNGP_UNKNOWN_CONSTRUCT' file='xmlerror' value='1115' type='xmlParserErrors' info='1115'/>
    <enum name='XML_RNGP_UNKNOWN_TYPE_LIB' file='xmlerror' value='1116' type='xmlParserErrors' info='1116'/>
    <enum name='XML_RNGP_URI_FRAGMENT' file='xmlerror' value='1117' type='xmlParserErrors' info='1117'/>
    <enum name='XML_RNGP_URI_NOT_ABSOLUTE' file='xmlerror' value='1118' type='xmlParserErrors' info='1118'/>
    <enum name='XML_RNGP_VALUE_EMPTY' file='xmlerror' value='1119' type='xmlParserErrors' info='1119'/>
    <enum name='XML_RNGP_VALUE_NO_CONTENT' file='xmlerror' value='1120' type='xmlParserErrors' info='1120'/>
    <enum name='XML_RNGP_XMLNS_NAME' file='xmlerror' value='1121' type='xmlParserErrors' info='1121'/>
    <enum name='XML_RNGP_XML_NS' file='xmlerror' value='1122' type='xmlParserErrors' info='1122'/>
    <enum name='XML_SAVE_AS_HTML' file='xmlsave' value='64' type='xmlSaveOption' info='force HTML serialization on XML doc'/>
    <enum name='XML_SAVE_AS_XML' file='xmlsave' value='32' type='xmlSaveOption' info='force XML serialization on HTML doc'/>
    <enum name='XML_SAVE_CHAR_INVALID' file='xmlerror' value='1401' type='xmlParserErrors' info='1401'/>
    <enum name='XML_SAVE_FORMAT' file='xmlsave' value='1' type='xmlSaveOption' info='format save output'/>
    <enum name='XML_SAVE_NOT_UTF8' file='xmlerror' value='1400' type='xmlParserErrors'/>
    <enum name='XML_SAVE_NO_DECL' file='xmlsave' value='2' type='xmlSaveOption' info='drop the xml declaration'/>
    <enum name='XML_SAVE_NO_DOCTYPE' file='xmlerror' value='1402' type='xmlParserErrors' info='1402'/>
    <enum name='XML_SAVE_NO_EMPTY' file='xmlsave' value='4' type='xmlSaveOption' info='no empty tags'/>
    <enum name='XML_SAVE_NO_XHTML' file='xmlsave' value='8' type='xmlSaveOption' info='disable XHTML1 specific rules'/>
    <enum name='XML_SAVE_UNKNOWN_ENCODING' file='xmlerror' value='1403' type='xmlParserErrors' info='1403'/>
    <enum name='XML_SAVE_WSNONSIG' file='xmlsave' value='128' type='xmlSaveOption' info=' format with non-significant whitespace'/>
    <enum name='XML_SAVE_XHTML' file='xmlsave' value='16' type='xmlSaveOption' info='force XHTML1 specific rules'/>
    <enum name='XML_SCHEMAP_AG_PROPS_CORRECT' file='xmlerror' value='3087' type='xmlParserErrors' info='3086'/>
    <enum name='XML_SCHEMAP_ATTRFORMDEFAULT_VALUE' file='xmlerror' value='1701' type='xmlParserErrors' info='1701'/>
    <enum name='XML_SCHEMAP_ATTRGRP_NONAME_NOREF' file='xmlerror' value='1702' type='xmlParserErrors' info='1702'/>
    <enum name='XML_SCHEMAP_ATTR_NONAME_NOREF' file='xmlerror' value='1703' type='xmlParserErrors' info='1703'/>
    <enum name='XML_SCHEMAP_AU_PROPS_CORRECT' file='xmlerror' value='3089' type='xmlParserErrors' info='3088'/>
    <enum name='XML_SCHEMAP_AU_PROPS_CORRECT_2' file='xmlerror' value='3078' type='xmlParserErrors' info='3078'/>
    <enum name='XML_SCHEMAP_A_PROPS_CORRECT_2' file='xmlerror' value='3079' type='xmlParserErrors' info='3079'/>
    <enum name='XML_SCHEMAP_A_PROPS_CORRECT_3' file='xmlerror' value='3090' type='xmlParserErrors' info='3089'/>
    <enum name='XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF' file='xmlerror' value='1704' type='xmlParserErrors' info='1704'/>
    <enum name='XML_SCHEMAP_COS_ALL_LIMITED' file='xmlerror' value='3091' type='xmlParserErrors' info='3090'/>
    <enum name='XML_SCHEMAP_COS_CT_EXTENDS_1_1' file='xmlerror' value='3063' type='xmlParserErrors' info='3063'/>
    <enum name='XML_SCHEMAP_COS_CT_EXTENDS_1_2' file='xmlerror' value='3088' type='xmlParserErrors' info='3087'/>
    <enum name='XML_SCHEMAP_COS_CT_EXTENDS_1_3' file='xmlerror' value='1800' type='xmlParserErrors' info='1800'/>
    <enum name='XML_SCHEMAP_COS_ST_DERIVED_OK_2_1' file='xmlerror' value='3031' type='xmlParserErrors' info='3031'/>
    <enum name='XML_SCHEMAP_COS_ST_DERIVED_OK_2_2' file='xmlerror' value='3032' type='xmlParserErrors' info='3032'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_1_1' file='xmlerror' value='3011' type='xmlParserErrors' info='3011'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_1_2' file='xmlerror' value='3012' type='xmlParserErrors' info='3012'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1' file='xmlerror' value='3013' type='xmlParserErrors' info='3013'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2' file='xmlerror' value='3014' type='xmlParserErrors' info='3014'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_1' file='xmlerror' value='3015' type='xmlParserErrors' info='3015'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1' file='xmlerror' value='3016' type='xmlParserErrors' info='3016'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2' file='xmlerror' value='3017' type='xmlParserErrors' info='3017'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1' file='xmlerror' value='3018' type='xmlParserErrors' info='3018'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2' file='xmlerror' value='3019' type='xmlParserErrors' info='3019'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3' file='xmlerror' value='3020' type='xmlParserErrors' info='3020'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4' file='xmlerror' value='3021' type='xmlParserErrors' info='3021'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5' file='xmlerror' value='3022' type='xmlParserErrors' info='3022'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_1' file='xmlerror' value='3023' type='xmlParserErrors' info='3023'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1' file='xmlerror' value='3024' type='xmlParserErrors' info='3024'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2' file='xmlerror' value='3025' type='xmlParserErrors' info='3025'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1' file='xmlerror' value='3027' type='xmlParserErrors' info='3027'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2' file='xmlerror' value='3026' type='xmlParserErrors' info='3026'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3' file='xmlerror' value='3028' type='xmlParserErrors' info='3028'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4' file='xmlerror' value='3029' type='xmlParserErrors' info='3029'/>
    <enum name='XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5' file='xmlerror' value='3030' type='xmlParserErrors' info='3030'/>
    <enum name='XML_SCHEMAP_COS_VALID_DEFAULT_1' file='xmlerror' value='3058' type='xmlParserErrors' info='3058'/>
    <enum name='XML_SCHEMAP_COS_VALID_DEFAULT_2_1' file='xmlerror' value='3059' type='xmlParserErrors' info='3059'/>
    <enum name='XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1' file='xmlerror' value='3060' type='xmlParserErrors' info='3060'/>
    <enum name='XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2' file='xmlerror' value='3061' type='xmlParserErrors' info='3061'/>
    <enum name='XML_SCHEMAP_CT_PROPS_CORRECT_1' file='xmlerror' value='1782' type='xmlParserErrors' info='1782'/>
    <enum name='XML_SCHEMAP_CT_PROPS_CORRECT_2' file='xmlerror' value='1783' type='xmlParserErrors' info='1783'/>
    <enum name='XML_SCHEMAP_CT_PROPS_CORRECT_3' file='xmlerror' value='1784' type='xmlParserErrors' info='1784'/>
    <enum name='XML_SCHEMAP_CT_PROPS_CORRECT_4' file='xmlerror' value='1785' type='xmlParserErrors' info='1785'/>
    <enum name='XML_SCHEMAP_CT_PROPS_CORRECT_5' file='xmlerror' value='1786' type='xmlParserErrors' info='1786'/>
    <enum name='XML_SCHEMAP_CVC_SIMPLE_TYPE' file='xmlerror' value='3062' type='xmlParserErrors' info='3062'/>
    <enum name='XML_SCHEMAP_C_PROPS_CORRECT' file='xmlerror' value='3080' type='xmlParserErrors' info='3080'/>
    <enum name='XML_SCHEMAP_DEF_AND_PREFIX' file='xmlerror' value='1768' type='xmlParserErrors' info='1768'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1' file='xmlerror' value='1787' type='xmlParserErrors' info='1787'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1' file='xmlerror' value='1788' type='xmlParserErrors' info='1788'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2' file='xmlerror' value='1789' type='xmlParserErrors' info='1789'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3' file='xmlerror' value='3077' type='xmlParserErrors' info='3077'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2' file='xmlerror' value='1790' type='xmlParserErrors' info='1790'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3' file='xmlerror' value='1791' type='xmlParserErrors' info='1791'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1' file='xmlerror' value='1797' type='xmlParserErrors' info='1797'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2' file='xmlerror' value='1798' type='xmlParserErrors' info='1798'/>
    <enum name='XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3' file='xmlerror' value='1799' type='xmlParserErrors' info='1799'/>
    <enum name='XML_SCHEMAP_ELEMFORMDEFAULT_VALUE' file='xmlerror' value='1705' type='xmlParserErrors' info='1705'/>
    <enum name='XML_SCHEMAP_ELEM_DEFAULT_FIXED' file='xmlerror' value='1755' type='xmlParserErrors' info='1755'/>
    <enum name='XML_SCHEMAP_ELEM_NONAME_NOREF' file='xmlerror' value='1706' type='xmlParserErrors' info='1706'/>
    <enum name='XML_SCHEMAP_EXTENSION_NO_BASE' file='xmlerror' value='1707' type='xmlParserErrors' info='1707'/>
    <enum name='XML_SCHEMAP_E_PROPS_CORRECT_2' file='xmlerror' value='3045' type='xmlParserErrors' info='3045'/>
    <enum name='XML_SCHEMAP_E_PROPS_CORRECT_3' file='xmlerror' value='3046' type='xmlParserErrors' info='3046'/>
    <enum name='XML_SCHEMAP_E_PROPS_CORRECT_4' file='xmlerror' value='3047' type='xmlParserErrors' info='3047'/>
    <enum name='XML_SCHEMAP_E_PROPS_CORRECT_5' file='xmlerror' value='3048' type='xmlParserErrors' info='3048'/>
    <enum name='XML_SCHEMAP_E_PROPS_CORRECT_6' file='xmlerror' value='3049' type='xmlParserErrors' info='3049'/>
    <enum name='XML_SCHEMAP_FACET_NO_VALUE' file='xmlerror' value='1708' type='xmlParserErrors' info='1708'/>
    <enum name='XML_SCHEMAP_FAILED_BUILD_IMPORT' file='xmlerror' value='1709' type='xmlParserErrors' info='1709'/>
    <enum name='XML_SCHEMAP_FAILED_LOAD' file='xmlerror' value='1757' type='xmlParserErrors' info='1757'/>
    <enum name='XML_SCHEMAP_FAILED_PARSE' file='xmlerror' value='1766' type='xmlParserErrors' info='1766'/>
    <enum name='XML_SCHEMAP_GROUP_NONAME_NOREF' file='xmlerror' value='1710' type='xmlParserErrors' info='1710'/>
    <enum name='XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI' file='xmlerror' value='1711' type='xmlParserErrors' info='1711'/>
    <enum name='XML_SCHEMAP_IMPORT_REDEFINE_NSNAME' file='xmlerror' value='1712' type='xmlParserErrors' info='1712'/>
    <enum name='XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI' file='xmlerror' value='1713' type='xmlParserErrors' info='1713'/>
    <enum name='XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI' file='xmlerror' value='1770' type='xmlParserErrors' info='1770'/>
    <enum name='XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI' file='xmlerror' value='1771' type='xmlParserErrors' info='1771'/>
    <enum name='XML_SCHEMAP_INTERNAL' file='xmlerror' value='3069' type='xmlParserErrors' info='3069 non-W3C'/>
    <enum name='XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE' file='xmlerror' value='1793' type='xmlParserErrors' info='1793'/>
    <enum name='XML_SCHEMAP_INVALID_ATTR_COMBINATION' file='xmlerror' value='1777' type='xmlParserErrors' info='1777'/>
    <enum name='XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION' file='xmlerror' value='1778' type='xmlParserErrors' info='1778'/>
    <enum name='XML_SCHEMAP_INVALID_ATTR_NAME' file='xmlerror' value='1780' type='xmlParserErrors' info='1780'/>
    <enum name='XML_SCHEMAP_INVALID_ATTR_USE' file='xmlerror' value='1774' type='xmlParserErrors' info='1774'/>
    <enum name='XML_SCHEMAP_INVALID_BOOLEAN' file='xmlerror' value='1714' type='xmlParserErrors' info='1714'/>
    <enum name='XML_SCHEMAP_INVALID_ENUM' file='xmlerror' value='1715' type='xmlParserErrors' info='1715'/>
    <enum name='XML_SCHEMAP_INVALID_FACET' file='xmlerror' value='1716' type='xmlParserErrors' info='1716'/>
    <enum name='XML_SCHEMAP_INVALID_FACET_VALUE' file='xmlerror' value='1717' type='xmlParserErrors' info='1717'/>
    <enum name='XML_SCHEMAP_INVALID_MAXOCCURS' file='xmlerror' value='1718' type='xmlParserErrors' info='1718'/>
    <enum name='XML_SCHEMAP_INVALID_MINOCCURS' file='xmlerror' value='1719' type='xmlParserErrors' info='1719'/>
    <enum name='XML_SCHEMAP_INVALID_REF_AND_SUBTYPE' file='xmlerror' value='1720' type='xmlParserErrors' info='1720'/>
    <enum name='XML_SCHEMAP_INVALID_WHITE_SPACE' file='xmlerror' value='1721' type='xmlParserErrors' info='1721'/>
    <enum name='XML_SCHEMAP_MG_PROPS_CORRECT_1' file='xmlerror' value='3074' type='xmlParserErrors' info='3074'/>
    <enum name='XML_SCHEMAP_MG_PROPS_CORRECT_2' file='xmlerror' value='3075' type='xmlParserErrors' info='3075'/>
    <enum name='XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD' file='xmlerror' value='1779' type='xmlParserErrors' info='1779'/>
    <enum name='XML_SCHEMAP_NOATTR_NOREF' file='xmlerror' value='1722' type='xmlParserErrors' info='1722'/>
    <enum name='XML_SCHEMAP_NOROOT' file='xmlerror' value='1759' type='xmlParserErrors' info='1759'/>
    <enum name='XML_SCHEMAP_NOTATION_NO_NAME' file='xmlerror' value='1723' type='xmlParserErrors' info='1723'/>
    <enum name='XML_SCHEMAP_NOTHING_TO_PARSE' file='xmlerror' value='1758' type='xmlParserErrors' info='1758'/>
    <enum name='XML_SCHEMAP_NOTYPE_NOREF' file='xmlerror' value='1724' type='xmlParserErrors' info='1724'/>
    <enum name='XML_SCHEMAP_NOT_DETERMINISTIC' file='xmlerror' value='3070' type='xmlParserErrors' info='3070 non-W3C'/>
    <enum name='XML_SCHEMAP_NOT_SCHEMA' file='xmlerror' value='1772' type='xmlParserErrors' info='1772'/>
    <enum name='XML_SCHEMAP_NO_XMLNS' file='xmlerror' value='3056' type='xmlParserErrors' info='3056'/>
    <enum name='XML_SCHEMAP_NO_XSI' file='xmlerror' value='3057' type='xmlParserErrors' info='3057'/>
    <enum name='XML_SCHEMAP_PREFIX_UNDEFINED' file='xmlerror' value='1700' type='xmlParserErrors'/>
    <enum name='XML_SCHEMAP_P_PROPS_CORRECT_1' file='xmlerror' value='3042' type='xmlParserErrors' info='3042'/>
    <enum name='XML_SCHEMAP_P_PROPS_CORRECT_2_1' file='xmlerror' value='3043' type='xmlParserErrors' info='3043'/>
    <enum name='XML_SCHEMAP_P_PROPS_CORRECT_2_2' file='xmlerror' value='3044' type='xmlParserErrors' info='3044'/>
    <enum name='XML_SCHEMAP_RECURSIVE' file='xmlerror' value='1775' type='xmlParserErrors' info='1775'/>
    <enum name='XML_SCHEMAP_REDEFINED_ATTR' file='xmlerror' value='1764' type='xmlParserErrors' info='1764'/>
    <enum name='XML_SCHEMAP_REDEFINED_ATTRGROUP' file='xmlerror' value='1763' type='xmlParserErrors' info='1763'/>
    <enum name='XML_SCHEMAP_REDEFINED_ELEMENT' file='xmlerror' value='1762' type='xmlParserErrors' info='1762'/>
    <enum name='XML_SCHEMAP_REDEFINED_GROUP' file='xmlerror' value='1760' type='xmlParserErrors' info='1760'/>
    <enum name='XML_SCHEMAP_REDEFINED_NOTATION' file='xmlerror' value='1765' type='xmlParserErrors' info='1765'/>
    <enum name='XML_SCHEMAP_REDEFINED_TYPE' file='xmlerror' value='1761' type='xmlParserErrors' info='1761'/>
    <enum name='XML_SCHEMAP_REF_AND_CONTENT' file='xmlerror' value='1781' type='xmlParserErrors' info='1781'/>
    <enum name='XML_SCHEMAP_REF_AND_SUBTYPE' file='xmlerror' value='1725' type='xmlParserErrors' info='1725'/>
    <enum name='XML_SCHEMAP_REGEXP_INVALID' file='xmlerror' value='1756' type='xmlParserErrors' info='1756'/>
    <enum name='XML_SCHEMAP_RESTRICTION_NONAME_NOREF' file='xmlerror' value='1726' type='xmlParserErrors' info='1726'/>
    <enum name='XML_SCHEMAP_S4S_ATTR_INVALID_VALUE' file='xmlerror' value='3037' type='xmlParserErrors' info='3037'/>
    <enum name='XML_SCHEMAP_S4S_ATTR_MISSING' file='xmlerror' value='3036' type='xmlParserErrors' info='3036'/>
    <enum name='XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED' file='xmlerror' value='3035' type='xmlParserErrors' info='3035'/>
    <enum name='XML_SCHEMAP_S4S_ELEM_MISSING' file='xmlerror' value='3034' type='xmlParserErrors' info='3034'/>
    <enum name='XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED' file='xmlerror' value='3033' type='xmlParserErrors' info='3033'/>
    <enum name='XML_SCHEMAP_SIMPLETYPE_NONAME' file='xmlerror' value='1727' type='xmlParserErrors' info='1727'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_1' file='xmlerror' value='3051' type='xmlParserErrors' info='3051'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_2' file='xmlerror' value='3052' type='xmlParserErrors' info='3052'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_3_1' file='xmlerror' value='3053' type='xmlParserErrors' info='3053'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_3_2' file='xmlerror' value='3054' type='xmlParserErrors' info='3054'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_4' file='xmlerror' value='3055' type='xmlParserErrors' info='3055'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1' file='xmlerror' value='3071' type='xmlParserErrors' info='3071'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2' file='xmlerror' value='3072' type='xmlParserErrors' info='3072'/>
    <enum name='XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3' file='xmlerror' value='3073' type='xmlParserErrors' info='3073'/>
    <enum name='XML_SCHEMAP_SRC_CT_1' file='xmlerror' value='3076' type='xmlParserErrors' info='3076'/>
    <enum name='XML_SCHEMAP_SRC_ELEMENT_1' file='xmlerror' value='3038' type='xmlParserErrors' info='3038'/>
    <enum name='XML_SCHEMAP_SRC_ELEMENT_2_1' file='xmlerror' value='3039' type='xmlParserErrors' info='3039'/>
    <enum name='XML_SCHEMAP_SRC_ELEMENT_2_2' file='xmlerror' value='3040' type='xmlParserErrors' info='3040'/>
    <enum name='XML_SCHEMAP_SRC_ELEMENT_3' file='xmlerror' value='3041' type='xmlParserErrors' info='3041'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT' file='xmlerror' value='3082' type='xmlParserErrors' info='3082'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_1_1' file='xmlerror' value='3064' type='xmlParserErrors' info='3064'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_1_2' file='xmlerror' value='3065' type='xmlParserErrors' info='3065'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_2' file='xmlerror' value='3066' type='xmlParserErrors' info='3066'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_2_1' file='xmlerror' value='3067' type='xmlParserErrors' info='3067'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_2_2' file='xmlerror' value='3068' type='xmlParserErrors' info='3068'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_3_1' file='xmlerror' value='1795' type='xmlParserErrors' info='1795'/>
    <enum name='XML_SCHEMAP_SRC_IMPORT_3_2' file='xmlerror' value='1796' type='xmlParserErrors' info='1796'/>
    <enum name='XML_SCHEMAP_SRC_INCLUDE' file='xmlerror' value='3050' type='xmlParserErrors' info='3050'/>
    <enum name='XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE' file='xmlerror' value='3006' type='xmlParserErrors' info='3006'/>
    <enum name='XML_SCHEMAP_SRC_REDEFINE' file='xmlerror' value='3081' type='xmlParserErrors' info='3081'/>
    <enum name='XML_SCHEMAP_SRC_RESOLVE' file='xmlerror' value='3004' type='xmlParserErrors' info='3004'/>
    <enum name='XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE' file='xmlerror' value='3005' type='xmlParserErrors' info='3005'/>
    <enum name='XML_SCHEMAP_SRC_SIMPLE_TYPE_1' file='xmlerror' value='3000' type='xmlParserErrors'/>
    <enum name='XML_SCHEMAP_SRC_SIMPLE_TYPE_2' file='xmlerror' value='3001' type='xmlParserErrors' info='3001'/>
    <enum name='XML_SCHEMAP_SRC_SIMPLE_TYPE_3' file='xmlerror' value='3002' type='xmlParserErrors' info='3002'/>
    <enum name='XML_SCHEMAP_SRC_SIMPLE_TYPE_4' file='xmlerror' value='3003' type='xmlParserErrors' info='3003'/>
    <enum name='XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES' file='xmlerror' value='3007' type='xmlParserErrors' info='3007'/>
    <enum name='XML_SCHEMAP_ST_PROPS_CORRECT_1' file='xmlerror' value='3008' type='xmlParserErrors' info='3008'/>
    <enum name='XML_SCHEMAP_ST_PROPS_CORRECT_2' file='xmlerror' value='3009' type='xmlParserErrors' info='3009'/>
    <enum name='XML_SCHEMAP_ST_PROPS_CORRECT_3' file='xmlerror' value='3010' type='xmlParserErrors' info='3010'/>
    <enum name='XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE' file='xmlerror' value='1776' type='xmlParserErrors' info='1776'/>
    <enum name='XML_SCHEMAP_TYPE_AND_SUBTYPE' file='xmlerror' value='1728' type='xmlParserErrors' info='1728'/>
    <enum name='XML_SCHEMAP_UNION_NOT_EXPRESSIBLE' file='xmlerror' value='1794' type='xmlParserErrors' info='1794'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ALL_CHILD' file='xmlerror' value='1729' type='xmlParserErrors' info='1729'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD' file='xmlerror' value='1730' type='xmlParserErrors' info='1730'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD' file='xmlerror' value='1732' type='xmlParserErrors' info='1732'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP' file='xmlerror' value='1733' type='xmlParserErrors' info='1733'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ATTR_CHILD' file='xmlerror' value='1731' type='xmlParserErrors' info='1731'/>
    <enum name='XML_SCHEMAP_UNKNOWN_BASE_TYPE' file='xmlerror' value='1734' type='xmlParserErrors' info='1734'/>
    <enum name='XML_SCHEMAP_UNKNOWN_CHOICE_CHILD' file='xmlerror' value='1735' type='xmlParserErrors' info='1735'/>
    <enum name='XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD' file='xmlerror' value='1736' type='xmlParserErrors' info='1736'/>
    <enum name='XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD' file='xmlerror' value='1737' type='xmlParserErrors' info='1737'/>
    <enum name='XML_SCHEMAP_UNKNOWN_ELEM_CHILD' file='xmlerror' value='1738' type='xmlParserErrors' info='1738'/>
    <enum name='XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD' file='xmlerror' value='1739' type='xmlParserErrors' info='1739'/>
    <enum name='XML_SCHEMAP_UNKNOWN_FACET_CHILD' file='xmlerror' value='1740' type='xmlParserErrors' info='1740'/>
    <enum name='XML_SCHEMAP_UNKNOWN_FACET_TYPE' file='xmlerror' value='1741' type='xmlParserErrors' info='1741'/>
    <enum name='XML_SCHEMAP_UNKNOWN_GROUP_CHILD' file='xmlerror' value='1742' type='xmlParserErrors' info='1742'/>
    <enum name='XML_SCHEMAP_UNKNOWN_IMPORT_CHILD' file='xmlerror' value='1743' type='xmlParserErrors' info='1743'/>
    <enum name='XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD' file='xmlerror' value='1769' type='xmlParserErrors' info='1769'/>
    <enum name='XML_SCHEMAP_UNKNOWN_LIST_CHILD' file='xmlerror' value='1744' type='xmlParserErrors' info='1744'/>
    <enum name='XML_SCHEMAP_UNKNOWN_MEMBER_TYPE' file='xmlerror' value='1773' type='xmlParserErrors' info='1773'/>
    <enum name='XML_SCHEMAP_UNKNOWN_NOTATION_CHILD' file='xmlerror' value='1745' type='xmlParserErrors' info='1745'/>
    <enum name='XML_SCHEMAP_UNKNOWN_PREFIX' file='xmlerror' value='1767' type='xmlParserErrors' info='1767'/>
    <enum name='XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD' file='xmlerror' value='1746' type='xmlParserErrors' info='1746'/>
    <enum name='XML_SCHEMAP_UNKNOWN_REF' file='xmlerror' value='1747' type='xmlParserErrors' info='1747'/>
    <enum name='XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD' file='xmlerror' value='1748' type='xmlParserErrors' info='1748'/>
    <enum name='XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD' file='xmlerror' value='1749' type='xmlParserErrors' info='1749'/>
    <enum name='XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD' file='xmlerror' value='1750' type='xmlParserErrors' info='1750'/>
    <enum name='XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD' file='xmlerror' value='1751' type='xmlParserErrors' info='1751'/>
    <enum name='XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD' file='xmlerror' value='1752' type='xmlParserErrors' info='1752'/>
    <enum name='XML_SCHEMAP_UNKNOWN_TYPE' file='xmlerror' value='1753' type='xmlParserErrors' info='1753'/>
    <enum name='XML_SCHEMAP_UNKNOWN_UNION_CHILD' file='xmlerror' value='1754' type='xmlParserErrors' info='1754'/>
    <enum name='XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH' file='xmlerror' value='3086' type='xmlParserErrors' info='3085'/>
    <enum name='XML_SCHEMAP_WARN_ATTR_REDECL_PROH' file='xmlerror' value='3085' type='xmlParserErrors' info='3085'/>
    <enum name='XML_SCHEMAP_WARN_SKIP_SCHEMA' file='xmlerror' value='3083' type='xmlParserErrors' info='3083'/>
    <enum name='XML_SCHEMAP_WARN_UNLOCATED_SCHEMA' file='xmlerror' value='3084' type='xmlParserErrors' info='3084'/>
    <enum name='XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER' file='xmlerror' value='1792' type='xmlParserErrors' info='1792'/>
    <enum name='XML_SCHEMAS_ANYSIMPLETYPE' file='schemasInternals' value='46' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ANYTYPE' file='schemasInternals' value='45' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ANYURI' file='schemasInternals' value='29' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_BASE64BINARY' file='schemasInternals' value='44' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_BOOLEAN' file='schemasInternals' value='15' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_BYTE' file='schemasInternals' value='41' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_DATE' file='schemasInternals' value='10' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_DATETIME' file='schemasInternals' value='11' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_DECIMAL' file='schemasInternals' value='3' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_DOUBLE' file='schemasInternals' value='14' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_DURATION' file='schemasInternals' value='12' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ENTITIES' file='schemasInternals' value='27' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ENTITY' file='schemasInternals' value='26' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ERR_' file='xmlschemas' value='24' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_ATTRINVALID' file='xmlschemas' value='21' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_ATTRUNKNOWN' file='xmlschemas' value='20' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_CONSTRUCT' file='xmlschemas' value='17' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_ELEMCONT' file='xmlschemas' value='10' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_EXTRACONTENT' file='xmlschemas' value='13' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_FACET' file='xmlschemas' value='23' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_HAVEDEFAULT' file='xmlschemas' value='11' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_INTERNAL' file='xmlschemas' value='18' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_INVALIDATTR' file='xmlschemas' value='14' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_INVALIDELEM' file='xmlschemas' value='15' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_ISABSTRACT' file='xmlschemas' value='8' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_MISSING' file='xmlschemas' value='4' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOROLLBACK' file='xmlschemas' value='7' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOROOT' file='xmlschemas' value='1' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTDETERMINIST' file='xmlschemas' value='16' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTEMPTY' file='xmlschemas' value='9' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTNILLABLE' file='xmlschemas' value='12' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTSIMPLE' file='xmlschemas' value='19' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTTOPLEVEL' file='xmlschemas' value='3' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_NOTYPE' file='xmlschemas' value='6' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_OK' file='xmlschemas' value='0' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_UNDECLAREDELEM' file='xmlschemas' value='2' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_VALUE' file='xmlschemas' value='22' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_WRONGELEM' file='xmlschemas' value='5' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_ERR_XXX' file='xmlschemas' value='25' type='xmlSchemaValidError'/>
    <enum name='XML_SCHEMAS_FLOAT' file='schemasInternals' value='13' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_GDAY' file='schemasInternals' value='5' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_GMONTH' file='schemasInternals' value='6' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_GMONTHDAY' file='schemasInternals' value='7' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_GYEAR' file='schemasInternals' value='8' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_GYEARMONTH' file='schemasInternals' value='9' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_HEXBINARY' file='schemasInternals' value='43' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ID' file='schemasInternals' value='23' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_IDREF' file='schemasInternals' value='24' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_IDREFS' file='schemasInternals' value='25' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_INT' file='schemasInternals' value='35' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_INTEGER' file='schemasInternals' value='30' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_LANGUAGE' file='schemasInternals' value='17' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_LONG' file='schemasInternals' value='37' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NAME' file='schemasInternals' value='20' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NCNAME' file='schemasInternals' value='22' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NINTEGER' file='schemasInternals' value='32' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NMTOKEN' file='schemasInternals' value='18' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NMTOKENS' file='schemasInternals' value='19' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NNINTEGER' file='schemasInternals' value='33' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NORMSTRING' file='schemasInternals' value='2' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NOTATION' file='schemasInternals' value='28' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_NPINTEGER' file='schemasInternals' value='31' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_PINTEGER' file='schemasInternals' value='34' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_QNAME' file='schemasInternals' value='21' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_SHORT' file='schemasInternals' value='39' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_STRING' file='schemasInternals' value='1' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_TIME' file='schemasInternals' value='4' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_TOKEN' file='schemasInternals' value='16' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_UBYTE' file='schemasInternals' value='42' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_UINT' file='schemasInternals' value='36' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_ULONG' file='schemasInternals' value='38' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_UNKNOWN' file='schemasInternals' value='0' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMAS_USHORT' file='schemasInternals' value='40' type='xmlSchemaValType'/>
    <enum name='XML_SCHEMATRONV_ASSERT' file='xmlerror' value='4000' type='xmlParserErrors' info='4000'/>
    <enum name='XML_SCHEMATRONV_REPORT' file='xmlerror' value='4001' type='xmlParserErrors'/>
    <enum name='XML_SCHEMATRON_OUT_BUFFER' file='schematron' value='512' type='xmlSchematronValidOptions' info='output to a buffer'/>
    <enum name='XML_SCHEMATRON_OUT_ERROR' file='schematron' value='8' type='xmlSchematronValidOptions' info='output via xmlStructuredErrorFunc'/>
    <enum name='XML_SCHEMATRON_OUT_FILE' file='schematron' value='256' type='xmlSchematronValidOptions' info='output to a file descriptor'/>
    <enum name='XML_SCHEMATRON_OUT_IO' file='schematron' value='1024' type='xmlSchematronValidOptions' info=' output to I/O mechanism'/>
    <enum name='XML_SCHEMATRON_OUT_QUIET' file='schematron' value='1' type='xmlSchematronValidOptions' info='quiet no report'/>
    <enum name='XML_SCHEMATRON_OUT_TEXT' file='schematron' value='2' type='xmlSchematronValidOptions' info='build a textual report'/>
    <enum name='XML_SCHEMATRON_OUT_XML' file='schematron' value='4' type='xmlSchematronValidOptions' info='output SVRL'/>
    <enum name='XML_SCHEMAV_ATTRINVALID' file='xmlerror' value='1821' type='xmlParserErrors' info='1821'/>
    <enum name='XML_SCHEMAV_ATTRUNKNOWN' file='xmlerror' value='1820' type='xmlParserErrors' info='1820'/>
    <enum name='XML_SCHEMAV_CONSTRUCT' file='xmlerror' value='1817' type='xmlParserErrors' info='1817'/>
    <enum name='XML_SCHEMAV_CVC_ATTRIBUTE_1' file='xmlerror' value='1861' type='xmlParserErrors' info='1861'/>
    <enum name='XML_SCHEMAV_CVC_ATTRIBUTE_2' file='xmlerror' value='1862' type='xmlParserErrors' info='1862'/>
    <enum name='XML_SCHEMAV_CVC_ATTRIBUTE_3' file='xmlerror' value='1863' type='xmlParserErrors' info='1863'/>
    <enum name='XML_SCHEMAV_CVC_ATTRIBUTE_4' file='xmlerror' value='1864' type='xmlParserErrors' info='1864'/>
    <enum name='XML_SCHEMAV_CVC_AU' file='xmlerror' value='1874' type='xmlParserErrors' info='1874'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_1' file='xmlerror' value='1873' type='xmlParserErrors' info='1873'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1' file='xmlerror' value='1841' type='xmlParserErrors' info='1841'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2' file='xmlerror' value='1842' type='xmlParserErrors' info='1842'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3' file='xmlerror' value='1843' type='xmlParserErrors' info='1843'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4' file='xmlerror' value='1844' type='xmlParserErrors' info='1844'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1' file='xmlerror' value='1865' type='xmlParserErrors' info='1865'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1' file='xmlerror' value='1866' type='xmlParserErrors' info='1866'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2' file='xmlerror' value='1867' type='xmlParserErrors' info='1867'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_4' file='xmlerror' value='1868' type='xmlParserErrors' info='1868'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1' file='xmlerror' value='1869' type='xmlParserErrors' info='1869'/>
    <enum name='XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2' file='xmlerror' value='1870' type='xmlParserErrors' info='1870'/>
    <enum name='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1' file='xmlerror' value='1824' type='xmlParserErrors' info='1824'/>
    <enum name='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2' file='xmlerror' value='1825' type='xmlParserErrors' info='1825'/>
    <enum name='XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3' file='xmlerror' value='1826' type='xmlParserErrors' info='1826'/>
    <enum name='XML_SCHEMAV_CVC_ELT_1' file='xmlerror' value='1845' type='xmlParserErrors' info='1845'/>
    <enum name='XML_SCHEMAV_CVC_ELT_2' file='xmlerror' value='1846' type='xmlParserErrors' info='1846'/>
    <enum name='XML_SCHEMAV_CVC_ELT_3_1' file='xmlerror' value='1847' type='xmlParserErrors' info='1847'/>
    <enum name='XML_SCHEMAV_CVC_ELT_3_2_1' file='xmlerror' value='1848' type='xmlParserErrors' info='1848'/>
    <enum name='XML_SCHEMAV_CVC_ELT_3_2_2' file='xmlerror' value='1849' type='xmlParserErrors' info='1849'/>
    <enum name='XML_SCHEMAV_CVC_ELT_4_1' file='xmlerror' value='1850' type='xmlParserErrors' info='1850'/>
    <enum name='XML_SCHEMAV_CVC_ELT_4_2' file='xmlerror' value='1851' type='xmlParserErrors' info='1851'/>
    <enum name='XML_SCHEMAV_CVC_ELT_4_3' file='xmlerror' value='1852' type='xmlParserErrors' info='1852'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_1_1' file='xmlerror' value='1853' type='xmlParserErrors' info='1853'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_1_2' file='xmlerror' value='1854' type='xmlParserErrors' info='1854'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_2_1' file='xmlerror' value='1855' type='xmlParserErrors' info='1855'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_2_2_1' file='xmlerror' value='1856' type='xmlParserErrors' info='1856'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_2_2_2_1' file='xmlerror' value='1857' type='xmlParserErrors' info='1857'/>
    <enum name='XML_SCHEMAV_CVC_ELT_5_2_2_2_2' file='xmlerror' value='1858' type='xmlParserErrors' info='1858'/>
    <enum name='XML_SCHEMAV_CVC_ELT_6' file='xmlerror' value='1859' type='xmlParserErrors' info='1859'/>
    <enum name='XML_SCHEMAV_CVC_ELT_7' file='xmlerror' value='1860' type='xmlParserErrors' info='1860'/>
    <enum name='XML_SCHEMAV_CVC_ENUMERATION_VALID' file='xmlerror' value='1840' type='xmlParserErrors' info='1840'/>
    <enum name='XML_SCHEMAV_CVC_FACET_VALID' file='xmlerror' value='1829' type='xmlParserErrors' info='1829'/>
    <enum name='XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID' file='xmlerror' value='1838' type='xmlParserErrors' info='1838'/>
    <enum name='XML_SCHEMAV_CVC_IDC' file='xmlerror' value='1877' type='xmlParserErrors' info='1877'/>
    <enum name='XML_SCHEMAV_CVC_LENGTH_VALID' file='xmlerror' value='1830' type='xmlParserErrors' info='1830'/>
    <enum name='XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID' file='xmlerror' value='1836' type='xmlParserErrors' info='1836'/>
    <enum name='XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID' file='xmlerror' value='1834' type='xmlParserErrors' info='1834'/>
    <enum name='XML_SCHEMAV_CVC_MAXLENGTH_VALID' file='xmlerror' value='1832' type='xmlParserErrors' info='1832'/>
    <enum name='XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID' file='xmlerror' value='1835' type='xmlParserErrors' info='1835'/>
    <enum name='XML_SCHEMAV_CVC_MININCLUSIVE_VALID' file='xmlerror' value='1833' type='xmlParserErrors' info='1833'/>
    <enum name='XML_SCHEMAV_CVC_MINLENGTH_VALID' file='xmlerror' value='1831' type='xmlParserErrors' info='1831'/>
    <enum name='XML_SCHEMAV_CVC_PATTERN_VALID' file='xmlerror' value='1839' type='xmlParserErrors' info='1839'/>
    <enum name='XML_SCHEMAV_CVC_TOTALDIGITS_VALID' file='xmlerror' value='1837' type='xmlParserErrors' info='1837'/>
    <enum name='XML_SCHEMAV_CVC_TYPE_1' file='xmlerror' value='1875' type='xmlParserErrors' info='1875'/>
    <enum name='XML_SCHEMAV_CVC_TYPE_2' file='xmlerror' value='1876' type='xmlParserErrors' info='1876'/>
    <enum name='XML_SCHEMAV_CVC_TYPE_3_1_1' file='xmlerror' value='1827' type='xmlParserErrors' info='1827'/>
    <enum name='XML_SCHEMAV_CVC_TYPE_3_1_2' file='xmlerror' value='1828' type='xmlParserErrors' info='1828'/>
    <enum name='XML_SCHEMAV_CVC_WILDCARD' file='xmlerror' value='1878' type='xmlParserErrors' info='1878'/>
    <enum name='XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING' file='xmlerror' value='1872' type='xmlParserErrors' info='1872'/>
    <enum name='XML_SCHEMAV_ELEMCONT' file='xmlerror' value='1810' type='xmlParserErrors' info='1810'/>
    <enum name='XML_SCHEMAV_ELEMENT_CONTENT' file='xmlerror' value='1871' type='xmlParserErrors' info='1871'/>
    <enum name='XML_SCHEMAV_EXTRACONTENT' file='xmlerror' value='1813' type='xmlParserErrors' info='1813'/>
    <enum name='XML_SCHEMAV_FACET' file='xmlerror' value='1823' type='xmlParserErrors' info='1823'/>
    <enum name='XML_SCHEMAV_HAVEDEFAULT' file='xmlerror' value='1811' type='xmlParserErrors' info='1811'/>
    <enum name='XML_SCHEMAV_INTERNAL' file='xmlerror' value='1818' type='xmlParserErrors' info='1818'/>
    <enum name='XML_SCHEMAV_INVALIDATTR' file='xmlerror' value='1814' type='xmlParserErrors' info='1814'/>
    <enum name='XML_SCHEMAV_INVALIDELEM' file='xmlerror' value='1815' type='xmlParserErrors' info='1815'/>
    <enum name='XML_SCHEMAV_ISABSTRACT' file='xmlerror' value='1808' type='xmlParserErrors' info='1808'/>
    <enum name='XML_SCHEMAV_MISC' file='xmlerror' value='1879' type='xmlParserErrors' info='1879'/>
    <enum name='XML_SCHEMAV_MISSING' file='xmlerror' value='1804' type='xmlParserErrors' info='1804'/>
    <enum name='XML_SCHEMAV_NOROLLBACK' file='xmlerror' value='1807' type='xmlParserErrors' info='1807'/>
    <enum name='XML_SCHEMAV_NOROOT' file='xmlerror' value='1801' type='xmlParserErrors'/>
    <enum name='XML_SCHEMAV_NOTDETERMINIST' file='xmlerror' value='1816' type='xmlParserErrors' info='1816'/>
    <enum name='XML_SCHEMAV_NOTEMPTY' file='xmlerror' value='1809' type='xmlParserErrors' info='1809'/>
    <enum name='XML_SCHEMAV_NOTNILLABLE' file='xmlerror' value='1812' type='xmlParserErrors' info='1812'/>
    <enum name='XML_SCHEMAV_NOTSIMPLE' file='xmlerror' value='1819' type='xmlParserErrors' info='1819'/>
    <enum name='XML_SCHEMAV_NOTTOPLEVEL' file='xmlerror' value='1803' type='xmlParserErrors' info='1803'/>
    <enum name='XML_SCHEMAV_NOTYPE' file='xmlerror' value='1806' type='xmlParserErrors' info='1806'/>
    <enum name='XML_SCHEMAV_UNDECLAREDELEM' file='xmlerror' value='1802' type='xmlParserErrors' info='1802'/>
    <enum name='XML_SCHEMAV_VALUE' file='xmlerror' value='1822' type='xmlParserErrors' info='1822'/>
    <enum name='XML_SCHEMAV_WRONGELEM' file='xmlerror' value='1805' type='xmlParserErrors' info='1805'/>
    <enum name='XML_SCHEMA_CONTENT_ANY' file='schemasInternals' value='7' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_BASIC' file='schemasInternals' value='6' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_ELEMENTS' file='schemasInternals' value='2' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_EMPTY' file='schemasInternals' value='1' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_MIXED' file='schemasInternals' value='3' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS' file='schemasInternals' value='5' type='xmlSchemaContentType' info='Obsolete'/>
    <enum name='XML_SCHEMA_CONTENT_SIMPLE' file='schemasInternals' value='4' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_CONTENT_UNKNOWN' file='schemasInternals' value='0' type='xmlSchemaContentType'/>
    <enum name='XML_SCHEMA_EXTRA_ATTR_USE_PROHIB' file='schemasInternals' value='2001' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_EXTRA_QNAMEREF' file='schemasInternals' value='2000' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_ENUMERATION' file='schemasInternals' value='1007' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_FRACTIONDIGITS' file='schemasInternals' value='1005' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_LENGTH' file='schemasInternals' value='1009' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MAXEXCLUSIVE' file='schemasInternals' value='1003' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MAXINCLUSIVE' file='schemasInternals' value='1002' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MAXLENGTH' file='schemasInternals' value='1010' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MINEXCLUSIVE' file='schemasInternals' value='1001' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MININCLUSIVE' file='schemasInternals' value='1000' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_MINLENGTH' file='schemasInternals' value='1011' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_PATTERN' file='schemasInternals' value='1006' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_TOTALDIGITS' file='schemasInternals' value='1004' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_FACET_WHITESPACE' file='schemasInternals' value='1008' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ALL' file='schemasInternals' value='8' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ANY' file='schemasInternals' value='2' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ANY_ATTRIBUTE' file='schemasInternals' value='21' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ATTRIBUTE' file='schemasInternals' value='15' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ATTRIBUTEGROUP' file='schemasInternals' value='16' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ATTRIBUTE_USE' file='schemasInternals' value='26' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_BASIC' file='schemasInternals' value='1' type='xmlSchemaTypeType' info='A built-in datatype'/>
    <enum name='XML_SCHEMA_TYPE_CHOICE' file='schemasInternals' value='7' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_COMPLEX' file='schemasInternals' value='5' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_COMPLEX_CONTENT' file='schemasInternals' value='10' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_ELEMENT' file='schemasInternals' value='14' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_EXTENSION' file='schemasInternals' value='13' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_FACET' file='schemasInternals' value='3' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_GROUP' file='schemasInternals' value='17' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_IDC_KEY' file='schemasInternals' value='23' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_IDC_KEYREF' file='schemasInternals' value='24' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_IDC_UNIQUE' file='schemasInternals' value='22' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_LIST' file='schemasInternals' value='19' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_NOTATION' file='schemasInternals' value='18' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_PARTICLE' file='schemasInternals' value='25' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_RESTRICTION' file='schemasInternals' value='12' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_SEQUENCE' file='schemasInternals' value='6' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_SIMPLE' file='schemasInternals' value='4' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_SIMPLE_CONTENT' file='schemasInternals' value='9' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_UNION' file='schemasInternals' value='20' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_TYPE_UR' file='schemasInternals' value='11' type='xmlSchemaTypeType'/>
    <enum name='XML_SCHEMA_VAL_VC_I_CREATE' file='xmlschemas' value='1' type='xmlSchemaValidOption' info=' Default/fixed: create an attribute node
* or an element&apos;s text node on the instance.
*'/>
    <enum name='XML_SCHEMA_WHITESPACE_COLLAPSE' file='xmlschemastypes' value='3' type='xmlSchemaWhitespaceValueType'/>
    <enum name='XML_SCHEMA_WHITESPACE_PRESERVE' file='xmlschemastypes' value='1' type='xmlSchemaWhitespaceValueType'/>
    <enum name='XML_SCHEMA_WHITESPACE_REPLACE' file='xmlschemastypes' value='2' type='xmlSchemaWhitespaceValueType'/>
    <enum name='XML_SCHEMA_WHITESPACE_UNKNOWN' file='xmlschemastypes' value='0' type='xmlSchemaWhitespaceValueType'/>
    <enum name='XML_TEXTREADER_MODE_CLOSED' file='xmlreader' value='4' type='xmlTextReaderMode'/>
    <enum name='XML_TEXTREADER_MODE_EOF' file='xmlreader' value='3' type='xmlTextReaderMode'/>
    <enum name='XML_TEXTREADER_MODE_ERROR' file='xmlreader' value='2' type='xmlTextReaderMode'/>
    <enum name='XML_TEXTREADER_MODE_INITIAL' file='xmlreader' value='0' type='xmlTextReaderMode'/>
    <enum name='XML_TEXTREADER_MODE_INTERACTIVE' file='xmlreader' value='1' type='xmlTextReaderMode'/>
    <enum name='XML_TEXTREADER_MODE_READING' file='xmlreader' value='5' type='xmlTextReaderMode'/>
    <enum name='XML_TEXT_NODE' file='tree' value='3' type='xmlElementType'/>
    <enum name='XML_TREE_INVALID_DEC' file='xmlerror' value='1301' type='xmlParserErrors' info='1301'/>
    <enum name='XML_TREE_INVALID_HEX' file='xmlerror' value='1300' type='xmlParserErrors'/>
    <enum name='XML_TREE_NOT_UTF8' file='xmlerror' value='1303' type='xmlParserErrors' info='1303'/>
    <enum name='XML_TREE_UNTERMINATED_ENTITY' file='xmlerror' value='1302' type='xmlParserErrors' info='1302'/>
    <enum name='XML_WAR_CATALOG_PI' file='xmlerror' value='93' type='xmlParserErrors' info='93'/>
    <enum name='XML_WAR_ENTITY_REDEFINED' file='xmlerror' value='107' type='xmlParserErrors' info='107'/>
    <enum name='XML_WAR_LANG_VALUE' file='xmlerror' value='98' type='xmlParserErrors' info='98'/>
    <enum name='XML_WAR_NS_COLUMN' file='xmlerror' value='106' type='xmlParserErrors' info='106'/>
    <enum name='XML_WAR_NS_URI' file='xmlerror' value='99' type='xmlParserErrors' info='99'/>
    <enum name='XML_WAR_NS_URI_RELATIVE' file='xmlerror' value='100' type='xmlParserErrors' info='100'/>
    <enum name='XML_WAR_SPACE_VALUE' file='xmlerror' value='102' type='xmlParserErrors' info='102'/>
    <enum name='XML_WAR_UNDECLARED_ENTITY' file='xmlerror' value='27' type='xmlParserErrors' info='27'/>
    <enum name='XML_WAR_UNKNOWN_VERSION' file='xmlerror' value='97' type='xmlParserErrors' info='97'/>
    <enum name='XML_WITH_AUTOMATA' file='parser' value='23' type='xmlFeature'/>
    <enum name='XML_WITH_C14N' file='parser' value='14' type='xmlFeature'/>
    <enum name='XML_WITH_CATALOG' file='parser' value='15' type='xmlFeature'/>
    <enum name='XML_WITH_DEBUG' file='parser' value='28' type='xmlFeature'/>
    <enum name='XML_WITH_DEBUG_MEM' file='parser' value='29' type='xmlFeature'/>
    <enum name='XML_WITH_DEBUG_RUN' file='parser' value='30' type='xmlFeature'/>
    <enum name='XML_WITH_EXPR' file='parser' value='24' type='xmlFeature'/>
    <enum name='XML_WITH_FTP' file='parser' value='9' type='xmlFeature'/>
    <enum name='XML_WITH_HTML' file='parser' value='12' type='xmlFeature'/>
    <enum name='XML_WITH_HTTP' file='parser' value='10' type='xmlFeature'/>
    <enum name='XML_WITH_ICONV' file='parser' value='19' type='xmlFeature'/>
    <enum name='XML_WITH_ICU' file='parser' value='32' type='xmlFeature'/>
    <enum name='XML_WITH_ISO8859X' file='parser' value='20' type='xmlFeature'/>
    <enum name='XML_WITH_LEGACY' file='parser' value='13' type='xmlFeature'/>
    <enum name='XML_WITH_LZMA' file='parser' value='33' type='xmlFeature'/>
    <enum name='XML_WITH_MODULES' file='parser' value='27' type='xmlFeature'/>
    <enum name='XML_WITH_NONE' file='parser' value='99999' type='xmlFeature' info=' just to be sure of allocation size'/>
    <enum name='XML_WITH_OUTPUT' file='parser' value='3' type='xmlFeature'/>
    <enum name='XML_WITH_PATTERN' file='parser' value='6' type='xmlFeature'/>
    <enum name='XML_WITH_PUSH' file='parser' value='4' type='xmlFeature'/>
    <enum name='XML_WITH_READER' file='parser' value='5' type='xmlFeature'/>
    <enum name='XML_WITH_REGEXP' file='parser' value='22' type='xmlFeature'/>
    <enum name='XML_WITH_SAX1' file='parser' value='8' type='xmlFeature'/>
    <enum name='XML_WITH_SCHEMAS' file='parser' value='25' type='xmlFeature'/>
    <enum name='XML_WITH_SCHEMATRON' file='parser' value='26' type='xmlFeature'/>
    <enum name='XML_WITH_THREAD' file='parser' value='1' type='xmlFeature'/>
    <enum name='XML_WITH_TREE' file='parser' value='2' type='xmlFeature'/>
    <enum name='XML_WITH_UNICODE' file='parser' value='21' type='xmlFeature'/>
    <enum name='XML_WITH_VALID' file='parser' value='11' type='xmlFeature'/>
    <enum name='XML_WITH_WRITER' file='parser' value='7' type='xmlFeature'/>
    <enum name='XML_WITH_XINCLUDE' file='parser' value='18' type='xmlFeature'/>
    <enum name='XML_WITH_XPATH' file='parser' value='16' type='xmlFeature'/>
    <enum name='XML_WITH_XPTR' file='parser' value='17' type='xmlFeature'/>
    <enum name='XML_WITH_ZLIB' file='parser' value='31' type='xmlFeature'/>
    <enum name='XML_XINCLUDE_BUILD_FAILED' file='xmlerror' value='1609' type='xmlParserErrors' info='1609'/>
    <enum name='XML_XINCLUDE_DEPRECATED_NS' file='xmlerror' value='1617' type='xmlParserErrors' info='1617'/>
    <enum name='XML_XINCLUDE_END' file='tree' value='20' type='xmlElementType'/>
    <enum name='XML_XINCLUDE_ENTITY_DEF_MISMATCH' file='xmlerror' value='1602' type='xmlParserErrors' info='1602'/>
    <enum name='XML_XINCLUDE_FALLBACKS_IN_INCLUDE' file='xmlerror' value='1615' type='xmlParserErrors' info='1615'/>
    <enum name='XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE' file='xmlerror' value='1616' type='xmlParserErrors' info='1616'/>
    <enum name='XML_XINCLUDE_FRAGMENT_ID' file='xmlerror' value='1618' type='xmlParserErrors' info='1618'/>
    <enum name='XML_XINCLUDE_HREF_URI' file='xmlerror' value='1605' type='xmlParserErrors' info='1605'/>
    <enum name='XML_XINCLUDE_INCLUDE_IN_INCLUDE' file='xmlerror' value='1614' type='xmlParserErrors' info='1614'/>
    <enum name='XML_XINCLUDE_INVALID_CHAR' file='xmlerror' value='1608' type='xmlParserErrors' info='1608'/>
    <enum name='XML_XINCLUDE_MULTIPLE_ROOT' file='xmlerror' value='1611' type='xmlParserErrors' info='1611'/>
    <enum name='XML_XINCLUDE_NO_FALLBACK' file='xmlerror' value='1604' type='xmlParserErrors' info='1604'/>
    <enum name='XML_XINCLUDE_NO_HREF' file='xmlerror' value='1603' type='xmlParserErrors' info='1603'/>
    <enum name='XML_XINCLUDE_PARSE_VALUE' file='xmlerror' value='1601' type='xmlParserErrors' info='1601'/>
    <enum name='XML_XINCLUDE_RECURSION' file='xmlerror' value='1600' type='xmlParserErrors'/>
    <enum name='XML_XINCLUDE_START' file='tree' value='19' type='xmlElementType'/>
    <enum name='XML_XINCLUDE_TEXT_DOCUMENT' file='xmlerror' value='1607' type='xmlParserErrors' info='1607'/>
    <enum name='XML_XINCLUDE_TEXT_FRAGMENT' file='xmlerror' value='1606' type='xmlParserErrors' info='1606'/>
    <enum name='XML_XINCLUDE_UNKNOWN_ENCODING' file='xmlerror' value='1610' type='xmlParserErrors' info='1610'/>
    <enum name='XML_XINCLUDE_XPTR_FAILED' file='xmlerror' value='1612' type='xmlParserErrors' info='1612'/>
    <enum name='XML_XINCLUDE_XPTR_RESULT' file='xmlerror' value='1613' type='xmlParserErrors' info='1613'/>
    <enum name='XML_XPATH_ENCODING_ERROR' file='xmlerror' value='1220' type='xmlParserErrors' info='1220'/>
    <enum name='XML_XPATH_EXPRESSION_OK' file='xmlerror' value='1200' type='xmlParserErrors'/>
    <enum name='XML_XPATH_EXPR_ERROR' file='xmlerror' value='1207' type='xmlParserErrors' info='1207'/>
    <enum name='XML_XPATH_INVALID_ARITY' file='xmlerror' value='1212' type='xmlParserErrors' info='1212'/>
    <enum name='XML_XPATH_INVALID_CHAR_ERROR' file='xmlerror' value='1221' type='xmlParserErrors' info='1221'/>
    <enum name='XML_XPATH_INVALID_CTXT_POSITION' file='xmlerror' value='1214' type='xmlParserErrors' info='1214'/>
    <enum name='XML_XPATH_INVALID_CTXT_SIZE' file='xmlerror' value='1213' type='xmlParserErrors' info='1213'/>
    <enum name='XML_XPATH_INVALID_OPERAND' file='xmlerror' value='1210' type='xmlParserErrors' info='1210'/>
    <enum name='XML_XPATH_INVALID_PREDICATE_ERROR' file='xmlerror' value='1206' type='xmlParserErrors' info='1206'/>
    <enum name='XML_XPATH_INVALID_TYPE' file='xmlerror' value='1211' type='xmlParserErrors' info='1211'/>
    <enum name='XML_XPATH_MEMORY_ERROR' file='xmlerror' value='1215' type='xmlParserErrors' info='1215'/>
    <enum name='XML_XPATH_NUMBER_ERROR' file='xmlerror' value='1201' type='xmlParserErrors' info='1201'/>
    <enum name='XML_XPATH_START_LITERAL_ERROR' file='xmlerror' value='1203' type='xmlParserErrors' info='1203'/>
    <enum name='XML_XPATH_UNCLOSED_ERROR' file='xmlerror' value='1208' type='xmlParserErrors' info='1208'/>
    <enum name='XML_XPATH_UNDEF_PREFIX_ERROR' file='xmlerror' value='1219' type='xmlParserErrors' info='1219'/>
    <enum name='XML_XPATH_UNDEF_VARIABLE_ERROR' file='xmlerror' value='1205' type='xmlParserErrors' info='1205'/>
    <enum name='XML_XPATH_UNFINISHED_LITERAL_ERROR' file='xmlerror' value='1202' type='xmlParserErrors' info='1202'/>
    <enum name='XML_XPATH_UNKNOWN_FUNC_ERROR' file='xmlerror' value='1209' type='xmlParserErrors' info='1209'/>
    <enum name='XML_XPATH_VARIABLE_REF_ERROR' file='xmlerror' value='1204' type='xmlParserErrors' info='1204'/>
    <enum name='XML_XPTR_CHILDSEQ_START' file='xmlerror' value='1901' type='xmlParserErrors' info='1901'/>
    <enum name='XML_XPTR_EVAL_FAILED' file='xmlerror' value='1902' type='xmlParserErrors' info='1902'/>
    <enum name='XML_XPTR_EXTRA_OBJECTS' file='xmlerror' value='1903' type='xmlParserErrors' info='1903'/>
    <enum name='XML_XPTR_RESOURCE_ERROR' file='xmlerror' value='1217' type='xmlParserErrors' info='1217'/>
    <enum name='XML_XPTR_SUB_RESOURCE_ERROR' file='xmlerror' value='1218' type='xmlParserErrors' info='1218'/>
    <enum name='XML_XPTR_SYNTAX_ERROR' file='xmlerror' value='1216' type='xmlParserErrors' info='1216'/>
    <enum name='XML_XPTR_UNKNOWN_SCHEME' file='xmlerror' value='1900' type='xmlParserErrors'/>
    <enum name='XPATH_BOOLEAN' file='xpath' value='2' type='xmlXPathObjectType'/>
    <enum name='XPATH_ENCODING_ERROR' file='xpath' value='20' type='xmlXPathError'/>
    <enum name='XPATH_EXPRESSION_OK' file='xpath' value='0' type='xmlXPathError'/>
    <enum name='XPATH_EXPR_ERROR' file='xpath' value='7' type='xmlXPathError'/>
    <enum name='XPATH_FORBID_VARIABLE_ERROR' file='xpath' value='24' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_ARITY' file='xpath' value='12' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_CHAR_ERROR' file='xpath' value='21' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_CTXT' file='xpath' value='22' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_CTXT_POSITION' file='xpath' value='14' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_CTXT_SIZE' file='xpath' value='13' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_OPERAND' file='xpath' value='10' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_PREDICATE_ERROR' file='xpath' value='6' type='xmlXPathError'/>
    <enum name='XPATH_INVALID_TYPE' file='xpath' value='11' type='xmlXPathError'/>
    <enum name='XPATH_LOCATIONSET' file='xpath' value='7' type='xmlXPathObjectType'/>
    <enum name='XPATH_MEMORY_ERROR' file='xpath' value='15' type='xmlXPathError'/>
    <enum name='XPATH_NODESET' file='xpath' value='1' type='xmlXPathObjectType'/>
    <enum name='XPATH_NUMBER' file='xpath' value='3' type='xmlXPathObjectType'/>
    <enum name='XPATH_NUMBER_ERROR' file='xpath' value='1' type='xmlXPathError'/>
    <enum name='XPATH_POINT' file='xpath' value='5' type='xmlXPathObjectType'/>
    <enum name='XPATH_RANGE' file='xpath' value='6' type='xmlXPathObjectType'/>
    <enum name='XPATH_STACK_ERROR' file='xpath' value='23' type='xmlXPathError'/>
    <enum name='XPATH_START_LITERAL_ERROR' file='xpath' value='3' type='xmlXPathError'/>
    <enum name='XPATH_STRING' file='xpath' value='4' type='xmlXPathObjectType'/>
    <enum name='XPATH_UNCLOSED_ERROR' file='xpath' value='8' type='xmlXPathError'/>
    <enum name='XPATH_UNDEFINED' file='xpath' value='0' type='xmlXPathObjectType'/>
    <enum name='XPATH_UNDEF_PREFIX_ERROR' file='xpath' value='19' type='xmlXPathError'/>
    <enum name='XPATH_UNDEF_VARIABLE_ERROR' file='xpath' value='5' type='xmlXPathError'/>
    <enum name='XPATH_UNFINISHED_LITERAL_ERROR' file='xpath' value='2' type='xmlXPathError'/>
    <enum name='XPATH_UNKNOWN_FUNC_ERROR' file='xpath' value='9' type='xmlXPathError'/>
    <enum name='XPATH_USERS' file='xpath' value='8' type='xmlXPathObjectType'/>
    <enum name='XPATH_VARIABLE_REF_ERROR' file='xpath' value='4' type='xmlXPathError'/>
    <enum name='XPATH_XSLT_TREE' file='xpath' value='9' type='xmlXPathObjectType' info=' An XSLT value tree, non modifiable'/>
    <enum name='XPTR_RESOURCE_ERROR' file='xpath' value='17' type='xmlXPathError'/>
    <enum name='XPTR_SUB_RESOURCE_ERROR' file='xpath' value='18' type='xmlXPathError'/>
    <enum name='XPTR_SYNTAX_ERROR' file='xpath' value='16' type='xmlXPathError'/>
    <typedef name='docbDocPtr' file='DOCBparser' type='xmlDocPtr'/>
    <typedef name='docbParserCtxt' file='DOCBparser' type='xmlParserCtxt'/>
    <typedef name='docbParserCtxtPtr' file='DOCBparser' type='xmlParserCtxtPtr'/>
    <typedef name='docbParserInput' file='DOCBparser' type='xmlParserInput'/>
    <typedef name='docbParserInputPtr' file='DOCBparser' type='xmlParserInputPtr'/>
    <typedef name='docbSAXHandler' file='DOCBparser' type='xmlSAXHandler'/>
    <typedef name='docbSAXHandlerPtr' file='DOCBparser' type='xmlSAXHandlerPtr'/>
    <typedef name='htmlDocPtr' file='HTMLparser' type='xmlDocPtr'/>
    <struct name='htmlElemDesc' file='HTMLparser' type='struct _htmlElemDesc'>
      <field name='name' type='const char *' info=' The tag name'/>
      <field name='startTag' type='char' info=' Whether the start tag can be implied'/>
      <field name='endTag' type='char' info=' Whether the end tag can be implied'/>
      <field name='saveEndTag' type='char' info=' Whether the end tag should be saved'/>
      <field name='empty' type='char' info=' Is this an empty element ?'/>
      <field name='depr' type='char' info=' Is this a deprecated element ?'/>
      <field name='dtd' type='char' info=' 1: only in Loose DTD, 2: only Frameset one'/>
      <field name='isinline' type='char' info=' is this a block 0 or inline 1 element'/>
      <field name='desc' type='const char *' info=' the description NRK Jan.2003
* New fields encapsulating HTML structure
*
* Bugs:
*	This is a very limited representation.  It fails to tell us when
*	an element *requires* subelements (we only have whether they&apos;re
*	allowed or not), and it doesn&apos;t tell us where CDATA and PCDATA
*	are allowed.  Some element relationships are not fully represented:
*	these are flagged with the word MODIFIER
*'/>
      <field name='subelts' type='const char **' info=' allowed sub-elements of this element'/>
      <field name='defaultsubelt' type='const char *' info=' subelement for suggested auto-repair
if necessary or NULL'/>
      <field name='attrs_opt' type='const char **' info=' Optional Attributes'/>
      <field name='attrs_depr' type='const char **' info=' Additional deprecated attributes'/>
      <field name='attrs_req' type='const char **' info=' Required attributes'/>
    </struct>
    <typedef name='htmlElemDescPtr' file='HTMLparser' type='htmlElemDesc *'/>
    <struct name='htmlEntityDesc' file='HTMLparser' type='struct _htmlEntityDesc'>
      <field name='value' type='unsigned int' info=' the UNICODE value for the character'/>
      <field name='name' type='const char *' info=' The entity name'/>
      <field name='desc' type='const char *' info=' the description'/>
    </struct>
    <typedef name='htmlEntityDescPtr' file='HTMLparser' type='htmlEntityDesc *'/>
    <typedef name='htmlNodePtr' file='HTMLparser' type='xmlNodePtr'/>
    <typedef name='htmlParserCtxt' file='HTMLparser' type='xmlParserCtxt'/>
    <typedef name='htmlParserCtxtPtr' file='HTMLparser' type='xmlParserCtxtPtr'/>
    <typedef name='htmlParserInput' file='HTMLparser' type='xmlParserInput'/>
    <typedef name='htmlParserInputPtr' file='HTMLparser' type='xmlParserInputPtr'/>
    <typedef name='htmlParserNodeInfo' file='HTMLparser' type='xmlParserNodeInfo'/>
    <typedef name='htmlParserOption' file='HTMLparser' type='enum'/>
    <typedef name='htmlSAXHandler' file='HTMLparser' type='xmlSAXHandler'/>
    <typedef name='htmlSAXHandlerPtr' file='HTMLparser' type='xmlSAXHandlerPtr'/>
    <typedef name='htmlStatus' file='HTMLparser' type='enum'/>
    <struct name='uconv_t' file='encoding' type='struct _uconv_t'>
      <field name='uconv' type='UConverter *' info=' for conversion between an encoding and UTF-16'/>
      <field name='utf8' type='UConverter *' info=' for conversion between UTF-8 and UTF-16'/>
    </struct>
    <typedef name='xlinkActuate' file='xlink' type='enum'/>
    <typedef name='xlinkHRef' file='xlink' type='xmlChar *'/>
    <struct name='xlinkHandler' file='xlink' type='struct _xlinkHandler'>
      <field name='simple' type='xlinkSimpleLinkFunk' info=''/>
      <field name='extended' type='xlinkExtendedLinkFunk' info=''/>
      <field name='set' type='xlinkExtendedLinkSetFunk' info=''/>
    </struct>
    <typedef name='xlinkHandlerPtr' file='xlink' type='xlinkHandler *'/>
    <typedef name='xlinkRole' file='xlink' type='xmlChar *'/>
    <typedef name='xlinkShow' file='xlink' type='enum'/>
    <typedef name='xlinkTitle' file='xlink' type='xmlChar *'/>
    <typedef name='xlinkType' file='xlink' type='enum'/>
    <struct name='xmlAttr' file='tree' type='struct _xmlAttr'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_ATTRIBUTE_NODE, must be second !'/>
      <field name='name' type='const xmlChar *' info=' the name of the property'/>
      <field name='children' type='struct _xmlNode *' info=' the value of the property'/>
      <field name='last' type='struct _xmlNode *' info=' NULL'/>
      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
      <field name='next' type='struct _xmlAttr *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlAttr *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
      <field name='ns' type='xmlNs *' info=' pointer to the associated namespace'/>
      <field name='atype' type='xmlAttributeType' info=' the attribute type if validating'/>
      <field name='psvi' type='void *' info=' for type/PSVI informations'/>
    </struct>
    <typedef name='xmlAttrPtr' file='tree' type='xmlAttr *'/>
    <struct name='xmlAttribute' file='tree' type='struct _xmlAttribute'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_ATTRIBUTE_DECL, must be second !'/>
      <field name='name' type='const xmlChar *' info=' Attribute name'/>
      <field name='children' type='struct _xmlNode *' info=' NULL'/>
      <field name='last' type='struct _xmlNode *' info=' NULL'/>
      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
      <field name='nexth' type='struct _xmlAttribute *' info=' next in hash table'/>
      <field name='atype' type='xmlAttributeType' info=' The attribute type'/>
      <field name='def' type='xmlAttributeDefault' info=' the default'/>
      <field name='defaultValue' type='const xmlChar *' info=' or the default value'/>
      <field name='tree' type='xmlEnumerationPtr' info=' or the enumeration tree if any'/>
      <field name='prefix' type='const xmlChar *' info=' the namespace prefix if any'/>
      <field name='elem' type='const xmlChar *' info=' Element holding the attribute'/>
    </struct>
    <typedef name='xmlAttributeDefault' file='tree' type='enum'/>
    <typedef name='xmlAttributePtr' file='tree' type='xmlAttribute *'/>
    <struct name='xmlAttributeTable' file='valid' type='struct _xmlHashTable'/>
    <typedef name='xmlAttributeTablePtr' file='valid' type='xmlAttributeTable *'/>
    <typedef name='xmlAttributeType' file='tree' type='enum'/>
    <struct name='xmlAutomata' file='xmlautomata' type='struct _xmlAutomata'/>
    <typedef name='xmlAutomataPtr' file='xmlautomata' type='xmlAutomata *'>
      <info>A libxml automata description, It can be compiled into a regexp</info>
    </typedef>
    <struct name='xmlAutomataState' file='xmlautomata' type='struct _xmlAutomataState'/>
    <typedef name='xmlAutomataStatePtr' file='xmlautomata' type='xmlAutomataState *'>
      <info>A state int the automata description,</info>
    </typedef>
    <struct name='xmlBuf' file='tree' type='struct _xmlBuf'/>
    <typedef name='xmlBufPtr' file='tree' type='xmlBuf *'>
      <info>A pointer to a buffer structure, the actual structure internals are not public</info>
    </typedef>
    <struct name='xmlBuffer' file='tree' type='struct _xmlBuffer'>
      <field name='content' type='xmlChar *' info=' The buffer content UTF8'/>
      <field name='use' type='unsigned int' info=' The buffer size used'/>
      <field name='size' type='unsigned int' info=' The buffer size'/>
      <field name='alloc' type='xmlBufferAllocationScheme' info=' The realloc method'/>
      <field name='contentIO' type='xmlChar *' info=' in IO mode we may have a different base'/>
    </struct>
    <typedef name='xmlBufferAllocationScheme' file='tree' type='enum'/>
    <typedef name='xmlBufferPtr' file='tree' type='xmlBuffer *'/>
    <typedef name='xmlC14NMode' file='c14n' type='enum'/>
    <struct name='xmlCatalog' file='catalog' type='struct _xmlCatalog'/>
    <typedef name='xmlCatalogAllow' file='catalog' type='enum'/>
    <typedef name='xmlCatalogPrefer' file='catalog' type='enum'/>
    <typedef name='xmlCatalogPtr' file='catalog' type='xmlCatalog *'/>
    <struct name='xmlChLRange' file='chvalid' type='struct _xmlChLRange'>
      <field name='low' type='unsigned int' info=''/>
      <field name='high' type='unsigned int' info=''/>
    </struct>
    <typedef name='xmlChLRangePtr' file='chvalid' type='xmlChLRange *'/>
    <struct name='xmlChRangeGroup' file='chvalid' type='struct _xmlChRangeGroup'>
      <field name='nbShortRange' type='int' info=''/>
      <field name='nbLongRange' type='int' info=''/>
      <field name='shortRange' type='const xmlChSRange *' info=' points to an array of ranges'/>
      <field name='longRange' type='const xmlChLRange *' info=''/>
    </struct>
    <typedef name='xmlChRangeGroupPtr' file='chvalid' type='xmlChRangeGroup *'/>
    <struct name='xmlChSRange' file='chvalid' type='struct _xmlChSRange'>
      <field name='low' type='unsigned short' info=''/>
      <field name='high' type='unsigned short' info=''/>
    </struct>
    <typedef name='xmlChSRangePtr' file='chvalid' type='xmlChSRange *'/>
    <typedef name='xmlChar' file='xmlstring' type='unsigned char'>
      <info>This is a basic byte in an UTF-8 encoded string. It&apos;s unsigned allowing to pinpoint case where char * are assigned to xmlChar * (possibly making serialization back impossible).</info>
    </typedef>
    <typedef name='xmlCharEncoding' file='encoding' type='enum'/>
    <struct name='xmlCharEncodingHandler' file='encoding' type='struct _xmlCharEncodingHandler'>
      <field name='name' type='char *' info=''/>
      <field name='input' type='xmlCharEncodingInputFunc' info=''/>
      <field name='output' type='xmlCharEncodingOutputFunc' info=''/>
      <field name='iconv_in' type='iconv_t' info=''/>
      <field name='iconv_out' type='iconv_t' info=''/>
      <field name='uconv_in' type='uconv_t *' info=''/>
      <field name='uconv_out' type='uconv_t *' info=''/>
    </struct>
    <typedef name='xmlCharEncodingHandlerPtr' file='encoding' type='xmlCharEncodingHandler *'/>
    <struct name='xmlDOMWrapCtxt' file='tree' type='struct _xmlDOMWrapCtxt'>
      <field name='_private' type='void *' info='* The type of this context, just in case we need specialized
* contexts in the future.
*'/>
      <field name='type' type='int' info='* Internal namespace map used for various operations.
*'/>
      <field name='namespaceMap' type='void *' info='* Use this one to acquire an xmlNsPtr intended for node-&gt;ns.
* (Note that this is not intended for elem-&gt;nsDef).
*'/>
      <field name='getNsForNodeFunc' type='xmlDOMWrapAcquireNsFunction' info=''/>
    </struct>
    <typedef name='xmlDOMWrapCtxtPtr' file='tree' type='xmlDOMWrapCtxt *'/>
    <struct name='xmlDict' file='dict' type='struct _xmlDict'/>
    <typedef name='xmlDictPtr' file='dict' type='xmlDict *'/>
    <struct name='xmlDoc' file='tree' type='struct _xmlDoc'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_DOCUMENT_NODE, must be second !'/>
      <field name='name' type='char *' info=' name/filename/URI of the document'/>
      <field name='children' type='struct _xmlNode *' info=' the document tree'/>
      <field name='last' type='struct _xmlNode *' info=' last child link'/>
      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' autoreference to itself End of common part'/>
      <field name='compression' type='int' info=' level of zlib compression'/>
      <field name='standalone' type='int' info=' standalone document (no external refs)
1 if standalone=&quot;yes&quot;
0 if standalone=&quot;no&quot;
-1 if there is no XML declaration
-2 if there is an XML declaration, but no
standalone attribute was specified'/>
      <field name='intSubset' type='struct _xmlDtd *' info=' the document internal subset'/>
      <field name='extSubset' type='struct _xmlDtd *' info=' the document external subset'/>
      <field name='oldNs' type='struct _xmlNs *' info=' Global namespace, the old way'/>
      <field name='version' type='const xmlChar *' info=' the XML version string'/>
      <field name='encoding' type='const xmlChar *' info=' external initial encoding, if any'/>
      <field name='ids' type='void *' info=' Hash table for ID attributes if any'/>
      <field name='refs' type='void *' info=' Hash table for IDREFs attributes if any'/>
      <field name='URL' type='const xmlChar *' info=' The URI for that document'/>
      <field name='charset' type='int' info=' encoding of the in-memory content
actually an xmlCharEncoding'/>
      <field name='dict' type='struct _xmlDict *' info=' dict used to allocate names or NULL'/>
      <field name='psvi' type='void *' info=' for type/PSVI informations'/>
      <field name='parseFlags' type='int' info=' set of xmlParserOption used to parse the
document'/>
      <field name='properties' type='int' info=' set of xmlDocProperties for this document
set at the end of parsing'/>
    </struct>
    <typedef name='xmlDocProperties' file='tree' type='enum'/>
    <typedef name='xmlDocPtr' file='tree' type='xmlDoc *'/>
    <struct name='xmlDtd' file='tree' type='struct _xmlDtd'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_DTD_NODE, must be second !'/>
      <field name='name' type='const xmlChar *' info=' Name of the DTD'/>
      <field name='children' type='struct _xmlNode *' info=' the value of the property link'/>
      <field name='last' type='struct _xmlNode *' info=' last child link'/>
      <field name='parent' type='struct _xmlDoc *' info=' child-&gt;parent link'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document End of common part'/>
      <field name='notations' type='void *' info=' Hash table for notations if any'/>
      <field name='elements' type='void *' info=' Hash table for elements if any'/>
      <field name='attributes' type='void *' info=' Hash table for attributes if any'/>
      <field name='entities' type='void *' info=' Hash table for entities if any'/>
      <field name='ExternalID' type='const xmlChar *' info=' External identifier for PUBLIC DTD'/>
      <field name='SystemID' type='const xmlChar *' info=' URI for a SYSTEM or PUBLIC DTD'/>
      <field name='pentities' type='void *' info=' Hash table for param entities if any'/>
    </struct>
    <typedef name='xmlDtdPtr' file='tree' type='xmlDtd *'/>
    <struct name='xmlElement' file='tree' type='struct _xmlElement'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_ELEMENT_DECL, must be second !'/>
      <field name='name' type='const xmlChar *' info=' Element name'/>
      <field name='children' type='struct _xmlNode *' info=' NULL'/>
      <field name='last' type='struct _xmlNode *' info=' NULL'/>
      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
      <field name='etype' type='xmlElementTypeVal' info=' The type'/>
      <field name='content' type='xmlElementContentPtr' info=' the allowed element content'/>
      <field name='attributes' type='xmlAttributePtr' info=' List of the declared attributes'/>
      <field name='prefix' type='const xmlChar *' info=' the namespace prefix if any'/>
      <field name='contModel' type='xmlRegexpPtr' info=' the validating regexp'/>
      <field name='contModel' type='void *' info=''/>
    </struct>
    <struct name='xmlElementContent' file='tree' type='struct _xmlElementContent'>
      <field name='type' type='xmlElementContentType' info=' PCDATA, ELEMENT, SEQ or OR'/>
      <field name='ocur' type='xmlElementContentOccur' info=' ONCE, OPT, MULT or PLUS'/>
      <field name='name' type='const xmlChar *' info=' Element name'/>
      <field name='c1' type='struct _xmlElementContent *' info=' first child'/>
      <field name='c2' type='struct _xmlElementContent *' info=' second child'/>
      <field name='parent' type='struct _xmlElementContent *' info=' parent'/>
      <field name='prefix' type='const xmlChar *' info=' Namespace prefix'/>
    </struct>
    <typedef name='xmlElementContentOccur' file='tree' type='enum'/>
    <typedef name='xmlElementContentPtr' file='tree' type='xmlElementContent *'/>
    <typedef name='xmlElementContentType' file='tree' type='enum'/>
    <typedef name='xmlElementPtr' file='tree' type='xmlElement *'/>
    <struct name='xmlElementTable' file='valid' type='struct _xmlHashTable'/>
    <typedef name='xmlElementTablePtr' file='valid' type='xmlElementTable *'/>
    <typedef name='xmlElementType' file='tree' type='enum'/>
    <typedef name='xmlElementTypeVal' file='tree' type='enum'/>
    <struct name='xmlEntitiesTable' file='entities' type='struct _xmlHashTable'/>
    <typedef name='xmlEntitiesTablePtr' file='entities' type='xmlEntitiesTable *'/>
    <struct name='xmlEntity' file='tree' type='struct _xmlEntity'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' XML_ENTITY_DECL, must be second !'/>
      <field name='name' type='const xmlChar *' info=' Entity name'/>
      <field name='children' type='struct _xmlNode *' info=' First child link'/>
      <field name='last' type='struct _xmlNode *' info=' Last child link'/>
      <field name='parent' type='struct _xmlDtd *' info=' -&gt; DTD'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document'/>
      <field name='orig' type='xmlChar *' info=' content without ref substitution'/>
      <field name='content' type='xmlChar *' info=' content or ndata if unparsed'/>
      <field name='length' type='int' info=' the content length'/>
      <field name='etype' type='xmlEntityType' info=' The entity type'/>
      <field name='ExternalID' type='const xmlChar *' info=' External identifier for PUBLIC'/>
      <field name='SystemID' type='const xmlChar *' info=' URI for a SYSTEM or PUBLIC Entity'/>
      <field name='nexte' type='struct _xmlEntity *' info=' unused'/>
      <field name='URI' type='const xmlChar *' info=' the full URI as computed'/>
      <field name='owner' type='int' info=' does the entity own the childrens'/>
      <field name='checked' type='int' info=' was the entity content checked this is also used to count entities
* references done from that entity
* and if it contains &apos;&lt;&apos;'/>
    </struct>
    <typedef name='xmlEntityPtr' file='tree' type='xmlEntity *'/>
    <typedef name='xmlEntityType' file='entities' type='enum'/>
    <struct name='xmlEnumeration' file='tree' type='struct _xmlEnumeration'>
      <field name='next' type='struct _xmlEnumeration *' info=' next one'/>
      <field name='name' type='const xmlChar *' info=' Enumeration name'/>
    </struct>
    <typedef name='xmlEnumerationPtr' file='tree' type='xmlEnumeration *'/>
    <struct name='xmlError' file='xmlerror' type='struct _xmlError'>
      <field name='domain' type='int' info=' What part of the library raised this error'/>
      <field name='code' type='int' info=' The error code, e.g. an xmlParserError'/>
      <field name='message' type='char *' info=' human-readable informative error message'/>
      <field name='level' type='xmlErrorLevel' info=' how consequent is the error'/>
      <field name='file' type='char *' info=' the filename'/>
      <field name='line' type='int' info=' the line number if available'/>
      <field name='str1' type='char *' info=' extra string information'/>
      <field name='str2' type='char *' info=' extra string information'/>
      <field name='str3' type='char *' info=' extra string information'/>
      <field name='int1' type='int' info=' extra number information'/>
      <field name='int2' type='int' info=' error column # or 0 if N/A (todo: rename field when we would brk ABI)'/>
      <field name='ctxt' type='void *' info=' the parser context if available'/>
      <field name='node' type='void *' info=' the node in the tree'/>
    </struct>
    <typedef name='xmlErrorDomain' file='xmlerror' type='enum'/>
    <typedef name='xmlErrorLevel' file='xmlerror' type='enum'/>
    <typedef name='xmlErrorPtr' file='xmlerror' type='xmlError *'/>
    <struct name='xmlExpCtxt' file='xmlregexp' type='struct _xmlExpCtxt'/>
    <typedef name='xmlExpCtxtPtr' file='xmlregexp' type='xmlExpCtxt *'/>
    <struct name='xmlExpNode' file='xmlregexp' type='struct _xmlExpNode'/>
    <typedef name='xmlExpNodePtr' file='xmlregexp' type='xmlExpNode *'/>
    <typedef name='xmlExpNodeType' file='xmlregexp' type='enum'/>
    <typedef name='xmlFeature' file='parser' type='enum'/>
    <struct name='xmlGlobalState' file='globals' type='struct _xmlGlobalState'>
      <field name='xmlParserVersion' type='const char *' info=''/>
      <field name='xmlDefaultSAXLocator' type='xmlSAXLocator' info=''/>
      <field name='xmlDefaultSAXHandler' type='xmlSAXHandlerV1' info=''/>
      <field name='docbDefaultSAXHandler' type='xmlSAXHandlerV1' info=''/>
      <field name='htmlDefaultSAXHandler' type='xmlSAXHandlerV1' info=''/>
      <field name='xmlFree' type='xmlFreeFunc' info=''/>
      <field name='xmlMalloc' type='xmlMallocFunc' info=''/>
      <field name='xmlMemStrdup' type='xmlStrdupFunc' info=''/>
      <field name='xmlRealloc' type='xmlReallocFunc' info=''/>
      <field name='xmlGenericError' type='xmlGenericErrorFunc' info=''/>
      <field name='xmlStructuredError' type='xmlStructuredErrorFunc' info=''/>
      <field name='xmlGenericErrorContext' type='void *' info=''/>
      <field name='oldXMLWDcompatibility' type='int' info=''/>
      <field name='xmlBufferAllocScheme' type='xmlBufferAllocationScheme' info=''/>
      <field name='xmlDefaultBufferSize' type='int' info=''/>
      <field name='xmlSubstituteEntitiesDefaultValue' type='int' info=''/>
      <field name='xmlDoValidityCheckingDefaultValue' type='int' info=''/>
      <field name='xmlGetWarningsDefaultValue' type='int' info=''/>
      <field name='xmlKeepBlanksDefaultValue' type='int' info=''/>
      <field name='xmlLineNumbersDefaultValue' type='int' info=''/>
      <field name='xmlLoadExtDtdDefaultValue' type='int' info=''/>
      <field name='xmlParserDebugEntities' type='int' info=''/>
      <field name='xmlPedanticParserDefaultValue' type='int' info=''/>
      <field name='xmlSaveNoEmptyTags' type='int' info=''/>
      <field name='xmlIndentTreeOutput' type='int' info=''/>
      <field name='xmlTreeIndentString' type='const char *' info=''/>
      <field name='xmlRegisterNodeDefaultValue' type='xmlRegisterNodeFunc' info=''/>
      <field name='xmlDeregisterNodeDefaultValue' type='xmlDeregisterNodeFunc' info=''/>
      <field name='xmlMallocAtomic' type='xmlMallocFunc' info=''/>
      <field name='xmlLastError' type='xmlError' info=''/>
      <field name='xmlParserInputBufferCreateFilenameValue' type='xmlParserInputBufferCreateFilenameFunc' info=''/>
      <field name='xmlOutputBufferCreateFilenameValue' type='xmlOutputBufferCreateFilenameFunc' info=''/>
      <field name='xmlStructuredErrorContext' type='void *' info=''/>
    </struct>
    <typedef name='xmlGlobalStatePtr' file='globals' type='xmlGlobalState *'/>
    <struct name='xmlHashTable' file='hash' type='struct _xmlHashTable'/>
    <typedef name='xmlHashTablePtr' file='hash' type='xmlHashTable *'/>
    <struct name='xmlID' file='tree' type='struct _xmlID'>
      <field name='next' type='struct _xmlID *' info=' next ID'/>
      <field name='value' type='const xmlChar *' info=' The ID name'/>
      <field name='attr' type='xmlAttrPtr' info=' The attribute holding it'/>
      <field name='name' type='const xmlChar *' info=' The attribute if attr is not available'/>
      <field name='lineno' type='int' info=' The line number if attr is not available'/>
      <field name='doc' type='struct _xmlDoc *' info=' The document holding the ID'/>
    </struct>
    <typedef name='xmlIDPtr' file='tree' type='xmlID *'/>
    <struct name='xmlIDTable' file='valid' type='struct _xmlHashTable'/>
    <typedef name='xmlIDTablePtr' file='valid' type='xmlIDTable *'/>
    <struct name='xmlLink' file='list' type='struct _xmlLink'/>
    <typedef name='xmlLinkPtr' file='list' type='xmlLink *'/>
    <struct name='xmlList' file='list' type='struct _xmlList'/>
    <typedef name='xmlListPtr' file='list' type='xmlList *'/>
    <struct name='xmlLocationSet' file='xpointer' type='struct _xmlLocationSet'>
      <field name='locNr' type='int' info=' number of locations in the set'/>
      <field name='locMax' type='int' info=' size of the array as allocated'/>
      <field name='locTab' type='xmlXPathObjectPtr *' info=' array of locations'/>
    </struct>
    <typedef name='xmlLocationSetPtr' file='xpointer' type='xmlLocationSet *'/>
    <struct name='xmlModule' file='xmlmodule' type='struct _xmlModule'/>
    <typedef name='xmlModuleOption' file='xmlmodule' type='enum'/>
    <typedef name='xmlModulePtr' file='xmlmodule' type='xmlModule *'>
      <info>A handle to a dynamically loaded module</info>
    </typedef>
    <struct name='xmlMutex' file='threads' type='struct _xmlMutex'/>
    <typedef name='xmlMutexPtr' file='threads' type='xmlMutex *'/>
    <struct name='xmlNode' file='tree' type='struct _xmlNode'>
      <field name='_private' type='void *' info=' application data'/>
      <field name='type' type='xmlElementType' info=' type number, must be second !'/>
      <field name='name' type='const xmlChar *' info=' the name of the node, or the entity'/>
      <field name='children' type='struct _xmlNode *' info=' parent-&gt;childs link'/>
      <field name='last' type='struct _xmlNode *' info=' last child link'/>
      <field name='parent' type='struct _xmlNode *' info=' child-&gt;parent link'/>
      <field name='next' type='struct _xmlNode *' info=' next sibling link '/>
      <field name='prev' type='struct _xmlNode *' info=' previous sibling link '/>
      <field name='doc' type='struct _xmlDoc *' info=' the containing document End of common part'/>
      <field name='ns' type='xmlNs *' info=' pointer to the associated namespace'/>
      <field name='content' type='xmlChar *' info=' the content'/>
      <field name='properties' type='struct _xmlAttr *' info=' properties list'/>
      <field name='nsDef' type='xmlNs *' info=' namespace definitions on this node'/>
      <field name='psvi' type='void *' info=' for type/PSVI informations'/>
      <field name='line' type='unsigned short' info=' line number'/>
      <field name='extra' type='unsigned short' info=' extra data for XPath/XSLT'/>
    </struct>
    <typedef name='xmlNodePtr' file='tree' type='xmlNode *'/>
    <struct name='xmlNodeSet' file='xpath' type='struct _xmlNodeSet'>
      <field name='nodeNr' type='int' info=' number of nodes in the set'/>
      <field name='nodeMax' type='int' info=' size of the array as allocated'/>
      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes in no particular order @@ with_ns to check wether namespace nodes should be looked at @@'/>
    </struct>
    <typedef name='xmlNodeSetPtr' file='xpath' type='xmlNodeSet *'/>
    <struct name='xmlNotation' file='tree' type='struct _xmlNotation'>
      <field name='name' type='const xmlChar *' info=' Notation name'/>
      <field name='PublicID' type='const xmlChar *' info=' Public identifier, if any'/>
      <field name='SystemID' type='const xmlChar *' info=' System identifier, if any'/>
    </struct>
    <typedef name='xmlNotationPtr' file='tree' type='xmlNotation *'/>
    <struct name='xmlNotationTable' file='valid' type='struct _xmlHashTable'/>
    <typedef name='xmlNotationTablePtr' file='valid' type='xmlNotationTable *'/>
    <struct name='xmlNs' file='tree' type='struct _xmlNs'>
      <field name='next' type='struct _xmlNs *' info=' next Ns link for this node '/>
      <field name='type' type='xmlNsType' info=' global or local'/>
      <field name='href' type='const xmlChar *' info=' URL for the namespace'/>
      <field name='prefix' type='const xmlChar *' info=' prefix for the namespace'/>
      <field name='_private' type='void *' info=' application data'/>
      <field name='context' type='struct _xmlDoc *' info=' normally an xmlDoc'/>
    </struct>
    <typedef name='xmlNsPtr' file='tree' type='xmlNs *'/>
    <typedef name='xmlNsType' file='tree' type='xmlElementType'/>
    <struct name='xmlOutputBuffer' file='tree' type='struct _xmlOutputBuffer'>
      <field name='context' type='void *' info=''/>
      <field name='writecallback' type='xmlOutputWriteCallback' info=''/>
      <field name='closecallback' type='xmlOutputCloseCallback' info=''/>
      <field name='encoder' type='xmlCharEncodingHandlerPtr' info=' I18N conversions to UTF-8'/>
      <field name='buffer' type='xmlBufPtr' info=' Local buffer encoded in UTF-8 or ISOLatin'/>
      <field name='conv' type='xmlBufPtr' info=' if encoder != NULL buffer for output'/>
      <field name='written' type='int' info=' total number of byte written'/>
      <field name='error' type='int' info=''/>
    </struct>
    <typedef name='xmlOutputBufferPtr' file='tree' type='xmlOutputBuffer *'/>
    <struct name='xmlParserCtxt' file='tree' type='struct _xmlParserCtxt'>
      <field name='sax' type='struct _xmlSAXHandler *' info=' The SAX handler'/>
      <field name='userData' type='void *' info=' For SAX interface only, used by DOM build'/>
      <field name='myDoc' type='xmlDocPtr' info=' the document being built'/>
      <field name='wellFormed' type='int' info=' is the document well formed'/>
      <field name='replaceEntities' type='int' info=' shall we replace entities ?'/>
      <field name='version' type='const xmlChar *' info=' the XML version string'/>
      <field name='encoding' type='const xmlChar *' info=' the declared encoding, if any'/>
      <field name='standalone' type='int' info=' standalone document'/>
      <field name='html' type='int' info=' an HTML(1)/Docbook(2) document
* 3 is HTML after &lt;head&gt;
* 10 is HTML after &lt;body&gt;
* Input stream stack'/>
      <field name='input' type='xmlParserInputPtr' info=' Current input stream'/>
      <field name='inputNr' type='int' info=' Number of current input streams'/>
      <field name='inputMax' type='int' info=' Max number of input streams'/>
      <field name='inputTab' type='xmlParserInputPtr *' info=' stack of inputs Node analysis stack only used for DOM building'/>
      <field name='node' type='xmlNodePtr' info=' Current parsed Node'/>
      <field name='nodeNr' type='int' info=' Depth of the parsing stack'/>
      <field name='nodeMax' type='int' info=' Max depth of the parsing stack'/>
      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes'/>
      <field name='record_info' type='int' info=' Whether node info should be kept'/>
      <field name='node_seq' type='xmlParserNodeInfoSeq' info=' info about each node parsed'/>
      <field name='errNo' type='int' info=' error code'/>
      <field name='hasExternalSubset' type='int' info=' reference and external subset'/>
      <field name='hasPErefs' type='int' info=' the internal subset has PE refs'/>
      <field name='external' type='int' info=' are we parsing an external entity'/>
      <field name='valid' type='int' info=' is the document valid'/>
      <field name='validate' type='int' info=' shall we try to validate ?'/>
      <field name='vctxt' type='xmlValidCtxt' info=' The validity context'/>
      <field name='instate' type='xmlParserInputState' info=' current type of input'/>
      <field name='token' type='int' info=' next char look-ahead'/>
      <field name='directory' type='char *' info=' the data directory Node name stack'/>
      <field name='name' type='const xmlChar *' info=' Current parsed Node'/>
      <field name='nameNr' type='int' info=' Depth of the parsing stack'/>
      <field name='nameMax' type='int' info=' Max depth of the parsing stack'/>
      <field name='nameTab' type='const xmlChar * *' info=' array of nodes'/>
      <field name='nbChars' type='long' info=' number of xmlChar processed'/>
      <field name='checkIndex' type='long' info=' used by progressive parsing lookup'/>
      <field name='keepBlanks' type='int' info=' ugly but ...'/>
      <field name='disableSAX' type='int' info=' SAX callbacks are disabled'/>
      <field name='inSubset' type='int' info=' Parsing is in int 1/ext 2 subset'/>
      <field name='intSubName' type='const xmlChar *' info=' name of subset'/>
      <field name='extSubURI' type='xmlChar *' info=' URI of external subset'/>
      <field name='extSubSystem' type='xmlChar *' info=' SYSTEM ID of external subset xml:space values'/>
      <field name='space' type='int *' info=' Should the parser preserve spaces'/>
      <field name='spaceNr' type='int' info=' Depth of the parsing stack'/>
      <field name='spaceMax' type='int' info=' Max depth of the parsing stack'/>
      <field name='spaceTab' type='int *' info=' array of space infos'/>
      <field name='depth' type='int' info=' to prevent entity substitution loops'/>
      <field name='entity' type='xmlParserInputPtr' info=' used to check entities boundaries'/>
      <field name='charset' type='int' info=' encoding of the in-memory content
actually an xmlCharEncoding'/>
      <field name='nodelen' type='int' info=' Those two fields are there to'/>
      <field name='nodemem' type='int' info=' Speed up large node parsing'/>
      <field name='pedantic' type='int' info=' signal pedantic warnings'/>
      <field name='_private' type='void *' info=' For user data, libxml won&apos;t touch it'/>
      <field name='loadsubset' type='int' info=' should the external subset be loaded'/>
      <field name='linenumbers' type='int' info=' set line number in element content'/>
      <field name='catalogs' type='void *' info=' document&apos;s own catalog'/>
      <field name='recovery' type='int' info=' run in recovery mode'/>
      <field name='progressive' type='int' info=' is this a progressive parsing'/>
      <field name='dict' type='xmlDictPtr' info=' dictionnary for the parser'/>
      <field name='atts' type='const xmlChar * *' info=' array for the attributes callbacks'/>
      <field name='maxatts' type='int' info=' the size of the array'/>
      <field name='docdict' type='int' info='* pre-interned strings
*'/>
      <field name='str_xml' type='const xmlChar *' info=''/>
      <field name='str_xmlns' type='const xmlChar *' info=''/>
      <field name='str_xml_ns' type='const xmlChar *' info='* Everything below is used only by the new SAX mode
*'/>
      <field name='sax2' type='int' info=' operating in the new SAX mode'/>
      <field name='nsNr' type='int' info=' the number of inherited namespaces'/>
      <field name='nsMax' type='int' info=' the size of the arrays'/>
      <field name='nsTab' type='const xmlChar * *' info=' the array of prefix/namespace name'/>
      <field name='attallocs' type='int *' info=' which attribute were allocated'/>
      <field name='pushTab' type='void * *' info=' array of data for push'/>
      <field name='attsDefault' type='xmlHashTablePtr' info=' defaulted attributes if any'/>
      <field name='attsSpecial' type='xmlHashTablePtr' info=' non-CDATA attributes if any'/>
      <field name='nsWellFormed' type='int' info=' is the document XML Nanespace okay'/>
      <field name='options' type='int' info='* Those fields are needed only for treaming parsing so far
*'/>
      <field name='dictNames' type='int' info=' Use dictionary names for the tree'/>
      <field name='freeElemsNr' type='int' info=' number of freed element nodes'/>
      <field name='freeElems' type='xmlNodePtr' info=' List of freed element nodes'/>
      <field name='freeAttrsNr' type='int' info=' number of freed attributes nodes'/>
      <field name='freeAttrs' type='xmlAttrPtr' info='* the complete error informations for the last error.
*'/>
      <field name='lastError' type='xmlError' info=''/>
      <field name='parseMode' type='xmlParserMode' info=' the parser mode'/>
      <field name='nbentities' type='unsigned long' info=' number of entities references'/>
      <field name='sizeentities' type='unsigned long' info=' size of parsed entities for use by HTML non-recursive parser'/>
      <field name='nodeInfo' type='xmlParserNodeInfo *' info=' Current NodeInfo'/>
      <field name='nodeInfoNr' type='int' info=' Depth of the parsing stack'/>
      <field name='nodeInfoMax' type='int' info=' Max depth of the parsing stack'/>
      <field name='nodeInfoTab' type='xmlParserNodeInfo *' info=' array of nodeInfos'/>
      <field name='input_id' type='int' info=' we need to label inputs'/>
      <field name='sizeentcopy' type='unsigned long' info=' volume of entity copy'/>
    </struct>
    <typedef name='xmlParserCtxtPtr' file='tree' type='xmlParserCtxt *'/>
    <typedef name='xmlParserErrors' file='xmlerror' type='enum'/>
    <struct name='xmlParserInput' file='tree' type='struct _xmlParserInput'>
      <field name='buf' type='xmlParserInputBufferPtr' info=' UTF-8 encoded buffer'/>
      <field name='filename' type='const char *' info=' The file analyzed, if any'/>
      <field name='directory' type='const char *' info=' the directory/base of the file'/>
      <field name='base' type='const xmlChar *' info=' Base of the array to parse'/>
      <field name='cur' type='const xmlChar *' info=' Current char being parsed'/>
      <field name='end' type='const xmlChar *' info=' end of the array to parse'/>
      <field name='length' type='int' info=' length if known'/>
      <field name='line' type='int' info=' Current line'/>
      <field name='col' type='int' info='* NOTE: consumed is only tested for equality in the parser code,
*       so even if there is an overflow this should not give troubles
*       for parsing very large instances.
*'/>
      <field name='consumed' type='unsigned long' info=' How many xmlChars already consumed'/>
      <field name='free' type='xmlParserInputDeallocate' info=' function to deallocate the base'/>
      <field name='encoding' type='const xmlChar *' info=' the encoding string for entity'/>
      <field name='version' type='const xmlChar *' info=' the version string for entity'/>
      <field name='standalone' type='int' info=' Was that entity marked standalone'/>
      <field name='id' type='int' info=' an unique identifier for the entity'/>
    </struct>
    <struct name='xmlParserInputBuffer' file='tree' type='struct _xmlParserInputBuffer'>
      <field name='context' type='void *' info=''/>
      <field name='readcallback' type='xmlInputReadCallback' info=''/>
      <field name='closecallback' type='xmlInputCloseCallback' info=''/>
      <field name='encoder' type='xmlCharEncodingHandlerPtr' info=' I18N conversions to UTF-8'/>
      <field name='buffer' type='xmlBufPtr' info=' Local buffer encoded in UTF-8'/>
      <field name='raw' type='xmlBufPtr' info=' if encoder != NULL buffer for raw input'/>
      <field name='compressed' type='int' info=' -1=unknown, 0=not compressed, 1=compressed'/>
      <field name='error' type='int' info=''/>
      <field name='rawconsumed' type='unsigned long' info=' amount consumed from raw'/>
    </struct>
    <typedef name='xmlParserInputBufferPtr' file='tree' type='xmlParserInputBuffer *'/>
    <typedef name='xmlParserInputPtr' file='tree' type='xmlParserInput *'/>
    <typedef name='xmlParserInputState' file='parser' type='enum'/>
    <typedef name='xmlParserMode' file='parser' type='enum'/>
    <struct name='xmlParserNodeInfo' file='parser' type='struct _xmlParserNodeInfo'>
      <field name='node' type='const struct _xmlNode *' info=' Position &amp; line # that text that created the node begins &amp; ends on'/>
      <field name='begin_pos' type='unsigned long' info=''/>
      <field name='begin_line' type='unsigned long' info=''/>
      <field name='end_pos' type='unsigned long' info=''/>
      <field name='end_line' type='unsigned long' info=''/>
    </struct>
    <typedef name='xmlParserNodeInfoPtr' file='parser' type='xmlParserNodeInfo *'/>
    <struct name='xmlParserNodeInfoSeq' file='parser' type='struct _xmlParserNodeInfoSeq'>
      <field name='maximum' type='unsigned long' info=''/>
      <field name='length' type='unsigned long' info=''/>
      <field name='buffer' type='xmlParserNodeInfo *' info=''/>
    </struct>
    <typedef name='xmlParserNodeInfoSeqPtr' file='parser' type='xmlParserNodeInfoSeq *'/>
    <typedef name='xmlParserOption' file='parser' type='enum'/>
    <typedef name='xmlParserProperties' file='xmlreader' type='enum'/>
    <typedef name='xmlParserSeverities' file='xmlreader' type='enum'/>
    <struct name='xmlPattern' file='pattern' type='struct _xmlPattern'/>
    <typedef name='xmlPatternFlags' file='pattern' type='enum'/>
    <typedef name='xmlPatternPtr' file='pattern' type='xmlPattern *'/>
    <struct name='xmlRMutex' file='threads' type='struct _xmlRMutex'/>
    <typedef name='xmlRMutexPtr' file='threads' type='xmlRMutex *'/>
    <typedef name='xmlReaderTypes' file='xmlreader' type='enum'/>
    <struct name='xmlRef' file='tree' type='struct _xmlRef'>
      <field name='next' type='struct _xmlRef *' info=' next Ref'/>
      <field name='value' type='const xmlChar *' info=' The Ref name'/>
      <field name='attr' type='xmlAttrPtr' info=' The attribute holding it'/>
      <field name='name' type='const xmlChar *' info=' The attribute if attr is not available'/>
      <field name='lineno' type='int' info=' The line number if attr is not available'/>
    </struct>
    <typedef name='xmlRefPtr' file='tree' type='xmlRef *'/>
    <struct name='xmlRefTable' file='valid' type='struct _xmlHashTable'/>
    <typedef name='xmlRefTablePtr' file='valid' type='xmlRefTable *'/>
    <struct name='xmlRegExecCtxt' file='xmlregexp' type='struct _xmlRegExecCtxt'/>
    <typedef name='xmlRegExecCtxtPtr' file='xmlregexp' type='xmlRegExecCtxt *'>
      <info>A libxml progressive regular expression evaluation context</info>
    </typedef>
    <struct name='xmlRegexp' file='xmlregexp' type='struct _xmlRegexp'/>
    <typedef name='xmlRegexpPtr' file='xmlregexp' type='xmlRegexp *'>
      <info>A libxml regular expression, they can actually be far more complex thank the POSIX regex expressions.</info>
    </typedef>
    <struct name='xmlRelaxNG' file='relaxng' type='struct _xmlRelaxNG'/>
    <struct name='xmlRelaxNGParserCtxt' file='relaxng' type='struct _xmlRelaxNGParserCtxt'/>
    <typedef name='xmlRelaxNGParserCtxtPtr' file='relaxng' type='xmlRelaxNGParserCtxt *'/>
    <typedef name='xmlRelaxNGParserFlag' file='relaxng' type='enum'/>
    <typedef name='xmlRelaxNGPtr' file='relaxng' type='xmlRelaxNG *'/>
    <struct name='xmlRelaxNGValidCtxt' file='relaxng' type='struct _xmlRelaxNGValidCtxt'/>
    <typedef name='xmlRelaxNGValidCtxtPtr' file='relaxng' type='xmlRelaxNGValidCtxt *'/>
    <typedef name='xmlRelaxNGValidErr' file='relaxng' type='enum'/>
    <struct name='xmlSAXHandler' file='tree' type='struct _xmlSAXHandler'>
      <field name='internalSubset' type='internalSubsetSAXFunc' info=''/>
      <field name='isStandalone' type='isStandaloneSAXFunc' info=''/>
      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc' info=''/>
      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc' info=''/>
      <field name='resolveEntity' type='resolveEntitySAXFunc' info=''/>
      <field name='getEntity' type='getEntitySAXFunc' info=''/>
      <field name='entityDecl' type='entityDeclSAXFunc' info=''/>
      <field name='notationDecl' type='notationDeclSAXFunc' info=''/>
      <field name='attributeDecl' type='attributeDeclSAXFunc' info=''/>
      <field name='elementDecl' type='elementDeclSAXFunc' info=''/>
      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc' info=''/>
      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc' info=''/>
      <field name='startDocument' type='startDocumentSAXFunc' info=''/>
      <field name='endDocument' type='endDocumentSAXFunc' info=''/>
      <field name='startElement' type='startElementSAXFunc' info=''/>
      <field name='endElement' type='endElementSAXFunc' info=''/>
      <field name='reference' type='referenceSAXFunc' info=''/>
      <field name='characters' type='charactersSAXFunc' info=''/>
      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc' info=''/>
      <field name='processingInstruction' type='processingInstructionSAXFunc' info=''/>
      <field name='comment' type='commentSAXFunc' info=''/>
      <field name='warning' type='warningSAXFunc' info=''/>
      <field name='error' type='errorSAXFunc' info=''/>
      <field name='fatalError' type='fatalErrorSAXFunc' info=' unused error() get all the errors'/>
      <field name='getParameterEntity' type='getParameterEntitySAXFunc' info=''/>
      <field name='cdataBlock' type='cdataBlockSAXFunc' info=''/>
      <field name='externalSubset' type='externalSubsetSAXFunc' info=''/>
      <field name='initialized' type='unsigned int' info=' The following fields are extensions available only on version 2'/>
      <field name='_private' type='void *' info=''/>
      <field name='startElementNs' type='startElementNsSAX2Func' info=''/>
      <field name='endElementNs' type='endElementNsSAX2Func' info=''/>
      <field name='serror' type='xmlStructuredErrorFunc' info=''/>
    </struct>
    <typedef name='xmlSAXHandlerPtr' file='tree' type='xmlSAXHandler *'/>
    <struct name='xmlSAXHandlerV1' file='parser' type='struct _xmlSAXHandlerV1'>
      <field name='internalSubset' type='internalSubsetSAXFunc' info=''/>
      <field name='isStandalone' type='isStandaloneSAXFunc' info=''/>
      <field name='hasInternalSubset' type='hasInternalSubsetSAXFunc' info=''/>
      <field name='hasExternalSubset' type='hasExternalSubsetSAXFunc' info=''/>
      <field name='resolveEntity' type='resolveEntitySAXFunc' info=''/>
      <field name='getEntity' type='getEntitySAXFunc' info=''/>
      <field name='entityDecl' type='entityDeclSAXFunc' info=''/>
      <field name='notationDecl' type='notationDeclSAXFunc' info=''/>
      <field name='attributeDecl' type='attributeDeclSAXFunc' info=''/>
      <field name='elementDecl' type='elementDeclSAXFunc' info=''/>
      <field name='unparsedEntityDecl' type='unparsedEntityDeclSAXFunc' info=''/>
      <field name='setDocumentLocator' type='setDocumentLocatorSAXFunc' info=''/>
      <field name='startDocument' type='startDocumentSAXFunc' info=''/>
      <field name='endDocument' type='endDocumentSAXFunc' info=''/>
      <field name='startElement' type='startElementSAXFunc' info=''/>
      <field name='endElement' type='endElementSAXFunc' info=''/>
      <field name='reference' type='referenceSAXFunc' info=''/>
      <field name='characters' type='charactersSAXFunc' info=''/>
      <field name='ignorableWhitespace' type='ignorableWhitespaceSAXFunc' info=''/>
      <field name='processingInstruction' type='processingInstructionSAXFunc' info=''/>
      <field name='comment' type='commentSAXFunc' info=''/>
      <field name='warning' type='warningSAXFunc' info=''/>
      <field name='error' type='errorSAXFunc' info=''/>
      <field name='fatalError' type='fatalErrorSAXFunc' info=' unused error() get all the errors'/>
      <field name='getParameterEntity' type='getParameterEntitySAXFunc' info=''/>
      <field name='cdataBlock' type='cdataBlockSAXFunc' info=''/>
      <field name='externalSubset' type='externalSubsetSAXFunc' info=''/>
      <field name='initialized' type='unsigned int' info=''/>
    </struct>
    <typedef name='xmlSAXHandlerV1Ptr' file='parser' type='xmlSAXHandlerV1 *'/>
    <struct name='xmlSAXLocator' file='tree' type='struct _xmlSAXLocator'>
      <field name='getPublicId' type='const xmlChar *(*getPublicId)' info=''/>
      <field name='getSystemId' type='const xmlChar *(*getSystemId)' info=''/>
      <field name='getLineNumber' type='int(*getLineNumber)' info=''/>
      <field name='getColumnNumber' type='int(*getColumnNumber)' info=''/>
    </struct>
    <typedef name='xmlSAXLocatorPtr' file='tree' type='xmlSAXLocator *'/>
    <struct name='xmlSaveCtxt' file='xmlsave' type='struct _xmlSaveCtxt'/>
    <typedef name='xmlSaveCtxtPtr' file='xmlsave' type='xmlSaveCtxt *'/>
    <typedef name='xmlSaveOption' file='xmlsave' type='enum'/>
    <struct name='xmlSchema' file='xmlschemas' type='struct _xmlSchema'>
      <field name='name' type='const xmlChar *' info=' schema name'/>
      <field name='targetNamespace' type='const xmlChar *' info=' the target namespace'/>
      <field name='version' type='const xmlChar *' info=''/>
      <field name='id' type='const xmlChar *' info=' Obsolete'/>
      <field name='doc' type='xmlDocPtr' info=''/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='flags' type='int' info=''/>
      <field name='typeDecl' type='xmlHashTablePtr' info=''/>
      <field name='attrDecl' type='xmlHashTablePtr' info=''/>
      <field name='attrgrpDecl' type='xmlHashTablePtr' info=''/>
      <field name='elemDecl' type='xmlHashTablePtr' info=''/>
      <field name='notaDecl' type='xmlHashTablePtr' info=''/>
      <field name='schemasImports' type='xmlHashTablePtr' info=''/>
      <field name='_private' type='void *' info=' unused by the library for users or bindings'/>
      <field name='groupDecl' type='xmlHashTablePtr' info=''/>
      <field name='dict' type='xmlDictPtr' info=''/>
      <field name='includes' type='void *' info=' the includes, this is opaque for now'/>
      <field name='preserve' type='int' info=' whether to free the document'/>
      <field name='counter' type='int' info=' used to give ononymous components unique names'/>
      <field name='idcDef' type='xmlHashTablePtr' info=' All identity-constraint defs.'/>
      <field name='volatiles' type='void *' info=' Obsolete'/>
    </struct>
    <struct name='xmlSchemaAnnot' file='schemasInternals' type='struct _xmlSchemaAnnot'>
      <field name='next' type='struct _xmlSchemaAnnot *' info=''/>
      <field name='content' type='xmlNodePtr' info=' the annotation'/>
    </struct>
    <typedef name='xmlSchemaAnnotPtr' file='schemasInternals' type='xmlSchemaAnnot *'/>
    <struct name='xmlSchemaAttribute' file='schemasInternals' type='struct _xmlSchemaAttribute'>
      <field name='type' type='xmlSchemaTypeType' info=''/>
      <field name='next' type='struct _xmlSchemaAttribute *' info=' the next attribute (not used?)'/>
      <field name='name' type='const xmlChar *' info=' the name of the declaration'/>
      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='typeName' type='const xmlChar *' info=' the local name of the type definition'/>
      <field name='typeNs' type='const xmlChar *' info=' the ns URI of the type definition'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='base' type='xmlSchemaTypePtr' info=' Deprecated; not used'/>
      <field name='occurs' type='int' info=' Deprecated; not used'/>
      <field name='defValue' type='const xmlChar *' info=' The initial value of the value constraint'/>
      <field name='subtypes' type='xmlSchemaTypePtr' info=' the type definition'/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='targetNamespace' type='const xmlChar *' info=''/>
      <field name='flags' type='int' info=''/>
      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='defVal' type='xmlSchemaValPtr' info=' The compiled value constraint'/>
      <field name='refDecl' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
    </struct>
    <struct name='xmlSchemaAttributeGroup' file='schemasInternals' type='struct _xmlSchemaAttributeGroup'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='next' type='struct _xmlSchemaAttribute *' info=' the next attribute if in a group ...'/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='id' type='const xmlChar *' info=''/>
      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='attributes' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='flags' type='int' info=''/>
      <field name='attributeWildcard' type='xmlSchemaWildcardPtr' info=''/>
      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='refItem' type='xmlSchemaAttributeGroupPtr' info=' Deprecated; not used'/>
      <field name='targetNamespace' type='const xmlChar *' info=''/>
      <field name='attrUses' type='void *' info=''/>
    </struct>
    <typedef name='xmlSchemaAttributeGroupPtr' file='schemasInternals' type='xmlSchemaAttributeGroup *'/>
    <struct name='xmlSchemaAttributeLink' file='schemasInternals' type='struct _xmlSchemaAttributeLink'>
      <field name='next' type='struct _xmlSchemaAttributeLink *' info=' the next attribute link ...'/>
      <field name='attr' type='struct _xmlSchemaAttribute *' info=' the linked attribute'/>
    </struct>
    <typedef name='xmlSchemaAttributeLinkPtr' file='schemasInternals' type='xmlSchemaAttributeLink *'/>
    <typedef name='xmlSchemaAttributePtr' file='schemasInternals' type='xmlSchemaAttribute *'/>
    <typedef name='xmlSchemaContentType' file='schemasInternals' type='enum'/>
    <struct name='xmlSchemaElement' file='schemasInternals' type='struct _xmlSchemaElement'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='next' type='struct _xmlSchemaType *' info=' Not used?'/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='subtypes' type='xmlSchemaTypePtr' info=' the type definition'/>
      <field name='attributes' type='xmlSchemaAttributePtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
      <field name='flags' type='int' info=''/>
      <field name='targetNamespace' type='const xmlChar *' info=''/>
      <field name='namedType' type='const xmlChar *' info=''/>
      <field name='namedTypeNs' type='const xmlChar *' info=''/>
      <field name='substGroup' type='const xmlChar *' info=''/>
      <field name='substGroupNs' type='const xmlChar *' info=''/>
      <field name='scope' type='const xmlChar *' info=''/>
      <field name='value' type='const xmlChar *' info=' The original value of the value constraint.'/>
      <field name='refDecl' type='struct _xmlSchemaElement *' info=' This will now be used for the
substitution group affiliation'/>
      <field name='contModel' type='xmlRegexpPtr' info=' Obsolete for WXS, maybe used for RelaxNG'/>
      <field name='contentType' type='xmlSchemaContentType' info=''/>
      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='defVal' type='xmlSchemaValPtr' info=' The compiled value contraint.'/>
      <field name='idcs' type='void *' info=' The identity-constraint defs'/>
    </struct>
    <typedef name='xmlSchemaElementPtr' file='schemasInternals' type='xmlSchemaElement *'/>
    <struct name='xmlSchemaFacet' file='schemasInternals' type='struct _xmlSchemaFacet'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='next' type='struct _xmlSchemaFacet *' info=' the next type if in a sequence ...'/>
      <field name='value' type='const xmlChar *' info=' The original value'/>
      <field name='id' type='const xmlChar *' info=' Obsolete'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='fixed' type='int' info=' XML_SCHEMAS_FACET_PRESERVE, etc.'/>
      <field name='whitespace' type='int' info=''/>
      <field name='val' type='xmlSchemaValPtr' info=' The compiled value'/>
      <field name='regexp' type='xmlRegexpPtr' info=' The regex for patterns'/>
    </struct>
    <struct name='xmlSchemaFacetLink' file='schemasInternals' type='struct _xmlSchemaFacetLink'>
      <field name='next' type='struct _xmlSchemaFacetLink *' info=' the next facet link ...'/>
      <field name='facet' type='xmlSchemaFacetPtr' info=' the linked facet'/>
    </struct>
    <typedef name='xmlSchemaFacetLinkPtr' file='schemasInternals' type='xmlSchemaFacetLink *'/>
    <typedef name='xmlSchemaFacetPtr' file='schemasInternals' type='xmlSchemaFacet *'/>
    <struct name='xmlSchemaNotation' file='schemasInternals' type='struct _xmlSchemaNotation'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='identifier' type='const xmlChar *' info=''/>
      <field name='targetNamespace' type='const xmlChar *' info=''/>
    </struct>
    <typedef name='xmlSchemaNotationPtr' file='schemasInternals' type='xmlSchemaNotation *'/>
    <struct name='xmlSchemaParserCtxt' file='xmlschemas' type='struct _xmlSchemaParserCtxt'/>
    <typedef name='xmlSchemaParserCtxtPtr' file='xmlschemas' type='xmlSchemaParserCtxt *'/>
    <typedef name='xmlSchemaPtr' file='xmlschemas' type='xmlSchema *'/>
    <typedef name='xmlSchemaSAXPlugPtr' file='xmlschemas' type='xmlSchemaSAXPlugStruct *'/>
    <struct name='xmlSchemaSAXPlugStruct' file='xmlschemas' type='struct _xmlSchemaSAXPlug'/>
    <struct name='xmlSchemaType' file='schemasInternals' type='struct _xmlSchemaType'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='next' type='struct _xmlSchemaType *' info=' the next type if in a sequence ...'/>
      <field name='name' type='const xmlChar *' info=''/>
      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='ref' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='refNs' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='subtypes' type='xmlSchemaTypePtr' info=''/>
      <field name='attributes' type='xmlSchemaAttributePtr' info=' Deprecated; not used'/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
      <field name='flags' type='int' info=''/>
      <field name='contentType' type='xmlSchemaContentType' info=''/>
      <field name='base' type='const xmlChar *' info=' Base type&apos;s local name'/>
      <field name='baseNs' type='const xmlChar *' info=' Base type&apos;s target namespace'/>
      <field name='baseType' type='xmlSchemaTypePtr' info=' The base type component'/>
      <field name='facets' type='xmlSchemaFacetPtr' info=' Local facets'/>
      <field name='redef' type='struct _xmlSchemaType *' info=' Deprecated; not used'/>
      <field name='recurse' type='int' info=' Obsolete'/>
      <field name='attributeUses' type='xmlSchemaAttributeLinkPtr *' info=' Deprecated; not used'/>
      <field name='attributeWildcard' type='xmlSchemaWildcardPtr' info=''/>
      <field name='builtInType' type='int' info=' Type of built-in types.'/>
      <field name='memberTypes' type='xmlSchemaTypeLinkPtr' info=' member-types if a union type.'/>
      <field name='facetSet' type='xmlSchemaFacetLinkPtr' info=' All facets (incl. inherited)'/>
      <field name='refPrefix' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='contentTypeDef' type='xmlSchemaTypePtr' info=' Used for the simple content of complex types.
Could we use @subtypes for this?'/>
      <field name='contModel' type='xmlRegexpPtr' info=' Holds the automaton of the content model'/>
      <field name='targetNamespace' type='const xmlChar *' info=''/>
      <field name='attrUses' type='void *' info=''/>
    </struct>
    <struct name='xmlSchemaTypeLink' file='schemasInternals' type='struct _xmlSchemaTypeLink'>
      <field name='next' type='struct _xmlSchemaTypeLink *' info=' the next type link ...'/>
      <field name='type' type='xmlSchemaTypePtr' info=' the linked type'/>
    </struct>
    <typedef name='xmlSchemaTypeLinkPtr' file='schemasInternals' type='xmlSchemaTypeLink *'/>
    <typedef name='xmlSchemaTypePtr' file='schemasInternals' type='xmlSchemaType *'/>
    <typedef name='xmlSchemaTypeType' file='schemasInternals' type='enum'/>
    <struct name='xmlSchemaVal' file='schemasInternals' type='struct _xmlSchemaVal'/>
    <typedef name='xmlSchemaValPtr' file='schemasInternals' type='xmlSchemaVal *'/>
    <typedef name='xmlSchemaValType' file='schemasInternals' type='enum'/>
    <struct name='xmlSchemaValidCtxt' file='xmlschemas' type='struct _xmlSchemaValidCtxt'/>
    <typedef name='xmlSchemaValidCtxtPtr' file='xmlschemas' type='xmlSchemaValidCtxt *'/>
    <typedef name='xmlSchemaValidError' file='xmlschemas' type='enum'/>
    <typedef name='xmlSchemaValidOption' file='xmlschemas' type='enum'/>
    <typedef name='xmlSchemaWhitespaceValueType' file='xmlschemastypes' type='enum'/>
    <struct name='xmlSchemaWildcard' file='schemasInternals' type='struct _xmlSchemaWildcard'>
      <field name='type' type='xmlSchemaTypeType' info=' The kind of type'/>
      <field name='id' type='const xmlChar *' info=' Deprecated; not used'/>
      <field name='annot' type='xmlSchemaAnnotPtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='minOccurs' type='int' info=' Deprecated; not used'/>
      <field name='maxOccurs' type='int' info=' Deprecated; not used'/>
      <field name='processContents' type='int' info=''/>
      <field name='any' type='int' info=' Indicates if the ns constraint is of ##any'/>
      <field name='nsSet' type='xmlSchemaWildcardNsPtr' info=' The list of allowed namespaces'/>
      <field name='negNsSet' type='xmlSchemaWildcardNsPtr' info=' The negated namespace'/>
      <field name='flags' type='int' info=''/>
    </struct>
    <struct name='xmlSchemaWildcardNs' file='schemasInternals' type='struct _xmlSchemaWildcardNs'>
      <field name='next' type='struct _xmlSchemaWildcardNs *' info=' the next constraint link ...'/>
      <field name='value' type='const xmlChar *' info=' the value'/>
    </struct>
    <typedef name='xmlSchemaWildcardNsPtr' file='schemasInternals' type='xmlSchemaWildcardNs *'/>
    <typedef name='xmlSchemaWildcardPtr' file='schemasInternals' type='xmlSchemaWildcard *'/>
    <struct name='xmlSchematron' file='schematron' type='struct _xmlSchematron'/>
    <struct name='xmlSchematronParserCtxt' file='schematron' type='struct _xmlSchematronParserCtxt'/>
    <typedef name='xmlSchematronParserCtxtPtr' file='schematron' type='xmlSchematronParserCtxt *'/>
    <typedef name='xmlSchematronPtr' file='schematron' type='xmlSchematron *'/>
    <struct name='xmlSchematronValidCtxt' file='schematron' type='struct _xmlSchematronValidCtxt'/>
    <typedef name='xmlSchematronValidCtxtPtr' file='schematron' type='xmlSchematronValidCtxt *'/>
    <typedef name='xmlSchematronValidOptions' file='schematron' type='enum'/>
    <struct name='xmlShellCtxt' file='debugXML' type='struct _xmlShellCtxt'>
      <field name='filename' type='char *' info=''/>
      <field name='doc' type='xmlDocPtr' info=''/>
      <field name='node' type='xmlNodePtr' info=''/>
      <field name='pctxt' type='xmlXPathContextPtr' info=''/>
      <field name='loaded' type='int' info=''/>
      <field name='output' type='FILE *' info=''/>
      <field name='input' type='xmlShellReadlineFunc' info=''/>
    </struct>
    <typedef name='xmlShellCtxtPtr' file='debugXML' type='xmlShellCtxt *'/>
    <struct name='xmlStreamCtxt' file='pattern' type='struct _xmlStreamCtxt'/>
    <typedef name='xmlStreamCtxtPtr' file='pattern' type='xmlStreamCtxt *'/>
    <struct name='xmlTextReader' file='xmlreader' type='struct _xmlTextReader'/>
    <typedef name='xmlTextReaderLocatorPtr' file='xmlreader' type='void *'/>
    <typedef name='xmlTextReaderMode' file='xmlreader' type='enum'/>
    <typedef name='xmlTextReaderPtr' file='xmlreader' type='xmlTextReader *'>
      <info>Pointer to an xmlReader context.</info>
    </typedef>
    <struct name='xmlTextWriter' file='xmlwriter' type='struct _xmlTextWriter'/>
    <typedef name='xmlTextWriterPtr' file='xmlwriter' type='xmlTextWriter *'/>
    <struct name='xmlURI' file='uri' type='struct _xmlURI'>
      <field name='scheme' type='char *' info=' the URI scheme'/>
      <field name='opaque' type='char *' info=' opaque part'/>
      <field name='authority' type='char *' info=' the authority part'/>
      <field name='server' type='char *' info=' the server part'/>
      <field name='user' type='char *' info=' the user part'/>
      <field name='port' type='int' info=' the port number'/>
      <field name='path' type='char *' info=' the path string'/>
      <field name='query' type='char *' info=' the query string (deprecated - use with caution)'/>
      <field name='fragment' type='char *' info=' the fragment identifier'/>
      <field name='cleanup' type='int' info=' parsing potentially unclean URI'/>
      <field name='query_raw' type='char *' info=' the query string (as it appears in the URI)'/>
    </struct>
    <typedef name='xmlURIPtr' file='uri' type='xmlURI *'/>
    <struct name='xmlValidCtxt' file='valid' type='struct _xmlValidCtxt'>
      <field name='userData' type='void *' info=' user specific data block'/>
      <field name='error' type='xmlValidityErrorFunc' info=' the callback in case of errors'/>
      <field name='warning' type='xmlValidityWarningFunc' info=' the callback in case of warning Node analysis stack used when validating within entities'/>
      <field name='node' type='xmlNodePtr' info=' Current parsed Node'/>
      <field name='nodeNr' type='int' info=' Depth of the parsing stack'/>
      <field name='nodeMax' type='int' info=' Max depth of the parsing stack'/>
      <field name='nodeTab' type='xmlNodePtr *' info=' array of nodes'/>
      <field name='finishDtd' type='unsigned int' info=' finished validating the Dtd ?'/>
      <field name='doc' type='xmlDocPtr' info=' the document'/>
      <field name='valid' type='int' info=' temporary validity check result state state used for non-determinist content validation'/>
      <field name='vstate' type='xmlValidState *' info=' current state'/>
      <field name='vstateNr' type='int' info=' Depth of the validation stack'/>
      <field name='vstateMax' type='int' info=' Max depth of the validation stack'/>
      <field name='vstateTab' type='xmlValidState *' info=' array of validation states'/>
      <field name='am' type='xmlAutomataPtr' info=' the automata'/>
      <field name='state' type='xmlAutomataStatePtr' info=' used to build the automata'/>
      <field name='am' type='void *' info=''/>
      <field name='state' type='void *' info=''/>
    </struct>
    <typedef name='xmlValidCtxtPtr' file='valid' type='xmlValidCtxt *'/>
    <struct name='xmlValidState' file='valid' type='struct _xmlValidState'/>
    <typedef name='xmlValidStatePtr' file='valid' type='xmlValidState *'/>
    <struct name='xmlXIncludeCtxt' file='xinclude' type='struct _xmlXIncludeCtxt'/>
    <typedef name='xmlXIncludeCtxtPtr' file='xinclude' type='xmlXIncludeCtxt *'/>
    <struct name='xmlXPathAxis' file='xpath' type='struct _xmlXPathAxis'>
      <field name='name' type='const xmlChar *' info=' the axis name'/>
      <field name='func' type='xmlXPathAxisFunc' info=' the search function'/>
    </struct>
    <typedef name='xmlXPathAxisPtr' file='xpath' type='xmlXPathAxis *'/>
    <struct name='xmlXPathCompExpr' file='xpath' type='struct _xmlXPathCompExpr'/>
    <typedef name='xmlXPathCompExprPtr' file='xpath' type='xmlXPathCompExpr *'/>
    <struct name='xmlXPathContext' file='xpath' type='struct _xmlXPathContext'>
      <field name='doc' type='xmlDocPtr' info=' The current document'/>
      <field name='node' type='xmlNodePtr' info=' The current node'/>
      <field name='nb_variables_unused' type='int' info=' unused (hash table)'/>
      <field name='max_variables_unused' type='int' info=' unused (hash table)'/>
      <field name='varHash' type='xmlHashTablePtr' info=' Hash table of defined variables'/>
      <field name='nb_types' type='int' info=' number of defined types'/>
      <field name='max_types' type='int' info=' max number of types'/>
      <field name='types' type='xmlXPathTypePtr' info=' Array of defined types'/>
      <field name='nb_funcs_unused' type='int' info=' unused (hash table)'/>
      <field name='max_funcs_unused' type='int' info=' unused (hash table)'/>
      <field name='funcHash' type='xmlHashTablePtr' info=' Hash table of defined funcs'/>
      <field name='nb_axis' type='int' info=' number of defined axis'/>
      <field name='max_axis' type='int' info=' max number of axis'/>
      <field name='axis' type='xmlXPathAxisPtr' info=' Array of defined axis the namespace nodes of the context node'/>
      <field name='namespaces' type='xmlNsPtr *' info=' Array of namespaces'/>
      <field name='nsNr' type='int' info=' number of namespace in scope'/>
      <field name='user' type='void *' info=' function to free extra variables'/>
      <field name='contextSize' type='int' info=' the context size'/>
      <field name='proximityPosition' type='int' info=' the proximity position extra stuff for XPointer'/>
      <field name='xptr' type='int' info=' is this an XPointer context?'/>
      <field name='here' type='xmlNodePtr' info=' for here()'/>
      <field name='origin' type='xmlNodePtr' info=' for origin() the set of namespace declarations in scope for the expression'/>
      <field name='nsHash' type='xmlHashTablePtr' info=' The namespaces hash table'/>
      <field name='varLookupFunc' type='xmlXPathVariableLookupFunc' info=' variable lookup func'/>
      <field name='varLookupData' type='void *' info=' variable lookup data Possibility to link in an extra item'/>
      <field name='extra' type='void *' info=' needed for XSLT The function name and URI when calling a function'/>
      <field name='function' type='const xmlChar *' info=''/>
      <field name='functionURI' type='const xmlChar *' info=' function lookup function and data'/>
      <field name='funcLookupFunc' type='xmlXPathFuncLookupFunc' info=' function lookup func'/>
      <field name='funcLookupData' type='void *' info=' function lookup data temporary namespace lists kept for walking the namespace axis'/>
      <field name='tmpNsList' type='xmlNsPtr *' info=' Array of namespaces'/>
      <field name='tmpNsNr' type='int' info=' number of namespaces in scope error reporting mechanism'/>
      <field name='userData' type='void *' info=' user specific data block'/>
      <field name='error' type='xmlStructuredErrorFunc' info=' the callback in case of errors'/>
      <field name='lastError' type='xmlError' info=' the last error'/>
      <field name='debugNode' type='xmlNodePtr' info=' the source node XSLT dictionary'/>
      <field name='dict' type='xmlDictPtr' info=' dictionary if any'/>
      <field name='flags' type='int' info=' flags to control compilation Cache for reusal of XPath objects'/>
      <field name='cache' type='void *' info=''/>
    </struct>
    <typedef name='xmlXPathContextPtr' file='xpath' type='xmlXPathContext *'/>
    <typedef name='xmlXPathError' file='xpath' type='enum'/>
    <typedef name='xmlXPathFuncPtr' file='xpath' type='xmlXPathFunct *'/>
    <struct name='xmlXPathFunct' file='xpath' type='struct _xmlXPathFunct'>
      <field name='name' type='const xmlChar *' info=' the function name'/>
      <field name='func' type='xmlXPathEvalFunc' info=' the evaluation function'/>
    </struct>
    <struct name='xmlXPathObject' file='xpath' type='struct _xmlXPathObject'>
      <field name='type' type='xmlXPathObjectType' info=''/>
      <field name='nodesetval' type='xmlNodeSetPtr' info=''/>
      <field name='boolval' type='int' info=''/>
      <field name='floatval' type='double' info=''/>
      <field name='stringval' type='xmlChar *' info=''/>
      <field name='user' type='void *' info=''/>
      <field name='index' type='int' info=''/>
      <field name='user2' type='void *' info=''/>
      <field name='index2' type='int' info=''/>
    </struct>
    <typedef name='xmlXPathObjectPtr' file='xpath' type='xmlXPathObject *'/>
    <typedef name='xmlXPathObjectType' file='xpath' type='enum'/>
    <struct name='xmlXPathParserContext' file='xpath' type='struct _xmlXPathParserContext'>
      <field name='cur' type='const xmlChar *' info=' the current char being parsed'/>
      <field name='base' type='const xmlChar *' info=' the full expression'/>
      <field name='error' type='int' info=' error code'/>
      <field name='context' type='xmlXPathContextPtr' info=' the evaluation context'/>
      <field name='value' type='xmlXPathObjectPtr' info=' the current value'/>
      <field name='valueNr' type='int' info=' number of values stacked'/>
      <field name='valueMax' type='int' info=' max number of values stacked'/>
      <field name='valueTab' type='xmlXPathObjectPtr *' info=' stack of values'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' the precompiled expression'/>
      <field name='xptr' type='int' info=' it this an XPointer expression'/>
      <field name='ancestor' type='xmlNodePtr' info=' used for walking preceding axis'/>
      <field name='valueFrame' type='int' info=' used to limit Pop on the stack'/>
    </struct>
    <typedef name='xmlXPathParserContextPtr' file='xpath' type='xmlXPathParserContext *'/>
    <struct name='xmlXPathType' file='xpath' type='struct _xmlXPathType'>
      <field name='name' type='const xmlChar *' info=' the type name'/>
      <field name='func' type='xmlXPathConvertFunc' info=' the conversion function'/>
    </struct>
    <typedef name='xmlXPathTypePtr' file='xpath' type='xmlXPathType *'/>
    <struct name='xmlXPathVariable' file='xpath' type='struct _xmlXPathVariable'>
      <field name='name' type='const xmlChar *' info=' the variable name'/>
      <field name='value' type='xmlXPathObjectPtr' info=' the value'/>
    </struct>
    <typedef name='xmlXPathVariablePtr' file='xpath' type='xmlXPathVariable *'/>
    <variable name='docbDefaultSAXHandler' file='globals' type='xmlSAXHandlerV1'/>
    <variable name='emptyExp' file='xmlregexp' type='xmlExpNodePtr'/>
    <variable name='forbiddenExp' file='xmlregexp' type='xmlExpNodePtr'/>
    <variable name='htmlDefaultSAXHandler' file='globals' type='xmlSAXHandlerV1'/>
    <variable name='oldXMLWDcompatibility' file='globals' type='int'/>
    <variable name='xmlBufferAllocScheme' file='globals' type='xmlBufferAllocationScheme'/>
    <variable name='xmlDefaultBufferSize' file='globals' type='int'/>
    <variable name='xmlDefaultSAXHandler' file='globals' type='xmlSAXHandlerV1'/>
    <variable name='xmlDefaultSAXLocator' file='globals' type='xmlSAXLocator'/>
    <variable name='xmlDeregisterNodeDefaultValue' file='globals' type='xmlDeregisterNodeFunc'/>
    <variable name='xmlDoValidityCheckingDefaultValue' file='globals' type='int'/>
    <variable name='xmlFree' file='globals' type='xmlFreeFunc'/>
    <variable name='xmlGenericError' file='globals' type='xmlGenericErrorFunc'/>
    <variable name='xmlGenericErrorContext' file='globals' type='void *'/>
    <variable name='xmlGetWarningsDefaultValue' file='globals' type='int'/>
    <variable name='xmlIndentTreeOutput' file='globals' type='int'/>
    <variable name='xmlIsBaseCharGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsCharGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsCombiningGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsDigitGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsExtenderGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsIdeographicGroup' file='chvalid' type='const xmlChRangeGroup'/>
    <variable name='xmlIsPubidChar_tab' file='chvalid' type='const unsigned charxmlIsPubidChar_tab[256]'/>
    <variable name='xmlKeepBlanksDefaultValue' file='globals' type='int'/>
    <variable name='xmlLastError' file='globals' type='xmlError'/>
    <variable name='xmlLineNumbersDefaultValue' file='globals' type='int'/>
    <variable name='xmlLoadExtDtdDefaultValue' file='globals' type='int'/>
    <variable name='xmlMalloc' file='globals' type='xmlMallocFunc'/>
    <variable name='xmlMallocAtomic' file='globals' type='xmlMallocFunc'/>
    <variable name='xmlMemStrdup' file='globals' type='xmlStrdupFunc'/>
    <variable name='xmlOutputBufferCreateFilenameValue' file='globals' type='xmlOutputBufferCreateFilenameFunc'/>
    <variable name='xmlParserDebugEntities' file='globals' type='int'/>
    <variable name='xmlParserInputBufferCreateFilenameValue' file='globals' type='xmlParserInputBufferCreateFilenameFunc'/>
    <variable name='xmlParserMaxDepth' file='parserInternals' type='unsigned int'/>
    <variable name='xmlParserVersion' file='globals' type='const char *'/>
    <variable name='xmlPedanticParserDefaultValue' file='globals' type='int'/>
    <variable name='xmlRealloc' file='globals' type='xmlReallocFunc'/>
    <variable name='xmlRegisterNodeDefaultValue' file='globals' type='xmlRegisterNodeFunc'/>
    <variable name='xmlSaveNoEmptyTags' file='globals' type='int'/>
    <variable name='xmlStringComment' file='parserInternals' type='const xmlCharxmlStringComment[]'/>
    <variable name='xmlStringText' file='parserInternals' type='const xmlCharxmlStringText[]'/>
    <variable name='xmlStringTextNoenc' file='parserInternals' type='const xmlCharxmlStringTextNoenc[]'/>
    <variable name='xmlStructuredError' file='globals' type='xmlStructuredErrorFunc'/>
    <variable name='xmlStructuredErrorContext' file='globals' type='void *'/>
    <variable name='xmlSubstituteEntitiesDefaultValue' file='globals' type='int'/>
    <variable name='xmlTreeIndentString' file='globals' type='const char *'/>
    <variable name='xmlXPathNAN' file='xpath' type='double'/>
    <variable name='xmlXPathNINF' file='xpath' type='double'/>
    <variable name='xmlXPathPINF' file='xpath' type='double'/>
    <function name='UTF8ToHtml' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int' info='0 if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed as the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
    </function>
    <function name='UTF8Toisolat1' file='encoding' module='encoding'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1 block of chars out.</info>
      <return type='int' info='the number of bytes written if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
    </function>
    <function name='attribute' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element. DEPRECATED: use xmlSAX2Attribute()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='fullname' type='const xmlChar *' info='The attribute name, including namespace prefix'/>
      <arg name='value' type='const xmlChar *' info='The attribute value'/>
    </function>
    <function name='attributeDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>An attribute definition has been parsed DEPRECATED: use xmlSAX2AttributeDecl()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='elem' type='const xmlChar *' info='the name of the element'/>
      <arg name='fullname' type='const xmlChar *' info='the attribute name'/>
      <arg name='type' type='int' info='the attribute type'/>
      <arg name='def' type='int' info='the type of default value'/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value'/>
      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set'/>
    </function>
    <functype name='attributeDeclSAXFunc' file='parser' module='parser'>
      <info>An attribute definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='elem' type='const xmlChar *' info='the name of the element'/>
      <arg name='fullname' type='const xmlChar *' info='the attribute name'/>
      <arg name='type' type='int' info='the attribute type'/>
      <arg name='def' type='int' info='the type of default value'/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value'/>
      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set'/>
    </functype>
    <functype name='attributeSAXFunc' file='parser' module='parser'>
      <info>Handle an attribute that has been read by the parser. The default handling is to convert the attribute into an DOM subtree and past it in a new xmlAttr element added to the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The attribute name, including namespace prefix'/>
      <arg name='value' type='const xmlChar *' info='The attribute value'/>
    </functype>
    <function name='cdataBlock' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when a pcdata block has been parsed DEPRECATED: use xmlSAX2CDataBlock()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='The pcdata content'/>
      <arg name='len' type='int' info='the block length'/>
    </function>
    <functype name='cdataBlockSAXFunc' file='parser' module='parser'>
      <info>Called when a pcdata block has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='The pcdata content'/>
      <arg name='len' type='int' info='the block length'/>
    </functype>
    <function name='characters' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>receiving some chars from the parser. DEPRECATED: use xmlSAX2Characters()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </function>
    <functype name='charactersSAXFunc' file='parser' module='parser'>
      <info>Receiving some chars from the parser.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </functype>
    <function name='checkNamespace' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Check that the current element namespace is the same as the one read upon parsing. DEPRECATED</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='namespace' type='xmlChar *' info='the namespace to check against'/>
    </function>
    <function name='comment' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>A comment has been parsed. DEPRECATED: use xmlSAX2Comment()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='the comment content'/>
    </function>
    <functype name='commentSAXFunc' file='parser' module='parser'>
      <info>A comment has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='the comment content'/>
    </functype>
    <function name='docbCreateFileParserCtxt' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='the SGML document encoding, or NULL'/>
    </function>
    <function name='docbCreatePushParserCtxt' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Create a parser context for using the DocBook SGML parser in push mode To allow content encoding detection, @size should be &gt;= 4 The value of @filename is used for fetching external entities and error/warning reports.</info>
      <return type='docbParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='sax' type='docbSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars'/>
      <arg name='size' type='int' info='number of chars in the array'/>
      <arg name='filename' type='const char *' info='an optional file name or URI'/>
      <arg name='enc' type='xmlCharEncoding' info='an optional encoding'/>
    </function>
    <function name='docbDefaultSAXHandlerInit' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
    </function>
    <function name='docbEncodeEntities' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus SGML entities block of chars out.</info>
      <return type='int' info='0 if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed as the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
      <arg name='quoteChar' type='int' info='the quote character to escape (&apos; or &quot;) or zero.'/>
    </function>
    <function name='docbFreeParserCtxt' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an SGML parser context'/>
    </function>
    <function name='docbParseChunk' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise.'/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an XML parser context'/>
      <arg name='chunk' type='const char *' info='an char array'/>
      <arg name='size' type='int' info='the size in byte of the chunk'/>
      <arg name='terminate' type='int' info='last chunk indicator'/>
    </function>
    <function name='docbParseDoc' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>parse an SGML in-memory document and build a tree.</info>
      <return type='docbDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL'/>
    </function>
    <function name='docbParseDocument' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>parse an SGML document (and build a tree if using the standard SAX interface).</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing.'/>
      <arg name='ctxt' type='docbParserCtxtPtr' info='an SGML parser context'/>
    </function>
    <function name='docbParseFile' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>parse a Docbook SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='docbDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='a free form C string describing document encoding, or NULL'/>
    </function>
    <function name='docbSAXParseDoc' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>parse an SGML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL'/>
      <arg name='sax' type='docbSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks.'/>
    </function>
    <function name='docbSAXParseFile' file='DOCBparser' module='DOCBparser'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>parse an SGML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='docbDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the SGML document encoding, or NULL'/>
      <arg name='sax' type='docbSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks.'/>
    </function>
    <function name='elementDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>An element definition has been parsed DEPRECATED: use xmlSAX2ElementDecl()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='type' type='int' info='the element type'/>
      <arg name='content' type='xmlElementContentPtr' info='the element value tree'/>
    </function>
    <functype name='elementDeclSAXFunc' file='parser' module='parser'>
      <info>An element definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='type' type='int' info='the element type'/>
      <arg name='content' type='xmlElementContentPtr' info='the element value tree'/>
    </functype>
    <function name='endDocument' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when the document end has been detected. DEPRECATED: use xmlSAX2EndDocument()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <functype name='endDocumentSAXFunc' file='parser' module='parser'>
      <info>Called when the document end has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </functype>
    <function name='endElement' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when the end of an element has been detected. DEPRECATED: use xmlSAX2EndElement()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The element name'/>
    </function>
    <functype name='endElementNsSAX2Func' file='parser' module='parser'>
      <info>SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='localname' type='const xmlChar *' info='the local name of the element'/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix if available'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace name if available'/>
    </functype>
    <functype name='endElementSAXFunc' file='parser' module='parser'>
      <info>Called when the end of an element has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The element name'/>
    </functype>
    <function name='entityDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>An entity definition has been parsed DEPRECATED: use xmlSAX2EntityDecl()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='content' type='xmlChar *' info='the entity value (without processing).'/>
    </function>
    <functype name='entityDeclSAXFunc' file='parser' module='parser'>
      <info>An entity definition has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='content' type='xmlChar *' info='the entity value (without processing).'/>
    </functype>
    <functype name='errorSAXFunc' file='parser' module='parser'>
      <info>Display and format an error messages, callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </functype>
    <function name='externalSubset' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Callback on external subset declaration. DEPRECATED: use xmlSAX2ExternalSubset()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </function>
    <functype name='externalSubsetSAXFunc' file='parser' module='parser'>
      <info>Callback on external subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </functype>
    <functype name='fatalErrorSAXFunc' file='parser' module='parser'>
      <info>Display and format fatal error messages, callback. Note: so far fatalError() SAX callbacks are not used, error() get all the callbacks for errors.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </functype>
    <functype name='ftpDataCallback' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>A callback for the xmlNanoFTPGet command.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='the user provided context'/>
      <arg name='data' type='const char *' info='the data received'/>
      <arg name='len' type='int' info='its size in bytes'/>
    </functype>
    <functype name='ftpListCallback' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>A callback for the xmlNanoFTPList command. Note that only one of year and day:minute are specified.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the callback'/>
      <arg name='filename' type='const char *' info='the file name (including &quot;-&gt;&quot; when links are shown)'/>
      <arg name='attrib' type='const char *' info='the attribute string'/>
      <arg name='owner' type='const char *' info='the owner string'/>
      <arg name='group' type='const char *' info='the group string'/>
      <arg name='size' type='unsigned long' info='the file size'/>
      <arg name='links' type='int' info='the link count'/>
      <arg name='year' type='int' info='the year'/>
      <arg name='month' type='const char *' info='the month'/>
      <arg name='day' type='int' info='the day'/>
      <arg name='hour' type='int' info='the hour'/>
      <arg name='minute' type='int' info='the minute'/>
    </functype>
    <function name='getColumnNumber' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Provide the column number of the current parsing point. DEPRECATED: use xmlSAX2GetColumnNumber()</info>
      <return type='int' info='an int'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='getEntity' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Get an entity by name DEPRECATED: use xmlSAX2GetEntity()</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <functype name='getEntitySAXFunc' file='parser' module='parser'>
      <info>Get an entity by name.</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </functype>
    <function name='getLineNumber' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Provide the line number of the current parsing point. DEPRECATED: use xmlSAX2GetLineNumber()</info>
      <return type='int' info='an int'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='getNamespace' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Get the current element namespace. DEPRECATED</info>
      <return type='xmlNsPtr' info='the xmlNsPtr or NULL if none'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='getParameterEntity' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Get a parameter entity by name DEPRECATED: use xmlSAX2GetParameterEntity()</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <functype name='getParameterEntitySAXFunc' file='parser' module='parser'>
      <info>Get a parameter entity by name.</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </functype>
    <function name='getPublicId' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Provides the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot; DEPRECATED: use xmlSAX2GetPublicId()</info>
      <return type='const xmlChar *' info='a xmlChar *'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='getSystemId' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Provides the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd DEPRECATED: use xmlSAX2GetSystemId()</info>
      <return type='const xmlChar *' info='a xmlChar *'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='globalNamespace' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>An old global namespace has been parsed. DEPRECATED</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='href' type='const xmlChar *' info='the namespace associated URN'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix'/>
    </function>
    <function name='hasExternalSubset' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Does this document has an external subset DEPRECATED: use xmlSAX2HasExternalSubset()</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <functype name='hasExternalSubsetSAXFunc' file='parser' module='parser'>
      <info>Does this document has an external subset?</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </functype>
    <function name='hasInternalSubset' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Does this document has an internal subset DEPRECATED: use xmlSAX2HasInternalSubset()</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <functype name='hasInternalSubsetSAXFunc' file='parser' module='parser'>
      <info>Does this document has an internal subset.</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </functype>
    <function name='htmlAttrAllowed' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Checks whether an attribute is valid for an element Has full knowledge of Required and Deprecated attributes</info>
      <return type='htmlStatus' info='one of HTML_REQUIRED, HTML_VALID, HTML_DEPRECATED, HTML_INVALID'/>
      <arg name='elt' type='const htmlElemDesc *' info='HTML element'/>
      <arg name='attr' type='const xmlChar *' info='HTML attribute'/>
      <arg name='legacy' type='int' info='whether to allow deprecated attributes'/>
    </function>
    <function name='htmlAutoCloseTag' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if the element or one of it&apos;s children would autoclose the given tag.</info>
      <return type='int' info='1 if autoclose, 0 otherwise'/>
      <arg name='doc' type='htmlDocPtr' info='the HTML document'/>
      <arg name='name' type='const xmlChar *' info='The tag name'/>
      <arg name='elem' type='htmlNodePtr' info='the HTML element'/>
    </function>
    <function name='htmlCreateFileParserCtxt' file='parserInternals' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL'/>
    </function>
    <function name='htmlCreateMemoryParserCtxt' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Create a parser context for an HTML in-memory document.</info>
      <return type='htmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='htmlCreatePushParserCtxt' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_PUSH_ENABLED)</cond>
      <info>Create a parser context for using the HTML parser in push mode The value of @filename is used for fetching external entities and error/warning reports.</info>
      <return type='htmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars'/>
      <arg name='size' type='int' info='number of chars in the array'/>
      <arg name='filename' type='const char *' info='an optional file name or URI'/>
      <arg name='enc' type='xmlCharEncoding' info='an optional encoding'/>
    </function>
    <function name='htmlCtxtReadDoc' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlCtxtReadFd' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML from a file descriptor and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlCtxtReadFile' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML file from the filesystem or the network. This reuses the existing @ctxt parser context</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlCtxtReadIO' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML document from I/O functions and source and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlCtxtReadMemory' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlCtxtReset' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Reset a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
    </function>
    <function name='htmlCtxtUseOptions' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Applies the options to the parser context</info>
      <return type='int' info='0 in case of success, the set of unknown or unimplemented options in case of error.'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlDefaultSAXHandlerInit' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Initialize the default SAX handler</info>
      <return type='void'/>
    </function>
    <function name='htmlDocContentDumpFormatOutput' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the encoding string'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='htmlDocContentDumpOutput' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document. Formating return/spaces are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the encoding string'/>
    </function>
    <function name='htmlDocDump' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document to an open FILE.</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='f' type='FILE *' info='the FILE*'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='htmlDocDumpMemory' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document in memory and return the xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer'/>
      <arg name='size' type='int *' info='OUT: the memory length'/>
    </function>
    <function name='htmlDocDumpMemoryFormat' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document in memory and return the xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer'/>
      <arg name='size' type='int *' info='OUT: the memory length'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='htmlElementAllowedHere' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Checks whether an HTML element may be a direct child of a parent element. Note - doesn&apos;t check for deprecated elements</info>
      <return type='int' info='1 if allowed; 0 otherwise.'/>
      <arg name='parent' type='const htmlElemDesc *' info='HTML parent element'/>
      <arg name='elt' type='const xmlChar *' info='HTML element'/>
    </function>
    <function name='htmlElementStatusHere' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Checks whether an HTML element may be a direct child of a parent element. and if so whether it is valid or deprecated.</info>
      <return type='htmlStatus' info='one of HTML_VALID, HTML_DEPRECATED, HTML_INVALID'/>
      <arg name='parent' type='const htmlElemDesc *' info='HTML parent element'/>
      <arg name='elt' type='const htmlElemDesc *' info='HTML element'/>
    </function>
    <function name='htmlEncodeEntities' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Take a block of UTF-8 chars in and try to convert it to an ASCII plus HTML entities block of chars out.</info>
      <return type='int' info='0 if success, -2 if the transcoding fails, or -1 otherwise The value of @inlen after return is the number of octets consumed as the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
      <arg name='quoteChar' type='int' info='the quote character to escape (&apos; or &quot;) or zero.'/>
    </function>
    <function name='htmlEntityLookup' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Lookup the given entity in EntitiesTable  TODO: the linear scan is really ugly, an hash table is really needed.</info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
    </function>
    <function name='htmlEntityValueLookup' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Lookup the given entity in EntitiesTable  TODO: the linear scan is really ugly, an hash table is really needed.</info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, NULL otherwise.'/>
      <arg name='value' type='unsigned int' info='the entity&apos;s unicode value'/>
    </function>
    <function name='htmlFreeParserCtxt' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
    </function>
    <function name='htmlGetMetaEncoding' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Encoding definition lookup in the Meta tags</info>
      <return type='const xmlChar *' info='the current encoding as flagged in the HTML source'/>
      <arg name='doc' type='htmlDocPtr' info='the document'/>
    </function>
    <function name='htmlHandleOmittedElem' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Set and return the previous value for handling HTML omitted tags.</info>
      <return type='int' info='the last value for 0 for no handling, 1 for auto insertion.'/>
      <arg name='val' type='int' info='int 0 or 1'/>
    </function>
    <function name='htmlInitAutoClose' file='parserInternals' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Initialize the htmlStartCloseIndex for fast lookup of closing tags names. This is not reentrant. Call xmlInitParser() once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
    </function>
    <function name='htmlIsAutoClosed' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>The HTML DTD allows a tag to implicitly close other tags. The list is kept in htmlStartClose array. This function checks if a tag is autoclosed by one of it&apos;s child</info>
      <return type='int' info='1 if autoclosed, 0 otherwise'/>
      <arg name='doc' type='htmlDocPtr' info='the HTML document'/>
      <arg name='elem' type='htmlNodePtr' info='the HTML element'/>
    </function>
    <function name='htmlIsBooleanAttr' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Determine if a given attribute is a boolean attribute.</info>
      <return type='int' info='false if the attribute is not boolean, true otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute to check'/>
    </function>
    <function name='htmlIsScriptAttribute' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Check if an attribute is of content type Script</info>
      <return type='int' info='1 is the attribute is a script 0 otherwise'/>
      <arg name='name' type='const xmlChar *' info='an attribute name'/>
    </function>
    <function name='htmlNewDoc' file='HTMLtree' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Creates a new HTML document</info>
      <return type='htmlDocPtr' info='a new document'/>
      <arg name='URI' type='const xmlChar *' info='URI for the dtd, or NULL'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID of the DTD, or NULL'/>
    </function>
    <function name='htmlNewDocNoDtD' file='HTMLtree' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Creates a new HTML document without a DTD node if @URI and @ExternalID are NULL</info>
      <return type='htmlDocPtr' info='a new document, do not initialize the DTD if not provided'/>
      <arg name='URI' type='const xmlChar *' info='URI for the dtd, or NULL'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID of the DTD, or NULL'/>
    </function>
    <function name='htmlNewParserCtxt' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Allocate and initialize a new parser context.</info>
      <return type='htmlParserCtxtPtr' info='the htmlParserCtxtPtr or NULL in case of allocation error'/>
    </function>
    <function name='htmlNodeDump' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='int' info='the number of byte written or -1 in case of error'/>
      <arg name='buf' type='xmlBufferPtr' info='the HTML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
    </function>
    <function name='htmlNodeDumpFile' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns are added.</info>
      <return type='void'/>
      <arg name='out' type='FILE *' info='the FILE pointer'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
    </function>
    <function name='htmlNodeDumpFileFormat' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML node, recursive behaviour,children are printed too.  TODO: if encoding == NULL try to save in the doc encoding</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='out' type='FILE *' info='the FILE pointer'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='encoding' type='const char *' info='the document encoding'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='htmlNodeDumpFormatOutput' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML node, recursive behaviour,children are printed too.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='encoding' type='const char *' info='the encoding string'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='htmlNodeDumpOutput' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML node, recursive behaviour,children are printed too, and formatting returns/spaces are added.</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the HTML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='encoding' type='const char *' info='the encoding string'/>
    </function>
    <function name='htmlNodeStatus' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Checks whether the tree node is valid.  Experimental (the author only uses the HTML enhancements in a SAX parser)</info>
      <return type='htmlStatus' info='for Element nodes, a return from htmlElementAllowedHere (if legacy allowed) or htmlElementStatusHere (otherwise). for Attribute nodes, a return from htmlAttrAllowed for other nodes, HTML_NA (no checks performed)'/>
      <arg name='node' type='const htmlNodePtr' info='an htmlNodePtr in a tree'/>
      <arg name='legacy' type='int' info='whether to allow deprecated elements (YES is faster here for Element nodes)'/>
    </function>
    <function name='htmlParseCharRef' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse Reference declarations  [66] CharRef ::= &apos;&amp;#&apos; [0-9]+ &apos;;&apos; | &apos;&amp;#x&apos; [0-9a-fA-F]+ &apos;;&apos;</info>
      <return type='int' info='the value parsed (as an int)'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
    </function>
    <function name='htmlParseChunk' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_PUSH_ENABLED)</cond>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise.'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='chunk' type='const char *' info='an char array'/>
      <arg name='size' type='int' info='the size in byte of the chunk'/>
      <arg name='terminate' type='int' info='last chunk indicator'/>
    </function>
    <function name='htmlParseDoc' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML in-memory document and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL'/>
    </function>
    <function name='htmlParseDocument' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML document (and build a tree if using the standard SAX interface).</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing.'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
    </function>
    <function name='htmlParseElement' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML element, this is highly recursive this is kept for compatibility with previous code versions  [39] element ::= EmptyElemTag | STag content ETag  [41] Attribute ::= Name Eq AttValue</info>
      <return type='void'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
    </function>
    <function name='htmlParseEntityRef' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML ENTITY references  [68] EntityRef ::= &apos;&amp;&apos; Name &apos;;&apos;</info>
      <return type='const htmlEntityDesc *' info='the associated htmlEntityDescPtr if found, or NULL otherwise, if non-NULL *str will have to be freed by the caller.'/>
      <arg name='ctxt' type='htmlParserCtxtPtr' info='an HTML parser context'/>
      <arg name='str' type='const xmlChar **' info='location to store the entity name'/>
    </function>
    <function name='htmlParseFile' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL'/>
    </function>
    <function name='htmlReadDoc' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlReadFd' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML from a file descriptor and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlReadFile' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML file from the filesystem or the network.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlReadIO' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML document from I/O functions and source and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlReadMemory' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of htmlParserOption(s)'/>
    </function>
    <function name='htmlSAXParseDoc' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Parse an HTML in-memory document. If sax is not NULL, use the SAX callbacks to handle parse events. If sax is NULL, fallback to the default DOM behavior and return a tree.</info>
      <return type='htmlDocPtr' info='the resulting document tree unless SAX is NULL or the document is not well formed.'/>
      <arg name='cur' type='xmlChar *' info='a pointer to an array of xmlChar'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL'/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks.'/>
    </function>
    <function name='htmlSAXParseFile' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>parse an HTML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='htmlDocPtr' info='the resulting document tree unless SAX is NULL or the document is not well formed.'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='encoding' type='const char *' info='a free form C string describing the HTML document encoding, or NULL'/>
      <arg name='sax' type='htmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='userData' type='void *' info='if using SAX, this pointer will be provided on callbacks.'/>
    </function>
    <function name='htmlSaveFile' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document to a file. If @filename is &quot;-&quot; the stdout file is used.</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename (or URL)'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='htmlSaveFileEnc' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document to a file using a given encoding and formatting returns/spaces are added.</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the document encoding'/>
    </function>
    <function name='htmlSaveFileFormat' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an HTML document to a file using a given encoding.</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the document encoding'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='htmlSetMetaEncoding' file='HTMLtree' module='HTMLtree'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Sets the current encoding in the Meta tags NOTE: this will not change the document content encoding, just the META flag associated.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='doc' type='htmlDocPtr' info='the document'/>
      <arg name='encoding' type='const xmlChar *' info='the encoding string'/>
    </function>
    <function name='htmlTagLookup' file='HTMLparser' module='HTMLparser'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Lookup the HTML tag in the ElementTable</info>
      <return type='const htmlElemDesc *' info='the related htmlElemDescPtr or NULL if not found.'/>
      <arg name='tag' type='const xmlChar *' info='The tag name in lowercase'/>
    </function>
    <function name='ignorableWhitespace' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters DEPRECATED: use xmlSAX2IgnorableWhitespace()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </function>
    <functype name='ignorableWhitespaceSAXFunc' file='parser' module='parser'>
      <info>Receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use characters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </functype>
    <function name='initGenericErrorDefaultFunc' file='xmlerror' module='error'>
      <info>Set or reset (if NULL) the default handler for generic errors to the builtin error function.</info>
      <return type='void'/>
      <arg name='handler' type='xmlGenericErrorFunc *' info='the handler'/>
    </function>
    <function name='initdocbDefaultSAXHandler' file='SAX' module='SAX'>
      <cond>defined(LIBXML_LEGACY_ENABLED) &amp;&amp; defined(LIBXML_SAX1_ENABLED) &amp;&amp; defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Initialize the default DocBook SAX version 1 handler DEPRECATED: use xmlSAX2InitDocbDefaultSAXHandler() for the new SAX2 blocks</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandlerV1 *' info='the SAX handler'/>
    </function>
    <function name='inithtmlDefaultSAXHandler' file='SAX' module='SAX'>
      <cond>defined(LIBXML_LEGACY_ENABLED) &amp;&amp; defined(LIBXML_SAX1_ENABLED) &amp;&amp; defined(LIBXML_HTML_ENABLED)</cond>
      <info>Initialize the default HTML SAX version 1 handler DEPRECATED: use xmlSAX2InitHtmlDefaultSAXHandler() for the new SAX2 blocks</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandlerV1 *' info='the SAX handler'/>
    </function>
    <function name='initxmlDefaultSAXHandler' file='SAX' module='SAX'>
      <cond>defined(LIBXML_LEGACY_ENABLED) &amp;&amp; defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Initialize the default XML SAX version 1 handler DEPRECATED: use xmlSAX2InitDefaultSAXHandler() for the new SAX2 blocks</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandlerV1 *' info='the SAX handler'/>
      <arg name='warning' type='int' info='flag if non-zero sets the handler warning procedure'/>
    </function>
    <function name='inputPop' file='parserInternals' module='parser'>
      <info>Pops the top parser input from the input stack</info>
      <return type='xmlParserInputPtr' info='the input just removed'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='inputPush' file='parserInternals' module='parser'>
      <info>Pushes a new parser input on top of the input stack</info>
      <return type='int' info='-1 in case of error, the index in the stack otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='value' type='xmlParserInputPtr' info='the parser input'/>
    </function>
    <function name='internalSubset' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Callback on internal subset declaration. DEPRECATED: use xmlSAX2InternalSubset()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </function>
    <functype name='internalSubsetSAXFunc' file='parser' module='parser'>
      <info>Callback on internal subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </functype>
    <function name='isStandalone' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Is this document tagged standalone ? DEPRECATED: use xmlSAX2IsStandalone()</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <functype name='isStandaloneSAXFunc' file='parser' module='parser'>
      <info>Is this document tagged standalone?</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </functype>
    <function name='isolat1ToUTF8' file='encoding' module='encoding'>
      <info>Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8 block of chars out.</info>
      <return type='int' info='the number of bytes written if success, or -1 otherwise The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of ISO Latin 1 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
    </function>
    <function name='namePop' file='parserInternals' module='parser'>
      <info>Pops the top element name from the name stack</info>
      <return type='const xmlChar *' info='the name just removed'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='namePush' file='parserInternals' module='parser'>
      <info>Pushes a new element name on top of the name stack</info>
      <return type='int' info='-1 in case of error, the index in the stack otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='value' type='const xmlChar *' info='the element name'/>
    </function>
    <function name='namespaceDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>A namespace has been parsed. DEPRECATED</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='href' type='const xmlChar *' info='the namespace associated URN'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix'/>
    </function>
    <function name='nodePop' file='parserInternals' module='parser'>
      <info>Pops the top element node from the node stack</info>
      <return type='xmlNodePtr' info='the node just removed'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='nodePush' file='parserInternals' module='parser'>
      <info>Pushes a new element node on top of the node stack</info>
      <return type='int' info='-1 in case of error, the index in the stack otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='value' type='xmlNodePtr' info='the element node'/>
    </function>
    <function name='notationDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>What to do when a notation declaration has been parsed. DEPRECATED: use xmlSAX2NotationDecl()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the notation'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </function>
    <functype name='notationDeclSAXFunc' file='parser' module='parser'>
      <info>What to do when a notation declaration has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the notation'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </functype>
    <function name='processingInstruction' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>A processing instruction has been parsed. DEPRECATED: use xmlSAX2ProcessingInstruction()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='target' type='const xmlChar *' info='the target name'/>
      <arg name='data' type='const xmlChar *' info='the PI data&apos;s'/>
    </function>
    <functype name='processingInstructionSAXFunc' file='parser' module='parser'>
      <info>A processing instruction has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='target' type='const xmlChar *' info='the target name'/>
      <arg name='data' type='const xmlChar *' info='the PI data&apos;s'/>
    </functype>
    <function name='reference' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when an entity reference is detected. DEPRECATED: use xmlSAX2Reference()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <functype name='referenceSAXFunc' file='parser' module='parser'>
      <info>Called when an entity reference is detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </functype>
    <function name='resolveEntity' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine DEPRECATED: use xmlSAX2ResolveEntity()</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </function>
    <functype name='resolveEntitySAXFunc' file='parser' module='parser'>
      <info>Callback: The entity loader, to control the loading of external entities, the application can either: - override this resolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </functype>
    <function name='setDocumentLocator' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case. DEPRECATED</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator'/>
    </function>
    <functype name='setDocumentLocatorSAXFunc' file='parser' module='parser'>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator. Everything is available on the context, so this is useless in our case.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator'/>
    </functype>
    <function name='setNamespace' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Set the current element namespace. DEPRECATED</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the namespace prefix'/>
    </function>
    <function name='startDocument' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when the document start being processed. DEPRECATED: use xmlSAX2StartDocument()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <functype name='startDocumentSAXFunc' file='parser' module='parser'>
      <info>Called when the document start being processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </functype>
    <function name='startElement' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when an opening tag has been processed. DEPRECATED: use xmlSAX2StartElement()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='fullname' type='const xmlChar *' info='The element name, including namespace prefix'/>
      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated'/>
    </function>
    <functype name='startElementNsSAX2Func' file='parser' module='parser'>
      <info>SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='localname' type='const xmlChar *' info='the local name of the element'/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix if available'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace name if available'/>
      <arg name='nb_namespaces' type='int' info='number of namespace definitions on that node'/>
      <arg name='namespaces' type='const xmlChar **' info='pointer to the array of prefix/URI pairs namespace definitions'/>
      <arg name='nb_attributes' type='int' info='the number of attributes on that node'/>
      <arg name='nb_defaulted' type='int' info='the number of defaulted attributes. The defaulted ones are at the end of the array'/>
      <arg name='attributes' type='const xmlChar **' info='pointer to the array of (localname/prefix/URI/value/end) attribute values.'/>
    </functype>
    <functype name='startElementSAXFunc' file='parser' module='parser'>
      <info>Called when an opening tag has been processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The element name, including namespace prefix'/>
      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated'/>
    </functype>
    <function name='unparsedEntityDecl' file='SAX' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>What to do when an unparsed entity declaration is parsed DEPRECATED: use xmlSAX2UnparsedEntityDecl()</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the entity'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='notationName' type='const xmlChar *' info='the name of the notation'/>
    </function>
    <functype name='unparsedEntityDeclSAXFunc' file='parser' module='parser'>
      <info>What to do when an unparsed entity declaration is parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the entity'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='notationName' type='const xmlChar *' info='the name of the notation'/>
    </functype>
    <function name='valuePop' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops the top XPath object from the value stack</info>
      <return type='xmlXPathObjectPtr' info='the XPath object just removed'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath evaluation context'/>
    </function>
    <function name='valuePush' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pushes a new XPath object on top of the value stack</info>
      <return type='int' info='the number of items on the value stack'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath evaluation context'/>
      <arg name='value' type='xmlXPathObjectPtr' info='the XPath object'/>
    </function>
    <functype name='warningSAXFunc' file='parser' module='parser'>
      <info>Display and format a warning messages, callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </functype>
    <functype name='xlinkExtendedLinkFunk' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>This is the prototype for a extended link detection callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='user data pointer'/>
      <arg name='node' type='xmlNodePtr' info='the node carrying the link'/>
      <arg name='nbLocators' type='int' info='the number of locators detected on the link'/>
      <arg name='hrefs' type='const xlinkHRef *' info='pointer to the array of locator hrefs'/>
      <arg name='roles' type='const xlinkRole *' info='pointer to the array of locator roles'/>
      <arg name='nbArcs' type='int' info='the number of arcs detected on the link'/>
      <arg name='from' type='const xlinkRole *' info='pointer to the array of source roles found on the arcs'/>
      <arg name='to' type='const xlinkRole *' info='pointer to the array of target roles found on the arcs'/>
      <arg name='show' type='xlinkShow *' info='array of values for the show attributes found on the arcs'/>
      <arg name='actuate' type='xlinkActuate *' info='array of values for the actuate attributes found on the arcs'/>
      <arg name='nbTitles' type='int' info='the number of titles detected on the link'/>
      <arg name='titles' type='const xlinkTitle *' info=''/>
      <arg name='langs' type='const xmlChar **' info='array of xml:lang values for the titles'/>
    </functype>
    <functype name='xlinkExtendedLinkSetFunk' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>This is the prototype for a extended link set detection callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='user data pointer'/>
      <arg name='node' type='xmlNodePtr' info='the node carrying the link'/>
      <arg name='nbLocators' type='int' info='the number of locators detected on the link'/>
      <arg name='hrefs' type='const xlinkHRef *' info='pointer to the array of locator hrefs'/>
      <arg name='roles' type='const xlinkRole *' info='pointer to the array of locator roles'/>
      <arg name='nbTitles' type='int' info='the number of titles detected on the link'/>
      <arg name='titles' type='const xlinkTitle *' info=''/>
      <arg name='langs' type='const xmlChar **' info='array of xml:lang values for the titles'/>
    </functype>
    <function name='xlinkGetDefaultDetect' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Get the default xlink detection routine</info>
      <return type='xlinkNodeDetectFunc' info='the current function or NULL;'/>
    </function>
    <function name='xlinkGetDefaultHandler' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Get the default xlink handler.</info>
      <return type='xlinkHandlerPtr' info='the current xlinkHandlerPtr value.'/>
    </function>
    <function name='xlinkIsLink' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Check whether the given node carries the attributes needed to be a link element (or is one of the linking elements issued from the (X)HTML DtDs). This routine don&apos;t try to do full checking of the link validity but tries to detect and return the appropriate link type.</info>
      <return type='xlinkType' info='the xlinkType of the node (XLINK_TYPE_NONE if there is no link detected.'/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the node'/>
      <arg name='node' type='xmlNodePtr' info='the node pointer itself'/>
    </function>
    <functype name='xlinkNodeDetectFunc' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>This is the prototype for the link detection routine. It calls the default link detection callbacks upon link detection.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='user data pointer'/>
      <arg name='node' type='xmlNodePtr' info='the node to check'/>
    </functype>
    <function name='xlinkSetDefaultDetect' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Set the default xlink detection routine</info>
      <return type='void'/>
      <arg name='func' type='xlinkNodeDetectFunc' info='pointer to the new detection routine.'/>
    </function>
    <function name='xlinkSetDefaultHandler' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Set the default xlink handlers</info>
      <return type='void'/>
      <arg name='handler' type='xlinkHandlerPtr' info='the new value for the xlink handler block'/>
    </function>
    <functype name='xlinkSimpleLinkFunk' file='xlink' module='xlink'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>This is the prototype for a simple link detection callback.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='user data pointer'/>
      <arg name='node' type='xmlNodePtr' info='the node carrying the link'/>
      <arg name='href' type='const xlinkHRef' info='the target of the link'/>
      <arg name='role' type='const xlinkRole' info='the role string'/>
      <arg name='title' type='const xlinkTitle' info='the link title'/>
    </functype>
    <function name='xmlACatalogAdd' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Add an entry in the catalog, it may overwrite existing but different entries.</info>
      <return type='int' info='0 if successful, -1 otherwise'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='type' type='const xmlChar *' info='the type of record to add to the catalog'/>
      <arg name='orig' type='const xmlChar *' info='the system, public or prefix to match'/>
      <arg name='replace' type='const xmlChar *' info='the replacement value for the match'/>
    </function>
    <function name='xmlACatalogDump' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump the given catalog to the given file.</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='out' type='FILE *' info='the file.'/>
    </function>
    <function name='xmlACatalogRemove' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Remove an entry from the catalog</info>
      <return type='int' info='the number of entries removed if successful, -1 otherwise'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='value' type='const xmlChar *' info='the value to remove'/>
    </function>
    <function name='xmlACatalogResolve' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlACatalogResolvePublic' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog local reference associated to a public ID in that catalog</info>
      <return type='xmlChar *' info='the local resource if found or NULL otherwise, the value returned must be freed by the caller.'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
    </function>
    <function name='xmlACatalogResolveSystem' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *' info='the resource if found or NULL otherwise, the value returned must be freed by the caller.'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlACatalogResolveURI' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
      <arg name='URI' type='const xmlChar *' info='the URI'/>
    </function>
    <function name='xmlAddAttributeDecl' file='valid' module='valid'>
      <info>Register a new attribute declaration Note that @tree becomes the ownership of the DTD</info>
      <return type='xmlAttributePtr' info='NULL if not new, otherwise the attribute decl'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD'/>
      <arg name='elem' type='const xmlChar *' info='the element name'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace prefix'/>
      <arg name='type' type='xmlAttributeType' info='the attribute type'/>
      <arg name='def' type='xmlAttributeDefault' info='the attribute default type'/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value'/>
      <arg name='tree' type='xmlEnumerationPtr' info='if it&apos;s an enumeration, the associated list'/>
    </function>
    <function name='xmlAddChild' file='tree' module='tree'>
      <info>Add a new node to @parent, at the end of the child (or property) list merging adjacent TEXT nodes (in which case @cur is freed) If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the child or NULL in case of error.'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
      <arg name='cur' type='xmlNodePtr' info='the child node'/>
    </function>
    <function name='xmlAddChildList' file='tree' module='tree'>
      <info>Add a list of node at the end of the child list of the parent merging adjacent TEXT nodes (@cur may be freed)</info>
      <return type='xmlNodePtr' info='the last child or NULL in case of error.'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
      <arg name='cur' type='xmlNodePtr' info='the first node in the list'/>
    </function>
    <function name='xmlAddDocEntity' file='entities' module='entities'>
      <info>Register a new entity for this document.</info>
      <return type='xmlEntityPtr' info='a pointer to the entity or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type XML_xxx_yyy_ENTITY'/>
      <arg name='ExternalID' type='const xmlChar *' info='the entity external ID if available'/>
      <arg name='SystemID' type='const xmlChar *' info='the entity system ID if available'/>
      <arg name='content' type='const xmlChar *' info='the entity content'/>
    </function>
    <function name='xmlAddDtdEntity' file='entities' module='entities'>
      <info>Register a new entity for this document DTD external subset.</info>
      <return type='xmlEntityPtr' info='a pointer to the entity or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type XML_xxx_yyy_ENTITY'/>
      <arg name='ExternalID' type='const xmlChar *' info='the entity external ID if available'/>
      <arg name='SystemID' type='const xmlChar *' info='the entity system ID if available'/>
      <arg name='content' type='const xmlChar *' info='the entity content'/>
    </function>
    <function name='xmlAddElementDecl' file='valid' module='valid'>
      <info>Register a new element declaration</info>
      <return type='xmlElementPtr' info='NULL if not, otherwise the entity'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='xmlElementTypeVal' info='the element type'/>
      <arg name='content' type='xmlElementContentPtr' info='the element content tree or NULL'/>
    </function>
    <function name='xmlAddEncodingAlias' file='encoding' module='encoding'>
      <info>Registers an alias @alias for an encoding named @name. Existing alias will be overwritten.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='name' type='const char *' info='the encoding name as parsed, in UTF-8 format (ASCII actually)'/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
    </function>
    <function name='xmlAddID' file='valid' module='valid'>
      <info>Register a new id declaration</info>
      <return type='xmlIDPtr' info='NULL if not, otherwise the new xmlIDPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document'/>
      <arg name='value' type='const xmlChar *' info='the value name'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute holding the ID'/>
    </function>
    <function name='xmlAddNextSibling' file='tree' module='tree'>
      <info>Add a new node @elem as the next sibling of @cur If the new node was already inserted in a document it is first unlinked from its existing context. As a result of text merging @elem may be freed. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the new node or NULL in case of error.'/>
      <arg name='cur' type='xmlNodePtr' info='the child node'/>
      <arg name='elem' type='xmlNodePtr' info='the new node'/>
    </function>
    <function name='xmlAddNotationDecl' file='valid' module='valid'>
      <info>Register a new notation declaration</info>
      <return type='xmlNotationPtr' info='NULL if not, otherwise the entity'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='dtd' type='xmlDtdPtr' info='pointer to the DTD'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='PublicID' type='const xmlChar *' info='the public identifier or NULL'/>
      <arg name='SystemID' type='const xmlChar *' info='the system identifier or NULL'/>
    </function>
    <function name='xmlAddPrevSibling' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Add a new node @elem as the previous sibling of @cur merging adjacent TEXT nodes (@elem may be freed) If the new node was already inserted in a document it is first unlinked from its existing context. If the new node is ATTRIBUTE, it is added into properties instead of children. If there is an attribute with equal name, it is first destroyed.</info>
      <return type='xmlNodePtr' info='the new node or NULL in case of error.'/>
      <arg name='cur' type='xmlNodePtr' info='the child node'/>
      <arg name='elem' type='xmlNodePtr' info='the new node'/>
    </function>
    <function name='xmlAddRef' file='valid' module='valid'>
      <info>Register a new ref declaration</info>
      <return type='xmlRefPtr' info='NULL if not, otherwise the new xmlRefPtr'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document'/>
      <arg name='value' type='const xmlChar *' info='the value name'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute holding the Ref'/>
    </function>
    <function name='xmlAddSibling' file='tree' module='tree'>
      <info>Add a new element @elem to the list of siblings of @cur merging adjacent TEXT nodes (@elem may be freed) If the new element was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr' info='the new element or NULL in case of error.'/>
      <arg name='cur' type='xmlNodePtr' info='the child node'/>
      <arg name='elem' type='xmlNodePtr' info='the new node'/>
    </function>
    <function name='xmlAllocOutputBuffer' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered parser output</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL'/>
    </function>
    <function name='xmlAllocParserInputBuffer' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for progressive parsing</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlAttrSerializeTxtContent' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Serialize text attribute values to an xml simple buffer</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute node'/>
      <arg name='string' type='const xmlChar *' info='the text content'/>
    </function>
    <function name='xmlAutomataCompile' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Compile the automata into a Reg Exp ready for being executed. The automata should be free after this point.</info>
      <return type='xmlRegexpPtr' info='the compiled regexp or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
    </function>
    <function name='xmlAutomataGetInitState' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Initial state lookup</info>
      <return type='xmlAutomataStatePtr' info='the initial state of the automata'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
    </function>
    <function name='xmlAutomataIsDeterminist' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Checks if an automata is determinist.</info>
      <return type='int' info='1 if true, 0 if not, and -1 in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
    </function>
    <function name='xmlAutomataNewAllTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a an ALL transition from the @from state to the target state. That transition is an epsilon transition allowed only when all transitions from the @from node have been activated.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='lax' type='int' info='allow to transition if not all all transitions have been activated'/>
    </function>
    <function name='xmlAutomataNewCountTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and whose number is between @min and @max</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition'/>
      <arg name='min' type='int' info='the minimum successive occurences of token'/>
      <arg name='max' type='int' info='the maximum successive occurences of token'/>
      <arg name='data' type='void *' info='data associated to the transition'/>
    </function>
    <function name='xmlAutomataNewCountTrans2' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and @token2 and whose number is between @min and @max</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition'/>
      <arg name='token2' type='const xmlChar *' info='the second input string associated to that transition'/>
      <arg name='min' type='int' info='the minimum successive occurences of token'/>
      <arg name='max' type='int' info='the maximum successive occurences of token'/>
      <arg name='data' type='void *' info='data associated to the transition'/>
    </function>
    <function name='xmlAutomataNewCountedTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state which will increment the counter provided</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='counter' type='int' info='the counter associated to that transition'/>
    </function>
    <function name='xmlAutomataNewCounter' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Create a new counter</info>
      <return type='int' info='the counter number or -1 in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='min' type='int' info='the minimal value on the counter'/>
      <arg name='max' type='int' info='the maximal value on the counter'/>
    </function>
    <function name='xmlAutomataNewCounterTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state which will be allowed only if the counter is within the right range.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='counter' type='int' info='the counter associated to that transition'/>
    </function>
    <function name='xmlAutomataNewEpsilon' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds an epsilon transition from the @from state to the target state</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
    </function>
    <function name='xmlAutomataNewNegTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by any value except (@token,@token2) Note that if @token2 is not NULL, then (X, NULL) won&apos;t match to follow # the semantic of XSD ##other</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the first input string associated to that transition'/>
      <arg name='token2' type='const xmlChar *' info='the second input string associated to that transition'/>
      <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
    </function>
    <function name='xmlAutomataNewOnceTrans' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and whose number is between @min and @max, moreover that transition can only be crossed once.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition'/>
      <arg name='min' type='int' info='the minimum successive occurences of token'/>
      <arg name='max' type='int' info='the maximum successive occurences of token'/>
      <arg name='data' type='void *' info='data associated to the transition'/>
    </function>
    <function name='xmlAutomataNewOnceTrans2' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by a succession of input of value @token and @token2 and whose number is between @min and @max, moreover that transition can only be crossed once.</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition'/>
      <arg name='token2' type='const xmlChar *' info='the second input string associated to that transition'/>
      <arg name='min' type='int' info='the minimum successive occurences of token'/>
      <arg name='max' type='int' info='the maximum successive occurences of token'/>
      <arg name='data' type='void *' info='data associated to the transition'/>
    </function>
    <function name='xmlAutomataNewState' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Create a new disconnected state in the automata</info>
      <return type='xmlAutomataStatePtr' info='the new state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
    </function>
    <function name='xmlAutomataNewTransition' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by the value of @token</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the input string associated to that transition'/>
      <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
    </function>
    <function name='xmlAutomataNewTransition2' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>If @to is NULL, this creates first a new target state in the automata and then adds a transition from the @from state to the target state activated by the value of @token</info>
      <return type='xmlAutomataStatePtr' info='the target state or NULL in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='from' type='xmlAutomataStatePtr' info='the starting point of the transition'/>
      <arg name='to' type='xmlAutomataStatePtr' info='the target point of the transition or NULL'/>
      <arg name='token' type='const xmlChar *' info='the first input string associated to that transition'/>
      <arg name='token2' type='const xmlChar *' info='the second input string associated to that transition'/>
      <arg name='data' type='void *' info='data passed to the callback function if the transition is activated'/>
    </function>
    <function name='xmlAutomataSetFinalState' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Makes that state a final state</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
      <arg name='state' type='xmlAutomataStatePtr' info='a state in this automata'/>
    </function>
    <function name='xmlBoolToText' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Convenient way to turn bool into text</info>
      <return type='const char *' info='a pointer to either &quot;True&quot; or &quot;False&quot;'/>
      <arg name='boolval' type='int' info='a bool to turn into text'/>
    </function>
    <function name='xmlBufContent' file='tree' module='buf'>
      <info>Function to extract the content of a buffer</info>
      <return type='xmlChar *' info='the internal content'/>
      <arg name='buf' type='const xmlBuf *' info='the buffer'/>
    </function>
    <function name='xmlBufEnd' file='tree' module='buf'>
      <info>Function to extract the end of the content of a buffer</info>
      <return type='xmlChar *' info='the end of the internal content or NULL in case of error'/>
      <arg name='buf' type='xmlBufPtr' info='the buffer'/>
    </function>
    <function name='xmlBufGetNodeContent' file='tree' module='tree'>
      <info>Read the value of a node @cur, this can be either the text carried directly by this node if it&apos;s a TEXT node or the aggregate string of the values carried by this node child&apos;s (TEXT and ENTITY_REF). Entity references are substituted. Fills up the buffer @buf with this value</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='buf' type='xmlBufPtr' info='a buffer xmlBufPtr'/>
      <arg name='cur' type='const xmlNode *' info='the node being read'/>
    </function>
    <function name='xmlBufNodeDump' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML node, recursive behaviour,children are printed too. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='size_t' info='the number of bytes written to the buffer, in case of error 0 is returned or @buf stores the error'/>
      <arg name='buf' type='xmlBufPtr' info='the XML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='level' type='int' info='the imbrication level for indenting'/>
      <arg name='format' type='int' info='is formatting allowed'/>
    </function>
    <function name='xmlBufShrink' file='tree' module='buf'>
      <info>Remove the beginning of an XML buffer. NOTE that this routine behaviour differs from xmlBufferShrink() as it will return 0 on error instead of -1 due to size_t being used as the return type.</info>
      <return type='size_t' info='the number of byte removed or 0 in case of failure'/>
      <arg name='buf' type='xmlBufPtr' info='the buffer to dump'/>
      <arg name='len' type='size_t' info='the number of xmlChar to remove'/>
    </function>
    <function name='xmlBufUse' file='tree' module='buf'>
      <info>Function to get the length of a buffer</info>
      <return type='size_t' info='the length of data in the internal content'/>
      <arg name='buf' type='const xmlBufPtr' info='the buffer'/>
    </function>
    <function name='xmlBufferAdd' file='tree' module='tree'>
      <info>Add a string range to an XML buffer. if len == -1, the length of str is recomputed.</info>
      <return type='int' info='0 successful, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump'/>
      <arg name='str' type='const xmlChar *' info='the #xmlChar string'/>
      <arg name='len' type='int' info='the number of #xmlChar to add'/>
    </function>
    <function name='xmlBufferAddHead' file='tree' module='tree'>
      <info>Add a string range to the beginning of an XML buffer. if len == -1, the length of @str is recomputed.</info>
      <return type='int' info='0 successful, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer'/>
      <arg name='str' type='const xmlChar *' info='the #xmlChar string'/>
      <arg name='len' type='int' info='the number of #xmlChar to add'/>
    </function>
    <function name='xmlBufferCCat' file='tree' module='tree'>
      <info>Append a zero terminated C string to an XML buffer.</info>
      <return type='int' info='0 successful, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump'/>
      <arg name='str' type='const char *' info='the C char string'/>
    </function>
    <function name='xmlBufferCat' file='tree' module='tree'>
      <info>Append a zero terminated string to an XML buffer.</info>
      <return type='int' info='0 successful, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to add to'/>
      <arg name='str' type='const xmlChar *' info='the #xmlChar string'/>
    </function>
    <function name='xmlBufferContent' file='tree' module='tree'>
      <info>Function to extract the content of a buffer</info>
      <return type='const xmlChar *' info='the internal content'/>
      <arg name='buf' type='const xmlBuffer *' info='the buffer'/>
    </function>
    <function name='xmlBufferCreate' file='tree' module='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr' info='the new structure.'/>
    </function>
    <function name='xmlBufferCreateSize' file='tree' module='tree'>
      <info>routine to create an XML buffer.</info>
      <return type='xmlBufferPtr' info='the new structure.'/>
      <arg name='size' type='size_t' info='initial size of buffer'/>
    </function>
    <function name='xmlBufferCreateStatic' file='tree' module='tree'>
      <info>routine to create an XML buffer from an immutable memory area. The area won&apos;t be modified nor copied, and is expected to be present until the end of the buffer lifetime.</info>
      <return type='xmlBufferPtr' info='the new structure.'/>
      <arg name='mem' type='void *' info='the memory area'/>
      <arg name='size' type='size_t' info='the size in byte'/>
    </function>
    <function name='xmlBufferDetach' file='tree' module='tree'>
      <info>Remove the string contained in a buffer and gie it back to the caller. The buffer is reset to an empty content. This doesn&apos;t work with immutable buffers as they can&apos;t be reset.</info>
      <return type='xmlChar *' info='the previous string contained by the buffer.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer'/>
    </function>
    <function name='xmlBufferDump' file='tree' module='tree'>
      <info>Dumps an XML buffer to  a FILE *.</info>
      <return type='int' info='the number of #xmlChar written'/>
      <arg name='file' type='FILE *' info='the file output'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump'/>
    </function>
    <function name='xmlBufferEmpty' file='tree' module='tree'>
      <info>empty a buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer'/>
    </function>
    <function name='xmlBufferFree' file='tree' module='tree'>
      <info>Frees an XML buffer. It frees both the content and the structure which encapsulate it.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to free'/>
    </function>
    <function name='xmlBufferGrow' file='tree' module='tree'>
      <info>Grow the available space of an XML buffer.</info>
      <return type='int' info='the new available space or -1 in case of error'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer'/>
      <arg name='len' type='unsigned int' info='the minimum free size to allocate'/>
    </function>
    <function name='xmlBufferLength' file='tree' module='tree'>
      <info>Function to get the length of a buffer</info>
      <return type='int' info='the length of data in the internal content'/>
      <arg name='buf' type='const xmlBuffer *' info='the buffer'/>
    </function>
    <function name='xmlBufferResize' file='tree' module='tree'>
      <info>Resize a buffer to accommodate minimum size of @size.</info>
      <return type='int' info='0 in case of problems, 1 otherwise'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to resize'/>
      <arg name='size' type='unsigned int' info='the desired size'/>
    </function>
    <function name='xmlBufferSetAllocationScheme' file='tree' module='tree'>
      <info>Sets the allocation scheme for this buffer</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to tune'/>
      <arg name='scheme' type='xmlBufferAllocationScheme' info='allocation scheme to use'/>
    </function>
    <function name='xmlBufferShrink' file='tree' module='tree'>
      <info>Remove the beginning of an XML buffer.</info>
      <return type='int' info='the number of #xmlChar removed, or -1 in case of failure.'/>
      <arg name='buf' type='xmlBufferPtr' info='the buffer to dump'/>
      <arg name='len' type='unsigned int' info='the number of xmlChar to remove'/>
    </function>
    <function name='xmlBufferWriteCHAR' file='tree' module='tree'>
      <info>routine which manages and grows an output buffer. This one adds xmlChars at the end of the buffer.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer'/>
      <arg name='string' type='const xmlChar *' info='the string to add'/>
    </function>
    <function name='xmlBufferWriteChar' file='tree' module='tree'>
      <info>routine which manage and grows an output buffer. This one add C chars at the end of the array.</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='string' type='const char *' info='the string to add'/>
    </function>
    <function name='xmlBufferWriteQuotedString' file='tree' module='tree'>
      <info>routine which manage and grows an output buffer. This one writes a quoted or double quoted #xmlChar string, checking first if it holds quote or double-quotes internally</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='string' type='const xmlChar *' info='the string to add'/>
    </function>
    <function name='xmlBuildQName' file='tree' module='tree'>
      <info>Builds the QName @prefix:@ncname in @memory if there is enough space and prefix is not NULL nor empty, otherwise allocate a new string. If prefix is NULL or empty it returns ncname.</info>
      <return type='xmlChar *' info='the new string which must be freed by the caller if different from @memory and @ncname or NULL in case of error'/>
      <arg name='ncname' type='const xmlChar *' info='the Name'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix'/>
      <arg name='memory' type='xmlChar *' info='preallocated memory'/>
      <arg name='len' type='int' info='preallocated memory length'/>
    </function>
    <function name='xmlBuildRelativeURI' file='uri' module='uri'>
      <info>Expresses the URI of the reference in terms relative to the base.  Some examples of this operation include: base = &quot;http://site1.com/docs/book1.html&quot; URI input                        URI returned docs/pic1.gif                    pic1.gif docs/img/pic1.gif                img/pic1.gif img/pic1.gif                     ../img/pic1.gif http://site1.com/docs/pic1.gif   pic1.gif http://site2.com/docs/pic1.gif   http://site2.com/docs/pic1.gif  base = &quot;docs/book1.html&quot; URI input                        URI returned docs/pic1.gif                    pic1.gif docs/img/pic1.gif                img/pic1.gif img/pic1.gif                     ../img/pic1.gif http://site1.com/docs/pic1.gif   http://site1.com/docs/pic1.gif   Note: if the URI reference is really wierd or complicated, it may be worthwhile to first convert it into a &quot;nice&quot; one by calling xmlBuildURI (using &apos;base&apos;) before calling this routine, since this routine (for reasonable efficiency) assumes URI has already been through some validation.</info>
      <return type='xmlChar *' info='a new URI string (to be freed by the caller) or NULL in case error.'/>
      <arg name='URI' type='const xmlChar *' info='the URI reference under consideration'/>
      <arg name='base' type='const xmlChar *' info='the base value'/>
    </function>
    <function name='xmlBuildURI' file='uri' module='uri'>
      <info>Computes he final URI of the reference done by checking that the given URI is valid, and building the final URI using the base URI. This is processed according to section 5.2 of the RFC 2396  5.2. Resolving Relative References to Absolute Form</info>
      <return type='xmlChar *' info='a new URI string (to be freed by the caller) or NULL in case of error.'/>
      <arg name='URI' type='const xmlChar *' info='the URI instance found in the document'/>
      <arg name='base' type='const xmlChar *' info='the base value'/>
    </function>
    <function name='xmlByteConsumed' file='parser' module='encoding'>
      <info>This function provides the current index of the parser relative to the start of the current entity. This function is computed in bytes from the beginning starting at zero and finishing at the size in byte of the file if parsing a file. The function is of constant cost if the input is UTF-8 but can be costly if run on non-UTF-8 input.</info>
      <return type='long' info='the index in bytes from the beginning of the entity or -1 in case the index could not be computed.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlC14NDocDumpMemory' file='c14n' module='c14n'>
      <cond>defined(LIBXML_C14N_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dumps the canonized image of given XML document into memory. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='the number of bytes written on success or a negative value on fail'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document for canonization'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='the nodes set to be included in the canonized image or NULL if all document nodes should be included'/>
      <arg name='mode' type='int' info='the c14n mode (see @xmlC14NMode)'/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise)'/>
      <arg name='with_comments' type='int' info='include comments in the result (!=0) or not (==0)'/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='the memory pointer for allocated canonical XML text; the caller of this functions is responsible for calling xmlFree() to free allocated memory'/>
    </function>
    <function name='xmlC14NDocSave' file='c14n' module='c14n'>
      <cond>defined(LIBXML_C14N_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dumps the canonized image of given XML document into the file. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='the number of bytes written success or a negative value on fail'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document for canonization'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='the nodes set to be included in the canonized image or NULL if all document nodes should be included'/>
      <arg name='mode' type='int' info='the c14n mode (see @xmlC14NMode)'/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise)'/>
      <arg name='with_comments' type='int' info='include comments in the result (!=0) or not (==0)'/>
      <arg name='filename' type='const char *' info='the filename to store canonical XML image'/>
      <arg name='compression' type='int' info='the compression level (zlib requred): -1 - libxml default, 0 - uncompressed, &gt;0 - compression level'/>
    </function>
    <function name='xmlC14NDocSaveTo' file='c14n' module='c14n'>
      <cond>defined(LIBXML_C14N_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dumps the canonized image of given XML document into the provided buffer. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='non-negative value on success or a negative value on fail'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document for canonization'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='the nodes set to be included in the canonized image or NULL if all document nodes should be included'/>
      <arg name='mode' type='int' info='the c14n mode (see @xmlC14NMode)'/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise)'/>
      <arg name='with_comments' type='int' info='include comments in the result (!=0) or not (==0)'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output'/>
    </function>
    <function name='xmlC14NExecute' file='c14n' module='c14n'>
      <cond>defined(LIBXML_C14N_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dumps the canonized image of given XML document into the provided buffer. For details see &quot;Canonical XML&quot; (http://www.w3.org/TR/xml-c14n) or &quot;Exclusive XML Canonicalization&quot; (http://www.w3.org/TR/xml-exc-c14n)</info>
      <return type='int' info='non-negative value on success or a negative value on fail'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document for canonization'/>
      <arg name='is_visible_callback' type='xmlC14NIsVisibleCallback' info='the function to use to determine is node visible or not'/>
      <arg name='user_data' type='void *' info='the first parameter for @is_visible_callback function (in most cases, it is nodes set)'/>
      <arg name='mode' type='int' info='the c14n mode (see @xmlC14NMode)'/>
      <arg name='inclusive_ns_prefixes' type='xmlChar **' info='the list of inclusive namespace prefixes ended with a NULL or NULL if there is no inclusive namespaces (only for exclusive canonicalization, ignored otherwise)'/>
      <arg name='with_comments' type='int' info='include comments in the result (!=0) or not (==0)'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the output buffer to store canonical XML; this buffer MUST have encoder==NULL because C14N requires UTF-8 output'/>
    </function>
    <functype name='xmlC14NIsVisibleCallback' file='c14n' module='c14n'>
      <cond>defined(LIBXML_C14N_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Signature for a C14N callback on visible nodes</info>
      <return type='int' info='1 if the node should be included'/>
      <arg name='user_data' type='void *' info='user data'/>
      <arg name='node' type='xmlNodePtr' info='the curent node'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
    </functype>
    <function name='xmlCanonicPath' file='uri' module='uri'>
      <info>Constructs a canonic path from the specified path.</info>
      <return type='xmlChar *' info='a new canonic path, or a duplicate of the path parameter if the construction fails. The caller is responsible for freeing the memory occupied by the returned string. If there is insufficient memory available, or the argument is NULL, the function returns NULL.'/>
      <arg name='path' type='const xmlChar *' info='the resource locator in a filesystem notation'/>
    </function>
    <function name='xmlCatalogAdd' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Add an entry in the catalog, it may overwrite existing but different entries. If called before any other catalog routine, allows to override the default shared catalog put in place by xmlInitializeCatalog();</info>
      <return type='int' info='0 if successful, -1 otherwise'/>
      <arg name='type' type='const xmlChar *' info='the type of record to add to the catalog'/>
      <arg name='orig' type='const xmlChar *' info='the system, public or prefix to match'/>
      <arg name='replace' type='const xmlChar *' info='the replacement value for the match'/>
    </function>
    <function name='xmlCatalogAddLocal' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Add the new entry to the catalog list</info>
      <return type='void *' info='the updated list'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs'/>
      <arg name='URL' type='const xmlChar *' info='the URL to a new local catalog'/>
    </function>
    <function name='xmlCatalogCleanup' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Free up all the memory associated with catalogs</info>
      <return type='void'/>
    </function>
    <function name='xmlCatalogConvert' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int' info='the number of entries converted if successful, -1 otherwise'/>
    </function>
    <function name='xmlCatalogDump' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump all the global catalog content to the given file.</info>
      <return type='void'/>
      <arg name='out' type='FILE *' info='the file.'/>
    </function>
    <function name='xmlCatalogFreeLocal' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Free up the memory associated to the catalog list</info>
      <return type='void'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs'/>
    </function>
    <function name='xmlCatalogGetDefaults' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Used to get the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='xmlCatalogAllow' info='the current xmlCatalogAllow value'/>
    </function>
    <function name='xmlCatalogGetPublic' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog reference associated to a public ID DEPRECATED, use xmlCatalogResolvePublic()</info>
      <return type='const xmlChar *' info='the resource if found or NULL otherwise.'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
    </function>
    <function name='xmlCatalogGetSystem' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog reference associated to a system ID DEPRECATED, use xmlCatalogResolveSystem()</info>
      <return type='const xmlChar *' info='the resource if found or NULL otherwise.'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlCatalogIsEmpty' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Check is a catalog is empty</info>
      <return type='int' info='1 if the catalog is empty, 0 if not, amd -1 in case of error.'/>
      <arg name='catal' type='xmlCatalogPtr' info='should this create an SGML catalog'/>
    </function>
    <function name='xmlCatalogLocalResolve' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an External Identifier using a document&apos;s private catalog list</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlCatalogLocalResolveURI' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an URI using a document&apos;s private catalog list</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='catalogs' type='void *' info='a document&apos;s list of catalogs'/>
      <arg name='URI' type='const xmlChar *' info='the URI'/>
    </function>
    <function name='xmlCatalogRemove' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Remove an entry from the catalog</info>
      <return type='int' info='the number of entries removed if successful, -1 otherwise'/>
      <arg name='value' type='const xmlChar *' info='the value to remove'/>
    </function>
    <function name='xmlCatalogResolve' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an External Identifier</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlCatalogResolvePublic' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog reference associated to a public ID</info>
      <return type='xmlChar *' info='the resource if found or NULL otherwise, the value returned must be freed by the caller.'/>
      <arg name='pubID' type='const xmlChar *' info='the public ID string'/>
    </function>
    <function name='xmlCatalogResolveSystem' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Try to lookup the catalog resource for a system ID</info>
      <return type='xmlChar *' info='the resource if found or NULL otherwise, the value returned must be freed by the caller.'/>
      <arg name='sysID' type='const xmlChar *' info='the system ID string'/>
    </function>
    <function name='xmlCatalogResolveURI' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do a complete resolution lookup of an URI</info>
      <return type='xmlChar *' info='the URI of the resource or NULL if not found, it must be freed by the caller.'/>
      <arg name='URI' type='const xmlChar *' info='the URI'/>
    </function>
    <function name='xmlCatalogSetDebug' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Used to set the debug level for catalog operation, 0 disable debugging, 1 enable it</info>
      <return type='int' info='the previous value of the catalog debugging level'/>
      <arg name='level' type='int' info='the debug level of catalogs required'/>
    </function>
    <function name='xmlCatalogSetDefaultPrefer' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Allows to set the preference between public and system for deletion in XML Catalog resolution. C.f. section 4.1.1 of the spec Values accepted are XML_CATA_PREFER_PUBLIC or XML_CATA_PREFER_SYSTEM</info>
      <return type='xmlCatalogPrefer' info='the previous value of the default preference for delegation'/>
      <arg name='prefer' type='xmlCatalogPrefer' info='the default preference for delegation'/>
    </function>
    <function name='xmlCatalogSetDefaults' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Used to set the user preference w.r.t. to what catalogs should be accepted</info>
      <return type='void'/>
      <arg name='allow' type='xmlCatalogAllow' info='what catalogs should be accepted'/>
    </function>
    <function name='xmlCharEncCloseFunc' file='encoding' module='encoding'>
      <info>Generic front-end for encoding handler close function</info>
      <return type='int' info='0 if success, or -1 in case of error'/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='char enconding transformation data structure'/>
    </function>
    <function name='xmlCharEncFirstLine' file='encoding' module='encoding'>
      <info>Front-end for the encoding handler input function, but handle only the very first line, i.e. limit itself to 45 chars.</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or'/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='char enconding transformation data structure'/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output.'/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input'/>
    </function>
    <function name='xmlCharEncInFunc' file='encoding' module='encoding'>
      <info>Generic front-end for the encoding handler input function</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or'/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='char encoding transformation data structure'/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output.'/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input'/>
    </function>
    <function name='xmlCharEncOutFunc' file='encoding' module='encoding'>
      <info>Generic front-end for the encoding handler output function a first call with @in == NULL has to be made firs to initiate the output in case of non-stateless encoding needing to initiate their state or the output (like the BOM in UTF16). In case of UTF8 sequence conversion errors for the given encoder, the content will be automatically remapped to a CharRef sequence.</info>
      <return type='int' info='the number of byte written if success, or -1 general error -2 if the transcoding fails (for *in is not valid utf8 string or the result of transformation can&apos;t fit into the encoding we want), or'/>
      <arg name='handler' type='xmlCharEncodingHandler *' info='char enconding transformation data structure'/>
      <arg name='out' type='xmlBufferPtr' info='an xmlBuffer for the output.'/>
      <arg name='in' type='xmlBufferPtr' info='an xmlBuffer for the input'/>
    </function>
    <functype name='xmlCharEncodingInputFunc' file='encoding' module='encoding'>
      <info>Take a block of chars in the original encoding and try to convert it to an UTF-8 block of chars out.</info>
      <return type='int' info='the number of bytes written, -1 if lack of space, or -2 if the transcoding failed. The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictiable. The value of @outlen after return is the number of octets consumed.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the UTF-8 result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of chars in the original encoding'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
    </functype>
    <functype name='xmlCharEncodingOutputFunc' file='encoding' module='encoding'>
      <info>Take a block of UTF-8 chars in and try to convert it to another encoding. Note: a first call designed to produce heading info is called with in = NULL. If stateful this should also initialize the encoder state.</info>
      <return type='int' info='the number of bytes written, -1 if lack of space, or -2 if the transcoding failed. The value of @inlen after return is the number of octets consumed if the return value is positive, else unpredictiable. The value of @outlen after return is the number of octets produced.'/>
      <arg name='out' type='unsigned char *' info='a pointer to an array of bytes to store the result'/>
      <arg name='outlen' type='int *' info='the length of @out'/>
      <arg name='in' type='const unsigned char *' info='a pointer to an array of UTF-8 chars'/>
      <arg name='inlen' type='int *' info='the length of @in'/>
    </functype>
    <function name='xmlCharInRange' file='chvalid' module='chvalid'>
      <info>Does a binary search of the range table to determine if char is valid</info>
      <return type='int' info='true if character valid, false otherwise'/>
      <arg name='val' type='unsigned int' info='character to be validated'/>
      <arg name='rptr' type='const xmlChRangeGroup *' info='pointer to range to be used to validate'/>
    </function>
    <function name='xmlCharStrdup' file='xmlstring' module='xmlstring'>
      <info>a strdup for char&apos;s to xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL'/>
      <arg name='cur' type='const char *' info='the input char *'/>
    </function>
    <function name='xmlCharStrndup' file='xmlstring' module='xmlstring'>
      <info>a strndup for char&apos;s to xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL'/>
      <arg name='cur' type='const char *' info='the input char *'/>
      <arg name='len' type='int' info='the len of @cur'/>
    </function>
    <function name='xmlCheckFilename' file='xmlIO' module='xmlIO'>
      <info>function checks to see if @path is a valid source (file, socket...) for XML.  if stat is not available on the target machine,</info>
      <return type='int' info='1.  if stat fails, returns 0 (if calling stat on the filename fails, it can&apos;t be right). if stat succeeds and the file is a directory, returns 2.  otherwise returns 1.'/>
      <arg name='path' type='const char *' info='the path to check'/>
    </function>
    <function name='xmlCheckHTTPInput' file='xmlIO' module='xmlIO'>
      <info>Check an input in case it was created from an HTTP stream, in that case it will handle encoding and update of the base URL in case of redirection. It also checks for HTTP errors in which case the input is cleanly freed up and an appropriate error is raised in context</info>
      <return type='xmlParserInputPtr' info='the input or NULL in case of HTTP error.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='ret' type='xmlParserInputPtr' info='an XML parser input'/>
    </function>
    <function name='xmlCheckLanguageID' file='parserInternals' module='parser'>
      <info>Checks that the value conforms to the LanguageID production:  NOTE: this is somewhat deprecated, those productions were removed from the XML Second edition.  [33] LanguageID ::= Langcode (&apos;-&apos; Subcode)* [34] Langcode ::= ISO639Code |  IanaCode |  UserCode [35] ISO639Code ::= ([a-z] | [A-Z]) ([a-z] | [A-Z]) [36] IanaCode ::= (&apos;i&apos; | &apos;I&apos;) &apos;-&apos; ([a-z] | [A-Z])+ [37] UserCode ::= (&apos;x&apos; | &apos;X&apos;) &apos;-&apos; ([a-z] | [A-Z])+ [38] Subcode ::= ([a-z] | [A-Z])+  The current REC reference the sucessors of RFC 1766, currently 5646  http://www.rfc-editor.org/rfc/rfc5646.txt langtag       = language [&quot;-&quot; script] [&quot;-&quot; region] *(&quot;-&quot; variant) *(&quot;-&quot; extension) [&quot;-&quot; privateuse] language      = 2*3ALPHA            ; shortest ISO 639 code [&quot;-&quot; extlang]       ; sometimes followed by ; extended language subtags / 4ALPHA              ; or reserved for future use / 5*8ALPHA            ; or registered language subtag  extlang       = 3ALPHA              ; selected ISO 639 codes *2(&quot;-&quot; 3ALPHA)      ; permanently reserved  script        = 4ALPHA              ; ISO 15924 code  region        = 2ALPHA              ; ISO 3166-1 code / 3DIGIT              ; UN M.49 code  variant       = 5*8alphanum         ; registered variants / (DIGIT 3alphanum)  extension     = singleton 1*(&quot;-&quot; (2*8alphanum))  ; Single alphanumerics ; &quot;x&quot; reserved for private use singleton     = DIGIT               ; 0 - 9 / %x41-57             ; A - W / %x59-5A             ; Y - Z / %x61-77             ; a - w / %x79-7A             ; y - z  it sounds right to still allow Irregular i-xxx IANA and user codes too The parser below doesn&apos;t try to cope with extension or privateuse that could be added but that&apos;s not interoperable anyway</info>
      <return type='int' info='1 if correct 0 otherwise'/>
      <arg name='lang' type='const xmlChar *' info='pointer to the string value'/>
    </function>
    <function name='xmlCheckUTF8' file='xmlstring' module='xmlstring'>
      <info>Checks @utf for being valid UTF-8. @utf is assumed to be null-terminated. This function is not super-strict, as it will allow longer UTF-8 sequences than necessary. Note that Java is capable of producing these sequences if provoked. Also note, this routine checks for the 4-byte maximum size, but does not check for 0x10ffff maximum value.</info>
      <return type='int' info='value: true if @utf is valid.'/>
      <arg name='utf' type='const unsigned char *' info='Pointer to putative UTF-8 encoded string.'/>
    </function>
    <function name='xmlCheckVersion' file='xmlversion' module='parserInternals'>
      <info>check the compiled lib version against the include one. This can warn or immediately kill the application</info>
      <return type='void'/>
      <arg name='version' type='int' info='the include version number'/>
    </function>
    <function name='xmlChildElementCount' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Finds the current number of child nodes of that element which are element nodes. Note the handling of entities references is different than in the W3C DOM element traversal spec since we don&apos;t have back reference from entities content to entities references.</info>
      <return type='unsigned long' info='the count of element child or 0 if not available'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
    </function>
    <function name='xmlCleanupCharEncodingHandlers' file='encoding' module='encoding'>
      <info>Cleanup the memory allocated for the char encoding support, it unregisters all the encoding handlers and the aliases.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupEncodingAliases' file='encoding' module='encoding'>
      <info>Unregisters all aliases</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupGlobals' file='globals' module='globals'>
      <info>Additional cleanup for multi-threading</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupInputCallbacks' file='xmlIO' module='xmlIO'>
      <info>clears the entire input callback table. this includes the compiled-in I/O.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupMemory' file='xmlmemory' module='xmlmemory'>
      <info>Free up all the memory allocated by the library for its own use. This should not be called by user level code.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupOutputCallbacks' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>clears the entire output callback table. this includes the compiled-in I/O callbacks.</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupParser' file='parser' module='parser'>
      <info>This function name is somewhat misleading. It does not clean up parser state, it cleans up memory allocated by the library itself. It is a cleanup function for the XML library. It tries to reclaim all related global memory allocated for the library processing. It doesn&apos;t deallocate any document related memory. One should call xmlCleanupParser() only when the process has finished using the library and all XML/HTML documents built with it. See also xmlInitParser() which has the opposite function of preparing the library for operations.  WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It&apos;s sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupPredefinedEntities' file='entities' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Cleanup up the predefined entities table. Deprecated call</info>
      <return type='void'/>
    </function>
    <function name='xmlCleanupThreads' file='threads' module='threads'>
      <info>xmlCleanupThreads() is used to to cleanup all the thread related data of the libxml2 library once processing has ended.  WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It&apos;s sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !</info>
      <return type='void'/>
    </function>
    <function name='xmlClearNodeInfoSeq' file='parser' module='parserInternals'>
      <info>-- Clear (release memory and reinitialize) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr' info='a node info sequence pointer'/>
    </function>
    <function name='xmlClearParserCtxt' file='parser' module='parserInternals'>
      <info>Clear (release owned resources) and reinitialize a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlConvertSGMLCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Convert all the SGML catalog entries as XML ones</info>
      <return type='int' info='the number of entries converted if successful, -1 otherwise'/>
      <arg name='catal' type='xmlCatalogPtr' info='the catalog'/>
    </function>
    <function name='xmlCopyAttributeTable' file='valid' module='valid'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Build a copy of an attribute table.</info>
      <return type='xmlAttributeTablePtr' info='the new xmlAttributeTablePtr or NULL in case of error.'/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table'/>
    </function>
    <function name='xmlCopyChar' file='parserInternals' module='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int' info='the number of xmlChar written'/>
      <arg name='len' type='int' info='Ignored, compatibility'/>
      <arg name='out' type='xmlChar *' info='pointer to an array of xmlChar'/>
      <arg name='val' type='int' info='the char value'/>
    </function>
    <function name='xmlCopyCharMultiByte' file='parserInternals' module='parserInternals'>
      <info>append the char value in the array</info>
      <return type='int' info='the number of xmlChar written'/>
      <arg name='out' type='xmlChar *' info='pointer to an array of xmlChar'/>
      <arg name='val' type='int' info='the char value'/>
    </function>
    <function name='xmlCopyDoc' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Do a copy of the document info. If recursive, the content tree will be copied too as well as DTD, namespaces and entities.</info>
      <return type='xmlDocPtr' info='a new #xmlDocPtr, or NULL in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='recursive' type='int' info='if not zero do a recursive copy.'/>
    </function>
    <function name='xmlCopyDocElementContent' file='valid' module='valid'>
      <info>Build a copy of an element content description.</info>
      <return type='xmlElementContentPtr' info='the new xmlElementContentPtr or NULL in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='the document owning the element declaration'/>
      <arg name='cur' type='xmlElementContentPtr' info='An element content pointer.'/>
    </function>
    <function name='xmlCopyDtd' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Do a copy of the dtd.</info>
      <return type='xmlDtdPtr' info='a new #xmlDtdPtr, or NULL in case of error.'/>
      <arg name='dtd' type='xmlDtdPtr' info='the dtd'/>
    </function>
    <function name='xmlCopyElementContent' file='valid' module='valid'>
      <info>Build a copy of an element content description. Deprecated, use xmlCopyDocElementContent instead</info>
      <return type='xmlElementContentPtr' info='the new xmlElementContentPtr or NULL in case of error.'/>
      <arg name='cur' type='xmlElementContentPtr' info='An element content pointer.'/>
    </function>
    <function name='xmlCopyElementTable' file='valid' module='valid'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Build a copy of an element table.</info>
      <return type='xmlElementTablePtr' info='the new xmlElementTablePtr or NULL in case of error.'/>
      <arg name='table' type='xmlElementTablePtr' info='An element table'/>
    </function>
    <function name='xmlCopyEntitiesTable' file='entities' module='entities'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Build a copy of an entity table.</info>
      <return type='xmlEntitiesTablePtr' info='the new xmlEntitiesTablePtr or NULL in case of error.'/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table'/>
    </function>
    <function name='xmlCopyEnumeration' file='valid' module='valid'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Copy an enumeration attribute node (recursive).</info>
      <return type='xmlEnumerationPtr' info='the xmlEnumerationPtr just created or NULL in case of error.'/>
      <arg name='cur' type='xmlEnumerationPtr' info='the tree to copy.'/>
    </function>
    <function name='xmlCopyError' file='xmlerror' module='error'>
      <info>Save the original error to the new place.</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='from' type='xmlErrorPtr' info='a source error'/>
      <arg name='to' type='xmlErrorPtr' info='a target error'/>
    </function>
    <function name='xmlCopyNamespace' file='tree' module='tree'>
      <info>Do a copy of the namespace.</info>
      <return type='xmlNsPtr' info='a new #xmlNsPtr, or NULL in case of error.'/>
      <arg name='cur' type='xmlNsPtr' info='the namespace'/>
    </function>
    <function name='xmlCopyNamespaceList' file='tree' module='tree'>
      <info>Do a copy of an namespace list.</info>
      <return type='xmlNsPtr' info='a new #xmlNsPtr, or NULL in case of error.'/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace'/>
    </function>
    <function name='xmlCopyNode' file='tree' module='tree'>
      <info>Do a copy of the node.</info>
      <return type='xmlNodePtr' info='a new #xmlNodePtr, or NULL in case of error.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='extended' type='int' info='if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable)'/>
    </function>
    <function name='xmlCopyNodeList' file='tree' module='tree'>
      <info>Do a recursive copy of the node list. Use xmlDocCopyNodeList() if possible to ensure string interning.</info>
      <return type='xmlNodePtr' info='a new #xmlNodePtr, or NULL in case of error.'/>
      <arg name='node' type='xmlNodePtr' info='the first node in the list.'/>
    </function>
    <function name='xmlCopyNotationTable' file='valid' module='valid'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Build a copy of a notation table.</info>
      <return type='xmlNotationTablePtr' info='the new xmlNotationTablePtr or NULL in case of error.'/>
      <arg name='table' type='xmlNotationTablePtr' info='A notation table'/>
    </function>
    <function name='xmlCopyProp' file='tree' module='tree'>
      <info>Do a copy of the attribute.</info>
      <return type='xmlAttrPtr' info='a new #xmlAttrPtr, or NULL in case of error.'/>
      <arg name='target' type='xmlNodePtr' info='the element where the attribute will be grafted'/>
      <arg name='cur' type='xmlAttrPtr' info='the attribute'/>
    </function>
    <function name='xmlCopyPropList' file='tree' module='tree'>
      <info>Do a copy of an attribute list.</info>
      <return type='xmlAttrPtr' info='a new #xmlAttrPtr, or NULL in case of error.'/>
      <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted'/>
      <arg name='cur' type='xmlAttrPtr' info='the first attribute'/>
    </function>
    <function name='xmlCreateDocParserCtxt' file='parser' module='parser'>
      <info>Creates a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to an array of xmlChar'/>
    </function>
    <function name='xmlCreateEntitiesTable' file='entities' module='entities'>
      <info>create and initialize an empty entities hash table. This really doesn&apos;t make sense and should be deprecated</info>
      <return type='xmlEntitiesTablePtr' info='the xmlEntitiesTablePtr just created or NULL in case of error.'/>
    </function>
    <function name='xmlCreateEntityParserCtxt' file='parserInternals' module='parser'>
      <info>Create a parser context for an external entity Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='URL' type='const xmlChar *' info='the entity URL'/>
      <arg name='ID' type='const xmlChar *' info='the entity PUBLIC ID'/>
      <arg name='base' type='const xmlChar *' info='a possible base for the target URI'/>
    </function>
    <function name='xmlCreateEnumeration' file='valid' module='valid'>
      <info>create and initialize an enumeration attribute node.</info>
      <return type='xmlEnumerationPtr' info='the xmlEnumerationPtr just created or NULL in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the enumeration name or NULL'/>
    </function>
    <function name='xmlCreateFileParserCtxt' file='parserInternals' module='parser'>
      <info>Create a parser context for a file content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlCreateIOParserCtxt' file='parser' module='parser'>
      <info>Create a parser context for using the XML parser with an existing I/O stream</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlCreateIntSubset' file='tree' module='tree'>
      <info>Create the internal subset of a document</info>
      <return type='xmlDtdPtr' info='a pointer to the new DTD structure'/>
      <arg name='doc' type='xmlDocPtr' info='the document pointer'/>
      <arg name='name' type='const xmlChar *' info='the DTD name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external (PUBLIC) ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the system ID'/>
    </function>
    <function name='xmlCreateMemoryParserCtxt' file='parserInternals' module='parser'>
      <info>Create a parser context for an XML in-memory document.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='xmlCreatePushParserCtxt' file='parser' module='parser'>
      <cond>defined(LIBXML_PUSH_ENABLED)</cond>
      <info>Create a parser context for using the XML parser in push mode. If @buffer and @size are non-NULL, the data is used to detect the encoding.  The remaining characters will be parsed so they don&apos;t need to be fed in again through xmlParseChunk. To allow content encoding detection, @size should be &gt;= 4 The value of @filename is used for fetching external entities and error/warning reports.</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars'/>
      <arg name='size' type='int' info='number of chars in the array'/>
      <arg name='filename' type='const char *' info='an optional file name or URI'/>
    </function>
    <function name='xmlCreateURI' file='uri' module='uri'>
      <info>Simply creates an empty xmlURI</info>
      <return type='xmlURIPtr' info='the new structure or NULL in case of error'/>
    </function>
    <function name='xmlCreateURLParserCtxt' file='parserInternals' module='parser'>
      <info>Create a parser context for a file or URL content. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time and for file accesses</info>
      <return type='xmlParserCtxtPtr' info='the new parser context or NULL'/>
      <arg name='filename' type='const char *' info='the filename or URL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtGetLastError' file='xmlerror' module='error'>
      <info>Get the last parsing error registered.</info>
      <return type='xmlErrorPtr' info='NULL if no error occured or a pointer to the error'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
    </function>
    <function name='xmlCtxtReadDoc' file='parser' module='parser'>
      <info>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtReadFd' file='parser' module='parser'>
      <info>parse an XML from a file descriptor and build a tree. This reuses the existing @ctxt parser context NOTE that the file descriptor will not be closed when the reader is closed or reset.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtReadFile' file='parser' module='parser'>
      <info>parse an XML file from the filesystem or the network. This reuses the existing @ctxt parser context</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtReadIO' file='parser' module='parser'>
      <info>parse an XML document from I/O functions and source and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtReadMemory' file='parser' module='parser'>
      <info>parse an XML in-memory document and build a tree. This reuses the existing @ctxt parser context</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCtxtReset' file='parser' module='parser'>
      <info>Reset a parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlCtxtResetLastError' file='xmlerror' module='error'>
      <info>Cleanup the last global error registered. For parsing error this does not change the well-formedness result.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
    </function>
    <function name='xmlCtxtResetPush' file='parser' module='parser'>
      <info>Reset a push parser context</info>
      <return type='int' info='0 in case of success and 1 in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='chunk' type='const char *' info='a pointer to an array of chars'/>
      <arg name='size' type='int' info='number of chars in the array'/>
      <arg name='filename' type='const char *' info='an optional file name or URI'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
    </function>
    <function name='xmlCtxtUseOptions' file='parser' module='parser'>
      <info>Applies the options to the parser context</info>
      <return type='int' info='0 in case of success, the set of unknown or unimplemented options in case of error.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlCurrentChar' file='parserInternals' module='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer. Implement the end of line normalization: 2.11 End-of-Line Handling Wherever an external parsed entity or the literal entity value of an internal parsed entity contains either the literal two-character sequence &quot;#xD#xA&quot; or a standalone literal #xD, an XML processor must pass to the application the single character #xA. This behavior can conveniently be produced by normalizing all line breaks to #xA on input, before parsing.)</info>
      <return type='int' info='the current char value and its length'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context'/>
      <arg name='len' type='int *' info='pointer to the length of the char read'/>
    </function>
    <functype name='xmlDOMWrapAcquireNsFunction' file='tree' module='tree'>
      <info>A function called to acquire namespaces (xmlNs) from the wrapper.</info>
      <return type='xmlNsPtr' info='an xmlNsPtr or NULL in case of an error.'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='a DOM wrapper context'/>
      <arg name='node' type='xmlNodePtr' info='the context node (element or attribute)'/>
      <arg name='nsName' type='const xmlChar *' info='the requested namespace name'/>
      <arg name='nsPrefix' type='const xmlChar *' info='the requested namespace prefix'/>
    </functype>
    <function name='xmlDOMWrapAdoptNode' file='tree' module='tree'>
      <info>References of out-of scope ns-decls are remapped to point to @destDoc: 1) If @destParent is given, then nsDef entries on element-nodes are used 2) If *no* @destParent is given, then @destDoc-&gt;oldNs entries are used This is the case when you have an unlinked node and just want to move it to the context of  If @destParent is given, it ensures that the tree is namespace wellformed by creating additional ns-decls where needed. Note that, since prefixes of already existent ns-decls can be shadowed by this process, it could break QNames in attribute values or element content. NOTE: This function was not intensively tested.</info>
      <return type='int' info='0 if the operation succeeded, 1 if a node of unsupported type was given, 2 if a node of not yet supported type was given and -1 on API/internal errors.'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='the optional context for custom processing'/>
      <arg name='sourceDoc' type='xmlDocPtr' info='the optional sourceDoc'/>
      <arg name='node' type='xmlNodePtr' info='the node to start with'/>
      <arg name='destDoc' type='xmlDocPtr' info='the destination doc'/>
      <arg name='destParent' type='xmlNodePtr' info='the optional new parent of @node in @destDoc'/>
      <arg name='options' type='int' info='option flags'/>
    </function>
    <function name='xmlDOMWrapCloneNode' file='tree' module='tree'>
      <info>References of out-of scope ns-decls are remapped to point to @destDoc: 1) If @destParent is given, then nsDef entries on element-nodes are used 2) If *no* @destParent is given, then @destDoc-&gt;oldNs entries are used. This is the case when you don&apos;t know already where the cloned branch will be added to.  If @destParent is given, it ensures that the tree is namespace wellformed by creating additional ns-decls where needed. Note that, since prefixes of already existent ns-decls can be shadowed by this process, it could break QNames in attribute values or element content. TODO: 1) What to do with XInclude? Currently this returns an error for XInclude.</info>
      <return type='int' info='0 if the operation succeeded, 1 if a node of unsupported (or not yet supported) type was given, -1 on API/internal errors.'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='the optional context for custom processing'/>
      <arg name='sourceDoc' type='xmlDocPtr' info='the optional sourceDoc'/>
      <arg name='node' type='xmlNodePtr' info='the node to start with'/>
      <arg name='resNode' type='xmlNodePtr *' info='the clone of the given @node'/>
      <arg name='destDoc' type='xmlDocPtr' info='the destination doc'/>
      <arg name='destParent' type='xmlNodePtr' info='the optional new parent of @node in @destDoc'/>
      <arg name='deep' type='int' info='descend into child if set'/>
      <arg name='options' type='int' info='option flags'/>
    </function>
    <function name='xmlDOMWrapFreeCtxt' file='tree' module='tree'>
      <info>Frees the DOM-wrapper context.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='the DOM-wrapper context'/>
    </function>
    <function name='xmlDOMWrapNewCtxt' file='tree' module='tree'>
      <info>Allocates and initializes a new DOM-wrapper context.</info>
      <return type='xmlDOMWrapCtxtPtr' info='the xmlDOMWrapCtxtPtr or NULL in case of an internal error.'/>
    </function>
    <function name='xmlDOMWrapReconcileNamespaces' file='tree' module='tree'>
      <info>Ensures that ns-references point to ns-decls hold on element-nodes. Ensures that the tree is namespace wellformed by creating additional ns-decls where needed. Note that, since prefixes of already existent ns-decls can be shadowed by this process, it could break QNames in attribute values or element content.  NOTE: This function was not intensively tested.</info>
      <return type='int' info='0 if succeeded, -1 otherwise and on API/internal errors.'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='DOM wrapper context, unused at the moment'/>
      <arg name='elem' type='xmlNodePtr' info='the element-node'/>
      <arg name='options' type='int' info='option flags'/>
    </function>
    <function name='xmlDOMWrapRemoveNode' file='tree' module='tree'>
      <info>Unlinks the given node from its owner. This will substitute ns-references to node-&gt;nsDef for ns-references to doc-&gt;oldNs, thus ensuring the removed branch to be autark wrt ns-references.  NOTE: This function was not intensively tested.</info>
      <return type='int' info='0 on success, 1 if the node is not supported, -1 on API and internal errors.'/>
      <arg name='ctxt' type='xmlDOMWrapCtxtPtr' info='a DOM wrapper context'/>
      <arg name='doc' type='xmlDocPtr' info='the doc'/>
      <arg name='node' type='xmlNodePtr' info='the node to be removed.'/>
      <arg name='options' type='int' info='set of options, unused at the moment'/>
    </function>
    <function name='xmlDebugCheckDocument' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Check the document for potential content problems, and output the errors to @output</info>
      <return type='int' info='the number of errors found'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlDebugDumpAttr' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the attribute</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlDebugDumpAttrList' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the attribute list</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute list'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlDebugDumpDTD' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the DTD</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='dtd' type='xmlDtdPtr' info='the DTD'/>
    </function>
    <function name='xmlDebugDumpDocument' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the document, it&apos;s recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlDebugDumpDocumentHead' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information cncerning the document, not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlDebugDumpEntities' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for all the entities in use by the document</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlDebugDumpNode' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlDebugDumpNodeList' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the list of element node, it is recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='node' type='xmlNodePtr' info='the node list'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlDebugDumpOneNode' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps debug information for the element node, it is not recursive</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlDebugDumpString' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps informations about the string, shorten it if necessary</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='str' type='const xmlChar *' info='the string'/>
    </function>
    <function name='xmlDecodeEntities' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>This function is deprecated, we now always process entities content through xmlStringDecodeEntities  TODO: remove it in next major release.  [67] Reference ::= EntityRef | CharRef  [69] PEReference ::= &apos;%&apos; Name &apos;;&apos;</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it !'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='len' type='int' info='the len to decode (in bytes !), -1 for no size limit'/>
      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF'/>
      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
    </function>
    <function name='xmlDefaultSAXHandlerInit' file='SAX2' module='SAX2'>
      <info>Initialize the default SAX2 handler</info>
      <return type='void'/>
    </function>
    <function name='xmlDelEncodingAlias' file='encoding' module='encoding'>
      <info>Unregisters an encoding alias @alias</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
    </function>
    <function name='xmlDeregisterNodeDefault' file='globals' module='globals'>
      <info>Registers a callback for node destruction</info>
      <return type='xmlDeregisterNodeFunc' info='the previous value of the deregistration function'/>
      <arg name='func' type='xmlDeregisterNodeFunc' info='function pointer to the new DeregisterNodeFunc'/>
    </function>
    <functype name='xmlDeregisterNodeFunc' file='globals' module='globals'>
      <info>Signature for the deregistration callback of a discarded node</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
    </functype>
    <function name='xmlDetectCharEncoding' file='encoding' module='encoding'>
      <info>Guess the encoding of the entity using the first bytes of the entity content according to the non-normative appendix F of the XML-1.0 recommendation.</info>
      <return type='xmlCharEncoding' info='one of the XML_CHAR_ENCODING_... values.'/>
      <arg name='in' type='const unsigned char *' info='a pointer to the first bytes of the XML entity, must be at least 2 bytes long (at least 4 if encoding is UTF4 variant).'/>
      <arg name='len' type='int' info='pointer to the length of the buffer'/>
    </function>
    <function name='xmlDictCleanup' file='dict' module='dict'>
      <info>Free the dictionary mutex. Do not call unless sure the library is not in use anymore !</info>
      <return type='void'/>
    </function>
    <function name='xmlDictCreate' file='dict' module='dict'>
      <info>Create a new dictionary</info>
      <return type='xmlDictPtr' info='the newly created dictionnary, or NULL if an error occured.'/>
    </function>
    <function name='xmlDictCreateSub' file='dict' module='dict'>
      <info>Create a new dictionary, inheriting strings from the read-only dictionnary @sub. On lookup, strings are first searched in the new dictionnary, then in @sub, and if not found are created in the new dictionnary.</info>
      <return type='xmlDictPtr' info='the newly created dictionnary, or NULL if an error occured.'/>
      <arg name='sub' type='xmlDictPtr' info='an existing dictionnary'/>
    </function>
    <function name='xmlDictExists' file='dict' module='dict'>
      <info>Check if the @name exists in the dictionnary @dict.</info>
      <return type='const xmlChar *' info='the internal copy of the name or NULL if not found.'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='len' type='int' info='the length of the name, if -1 it is recomputed'/>
    </function>
    <function name='xmlDictFree' file='dict' module='dict'>
      <info>Free the hash @dict and its contents. The userdata is deallocated with @f if provided.</info>
      <return type='void'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
    </function>
    <function name='xmlDictGetUsage' file='dict' module='dict'>
      <info>Get how much memory is used by a dictionary for strings Added in 2.9.0</info>
      <return type='size_t' info='the amount of strings allocated'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
    </function>
    <function name='xmlDictLookup' file='dict' module='dict'>
      <info>Add the @name to the dictionnary @dict if not present.</info>
      <return type='const xmlChar *' info='the internal copy of the name or NULL in case of internal error'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='len' type='int' info='the length of the name, if -1 it is recomputed'/>
    </function>
    <function name='xmlDictOwns' file='dict' module='dict'>
      <info>check if a string is owned by the disctionary</info>
      <return type='int' info='1 if true, 0 if false and -1 in case of error -1 in case of error'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
      <arg name='str' type='const xmlChar *' info='the string'/>
    </function>
    <function name='xmlDictQLookup' file='dict' module='dict'>
      <info>Add the QName @prefix:@name to the hash @dict if not present.</info>
      <return type='const xmlChar *' info='the internal copy of the QName or NULL in case of internal error'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix'/>
      <arg name='name' type='const xmlChar *' info='the name'/>
    </function>
    <function name='xmlDictReference' file='dict' module='dict'>
      <info>Increment the reference counter of a dictionary</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
    </function>
    <function name='xmlDictSetLimit' file='dict' module='dict'>
      <info>Set a size limit for the dictionary Added in 2.9.0</info>
      <return type='size_t' info='the previous limit of the dictionary or 0'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
      <arg name='limit' type='size_t' info='the limit in bytes'/>
    </function>
    <function name='xmlDictSize' file='dict' module='dict'>
      <info>Query the number of elements installed in the hash @dict.</info>
      <return type='int' info='the number of elements in the dictionnary or -1 in case of error'/>
      <arg name='dict' type='xmlDictPtr' info='the dictionnary'/>
    </function>
    <function name='xmlDllMain' file='threads' module='threads'>
      <info></info>
      <return type='int' info=''/>
      <arg name='hinstDLL' type='void *' info=''/>
      <arg name='fdwReason' type='unsigned long' info=''/>
      <arg name='lpvReserved' type='void *' info=''/>
    </function>
    <function name='xmlDocCopyNode' file='tree' module='tree'>
      <info>Do a copy of the node to a given document.</info>
      <return type='xmlNodePtr' info='a new #xmlNodePtr, or NULL in case of error.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='extended' type='int' info='if 1 do a recursive copy (properties, namespaces and children when applicable) if 2 copy properties and namespaces (when applicable)'/>
    </function>
    <function name='xmlDocCopyNodeList' file='tree' module='tree'>
      <info>Do a recursive copy of the node list.</info>
      <return type='xmlNodePtr' info='a new #xmlNodePtr, or NULL in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='the target document'/>
      <arg name='node' type='xmlNodePtr' info='the first node in the list.'/>
    </function>
    <function name='xmlDocDump' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to an open FILE.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='f' type='FILE *' info='the FILE*'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlDocDumpFormatMemory' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document in memory and return the #xmlChar * and it&apos;s size. It&apos;s up to the caller to free the memory with xmlFree(). Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer'/>
      <arg name='size' type='int *' info='OUT: the memory length'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='xmlDocDumpFormatMemoryEnc' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller.  Note it is up to the caller of this function to free the allocated memory with xmlFree(). Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='out_doc' type='xmlDocPtr' info='Document to generate XML text from'/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text'/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text'/>
      <arg name='txt_encoding' type='const char *' info='Character encoding to use when generating XML text'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='xmlDocDumpMemory' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document in memory and return the #xmlChar * and it&apos;s size in bytes. It&apos;s up to the caller to free the memory with xmlFree(). The resulting byte array is zero terminated, though the last 0 is not included in the returned size.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='mem' type='xmlChar **' info='OUT: the memory pointer'/>
      <arg name='size' type='int *' info='OUT: the memory length'/>
    </function>
    <function name='xmlDocDumpMemoryEnc' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump the current DOM tree into memory using the character encoding specified by the caller.  Note it is up to the caller of this function to free the allocated memory with xmlFree().</info>
      <return type='void'/>
      <arg name='out_doc' type='xmlDocPtr' info='Document to generate XML text from'/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text'/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text'/>
      <arg name='txt_encoding' type='const char *' info='Character encoding to use when generating XML text'/>
    </function>
    <function name='xmlDocFormatDump' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to an open FILE.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called'/>
      <arg name='f' type='FILE *' info='the FILE*'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='xmlDocGetRootElement' file='tree' module='tree'>
      <info>Get the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr' info='the #xmlNodePtr for the root or NULL'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
    </function>
    <function name='xmlDocSetRootElement' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Set the root element of the document (doc-&gt;children is a list containing possibly comments, PIs, etc ...).</info>
      <return type='xmlNodePtr' info='the old root element if any was found, NULL if root was NULL'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='root' type='xmlNodePtr' info='the new document root element, if root is NULL no action is taken, to remove a node from a document use xmlUnlinkNode(root) instead.'/>
    </function>
    <function name='xmlDumpAttributeDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the attribute declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='attr' type='xmlAttributePtr' info='An attribute declaration'/>
    </function>
    <function name='xmlDumpAttributeTable' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the attribute table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table'/>
    </function>
    <function name='xmlDumpElementDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the element declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='elem' type='xmlElementPtr' info='An element table'/>
    </function>
    <function name='xmlDumpElementTable' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the element table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='table' type='xmlElementTablePtr' info='An element table'/>
    </function>
    <function name='xmlDumpEntitiesTable' file='entities' module='entities'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='An XML buffer.'/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table'/>
    </function>
    <function name='xmlDumpEntityDecl' file='entities' module='entities'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the entity table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='An XML buffer.'/>
      <arg name='ent' type='xmlEntityPtr' info='An entity table'/>
    </function>
    <function name='xmlDumpNotationDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content the notation declaration as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='nota' type='xmlNotationPtr' info='A notation declaration'/>
    </function>
    <function name='xmlDumpNotationTable' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This will dump the content of the notation table as an XML DTD definition</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='table' type='xmlNotationTablePtr' info='A notation table'/>
    </function>
    <function name='xmlElemDump' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML/HTML node, recursive behaviour, children are printed too.</info>
      <return type='void'/>
      <arg name='f' type='FILE *' info='the FILE * for the output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
    </function>
    <function name='xmlEncodeEntities' file='entities' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>TODO: remove xmlEncodeEntities, once we are not afraid of breaking binary compatibility  People must migrate their code to xmlEncodeEntitiesReentrant ! This routine will issue a warning when encountered.</info>
      <return type='const xmlChar *' info='NULL'/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the string'/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML.'/>
    </function>
    <function name='xmlEncodeEntitiesReentrant' file='entities' module='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities and non ASCII values with their entities and CharRef counterparts. Contrary to xmlEncodeEntities, this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done.'/>
      <arg name='doc' type='xmlDocPtr' info='the document containing the string'/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML.'/>
    </function>
    <function name='xmlEncodeSpecialChars' file='entities' module='entities'>
      <info>Do a global encoding of a string, replacing the predefined entities this routine is reentrant, and result must be deallocated.</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done.'/>
      <arg name='doc' type='const xmlDoc *' info='the document containing the string'/>
      <arg name='input' type='const xmlChar *' info='A string to convert to XML.'/>
    </function>
    <functype name='xmlEntityReferenceFunc' file='parserInternals' module='parserInternals'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Callback function used when one needs to be able to track back the provenance of a chunk of nodes inherited from an entity replacement.</info>
      <return type='void'/>
      <arg name='ent' type='xmlEntityPtr' info='the entity'/>
      <arg name='firstNode' type='xmlNodePtr' info='the fist node in the chunk'/>
      <arg name='lastNode' type='xmlNodePtr' info='the last nod in the chunk'/>
    </functype>
    <function name='xmlErrMemory' file='parserInternals' module='parserInternals'>
      <info>Handle a redefinition of attribute error</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='extra' type='const char *' info='extra informations'/>
    </function>
    <function name='xmlExpCtxtNbCons' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Debugging facility provides the number of allocated nodes over lifetime</info>
      <return type='int' info='the number of nodes ever allocated or -1 in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
    </function>
    <function name='xmlExpCtxtNbNodes' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Debugging facility provides the number of allocated nodes at a that point</info>
      <return type='int' info='the number of nodes in use or -1 in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
    </function>
    <function name='xmlExpDump' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Serialize the expression as compiled to the buffer</info>
      <return type='void'/>
      <arg name='buf' type='xmlBufferPtr' info='a buffer to receive the output'/>
      <arg name='expr' type='xmlExpNodePtr' info='the compiled expression'/>
    </function>
    <function name='xmlExpExpDerive' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Evaluates the expression resulting from @exp consuming a sub expression @sub Based on algebraic derivation and sometimes direct Brzozowski derivation it usually tatkes less than linear time and can handle expressions generating infinite languages.</info>
      <return type='xmlExpNodePtr' info='the resulting expression or NULL in case of internal error, the result must be freed'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the englobing expression'/>
      <arg name='sub' type='xmlExpNodePtr' info='the subexpression'/>
    </function>
    <function name='xmlExpFree' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Dereference the expression</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
    </function>
    <function name='xmlExpFreeCtxt' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Free an expression context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='an expression context'/>
    </function>
    <function name='xmlExpGetLanguage' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Find all the strings used in @exp and store them in @list</info>
      <return type='int' info='the number of unique strings found, -1 in case of errors and -2 if there is more than @len strings'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
      <arg name='langList' type='const xmlChar **' info='where to store the tokens'/>
      <arg name='len' type='int' info='the allocated length of @list'/>
    </function>
    <function name='xmlExpGetStart' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Find all the strings that appears at the start of the languages accepted by @exp and store them in @list. E.g. for (a, b) | c it will return the list [a, c]</info>
      <return type='int' info='the number of unique strings found, -1 in case of errors and -2 if there is more than @len strings'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
      <arg name='tokList' type='const xmlChar **' info='where to store the tokens'/>
      <arg name='len' type='int' info='the allocated length of @list'/>
    </function>
    <function name='xmlExpIsNillable' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Finds if the expression is nillable, i.e. if it accepts the empty sequqnce</info>
      <return type='int' info='1 if nillable, 0 if not and -1 in case of error'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
    </function>
    <function name='xmlExpMaxToken' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Indicate the maximum number of input a expression can accept</info>
      <return type='int' info='the maximum length or -1 in case of error'/>
      <arg name='expr' type='xmlExpNodePtr' info='a compiled expression'/>
    </function>
    <function name='xmlExpNewAtom' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Get the atom associated to this name from that context</info>
      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='name' type='const xmlChar *' info='the atom name'/>
      <arg name='len' type='int' info='the atom name length in byte (or -1);'/>
    </function>
    <function name='xmlExpNewCtxt' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Creates a new context for manipulating expressions</info>
      <return type='xmlExpCtxtPtr' info='the context or NULL in case of error'/>
      <arg name='maxNodes' type='int' info='the maximum number of nodes'/>
      <arg name='dict' type='xmlDictPtr' info='optional dictionnary to use internally'/>
    </function>
    <function name='xmlExpNewOr' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Get the atom associated to the choice @left | @right Note that @left and @right are consumed in the operation, to keep an handle on them use xmlExpRef() and use xmlExpFree() to release them, this is true even in case of failure (unless ctxt == NULL).</info>
      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='left' type='xmlExpNodePtr' info='left expression'/>
      <arg name='right' type='xmlExpNodePtr' info='right expression'/>
    </function>
    <function name='xmlExpNewRange' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Get the atom associated to the range (@subset){@min, @max} Note that @subset is consumed in the operation, to keep an handle on it use xmlExpRef() and use xmlExpFree() to release it, this is true even in case of failure (unless ctxt == NULL).</info>
      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='subset' type='xmlExpNodePtr' info='the expression to be repeated'/>
      <arg name='min' type='int' info='the lower bound for the repetition'/>
      <arg name='max' type='int' info='the upper bound for the repetition, -1 means infinite'/>
    </function>
    <function name='xmlExpNewSeq' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Get the atom associated to the sequence @left , @right Note that @left and @right are consumed in the operation, to keep an handle on them use xmlExpRef() and use xmlExpFree() to release them, this is true even in case of failure (unless ctxt == NULL).</info>
      <return type='xmlExpNodePtr' info='the node or NULL in case of error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='left' type='xmlExpNodePtr' info='left expression'/>
      <arg name='right' type='xmlExpNodePtr' info='right expression'/>
    </function>
    <function name='xmlExpParse' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Minimal parser for regexps, it understand the following constructs - string terminals - choice operator | - sequence operator , - subexpressions (...) - usual cardinality operators + * and ? - finite sequences  { min, max } - infinite sequences { min, * } There is minimal checkings made especially no checking on strings values</info>
      <return type='xmlExpNodePtr' info='a new expression or NULL in case of failure'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
      <arg name='expr' type='const char *' info='the 0 terminated string'/>
    </function>
    <function name='xmlExpRef' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Increase the reference count of the expression</info>
      <return type='void'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
    </function>
    <function name='xmlExpStringDerive' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Do one step of Brzozowski derivation of the expression @exp with respect to the input string</info>
      <return type='xmlExpNodePtr' info='the resulting expression or NULL in case of internal error'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expression context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the expression'/>
      <arg name='str' type='const xmlChar *' info='the string'/>
      <arg name='len' type='int' info='the string len in bytes if available'/>
    </function>
    <function name='xmlExpSubsume' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_EXPR_ENABLED)</cond>
      <info>Check whether @exp accepts all the languages accexpted by @sub the input being a subexpression.</info>
      <return type='int' info='1 if true 0 if false and -1 in case of failure.'/>
      <arg name='ctxt' type='xmlExpCtxtPtr' info='the expressions context'/>
      <arg name='exp' type='xmlExpNodePtr' info='the englobing expression'/>
      <arg name='sub' type='xmlExpNodePtr' info='the subexpression'/>
    </function>
    <functype name='xmlExternalEntityLoader' file='parser' module='parser'>
      <info>External entity loaders types.</info>
      <return type='xmlParserInputPtr' info='the entity input parser.'/>
      <arg name='URL' type='const char *' info='The System ID of the resource requested'/>
      <arg name='ID' type='const char *' info='The Public ID of the resource requested'/>
      <arg name='context' type='xmlParserCtxtPtr' info='the XML parser context'/>
    </functype>
    <function name='xmlFileClose' file='xmlIO' module='xmlIO'>
      <info>Close an I/O channel</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='context' type='void *' info='the I/O context'/>
    </function>
    <function name='xmlFileMatch' file='xmlIO' module='xmlIO'>
      <info>input from FILE *</info>
      <return type='int' info='1 if matches, 0 otherwise'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlFileOpen' file='xmlIO' module='xmlIO'>
      <info>Wrapper around xmlFileOpen_real that try it with an unescaped version of @filename, if this fails fallback to @filename</info>
      <return type='void *' info='a handler or NULL in case or failure'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlFileRead' file='xmlIO' module='xmlIO'>
      <info>Read @len bytes to @buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written or &lt; 0 in case of failure'/>
      <arg name='context' type='void *' info='the I/O context'/>
      <arg name='buffer' type='char *' info='where to drop data'/>
      <arg name='len' type='int' info='number of bytes to write'/>
    </function>
    <function name='xmlFindCharEncodingHandler' file='encoding' module='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the handler or NULL if not found'/>
      <arg name='name' type='const char *' info='a string describing the char encoding.'/>
    </function>
    <function name='xmlFirstElementChild' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Finds the first child node of that element which is a Element node Note the handling of entities references is different than in the W3C DOM element traversal spec since we don&apos;t have back reference from entities content to entities references.</info>
      <return type='xmlNodePtr' info='the first element child or NULL if not available'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
    </function>
    <function name='xmlFreeAttributeTable' file='valid' module='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlAttributeTablePtr' info='An attribute table'/>
    </function>
    <function name='xmlFreeAutomata' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Free an automata</info>
      <return type='void'/>
      <arg name='am' type='xmlAutomataPtr' info='an automata'/>
    </function>
    <function name='xmlFreeCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Free the memory allocated to a Catalog</info>
      <return type='void'/>
      <arg name='catal' type='xmlCatalogPtr' info='a Catalog'/>
    </function>
    <function name='xmlFreeDoc' file='tree' module='tree'>
      <info>Free up all the structures used by a document, tree included.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDocPtr' info='pointer to the document'/>
    </function>
    <function name='xmlFreeDocElementContent' file='valid' module='valid'>
      <info>Free an element content structure. The whole subtree is removed.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr' info='the document owning the element declaration'/>
      <arg name='cur' type='xmlElementContentPtr' info='the element content tree to free'/>
    </function>
    <function name='xmlFreeDtd' file='tree' module='tree'>
      <info>Free a DTD structure.</info>
      <return type='void'/>
      <arg name='cur' type='xmlDtdPtr' info='the DTD structure to free up'/>
    </function>
    <function name='xmlFreeElementContent' file='valid' module='valid'>
      <info>Free an element content structure. The whole subtree is removed. Deprecated, use xmlFreeDocElementContent instead</info>
      <return type='void'/>
      <arg name='cur' type='xmlElementContentPtr' info='the element content tree to free'/>
    </function>
    <function name='xmlFreeElementTable' file='valid' module='valid'>
      <info>Deallocate the memory used by an element hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlElementTablePtr' info='An element table'/>
    </function>
    <function name='xmlFreeEntitiesTable' file='entities' module='entities'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlEntitiesTablePtr' info='An entity table'/>
    </function>
    <function name='xmlFreeEnumeration' file='valid' module='valid'>
      <info>free an enumeration attribute node (recursive).</info>
      <return type='void'/>
      <arg name='cur' type='xmlEnumerationPtr' info='the tree to free.'/>
    </function>
    <functype name='xmlFreeFunc' file='xmlmemory' module='xmlmemory'>
      <info>Signature for a free() implementation.</info>
      <return type='void'/>
      <arg name='mem' type='void *' info='an already allocated block of memory'/>
    </functype>
    <function name='xmlFreeIDTable' file='valid' module='valid'>
      <info>Deallocate the memory used by an ID hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlIDTablePtr' info='An id table'/>
    </function>
    <function name='xmlFreeInputStream' file='parserInternals' module='parserInternals'>
      <info>Free up an input stream.</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr'/>
    </function>
    <function name='xmlFreeMutex' file='threads' module='threads'>
      <info>xmlFreeMutex() is used to reclaim resources associated with a libxml2 token struct.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex'/>
    </function>
    <function name='xmlFreeNode' file='tree' module='tree'>
      <info>Free a node, this is a recursive behaviour, all the children are freed too. This doesn&apos;t unlink the child from the list, use xmlUnlinkNode() first.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node'/>
    </function>
    <function name='xmlFreeNodeList' file='tree' module='tree'>
      <info>Free a node and all its siblings, this is a recursive behaviour, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the first node in the list'/>
    </function>
    <function name='xmlFreeNotationTable' file='valid' module='valid'>
      <info>Deallocate the memory used by an entities hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlNotationTablePtr' info='An notation table'/>
    </function>
    <function name='xmlFreeNs' file='tree' module='tree'>
      <info>Free up the structures associated to a namespace</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr' info='the namespace pointer'/>
    </function>
    <function name='xmlFreeNsList' file='tree' module='tree'>
      <info>Free up all the structures associated to the chained namespaces.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace pointer'/>
    </function>
    <function name='xmlFreeParserCtxt' file='parser' module='parserInternals'>
      <info>Free all the memory used by a parser context. However the parsed document in ctxt-&gt;myDoc is not freed.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlFreeParserInputBuffer' file='xmlIO' module='xmlIO'>
      <info>Free up the memory used by a buffered parser input</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input'/>
    </function>
    <function name='xmlFreePattern' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Free up the memory allocated by @comp</info>
      <return type='void'/>
      <arg name='comp' type='xmlPatternPtr' info='an XSLT comp'/>
    </function>
    <function name='xmlFreePatternList' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Free up the memory allocated by all the elements of @comp</info>
      <return type='void'/>
      <arg name='comp' type='xmlPatternPtr' info='an XSLT comp list'/>
    </function>
    <function name='xmlFreeProp' file='tree' module='tree'>
      <info>Free one attribute, all the content is freed too</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr' info='an attribute'/>
    </function>
    <function name='xmlFreePropList' file='tree' module='tree'>
      <info>Free a property and all its siblings, all the children are freed too.</info>
      <return type='void'/>
      <arg name='cur' type='xmlAttrPtr' info='the first property in the list'/>
    </function>
    <function name='xmlFreeRMutex' file='threads' module='threads'>
      <info>xmlRFreeMutex() is used to reclaim resources associated with a reentrant mutex.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr' info='the reentrant mutex'/>
    </function>
    <function name='xmlFreeRefTable' file='valid' module='valid'>
      <info>Deallocate the memory used by an Ref hash table.</info>
      <return type='void'/>
      <arg name='table' type='xmlRefTablePtr' info='An ref table'/>
    </function>
    <function name='xmlFreeStreamCtxt' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Free the stream context</info>
      <return type='void'/>
      <arg name='stream' type='xmlStreamCtxtPtr' info='the stream context'/>
    </function>
    <function name='xmlFreeTextReader' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Deallocate all the resources associated to the reader</info>
      <return type='void'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr'/>
    </function>
    <function name='xmlFreeTextWriter' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Deallocate all the resources associated to the writer</info>
      <return type='void'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlFreeURI' file='uri' module='uri'>
      <info>Free up the xmlURI struct</info>
      <return type='void'/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI'/>
    </function>
    <function name='xmlFreeValidCtxt' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Free a validation context structure.</info>
      <return type='void'/>
      <arg name='cur' type='xmlValidCtxtPtr' info='the validation context to free'/>
    </function>
    <function name='xmlGcMemGet' file='xmlmemory' module='xmlmemory'>
      <info>Provides the memory access functions set currently in use The mallocAtomicFunc is specialized for atomic block allocations (i.e. of areas  useful for garbage collected memory allocators</info>
      <return type='int' info='0 on success'/>
      <arg name='freeFunc' type='xmlFreeFunc *' info='place to save the free() function in use'/>
      <arg name='mallocFunc' type='xmlMallocFunc *' info='place to save the malloc() function in use'/>
      <arg name='mallocAtomicFunc' type='xmlMallocFunc *' info='place to save the atomic malloc() function in use'/>
      <arg name='reallocFunc' type='xmlReallocFunc *' info='place to save the realloc() function in use'/>
      <arg name='strdupFunc' type='xmlStrdupFunc *' info='place to save the strdup() function in use'/>
    </function>
    <function name='xmlGcMemSetup' file='xmlmemory' module='xmlmemory'>
      <info>Override the default memory access functions with a new set This has to be called before any other libxml routines ! The mallocAtomicFunc is specialized for atomic block allocations (i.e. of areas  useful for garbage collected memory allocators  Should this be blocked if there was already some allocations done ?</info>
      <return type='int' info='0 on success'/>
      <arg name='freeFunc' type='xmlFreeFunc' info='the free() function to use'/>
      <arg name='mallocFunc' type='xmlMallocFunc' info='the malloc() function to use'/>
      <arg name='mallocAtomicFunc' type='xmlMallocFunc' info='the malloc() function to use for atomic allocations'/>
      <arg name='reallocFunc' type='xmlReallocFunc' info='the realloc() function to use'/>
      <arg name='strdupFunc' type='xmlStrdupFunc' info='the strdup() function to use'/>
    </function>
    <functype name='xmlGenericErrorFunc' file='xmlerror' module='xmlerror'>
      <info>Signature of the function to use when there is an error and no parsing or validity context available .</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='a parsing context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='the extra arguments of the varags to format the message'/>
    </functype>
    <function name='xmlGetBufferAllocationScheme' file='tree' module='tree'>
      <info>Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, improves performance XML_BUFFER_ALLOC_HYBRID - use exact sizes on small strings to keep memory usage tight in normal usage, and doubleit on large strings to avoid pathological performance.</info>
      <return type='xmlBufferAllocationScheme' info='the current allocation scheme'/>
    </function>
    <function name='xmlGetCharEncodingHandler' file='encoding' module='encoding'>
      <info>Search in the registered set the handler able to read/write that encoding.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the handler or NULL if not found'/>
      <arg name='enc' type='xmlCharEncoding' info='an xmlCharEncoding value.'/>
    </function>
    <function name='xmlGetCharEncodingName' file='encoding' module='encoding'>
      <info>The &quot;canonical&quot; name for XML encoding. C.f. http://www.w3.org/TR/REC-xml#charencoding Section 4.3.3  Character Encoding in Entities</info>
      <return type='const char *' info='the canonical name for the given encoding'/>
      <arg name='enc' type='xmlCharEncoding' info='the encoding'/>
    </function>
    <function name='xmlGetCompressMode' file='tree' module='tree'>
      <info>get the default compression mode used, ZLIB based.</info>
      <return type='int' info='0 (uncompressed) to 9 (max compression)'/>
    </function>
    <function name='xmlGetDocCompressMode' file='tree' module='tree'>
      <info>get the compression ratio for a document, ZLIB based</info>
      <return type='int' info='0 (uncompressed) to 9 (max compression)'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
    </function>
    <function name='xmlGetDocEntity' file='entities' module='entities'>
      <info>Do an entity lookup in the document entity hash table and</info>
      <return type='xmlEntityPtr' info='the corresponding entity, otherwise a lookup is done in the predefined entities too.  Returns A pointer to the entity structure or NULL if not found.'/>
      <arg name='doc' type='const xmlDoc *' info='the document referencing the entity'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
    </function>
    <function name='xmlGetDtdAttrDesc' file='valid' module='valid'>
      <info>Search the DTD for the description of this attribute on this element.</info>
      <return type='xmlAttributePtr' info='the xmlAttributePtr if found or NULL'/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search'/>
      <arg name='elem' type='const xmlChar *' info='the element name'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlGetDtdElementDesc' file='valid' module='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr' info='the xmlElementPtr if found or NULL'/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
    </function>
    <function name='xmlGetDtdEntity' file='entities' module='entities'>
      <info>Do an entity lookup in the DTD entity hash table and</info>
      <return type='xmlEntityPtr' info='the corresponding entity, if found. Note: the first argument is the document node, not the DTD node.  Returns A pointer to the entity structure or NULL if not found.'/>
      <arg name='doc' type='xmlDocPtr' info='the document referencing the entity'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
    </function>
    <function name='xmlGetDtdNotationDesc' file='valid' module='valid'>
      <info>Search the DTD for the description of this notation</info>
      <return type='xmlNotationPtr' info='the xmlNotationPtr if found or NULL'/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search'/>
      <arg name='name' type='const xmlChar *' info='the notation name'/>
    </function>
    <function name='xmlGetDtdQAttrDesc' file='valid' module='valid'>
      <info>Search the DTD for the description of this qualified attribute on this element.</info>
      <return type='xmlAttributePtr' info='the xmlAttributePtr if found or NULL'/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search'/>
      <arg name='elem' type='const xmlChar *' info='the element name'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='prefix' type='const xmlChar *' info='the attribute namespace prefix'/>
    </function>
    <function name='xmlGetDtdQElementDesc' file='valid' module='valid'>
      <info>Search the DTD for the description of this element</info>
      <return type='xmlElementPtr' info='the xmlElementPtr if found or NULL'/>
      <arg name='dtd' type='xmlDtdPtr' info='a pointer to the DtD to search'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix'/>
    </function>
    <function name='xmlGetEncodingAlias' file='encoding' module='encoding'>
      <info>Lookup an encoding name for the given alias.</info>
      <return type='const char *' info='NULL if not found, otherwise the original name'/>
      <arg name='alias' type='const char *' info='the alias name as parsed, in UTF-8 format (ASCII actually)'/>
    </function>
    <function name='xmlGetExternalEntityLoader' file='parser' module='xmlIO'>
      <info>Get the default external entity resolver function for the application</info>
      <return type='xmlExternalEntityLoader' info='the xmlExternalEntityLoader function pointer'/>
    </function>
    <function name='xmlGetFeature' file='parser' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Read the current value of one feature of this parser instance</info>
      <return type='int' info='-1 in case or error, 0 otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context'/>
      <arg name='name' type='const char *' info='the feature name'/>
      <arg name='result' type='void *' info='location to store the result'/>
    </function>
    <function name='xmlGetFeaturesList' file='parser' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Copy at most *@len feature names into the @result array</info>
      <return type='int' info='-1 in case or error, or the total number of features, len is updated with the number of strings copied, strings must not be deallocated'/>
      <arg name='len' type='int *' info='the length of the features name array (input/output)'/>
      <arg name='result' type='const char **' info='an array of string to be filled with the features name.'/>
    </function>
    <function name='xmlGetGlobalState' file='threads' module='threads'>
      <info>xmlGetGlobalState() is called to retrieve the global state for a thread.</info>
      <return type='xmlGlobalStatePtr' info='the thread global state or NULL in case of error'/>
    </function>
    <function name='xmlGetID' file='valid' module='valid'>
      <info>Search the attribute declaring the given ID</info>
      <return type='xmlAttrPtr' info='NULL if not found, otherwise the xmlAttrPtr defining the ID'/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document'/>
      <arg name='ID' type='const xmlChar *' info='the ID value'/>
    </function>
    <function name='xmlGetIntSubset' file='tree' module='tree'>
      <info>Get the internal subset of a document</info>
      <return type='xmlDtdPtr' info='a pointer to the DTD structure or NULL if not found'/>
      <arg name='doc' type='const xmlDoc *' info='the document pointer'/>
    </function>
    <function name='xmlGetLastChild' file='tree' module='tree'>
      <info>Search the last child of a node.</info>
      <return type='xmlNodePtr' info='the last child or NULL if none.'/>
      <arg name='parent' type='const xmlNode *' info='the parent node'/>
    </function>
    <function name='xmlGetLastError' file='xmlerror' module='error'>
      <info>Get the last global error registered. This is per thread if compiled with thread support.</info>
      <return type='xmlErrorPtr' info='NULL if no error occured or a pointer to the error'/>
    </function>
    <function name='xmlGetLineNo' file='tree' module='tree'>
      <info>Get line number of @node. Try to override the limitation of lines being store in 16 bits ints if XML_PARSE_BIG_LINES parser option was used</info>
      <return type='long' info='the line number if successful, -1 otherwise'/>
      <arg name='node' type='const xmlNode *' info='valid node'/>
    </function>
    <function name='xmlGetNoNsProp' file='tree' module='tree'>
      <info>Search and get the value of an attribute associated to a node This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off. This function is similar to xmlGetProp except it will accept only an attribute in no namespace.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlGetNodePath' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Build a structure based Path for the given node</info>
      <return type='xmlChar *' info='the new path or NULL in case of error. The caller must free the returned string'/>
      <arg name='node' type='const xmlNode *' info='a node'/>
    </function>
    <function name='xmlGetNsList' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Search all the namespace applying to a given element.</info>
      <return type='xmlNsPtr *' info='an NULL terminated array of all the #xmlNsPtr found that need to be freed by the caller or NULL if no namespace if defined'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='node' type='const xmlNode *' info='the current node'/>
    </function>
    <function name='xmlGetNsProp' file='tree' module='tree'>
      <info>Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace'/>
    </function>
    <function name='xmlGetParameterEntity' file='entities' module='entities'>
      <info>Do an entity lookup in the internal and external subsets and</info>
      <return type='xmlEntityPtr' info='the corresponding parameter entity, if found.  Returns A pointer to the entity structure or NULL if not found.'/>
      <arg name='doc' type='xmlDocPtr' info='the document referencing the entity'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
    </function>
    <function name='xmlGetPredefinedEntity' file='entities' module='entities'>
      <info>Check whether this name is an predefined entity.</info>
      <return type='xmlEntityPtr' info='NULL if not, otherwise the entity'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
    </function>
    <function name='xmlGetProp' file='tree' module='tree'>
      <info>Search and get the value of an attribute associated to a node This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off. NOTE: this function acts independently of namespaces associated to the attribute. Use xmlGetNsProp() or xmlGetNoNsProp() for namespace aware processing.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlGetRefs' file='valid' module='valid'>
      <info>Find the set of references for the supplied ID.</info>
      <return type='xmlListPtr' info='NULL if not found, otherwise node set for the ID.'/>
      <arg name='doc' type='xmlDocPtr' info='pointer to the document'/>
      <arg name='ID' type='const xmlChar *' info='the ID value'/>
    </function>
    <function name='xmlGetThreadId' file='threads' module='threads'>
      <info>xmlGetThreadId() find the current thread ID number Note that this is likely to be broken on some platforms using pthreads as the specification doesn&apos;t mandate pthread_t to be an integer type</info>
      <return type='int' info='the current thread ID number'/>
    </function>
    <function name='xmlGetUTF8Char' file='xmlstring' module='xmlstring'>
      <info>Read the first UTF8 character from @utf</info>
      <return type='int' info='the char value or -1 in case of error, and sets *len to the actual number of bytes consumed (0 in case of error)'/>
      <arg name='utf' type='const unsigned char *' info='a sequence of UTF-8 encoded bytes'/>
      <arg name='len' type='int *' info='a pointer to the minimum number of bytes present in the sequence.  This is used to assure the next character is completely contained within the sequence.'/>
    </function>
    <function name='xmlHandleEntity' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Default handling of defined entities, when should we define a new input stream ? When do we just handle that as a set of chars ?  OBSOLETE: to be removed at some point.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='entity' type='xmlEntityPtr' info='an XML entity pointer.'/>
    </function>
    <function name='xmlHasFeature' file='parser' module='parser'>
      <info>Examines if the library has been compiled with a given feature.</info>
      <return type='int' info='a non-zero value if the feature exist, otherwise zero. Returns zero (0) if the feature does not exist or an unknown unknown feature is requested, non-zero otherwise.'/>
      <arg name='feature' type='xmlFeature' info='the feature to be examined'/>
    </function>
    <function name='xmlHasNsProp' file='tree' module='tree'>
      <info>Search for an attribute associated to a node This attribute has to be anchored in the namespace specified. This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off. Note that a namespace of NULL indicates to use the default namespace.</info>
      <return type='xmlAttrPtr' info='the attribute or the attribute declaration or NULL if neither was found.'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace'/>
    </function>
    <function name='xmlHasProp' file='tree' module='tree'>
      <info>Search an attribute associated to a node This function also looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlAttrPtr' info='the attribute or the attribute declaration or NULL if neither was found.'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlHashAddEntry' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the @name. Duplicate names generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
    </function>
    <function name='xmlHashAddEntry2' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the (@name, @name2) tuple. Duplicate tuples generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
    </function>
    <function name='xmlHashAddEntry3' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the tuple (@name, @name2, @name3). Duplicate entries generate errors.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
    </function>
    <functype name='xmlHashCopier' file='hash' module='hash'>
      <info>Callback to copy data from a hash.</info>
      <return type='void *' info='a copy of the data or NULL in case of error.'/>
      <arg name='payload' type='void *' info='the data in the hash'/>
      <arg name='name' type='xmlChar *' info='the name associated'/>
    </functype>
    <function name='xmlHashCopy' file='hash' module='hash'>
      <info>Scan the hash @table and applied @f to each value.</info>
      <return type='xmlHashTablePtr' info='the new table or NULL in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='f' type='xmlHashCopier' info='the copier function for items in the hash'/>
    </function>
    <function name='xmlHashCreate' file='hash' module='hash'>
      <info>Create a new xmlHashTablePtr.</info>
      <return type='xmlHashTablePtr' info='the newly created object, or NULL if an error occured.'/>
      <arg name='size' type='int' info='the size of the hash table'/>
    </function>
    <function name='xmlHashCreateDict' file='hash' module='hash'>
      <info>Create a new xmlHashTablePtr which will use @dict as the internal dictionary</info>
      <return type='xmlHashTablePtr' info='the newly created object, or NULL if an error occured.'/>
      <arg name='size' type='int' info='the size of the hash table'/>
      <arg name='dict' type='xmlDictPtr' info='a dictionary to use for the hash'/>
    </function>
    <functype name='xmlHashDeallocator' file='hash' module='hash'>
      <info>Callback to free data from a hash.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash'/>
      <arg name='name' type='xmlChar *' info='the name associated'/>
    </functype>
    <function name='xmlHashFree' file='hash' module='hash'>
      <info>Free the hash @table and its contents. The userdata is deallocated with @f if provided.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for items in the hash'/>
    </function>
    <function name='xmlHashLookup' file='hash' module='hash'>
      <info>Find the userdata specified by the @name.</info>
      <return type='void *' info='the pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
    </function>
    <function name='xmlHashLookup2' file='hash' module='hash'>
      <info>Find the userdata specified by the (@name, @name2) tuple.</info>
      <return type='void *' info='the pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
    </function>
    <function name='xmlHashLookup3' file='hash' module='hash'>
      <info>Find the userdata specified by the (@name, @name2, @name3) tuple.</info>
      <return type='void *' info='the a pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata'/>
    </function>
    <function name='xmlHashQLookup' file='hash' module='hash'>
      <info>Find the userdata specified by the QName @prefix:@name/@name.</info>
      <return type='void *' info='the pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix of the userdata'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
    </function>
    <function name='xmlHashQLookup2' file='hash' module='hash'>
      <info>Find the userdata specified by the QNames tuple</info>
      <return type='void *' info='the pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix of the userdata'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='prefix2' type='const xmlChar *' info='the second prefix of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
    </function>
    <function name='xmlHashQLookup3' file='hash' module='hash'>
      <info>Find the userdata specified by the (@name, @name2, @name3) tuple.</info>
      <return type='void *' info='the a pointer to the userdata'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix of the userdata'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='prefix2' type='const xmlChar *' info='the second prefix of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='prefix3' type='const xmlChar *' info='the third prefix of the userdata'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata'/>
    </function>
    <function name='xmlHashRemoveEntry' file='hash' module='hash'>
      <info>Find the userdata specified by the @name and remove it from the hash @table. Existing userdata for this tuple will be removed and freed with @f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any)'/>
    </function>
    <function name='xmlHashRemoveEntry2' file='hash' module='hash'>
      <info>Find the userdata specified by the (@name, @name2) tuple and remove it from the hash @table. Existing userdata for this tuple will be removed and freed with @f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any)'/>
    </function>
    <function name='xmlHashRemoveEntry3' file='hash' module='hash'>
      <info>Find the userdata specified by the (@name, @name2, @name3) tuple and remove it from the hash @table. Existing userdata for this tuple will be removed and freed with @f.</info>
      <return type='int' info='0 if the removal succeeded and -1 in case of error or not found.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for removed item (if any)'/>
    </function>
    <function name='xmlHashScan' file='hash' module='hash'>
      <info>Scan the hash @table and applied @f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='f' type='xmlHashScanner' info='the scanner function for items in the hash'/>
      <arg name='data' type='void *' info='extra data passed to f'/>
    </function>
    <function name='xmlHashScan3' file='hash' module='hash'>
      <info>Scan the hash @table and applied @f to each value matching (@name, @name2, @name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata or NULL'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata or NULL'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata or NULL'/>
      <arg name='f' type='xmlHashScanner' info='the scanner function for items in the hash'/>
      <arg name='data' type='void *' info='extra data passed to f'/>
    </function>
    <function name='xmlHashScanFull' file='hash' module='hash'>
      <info>Scan the hash @table and applied @f to each value.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='f' type='xmlHashScannerFull' info='the scanner function for items in the hash'/>
      <arg name='data' type='void *' info='extra data passed to f'/>
    </function>
    <function name='xmlHashScanFull3' file='hash' module='hash'>
      <info>Scan the hash @table and applied @f to each value matching (@name, @name2, @name3) tuple. If one of the names is null, the comparison is considered to match.</info>
      <return type='void'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata or NULL'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata or NULL'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata or NULL'/>
      <arg name='f' type='xmlHashScannerFull' info='the scanner function for items in the hash'/>
      <arg name='data' type='void *' info='extra data passed to f'/>
    </function>
    <functype name='xmlHashScanner' file='hash' module='hash'>
      <info>Callback when scanning data in a hash with the simple scanner.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash'/>
      <arg name='data' type='void *' info='extra scannner data'/>
      <arg name='name' type='xmlChar *' info='the name associated'/>
    </functype>
    <functype name='xmlHashScannerFull' file='hash' module='hash'>
      <info>Callback when scanning data in a hash with the full scanner.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='the data in the hash'/>
      <arg name='data' type='void *' info='extra scannner data'/>
      <arg name='name' type='const xmlChar *' info='the name associated'/>
      <arg name='name2' type='const xmlChar *' info='the second name associated'/>
      <arg name='name3' type='const xmlChar *' info='the third name associated'/>
    </functype>
    <function name='xmlHashSize' file='hash' module='hash'>
      <info>Query the number of elements installed in the hash @table.</info>
      <return type='int' info='the number of elements in the hash table or -1 in case of error'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
    </function>
    <function name='xmlHashUpdateEntry' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the @name. Existing entry for this @name will be removed and freed with @f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any)'/>
    </function>
    <function name='xmlHashUpdateEntry2' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the (@name, @name2) tuple. Existing entry for this tuple will be removed and freed with @f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any)'/>
    </function>
    <function name='xmlHashUpdateEntry3' file='hash' module='hash'>
      <info>Add the @userdata to the hash @table. This can later be retrieved by using the tuple (@name, @name2, @name3). Existing entry for this tuple will be removed and freed with @f if found.</info>
      <return type='int' info='0 the addition succeeded and -1 in case of error.'/>
      <arg name='table' type='xmlHashTablePtr' info='the hash table'/>
      <arg name='name' type='const xmlChar *' info='the name of the userdata'/>
      <arg name='name2' type='const xmlChar *' info='a second name of the userdata'/>
      <arg name='name3' type='const xmlChar *' info='a third name of the userdata'/>
      <arg name='userdata' type='void *' info='a pointer to the userdata'/>
      <arg name='f' type='xmlHashDeallocator' info='the deallocator function for replaced item (if any)'/>
    </function>
    <function name='xmlIOFTPClose' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Close an FTP I/O channel</info>
      <return type='int' info='0'/>
      <arg name='context' type='void *' info='the I/O context'/>
    </function>
    <function name='xmlIOFTPMatch' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>check if the URI matches an FTP one</info>
      <return type='int' info='1 if matches, 0 otherwise'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlIOFTPOpen' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>open an FTP I/O channel</info>
      <return type='void *' info='an I/O context or NULL in case of error'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlIOFTPRead' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Read @len bytes to @buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written'/>
      <arg name='context' type='void *' info='the I/O context'/>
      <arg name='buffer' type='char *' info='where to drop data'/>
      <arg name='len' type='int' info='number of bytes to write'/>
    </function>
    <function name='xmlIOHTTPClose' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Close an HTTP I/O channel</info>
      <return type='int' info='0'/>
      <arg name='context' type='void *' info='the I/O context'/>
    </function>
    <function name='xmlIOHTTPMatch' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>check if the URI matches an HTTP one</info>
      <return type='int' info='1 if matches, 0 otherwise'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlIOHTTPOpen' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>open an HTTP I/O channel</info>
      <return type='void *' info='an I/O context or NULL in case of error'/>
      <arg name='filename' type='const char *' info='the URI for matching'/>
    </function>
    <function name='xmlIOHTTPOpenW' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_HTTP_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Open a temporary buffer to collect the document for a subsequent HTTP POST request.  Non-static as is called from the output buffer creation routine.</info>
      <return type='void *' info='an I/O context or NULL in case of error.'/>
      <arg name='post_uri' type='const char *' info='The destination URI for the document'/>
      <arg name='compression' type='int' info='The compression desired for the document.'/>
    </function>
    <function name='xmlIOHTTPRead' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Read @len bytes to @buffer from the I/O channel.</info>
      <return type='int' info='the number of bytes written'/>
      <arg name='context' type='void *' info='the I/O context'/>
      <arg name='buffer' type='char *' info='where to drop data'/>
      <arg name='len' type='int' info='number of bytes to write'/>
    </function>
    <function name='xmlIOParseDTD' file='parser' module='parser'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Load and parse a DTD</info>
      <return type='xmlDtdPtr' info='the resulting xmlDtdPtr or NULL in case of error. @input will be freed by the function in any case.'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block or NULL'/>
      <arg name='input' type='xmlParserInputBufferPtr' info='an Input Buffer'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlInitCharEncodingHandlers' file='encoding' module='encoding'>
      <info>Initialize the char encoding support, it registers the default encoding supported. NOTE: while public, this function usually doesn&apos;t need to be called in normal processing.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitGlobals' file='globals' module='globals'>
      <info>Additional initialisation for multi-threading</info>
      <return type='void'/>
    </function>
    <function name='xmlInitMemory' file='xmlmemory' module='xmlmemory'>
      <info>Initialize the memory layer.</info>
      <return type='int' info='0 on success'/>
    </function>
    <function name='xmlInitNodeInfoSeq' file='parser' module='parserInternals'>
      <info>-- Initialize (set to initial state) node info sequence</info>
      <return type='void'/>
      <arg name='seq' type='xmlParserNodeInfoSeqPtr' info='a node info sequence pointer'/>
    </function>
    <function name='xmlInitParser' file='parser' module='parser'>
      <info>Initialization function for the XML parser. This is not reentrant. Call once before processing in case of use in multithreaded programs.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitParserCtxt' file='parser' module='parserInternals'>
      <info>Initialize a parser context</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlInitThreads' file='threads' module='threads'>
      <info>xmlInitThreads() is used to to initialize all the thread related data of the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlInitializeCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Do the catalog initialization. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
    </function>
    <function name='xmlInitializeDict' file='dict' module='dict'>
      <info>Do the dictionary mutex initialization. this function is deprecated</info>
      <return type='int' info='0 if initialization was already done, and 1 if that call led to the initialization'/>
    </function>
    <function name='xmlInitializeGlobalState' file='globals' module='globals'>
      <info>xmlInitializeGlobalState() initialize a global state with all the default values of the library.</info>
      <return type='void'/>
      <arg name='gs' type='xmlGlobalStatePtr' info='a pointer to a newly allocated global state'/>
    </function>
    <function name='xmlInitializePredefinedEntities' file='entities' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Set up the predefined entities. Deprecated call</info>
      <return type='void'/>
    </function>
    <functype name='xmlInputCloseCallback' file='xmlIO' module='xmlIO'>
      <info>Callback used in the I/O Input API to close the resource</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='context' type='void *' info='an Input context'/>
    </functype>
    <functype name='xmlInputMatchCallback' file='xmlIO' module='xmlIO'>
      <info>Callback used in the I/O Input API to detect if the current handler can provide input fonctionnalities for this resource.</info>
      <return type='int' info='1 if yes and 0 if another Input module should be used'/>
      <arg name='filename' type='char const *' info='the filename or URI'/>
    </functype>
    <functype name='xmlInputOpenCallback' file='xmlIO' module='xmlIO'>
      <info>Callback used in the I/O Input API to open the resource</info>
      <return type='void *' info='an Input context or NULL in case or error'/>
      <arg name='filename' type='char const *' info='the filename or URI'/>
    </functype>
    <functype name='xmlInputReadCallback' file='xmlIO' module='xmlIO'>
      <info>Callback used in the I/O Input API to read the resource</info>
      <return type='int' info='the number of bytes read or -1 in case of error'/>
      <arg name='context' type='void *' info='an Input context'/>
      <arg name='buffer' type='char *' info='the buffer to store data read'/>
      <arg name='len' type='int' info='the length of the buffer in bytes'/>
    </functype>
    <function name='xmlIsBaseChar' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsBaseChar_ch or xmlIsBaseCharQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsBlank' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsBlank_ch or xmlIsBlankQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsBlankNode' file='tree' module='tree'>
      <info>Checks whether this node is an empty or whitespace only (and possibly ignorable) text-node.</info>
      <return type='int' info='1 yes, 0 no'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
    </function>
    <function name='xmlIsChar' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsChar_ch or xmlIsCharQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsCombining' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsCombiningQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsDigit' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsDigit_ch or xmlIsDigitQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsExtender' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsExtender_ch or xmlIsExtenderQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsID' file='valid' module='valid'>
      <info>Determine whether an attribute is of type ID. In case we have DTD(s) then this is done if DTD loading has been requested. In the case of HTML documents parsed with the HTML parser, then ID detection is done systematically.</info>
      <return type='int' info='0 or 1 depending on the lookup result'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='elem' type='xmlNodePtr' info='the element carrying the attribute'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
    </function>
    <function name='xmlIsIdeographic' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsIdeographicQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsLetter' file='parserInternals' module='parserInternals'>
      <info>Check whether the character is allowed by the production [84] Letter ::= BaseChar | Ideographic</info>
      <return type='int' info='0 if not, non-zero otherwise'/>
      <arg name='c' type='int' info='an unicode character (int)'/>
    </function>
    <function name='xmlIsMainThread' file='threads' module='threads'>
      <info>xmlIsMainThread() check whether the current thread is the main thread.</info>
      <return type='int' info='1 if the current thread is the main thread, 0 otherwise'/>
    </function>
    <function name='xmlIsMixedElement' file='valid' module='valid'>
      <info>Search in the DtDs whether an element accept Mixed content (or ANY) basically if it is supposed to accept text childs</info>
      <return type='int' info='0 if no, 1 if yes, and -1 if no element description is available'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
    </function>
    <function name='xmlIsPubidChar' file='chvalid' module='chvalid'>
      <info>This function is DEPRECATED. Use xmlIsPubidChar_ch or xmlIsPubidCharQ instead</info>
      <return type='int' info='true if argument valid, false otherwise'/>
      <arg name='ch' type='unsigned int' info='character to validate'/>
    </function>
    <function name='xmlIsRef' file='valid' module='valid'>
      <info>Determine whether an attribute is of type Ref. In case we have DTD(s) then this is simple, otherwise we use an heuristic: name Ref (upper or lowercase).</info>
      <return type='int' info='0 or 1 depending on the lookup result'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='elem' type='xmlNodePtr' info='the element carrying the attribute'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
    </function>
    <function name='xmlIsXHTML' file='tree' module='xmlsave'>
      <info>Try to find if the document correspond to an XHTML DTD</info>
      <return type='int' info='1 if true, 0 if not and -1 in case of error'/>
      <arg name='systemID' type='const xmlChar *' info='the system identifier'/>
      <arg name='publicID' type='const xmlChar *' info='the public identifier'/>
    </function>
    <function name='xmlKeepBlanksDefault' file='parser' module='parserInternals'>
      <info>Set and return the previous value for default blanks text nodes support. The 1.x version of the parser used an heuristic to try to detect ignorable white spaces. As a result the SAX callback was generating xmlSAX2IgnorableWhitespace() callbacks instead of characters() one, and when using the DOM output text nodes containing those blanks were not generated. The 2.x and later version will switch to the XML standard way and ignorableWhitespace() are only generated when running the parser in validating mode and when the current element doesn&apos;t allow CDATA or mixed content. This function is provided as a way to force the standard behavior on 1.X libs and to switch back to the old mode for compatibility when running 1.X client code on 2.X . Upgrade of 1.X code should be done by using xmlIsBlankNode() commodity function to detect the &quot;empty&quot; nodes generated. This value also affect autogeneration of indentation when saving code if blanks sections are kept, indentation is not generated.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution.'/>
      <arg name='val' type='int' info='int 0 or 1'/>
    </function>
    <function name='xmlLastElementChild' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Finds the last child node of that element which is a Element node Note the handling of entities references is different than in the W3C DOM element traversal spec since we don&apos;t have back reference from entities content to entities references.</info>
      <return type='xmlNodePtr' info='the last element child or NULL if not available'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
    </function>
    <function name='xmlLineNumbersDefault' file='parser' module='parserInternals'>
      <info>Set and return the previous value for enabling line numbers in elements contents. This may break on old application and is turned off by default.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution.'/>
      <arg name='val' type='int' info='int 0 or 1'/>
    </function>
    <function name='xmlLinkGetData' file='list' module='list'>
      <info>See Returns.</info>
      <return type='void *' info='a pointer to the data referenced from this link'/>
      <arg name='lk' type='xmlLinkPtr' info='a link'/>
    </function>
    <function name='xmlListAppend' file='list' module='list'>
      <info>Insert data in the ordered list at the end for this value</info>
      <return type='int' info='0 in case of success, 1 in case of failure'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='the data'/>
    </function>
    <function name='xmlListClear' file='list' module='list'>
      <info>Remove the all data in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListCopy' file='list' module='list'>
      <info>Move all the element from the old list in the new list</info>
      <return type='int' info='0 in case of success 1 in case of error'/>
      <arg name='cur' type='xmlListPtr' info='the new list'/>
      <arg name='old' type='const xmlListPtr' info='the old list'/>
    </function>
    <function name='xmlListCreate' file='list' module='list'>
      <info>Create a new list</info>
      <return type='xmlListPtr' info='the new list or NULL in case of error'/>
      <arg name='deallocator' type='xmlListDeallocator' info='an optional deallocator function'/>
      <arg name='compare' type='xmlListDataCompare' info='an optional comparison function'/>
    </function>
    <functype name='xmlListDataCompare' file='list' module='list'>
      <info>Callback function used to compare 2 data.</info>
      <return type='int' info='0 is equality, -1 or 1 otherwise depending on the ordering.'/>
      <arg name='data0' type='const void *' info='the first data'/>
      <arg name='data1' type='const void *' info='the second data'/>
    </functype>
    <functype name='xmlListDeallocator' file='list' module='list'>
      <info>Callback function used to free data from a list.</info>
      <return type='void'/>
      <arg name='lk' type='xmlLinkPtr' info='the data to deallocate'/>
    </functype>
    <function name='xmlListDelete' file='list' module='list'>
      <info>Deletes the list and its associated data</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListDup' file='list' module='list'>
      <info>Duplicate the list</info>
      <return type='xmlListPtr' info='a new copy of the list or NULL in case of error'/>
      <arg name='old' type='const xmlListPtr' info='the list'/>
    </function>
    <function name='xmlListEmpty' file='list' module='list'>
      <info>Is the list empty ?</info>
      <return type='int' info='1 if the list is empty, 0 if not empty and -1 in case of error'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListEnd' file='list' module='list'>
      <info>Get the last element in the list</info>
      <return type='xmlLinkPtr' info='the last element in the list, or NULL'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListFront' file='list' module='list'>
      <info>Get the first element in the list</info>
      <return type='xmlLinkPtr' info='the first element in the list, or NULL'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListInsert' file='list' module='list'>
      <info>Insert data in the ordered list at the beginning for this value</info>
      <return type='int' info='0 in case of success, 1 in case of failure'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='the data'/>
    </function>
    <function name='xmlListMerge' file='list' module='list'>
      <info>include all the elements of the second list in the first one and clear the second list</info>
      <return type='void'/>
      <arg name='l1' type='xmlListPtr' info='the original list'/>
      <arg name='l2' type='xmlListPtr' info='the new list'/>
    </function>
    <function name='xmlListPopBack' file='list' module='list'>
      <info>Removes the last element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListPopFront' file='list' module='list'>
      <info>Removes the first element in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListPushBack' file='list' module='list'>
      <info>add the new data at the end of the list</info>
      <return type='int' info='1 if successful, 0 otherwise'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='new data'/>
    </function>
    <function name='xmlListPushFront' file='list' module='list'>
      <info>add the new data at the beginning of the list</info>
      <return type='int' info='1 if successful, 0 otherwise'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='new data'/>
    </function>
    <function name='xmlListRemoveAll' file='list' module='list'>
      <info>Remove the all instance associated to data in the list</info>
      <return type='int' info='the number of deallocation, or 0 if not found'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='list data'/>
    </function>
    <function name='xmlListRemoveFirst' file='list' module='list'>
      <info>Remove the first instance associated to data in the list</info>
      <return type='int' info='1 if a deallocation occured, or 0 if not found'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='list data'/>
    </function>
    <function name='xmlListRemoveLast' file='list' module='list'>
      <info>Remove the last instance associated to data in the list</info>
      <return type='int' info='1 if a deallocation occured, or 0 if not found'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='list data'/>
    </function>
    <function name='xmlListReverse' file='list' module='list'>
      <info>Reverse the order of the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListReverseSearch' file='list' module='list'>
      <info>Search the list in reverse order for an existing value of @data</info>
      <return type='void *' info='the value associated to @data or NULL in case of error'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='a search value'/>
    </function>
    <function name='xmlListReverseWalk' file='list' module='list'>
      <info>Walk all the element of the list in reverse order and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='walker' type='xmlListWalker' info='a processing function'/>
      <arg name='user' type='const void *' info='a user parameter passed to the walker function'/>
    </function>
    <function name='xmlListSearch' file='list' module='list'>
      <info>Search the list for an existing value of @data</info>
      <return type='void *' info='the value associated to @data or NULL in case of error'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='data' type='void *' info='a search value'/>
    </function>
    <function name='xmlListSize' file='list' module='list'>
      <info>Get the number of elements in the list</info>
      <return type='int' info='the number of elements in the list or -1 in case of error'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListSort' file='list' module='list'>
      <info>Sort all the elements in the list</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
    </function>
    <function name='xmlListWalk' file='list' module='list'>
      <info>Walk all the element of the first from first to last and apply the walker function to it</info>
      <return type='void'/>
      <arg name='l' type='xmlListPtr' info='a list'/>
      <arg name='walker' type='xmlListWalker' info='a processing function'/>
      <arg name='user' type='const void *' info='a user parameter passed to the walker function'/>
    </function>
    <functype name='xmlListWalker' file='list' module='list'>
      <info>Callback function used when walking a list with xmlListWalk().</info>
      <return type='int' info='0 to stop walking the list, 1 otherwise.'/>
      <arg name='data' type='const void *' info='the data found in the list'/>
      <arg name='user' type='const void *' info='extra user provided data to the walker'/>
    </functype>
    <function name='xmlLoadACatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Load the catalog and build the associated data structures. This can be either an XML Catalog or an SGML Catalog It will recurse in SGML CATALOG entries. On the other hand XML Catalogs are not handled recursively.</info>
      <return type='xmlCatalogPtr' info='the catalog parsed or NULL in case of error'/>
      <arg name='filename' type='const char *' info='a file path'/>
    </function>
    <function name='xmlLoadCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Load the catalog and makes its definitions effective for the default external entity loader. It will recurse in SGML CATALOG entries. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='int' info='0 in case of success -1 in case of error'/>
      <arg name='filename' type='const char *' info='a file path'/>
    </function>
    <function name='xmlLoadCatalogs' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Load the catalogs and makes their definitions effective for the default external entity loader. this function is not thread safe, catalog initialization should preferably be done once at startup</info>
      <return type='void'/>
      <arg name='pathss' type='const char *' info='a list of directories separated by a colon or a space.'/>
    </function>
    <function name='xmlLoadExternalEntity' file='parser' module='xmlIO'>
      <info>Load an external entity, note that the use of this function for unparsed entities may generate problems</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr or NULL'/>
      <arg name='URL' type='const char *' info='the URL for the entity to load'/>
      <arg name='ID' type='const char *' info='the Public ID for the entity to load'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the context in which the entity is called or NULL'/>
    </function>
    <function name='xmlLoadSGMLSuperCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>Load an SGML super catalog. It won&apos;t expand CATALOG or DELEGATE references. This is only needed for manipulating SGML Super Catalogs like adding and removing CATALOG or DELEGATE entries.</info>
      <return type='xmlCatalogPtr' info='the catalog parsed or NULL in case of error'/>
      <arg name='filename' type='const char *' info='a file path'/>
    </function>
    <function name='xmlLockLibrary' file='threads' module='threads'>
      <info>xmlLockLibrary() is used to take out a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlLsCountNode' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Count the children of @node.</info>
      <return type='int' info='the number of children of @node.'/>
      <arg name='node' type='xmlNodePtr' info='the node to count'/>
    </function>
    <function name='xmlLsOneNode' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dump to @output the type and name of @node.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='node' type='xmlNodePtr' info='the node to dump'/>
    </function>
    <function name='xmlMallocAtomicLoc' file='xmlmemory' module='xmlmemory'>
      <info>a malloc() equivalent, with logging of the allocation info.</info>
      <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate.'/>
      <arg name='file' type='const char *' info='the file name or NULL'/>
      <arg name='line' type='int' info='the line number'/>
    </function>
    <functype name='xmlMallocFunc' file='xmlmemory' module='xmlmemory'>
      <info>Signature for a malloc() implementation.</info>
      <return type='void *' info='a pointer to the newly allocated block or NULL in case of error.'/>
      <arg name='size' type='size_t' info='the size requested in bytes'/>
    </functype>
    <function name='xmlMallocLoc' file='xmlmemory' module='xmlmemory'>
      <info>a malloc() equivalent, with logging of the allocation info.</info>
      <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate.'/>
      <arg name='file' type='const char *' info='the file name or NULL'/>
      <arg name='line' type='int' info='the line number'/>
    </function>
    <function name='xmlMemBlocks' file='xmlmemory' module='xmlmemory'>
      <info>Provides the number of memory areas currently allocated</info>
      <return type='int' info='an int representing the number of blocks'/>
    </function>
    <function name='xmlMemDisplay' file='xmlmemory' module='xmlmemory'>
      <info>show in-extenso the memory blocks allocated</info>
      <return type='void'/>
      <arg name='fp' type='FILE *' info='a FILE descriptor used as the output file, if NULL, the result is written to the file .memorylist'/>
    </function>
    <function name='xmlMemDisplayLast' file='xmlmemory' module='xmlmemory'>
      <info>the last nbBytes of memory allocated and not freed, useful for dumping the memory left allocated between two places at runtime.</info>
      <return type='void'/>
      <arg name='fp' type='FILE *' info='a FILE descriptor used as the output file, if NULL, the result is written to the file .memorylist'/>
      <arg name='nbBytes' type='long' info='the amount of memory to dump'/>
    </function>
    <function name='xmlMemFree' file='xmlmemory' module='xmlmemory'>
      <info>a free() equivalent, with error checking.</info>
      <return type='void'/>
      <arg name='ptr' type='void *' info='the memory block pointer'/>
    </function>
    <function name='xmlMemGet' file='xmlmemory' module='xmlmemory'>
      <info>Provides the memory access functions set currently in use</info>
      <return type='int' info='0 on success'/>
      <arg name='freeFunc' type='xmlFreeFunc *' info='place to save the free() function in use'/>
      <arg name='mallocFunc' type='xmlMallocFunc *' info='place to save the malloc() function in use'/>
      <arg name='reallocFunc' type='xmlReallocFunc *' info='place to save the realloc() function in use'/>
      <arg name='strdupFunc' type='xmlStrdupFunc *' info='place to save the strdup() function in use'/>
    </function>
    <function name='xmlMemMalloc' file='xmlmemory' module='xmlmemory'>
      <info>a malloc() equivalent, with logging of the allocation info.</info>
      <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate.'/>
    </function>
    <function name='xmlMemRealloc' file='xmlmemory' module='xmlmemory'>
      <info>a realloc() equivalent, with logging of the allocation info.</info>
      <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
      <arg name='ptr' type='void *' info='the initial memory block pointer'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate.'/>
    </function>
    <function name='xmlMemSetup' file='xmlmemory' module='xmlmemory'>
      <info>Override the default memory access functions with a new set This has to be called before any other libxml routines !  Should this be blocked if there was already some allocations done ?</info>
      <return type='int' info='0 on success'/>
      <arg name='freeFunc' type='xmlFreeFunc' info='the free() function to use'/>
      <arg name='mallocFunc' type='xmlMallocFunc' info='the malloc() function to use'/>
      <arg name='reallocFunc' type='xmlReallocFunc' info='the realloc() function to use'/>
      <arg name='strdupFunc' type='xmlStrdupFunc' info='the strdup() function to use'/>
    </function>
    <function name='xmlMemShow' file='xmlmemory' module='xmlmemory'>
      <info>show a show display of the memory allocated, and dump the @nr last allocated areas which were not freed</info>
      <return type='void'/>
      <arg name='fp' type='FILE *' info='a FILE descriptor used as the output file'/>
      <arg name='nr' type='int' info='number of entries to dump'/>
    </function>
    <function name='xmlMemStrdupLoc' file='xmlmemory' module='xmlmemory'>
      <info>a strdup() equivalent, with logging of the allocation info.</info>
      <return type='char *' info='a pointer to the new string or NULL if allocation error occurred.'/>
      <arg name='str' type='const char *' info='the initial string pointer'/>
      <arg name='file' type='const char *' info='the file name or NULL'/>
      <arg name='line' type='int' info='the line number'/>
    </function>
    <function name='xmlMemUsed' file='xmlmemory' module='xmlmemory'>
      <info>Provides the amount of memory currently allocated</info>
      <return type='int' info='an int representing the amount of memory allocated.'/>
    </function>
    <function name='xmlMemoryDump' file='xmlmemory' module='xmlmemory'>
      <info>Dump in-extenso the memory blocks allocated to the file .memorylist</info>
      <return type='void'/>
    </function>
    <function name='xmlMemoryStrdup' file='xmlmemory' module='xmlmemory'>
      <info>a strdup() equivalent, with logging of the allocation info.</info>
      <return type='char *' info='a pointer to the new string or NULL if allocation error occurred.'/>
      <arg name='str' type='const char *' info='the initial string pointer'/>
    </function>
    <function name='xmlModuleClose' file='xmlmodule' module='xmlmodule'>
      <cond>defined(LIBXML_MODULES_ENABLED)</cond>
      <info>The close operations unload the associated module and free the data associated to the module.</info>
      <return type='int' info='0 in case of success, -1 in case of argument error and -2 if the module could not be closed/unloaded.'/>
      <arg name='module' type='xmlModulePtr' info='the module handle'/>
    </function>
    <function name='xmlModuleFree' file='xmlmodule' module='xmlmodule'>
      <cond>defined(LIBXML_MODULES_ENABLED)</cond>
      <info>The free operations free the data associated to the module but does not unload the associated shared library which may still be in use.</info>
      <return type='int' info='0 in case of success, -1 in case of argument error'/>
      <arg name='module' type='xmlModulePtr' info='the module handle'/>
    </function>
    <function name='xmlModuleOpen' file='xmlmodule' module='xmlmodule'>
      <cond>defined(LIBXML_MODULES_ENABLED)</cond>
      <info>Opens a module/shared library given its name or path NOTE: that due to portability issues, behaviour can only be guaranteed with @name using ASCII. We canot guarantee that an UTF-8 string would work, which is why name is a const char * and not a const xmlChar * . TODO: options are not yet implemented.</info>
      <return type='xmlModulePtr' info='a handle for the module or NULL in case of error'/>
      <arg name='name' type='const char *' info='the module name'/>
      <arg name='options' type='int' info='a set of xmlModuleOption'/>
    </function>
    <function name='xmlModuleSymbol' file='xmlmodule' module='xmlmodule'>
      <cond>defined(LIBXML_MODULES_ENABLED)</cond>
      <info>Lookup for a symbol address in the given module NOTE: that due to portability issues, behaviour can only be guaranteed with @name using ASCII. We canot guarantee that an UTF-8 string would work, which is why name is a const char * and not a const xmlChar * .</info>
      <return type='int' info='0 if the symbol was found, or -1 in case of error'/>
      <arg name='module' type='xmlModulePtr' info='the module'/>
      <arg name='name' type='const char *' info='the name of the symbol'/>
      <arg name='symbol' type='void **' info='the resulting symbol address'/>
    </function>
    <function name='xmlMutexLock' file='threads' module='threads'>
      <info>xmlMutexLock() is used to lock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex'/>
    </function>
    <function name='xmlMutexUnlock' file='threads' module='threads'>
      <info>xmlMutexUnlock() is used to unlock a libxml2 token.</info>
      <return type='void'/>
      <arg name='tok' type='xmlMutexPtr' info='the simple mutex'/>
    </function>
    <function name='xmlNamespaceParseNCName' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>parse an XML namespace name.  TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  [NS 3] NCName ::= (Letter | &apos;_&apos;) (NCNameChar)*  [NS 4] NCNameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | CombiningChar | Extender</info>
      <return type='xmlChar *' info='the namespace name or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlNamespaceParseNSDef' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>parse a namespace prefix declaration  TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  [NS 1] NSDef ::= PrefixDef Eq SystemLiteral  [NS 2] PrefixDef ::= &apos;xmlns&apos; (&apos;:&apos; NCName)?</info>
      <return type='xmlChar *' info='the namespace name'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlNamespaceParseQName' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>TODO: this seems not in use anymore, the namespace handling is done on top of the SAX interfaces, i.e. not on raw input.  parse an XML qualified name  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
      <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar **'/>
    </function>
    <function name='xmlNanoFTPCheckResponse' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Check if there is a response from the FTP server after a command.</info>
      <return type='int' info='the code number, or 0'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPCleanup' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Cleanup the FTP protocol layer. This cleanup proxy informations.</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoFTPClose' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Close the connection and both control and transport</info>
      <return type='int' info='-1 incase of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPCloseConnection' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Close the data connection from the server</info>
      <return type='int' info='-1 incase of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPConnect' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Tries to open a control connection</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPConnectTo' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Tries to open a control connection to the given server/port</info>
      <return type='void *' info='an fTP context or NULL if it failed'/>
      <arg name='server' type='const char *' info='an FTP server name'/>
      <arg name='port' type='int' info='the port (use 21 if 0)'/>
    </function>
    <function name='xmlNanoFTPCwd' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Tries to change the remote directory</info>
      <return type='int' info='-1 incase of error, 1 if CWD worked, 0 if it failed'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='directory' type='const char *' info='a directory on the server'/>
    </function>
    <function name='xmlNanoFTPDele' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Tries to delete an item (file or directory) from server</info>
      <return type='int' info='-1 incase of error, 1 if DELE worked, 0 if it failed'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='file' type='const char *' info='a file or directory on the server'/>
    </function>
    <function name='xmlNanoFTPFreeCtxt' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Frees the context after closing the connection.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPGet' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Fetch the given file from the server. All data are passed back in the callbacks. The last callback has a size of 0 block.</info>
      <return type='int' info='-1 incase of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='callback' type='ftpDataCallback' info='the user callback'/>
      <arg name='userData' type='void *' info='the user callback data'/>
      <arg name='filename' type='const char *' info='the file to retrieve'/>
    </function>
    <function name='xmlNanoFTPGetConnection' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Try to open a data connection to the server. Currently only passive mode is supported.</info>
      <return type='SOCKET' info='-1 incase of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPGetResponse' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Get the response from the FTP server after a command.</info>
      <return type='int' info='the code number'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPGetSocket' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Initiate fetch of the given file from the server.</info>
      <return type='SOCKET' info='the socket for the data connection, or &lt;0 in case of error'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='filename' type='const char *' info='the file to retrieve (or NULL if path is in context).'/>
    </function>
    <function name='xmlNanoFTPInit' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Initialize the FTP protocol layer. Currently it just checks for proxy informations, and get the hostname</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoFTPList' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Do a listing on the server. All files info are passed back in the callbacks.</info>
      <return type='int' info='-1 incase of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='callback' type='ftpListCallback' info='the user callback'/>
      <arg name='userData' type='void *' info='the user callback data'/>
      <arg name='filename' type='const char *' info='optional files to list'/>
    </function>
    <function name='xmlNanoFTPNewCtxt' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Allocate and initialize a new FTP context.</info>
      <return type='void *' info='an FTP context or NULL in case of error.'/>
      <arg name='URL' type='const char *' info='The URL used to initialize the context'/>
    </function>
    <function name='xmlNanoFTPOpen' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Start to fetch the given ftp:// resource</info>
      <return type='void *' info='an FTP context, or NULL'/>
      <arg name='URL' type='const char *' info='the URL to the resource'/>
    </function>
    <function name='xmlNanoFTPProxy' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Setup the FTP proxy informations. This can also be done by using ftp_proxy ftp_proxy_user and ftp_proxy_password environment variables.</info>
      <return type='void'/>
      <arg name='host' type='const char *' info='the proxy host name'/>
      <arg name='port' type='int' info='the proxy port'/>
      <arg name='user' type='const char *' info='the proxy user name'/>
      <arg name='passwd' type='const char *' info='the proxy password'/>
      <arg name='type' type='int' info='the type of proxy 1 for using SITE, 2 for USER a@b'/>
    </function>
    <function name='xmlNanoFTPQuit' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Send a QUIT command to the server</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
    </function>
    <function name='xmlNanoFTPRead' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>This function tries to read @len bytes from the existing FTP connection and saves them in @dest. This is a blocking call.</info>
      <return type='int' info='the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error.'/>
      <arg name='ctx' type='void *' info='the FTP context'/>
      <arg name='dest' type='void *' info='a buffer'/>
      <arg name='len' type='int' info='the buffer length'/>
    </function>
    <function name='xmlNanoFTPScanProxy' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>(Re)Initialize the FTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like ftp://myproxy/ or ftp://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context'/>
    </function>
    <function name='xmlNanoFTPUpdateURL' file='nanoftp' module='nanoftp'>
      <cond>defined(LIBXML_FTP_ENABLED)</cond>
      <info>Update an FTP context by parsing the URL and finding new path it indicates. If there is an error in the protocol, hostname, port or other information, the error is raised. It indicates a new connection has to be established.</info>
      <return type='int' info='0 if Ok, -1 in case of error (other host).'/>
      <arg name='ctx' type='void *' info='an FTP context'/>
      <arg name='URL' type='const char *' info='The URL used to update the context'/>
    </function>
    <function name='xmlNanoHTTPAuthHeader' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Get the authentication header of an HTTP context</info>
      <return type='const char *' info='the stashed value of the WWW-Authenticate or Proxy-Authenticate header.'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPCleanup' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Cleanup the HTTP protocol layer.</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoHTTPClose' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function closes an HTTP context, it ends up the connection and free all data related to it.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPContentLength' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Provides the specified content length from the HTTP header.</info>
      <return type='int' info='the specified content length from the HTTP header.  Note that a value of -1 indicates that the content length element was not included in the response header.'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPEncoding' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Provides the specified encoding if specified in the HTTP headers.</info>
      <return type='const char *' info='the specified encoding or NULL if not available'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPFetch' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function try to fetch the indicated resource via HTTP GET and save it&apos;s content in the file.</info>
      <return type='int' info='-1 in case of failure, 0 incase of success. The contentType, if provided must be freed by the caller'/>
      <arg name='URL' type='const char *' info='The URL to load'/>
      <arg name='filename' type='const char *' info='the filename where the content should be saved'/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location'/>
    </function>
    <function name='xmlNanoHTTPInit' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Initialize the HTTP protocol layer. Currently it just checks for proxy informations</info>
      <return type='void'/>
    </function>
    <function name='xmlNanoHTTPMethod' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function try to open a connection to the indicated resource via HTTP using the given @method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *' info='NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller'/>
      <arg name='URL' type='const char *' info='The URL to load'/>
      <arg name='method' type='const char *' info='the HTTP method to use'/>
      <arg name='input' type='const char *' info='the input string if any'/>
      <arg name='contentType' type='char **' info='the Content-Type information IN and OUT'/>
      <arg name='headers' type='const char *' info='the extra headers'/>
      <arg name='ilen' type='int' info='input length'/>
    </function>
    <function name='xmlNanoHTTPMethodRedir' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function try to open a connection to the indicated resource via HTTP using the given @method, adding the given extra headers and the input buffer for the request content.</info>
      <return type='void *' info='NULL in case of failure, otherwise a request handler. The contentType, or redir, if provided must be freed by the caller'/>
      <arg name='URL' type='const char *' info='The URL to load'/>
      <arg name='method' type='const char *' info='the HTTP method to use'/>
      <arg name='input' type='const char *' info='the input string if any'/>
      <arg name='contentType' type='char **' info='the Content-Type information IN and OUT'/>
      <arg name='redir' type='char **' info='the redirected URL OUT'/>
      <arg name='headers' type='const char *' info='the extra headers'/>
      <arg name='ilen' type='int' info='input length'/>
    </function>
    <function name='xmlNanoHTTPMimeType' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Provides the specified Mime-Type if specified in the HTTP headers.</info>
      <return type='const char *' info='the specified Mime-Type or NULL if not available'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPOpen' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *' info='NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller'/>
      <arg name='URL' type='const char *' info='The URL to load'/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location'/>
    </function>
    <function name='xmlNanoHTTPOpenRedir' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function try to open a connection to the indicated resource via HTTP GET.</info>
      <return type='void *' info='NULL in case of failure, otherwise a request handler. The contentType, if provided must be freed by the caller'/>
      <arg name='URL' type='const char *' info='The URL to load'/>
      <arg name='contentType' type='char **' info='if available the Content-Type information will be returned at that location'/>
      <arg name='redir' type='char **' info='if available the redirected URL will be returned'/>
    </function>
    <function name='xmlNanoHTTPRead' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>This function tries to read @len bytes from the existing HTTP connection and saves them in @dest. This is a blocking call.</info>
      <return type='int' info='the number of byte read. 0 is an indication of an end of connection. -1 indicates a parameter error.'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
      <arg name='dest' type='void *' info='a buffer'/>
      <arg name='len' type='int' info='the buffer length'/>
    </function>
    <function name='xmlNanoHTTPRedir' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Provides the specified redirection URL if available from the HTTP header.</info>
      <return type='const char *' info='the specified redirection URL or NULL if not redirected.'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPReturnCode' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>Get the latest HTTP return code received</info>
      <return type='int' info='the HTTP return code for the request.'/>
      <arg name='ctx' type='void *' info='the HTTP context'/>
    </function>
    <function name='xmlNanoHTTPSave' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>This function saves the output of the HTTP transaction to a file It closes and free the context at the end</info>
      <return type='int' info='-1 in case of failure, 0 incase of success.'/>
      <arg name='ctxt' type='void *' info='the HTTP context'/>
      <arg name='filename' type='const char *' info='the filename where the content should be saved'/>
    </function>
    <function name='xmlNanoHTTPScanProxy' file='nanohttp' module='nanohttp'>
      <cond>defined(LIBXML_HTTP_ENABLED)</cond>
      <info>(Re)Initialize the HTTP Proxy context by parsing the URL and finding the protocol host port it indicates. Should be like http://myproxy/ or http://myproxy:3128/ A NULL URL cleans up proxy informations.</info>
      <return type='void'/>
      <arg name='URL' type='const char *' info='The proxy URL used to initialize the proxy context'/>
    </function>
    <function name='xmlNewAutomata' file='xmlautomata' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED) &amp;&amp; defined(LIBXML_AUTOMATA_ENABLED)</cond>
      <info>Create a new automata</info>
      <return type='xmlAutomataPtr' info='the new object or NULL in case of failure'/>
    </function>
    <function name='xmlNewCDataBlock' file='tree' module='tree'>
      <info>Creation of a new node containing a CDATA block.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='content' type='const xmlChar *' info='the CDATA block content content'/>
      <arg name='len' type='int' info='the length of the block'/>
    </function>
    <function name='xmlNewCatalog' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>create a new Catalog.</info>
      <return type='xmlCatalogPtr' info='the xmlCatalogPtr or NULL in case of error'/>
      <arg name='sgml' type='int' info='should this create an SGML catalog'/>
    </function>
    <function name='xmlNewCharEncodingHandler' file='encoding' module='encoding'>
      <info>Create and registers an xmlCharEncodingHandler.</info>
      <return type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr created (or NULL in case of error).'/>
      <arg name='name' type='const char *' info='the encoding name, in UTF-8 format (ASCII actually)'/>
      <arg name='input' type='xmlCharEncodingInputFunc' info='the xmlCharEncodingInputFunc to read that encoding'/>
      <arg name='output' type='xmlCharEncodingOutputFunc' info='the xmlCharEncodingOutputFunc to write that encoding'/>
    </function>
    <function name='xmlNewCharRef' file='tree' module='tree'>
      <info>Creation of a new character reference node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the char ref string, starting with # or &quot;&amp;# ... ;&quot;'/>
    </function>
    <function name='xmlNewChild' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Creation of a new child element, added at the end of @parent children list. @ns and @content parameters are optional (NULL). If @ns is NULL, the newly created element inherits the namespace of @parent. If @content is non NULL, a child list containing the TEXTs and ENTITY_REFs node will be created. NOTE: @content is supposed to be a piece of XML CDATA, so it allows entity references. XML special chars must be escaped first by using xmlEncodeEntitiesReentrant(), or xmlNewTextChild() should be used.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
      <arg name='ns' type='xmlNsPtr' info='a namespace if any'/>
      <arg name='name' type='const xmlChar *' info='the name of the child'/>
      <arg name='content' type='const xmlChar *' info='the XML content of the child if any.'/>
    </function>
    <function name='xmlNewComment' file='tree' module='tree'>
      <info>Creation of a new node containing a comment.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='content' type='const xmlChar *' info='the comment content'/>
    </function>
    <function name='xmlNewDoc' file='tree' module='tree'>
      <info>Creates a new XML document</info>
      <return type='xmlDocPtr' info='a new document'/>
      <arg name='version' type='const xmlChar *' info='xmlChar string giving the version of XML &quot;1.0&quot;'/>
    </function>
    <function name='xmlNewDocComment' file='tree' module='tree'>
      <info>Creation of a new node containing a comment within a document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='content' type='const xmlChar *' info='the comment content'/>
    </function>
    <function name='xmlNewDocElementContent' file='valid' module='valid'>
      <info>Allocate an element content structure for the document.</info>
      <return type='xmlElementContentPtr' info='NULL if not, otherwise the new element content structure'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the subelement name or NULL'/>
      <arg name='type' type='xmlElementContentType' info='the type of element content decl'/>
    </function>
    <function name='xmlNewDocFragment' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Creation of a new Fragment node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document owning the fragment'/>
    </function>
    <function name='xmlNewDocNode' file='tree' module='tree'>
      <info>Creation of a new node element within a document. @ns and @content are optional (NULL). NOTE: @content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don&apos;t need entities support.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any'/>
      <arg name='name' type='const xmlChar *' info='the node name'/>
      <arg name='content' type='const xmlChar *' info='the XML text content if any'/>
    </function>
    <function name='xmlNewDocNodeEatName' file='tree' module='tree'>
      <info>Creation of a new node element within a document. @ns and @content are optional (NULL). NOTE: @content is supposed to be a piece of XML CDATA, so it allow entities references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant(). Use xmlNewDocRawNode() if you don&apos;t need entities support.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any'/>
      <arg name='name' type='xmlChar *' info='the node name'/>
      <arg name='content' type='const xmlChar *' info='the XML text content if any'/>
    </function>
    <function name='xmlNewDocPI' file='tree' module='tree'>
      <info>Creation of a processing instruction element.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the target document'/>
      <arg name='name' type='const xmlChar *' info='the processing instruction name'/>
      <arg name='content' type='const xmlChar *' info='the PI content'/>
    </function>
    <function name='xmlNewDocProp' file='tree' module='tree'>
      <info>Create a new property carried by a document.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute'/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute'/>
    </function>
    <function name='xmlNewDocRawNode' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Creation of a new node element within a document. @ns and @content are optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any'/>
      <arg name='name' type='const xmlChar *' info='the node name'/>
      <arg name='content' type='const xmlChar *' info='the text content if any'/>
    </function>
    <function name='xmlNewDocText' file='tree' module='tree'>
      <info>Creation of a new text node within a document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='content' type='const xmlChar *' info='the text content'/>
    </function>
    <function name='xmlNewDocTextLen' file='tree' module='tree'>
      <info>Creation of a new text node with an extra content length parameter. The text node pertain to a given document.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='content' type='const xmlChar *' info='the text content'/>
      <arg name='len' type='int' info='the text len.'/>
    </function>
    <function name='xmlNewDtd' file='tree' module='tree'>
      <info>Creation of a new DTD for the external subset. To create an internal subset, use xmlCreateIntSubset().</info>
      <return type='xmlDtdPtr' info='a pointer to the new DTD structure'/>
      <arg name='doc' type='xmlDocPtr' info='the document pointer'/>
      <arg name='name' type='const xmlChar *' info='the DTD name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the system ID'/>
    </function>
    <function name='xmlNewElementContent' file='valid' module='valid'>
      <info>Allocate an element content structure. Deprecated in favor of xmlNewDocElementContent</info>
      <return type='xmlElementContentPtr' info='NULL if not, otherwise the new element content structure'/>
      <arg name='name' type='const xmlChar *' info='the subelement name or NULL'/>
      <arg name='type' type='xmlElementContentType' info='the type of element content decl'/>
    </function>
    <function name='xmlNewEntity' file='entities' module='entities'>
      <info>Create a new entity, this differs from xmlAddDocEntity() that if the document is NULL or has no internal subset defined, then an unlinked entity structure will be returned, it is then the responsability of the caller to link it to the document later or free it when not needed anymore.</info>
      <return type='xmlEntityPtr' info='a pointer to the entity or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type XML_xxx_yyy_ENTITY'/>
      <arg name='ExternalID' type='const xmlChar *' info='the entity external ID if available'/>
      <arg name='SystemID' type='const xmlChar *' info='the entity system ID if available'/>
      <arg name='content' type='const xmlChar *' info='the entity content'/>
    </function>
    <function name='xmlNewEntityInputStream' file='parserInternals' module='parserInternals'>
      <info>Create a new input stream based on an xmlEntityPtr</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='entity' type='xmlEntityPtr' info='an Entity pointer'/>
    </function>
    <function name='xmlNewGlobalNs' file='tree' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Creation of a Namespace, the old way using PI and without scoping DEPRECATED !!!</info>
      <return type='xmlNsPtr' info='NULL this functionality had been removed'/>
      <arg name='doc' type='xmlDocPtr' info='the document carrying the namespace'/>
      <arg name='href' type='const xmlChar *' info='the URI associated'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix for the namespace'/>
    </function>
    <function name='xmlNewIOInputStream' file='parser' module='parserInternals'>
      <info>Create a new input stream structure encapsulating the @input into a stream suitable for the parser.</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='input' type='xmlParserInputBufferPtr' info='an I/O Input'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlNewInputFromFile' file='parserInternals' module='parserInternals'>
      <info>Create a new input stream based on a file or an URL.</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='filename' type='const char *' info='the filename to use as entity'/>
    </function>
    <function name='xmlNewInputStream' file='parserInternals' module='parserInternals'>
      <info>Create a new input stream structure.</info>
      <return type='xmlParserInputPtr' info='the new input stream or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlNewMutex' file='threads' module='threads'>
      <info>xmlNewMutex() is used to allocate a libxml2 token struct for use in synchronizing access to data.</info>
      <return type='xmlMutexPtr' info='a new simple mutex pointer or NULL in case of error'/>
    </function>
    <function name='xmlNewNode' file='tree' module='tree'>
      <info>Creation of a new node element. @ns is optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object. Uses xmlStrdup() to make copy of @name.'/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any'/>
      <arg name='name' type='const xmlChar *' info='the node name'/>
    </function>
    <function name='xmlNewNodeEatName' file='tree' module='tree'>
      <info>Creation of a new node element. @ns is optional (NULL).</info>
      <return type='xmlNodePtr' info='a pointer to the new node object, with pointer @name as new node&apos;s name. Use xmlNewNode() if a copy of @name string is is needed as new node&apos;s name.'/>
      <arg name='ns' type='xmlNsPtr' info='namespace if any'/>
      <arg name='name' type='xmlChar *' info='the node name'/>
    </function>
    <function name='xmlNewNs' file='tree' module='tree'>
      <info>Creation of a new Namespace. This function will refuse to create a namespace with a similar prefix than an existing one present on this node. Note that for a default namespace, @prefix should be NULL.  We use href==NULL in the case of an element creation where the namespace was not defined.</info>
      <return type='xmlNsPtr' info='a new namespace pointer or NULL'/>
      <arg name='node' type='xmlNodePtr' info='the element carrying the namespace'/>
      <arg name='href' type='const xmlChar *' info='the URI associated'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix for the namespace'/>
    </function>
    <function name='xmlNewNsProp' file='tree' module='tree'>
      <info>Create a new property tagged with a namespace and carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute'/>
      <arg name='node' type='xmlNodePtr' info='the holding node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace'/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute'/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute'/>
    </function>
    <function name='xmlNewNsPropEatName' file='tree' module='tree'>
      <info>Create a new property tagged with a namespace and carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute'/>
      <arg name='node' type='xmlNodePtr' info='the holding node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace'/>
      <arg name='name' type='xmlChar *' info='the name of the attribute'/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute'/>
    </function>
    <function name='xmlNewPI' file='tree' module='tree'>
      <info>Creation of a processing instruction element. Use xmlDocNewPI preferably to get string interning</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='name' type='const xmlChar *' info='the processing instruction name'/>
      <arg name='content' type='const xmlChar *' info='the PI content'/>
    </function>
    <function name='xmlNewParserCtxt' file='parser' module='parserInternals'>
      <info>Allocate and initialize a new parser context.</info>
      <return type='xmlParserCtxtPtr' info='the xmlParserCtxtPtr or NULL'/>
    </function>
    <function name='xmlNewProp' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create a new property carried by a node.</info>
      <return type='xmlAttrPtr' info='a pointer to the attribute'/>
      <arg name='node' type='xmlNodePtr' info='the holding node'/>
      <arg name='name' type='const xmlChar *' info='the name of the attribute'/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute'/>
    </function>
    <function name='xmlNewRMutex' file='threads' module='threads'>
      <info>xmlRNewMutex() is used to allocate a reentrant mutex for use in synchronizing access to data. token_r is a re-entrant lock and thus useful for synchronizing access to data structures that may be manipulated in a recursive fashion.</info>
      <return type='xmlRMutexPtr' info='the new reentrant mutex pointer or NULL in case of error'/>
    </function>
    <function name='xmlNewReference' file='tree' module='tree'>
      <info>Creation of a new reference node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='name' type='const xmlChar *' info='the reference name, or the reference string with &amp; and ;'/>
    </function>
    <function name='xmlNewStringInputStream' file='parserInternals' module='parserInternals'>
      <info>Create a new input stream based on a memory buffer.</info>
      <return type='xmlParserInputPtr' info='the new input stream'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='buffer' type='const xmlChar *' info='an memory buffer'/>
    </function>
    <function name='xmlNewText' file='tree' module='tree'>
      <info>Creation of a new text node.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='content' type='const xmlChar *' info='the text content'/>
    </function>
    <function name='xmlNewTextChild' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Creation of a new child element, added at the end of @parent children list. @ns and @content parameters are optional (NULL). If @ns is NULL, the newly created element inherits the namespace of @parent. If @content is non NULL, a child TEXT node will be created containing the string @content. NOTE: Use xmlNewChild() if @content will contain entities that need to be preserved. Use this function, xmlNewTextChild(), if you need to ensure that reserved XML chars that might appear in @content, such as the ampersand, greater-than or less-than signs, are automatically replaced by their XML escaped entity representations.</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='parent' type='xmlNodePtr' info='the parent node'/>
      <arg name='ns' type='xmlNsPtr' info='a namespace if any'/>
      <arg name='name' type='const xmlChar *' info='the name of the child'/>
      <arg name='content' type='const xmlChar *' info='the text content of the child if any.'/>
    </function>
    <function name='xmlNewTextLen' file='tree' module='tree'>
      <info>Creation of a new text node with an extra parameter for the content&apos;s length</info>
      <return type='xmlNodePtr' info='a pointer to the new node object.'/>
      <arg name='content' type='const xmlChar *' info='the text content'/>
      <arg name='len' type='int' info='the text len.'/>
    </function>
    <function name='xmlNewTextReader' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmlTextReader structure fed with @input</info>
      <return type='xmlTextReaderPtr' info='the new xmlTextReaderPtr or NULL in case of error'/>
      <arg name='input' type='xmlParserInputBufferPtr' info='the xmlParserInputBufferPtr used to read data'/>
      <arg name='URI' type='const char *' info='the URI information for the source if available'/>
    </function>
    <function name='xmlNewTextReaderFilename' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmlTextReader structure fed with the resource at @URI</info>
      <return type='xmlTextReaderPtr' info='the new xmlTextReaderPtr or NULL in case of error'/>
      <arg name='URI' type='const char *' info='the URI of the resource to process'/>
    </function>
    <function name='xmlNewTextWriter' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure using an xmlOutputBufferPtr NOTE: the @out parameter will be deallocated when the writer is closed (if the call succeed.)</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='out' type='xmlOutputBufferPtr' info='an xmlOutputBufferPtr'/>
    </function>
    <function name='xmlNewTextWriterDoc' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure with @*doc as output</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr *' info='address of a xmlDocPtr to hold the new XML document tree'/>
      <arg name='compression' type='int' info='compress the output?'/>
    </function>
    <function name='xmlNewTextWriterFilename' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure with @uri as output</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='uri' type='const char *' info='the URI of the resource for the output'/>
      <arg name='compression' type='int' info='compress the output?'/>
    </function>
    <function name='xmlNewTextWriterMemory' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure with @buf as output TODO: handle compression</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='buf' type='xmlBufferPtr' info='xmlBufferPtr'/>
      <arg name='compression' type='int' info='compress the output?'/>
    </function>
    <function name='xmlNewTextWriterPushParser' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure with @ctxt as output NOTE: the @ctxt context will be freed with the resulting writer (if the call succeeds). TODO: handle compression</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='xmlParserCtxtPtr to hold the new XML document tree'/>
      <arg name='compression' type='int' info='compress the output?'/>
    </function>
    <function name='xmlNewTextWriterTree' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Create a new xmlNewTextWriter structure with @doc as output starting at @node</info>
      <return type='xmlTextWriterPtr' info='the new xmlTextWriterPtr or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='xmlDocPtr'/>
      <arg name='node' type='xmlNodePtr' info='xmlNodePtr or NULL for doc-&gt;children'/>
      <arg name='compression' type='int' info='compress the output?'/>
    </function>
    <function name='xmlNewValidCtxt' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Allocate a validation context structure.</info>
      <return type='xmlValidCtxtPtr' info='NULL if not, otherwise the new validation context structure'/>
    </function>
    <function name='xmlNextChar' file='parserInternals' module='parserInternals'>
      <info>Skip to the next char input char.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context'/>
    </function>
    <function name='xmlNextElementSibling' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Finds the first closest next sibling of the node which is an element node. Note the handling of entities references is different than in the W3C DOM element traversal spec since we don&apos;t have back reference from entities content to entities references.</info>
      <return type='xmlNodePtr' info='the next element sibling or NULL if not available'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
    </function>
    <function name='xmlNoNetExternalEntityLoader' file='xmlIO' module='xmlIO'>
      <info>A specific entity loader disabling network accesses, though still allowing local catalog accesses for resolution.</info>
      <return type='xmlParserInputPtr' info='a new allocated xmlParserInputPtr, or NULL.'/>
      <arg name='URL' type='const char *' info='the URL for the entity to load'/>
      <arg name='ID' type='const char *' info='the System ID for the entity to load'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the context in which the entity is called or NULL'/>
    </function>
    <function name='xmlNodeAddContent' file='tree' module='tree'>
      <info>Append the extra substring to the node content. NOTE: In contrast to xmlNodeSetContent(), @content is supposed to be raw text, so unescaped XML special chars are allowed, entity references are not supported.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified'/>
      <arg name='content' type='const xmlChar *' info='extra content'/>
    </function>
    <function name='xmlNodeAddContentLen' file='tree' module='tree'>
      <info>Append the extra substring to the node content. NOTE: In contrast to xmlNodeSetContentLen(), @content is supposed to be raw text, so unescaped XML special chars are allowed, entity references are not supported.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified'/>
      <arg name='content' type='const xmlChar *' info='extra content'/>
      <arg name='len' type='int' info='the size of @content'/>
    </function>
    <function name='xmlNodeBufGetContent' file='tree' module='tree'>
      <info>Read the value of a node @cur, this can be either the text carried directly by this node if it&apos;s a TEXT node or the aggregate string of the values carried by this node child&apos;s (TEXT and ENTITY_REF). Entity references are substituted. Fills up the buffer @buffer with this value</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='buffer' type='xmlBufferPtr' info='a buffer'/>
      <arg name='cur' type='const xmlNode *' info='the node being read'/>
    </function>
    <function name='xmlNodeDump' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML node, recursive behaviour,children are printed too. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called Since this is using xmlBuffer structures it is limited to 2GB and somehow deprecated, use xmlBufNodeDump() instead.</info>
      <return type='int' info='the number of bytes written to the buffer or -1 in case of error'/>
      <arg name='buf' type='xmlBufferPtr' info='the XML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='level' type='int' info='the imbrication level for indenting'/>
      <arg name='format' type='int' info='is formatting allowed'/>
    </function>
    <function name='xmlNodeDumpOutput' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML node, recursive behaviour, children are printed too. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='void'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='the XML buffer output'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='cur' type='xmlNodePtr' info='the current node'/>
      <arg name='level' type='int' info='the imbrication level for indenting'/>
      <arg name='format' type='int' info='is formatting allowed'/>
      <arg name='encoding' type='const char *' info='an optional encoding string'/>
    </function>
    <function name='xmlNodeGetBase' file='tree' module='tree'>
      <info>Searches for the BASE URL. The code should work on both XML and HTML document even if base mechanisms are completely different. It returns the base as defined in RFC 2396 sections 5.1.1. Base URI within Document Content and 5.1.2. Base URI from the Encapsulating Entity However it does not return the document base (5.1.3), use doc-&gt;URL in this case</info>
      <return type='xmlChar *' info='a pointer to the base URL, or NULL if not found It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='doc' type='const xmlDoc *' info='the document the node pertains to'/>
      <arg name='cur' type='const xmlNode *' info='the node being checked'/>
    </function>
    <function name='xmlNodeGetContent' file='tree' module='tree'>
      <info>Read the value of a node, this can be either the text carried directly by this node if it&apos;s a TEXT node or the aggregate string of the values carried by this node child&apos;s (TEXT and ENTITY_REF). Entity references are substituted.</info>
      <return type='xmlChar *' info='a new #xmlChar * or NULL if no content is available. It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='cur' type='const xmlNode *' info='the node being read'/>
    </function>
    <function name='xmlNodeGetLang' file='tree' module='tree'>
      <info>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</info>
      <return type='xmlChar *' info='a pointer to the lang value, or NULL if not found It&apos;s up to the caller to free the memory with xmlFree().'/>
      <arg name='cur' type='const xmlNode *' info='the node being checked'/>
    </function>
    <function name='xmlNodeGetSpacePreserve' file='tree' module='tree'>
      <info>Searches the space preserving behaviour of a node, i.e. the values of the xml:space attribute or the one carried by the nearest ancestor.</info>
      <return type='int' info='-1 if xml:space is not inherited, 0 if &quot;default&quot;, 1 if &quot;preserve&quot;'/>
      <arg name='cur' type='const xmlNode *' info='the node being checked'/>
    </function>
    <function name='xmlNodeIsText' file='tree' module='tree'>
      <info>Is this node a Text node ?</info>
      <return type='int' info='1 yes, 0 no'/>
      <arg name='node' type='const xmlNode *' info='the node'/>
    </function>
    <function name='xmlNodeListGetRawString' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Builds the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs, contrary to xmlNodeListGetString() this function doesn&apos;t do any character encoding handling.</info>
      <return type='xmlChar *' info='a pointer to the string copy, the caller must free it with xmlFree().'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='list' type='const xmlNode *' info='a Node list'/>
      <arg name='inLine' type='int' info='should we replace entity contents or show their external form'/>
    </function>
    <function name='xmlNodeListGetString' file='tree' module='tree'>
      <info>Build the string equivalent to the text contained in the Node list made of TEXTs and ENTITY_REFs</info>
      <return type='xmlChar *' info='a pointer to the string copy, the caller must free it with xmlFree().'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='list' type='const xmlNode *' info='a Node list'/>
      <arg name='inLine' type='int' info='should we replace entity contents or show their external form'/>
    </function>
    <function name='xmlNodeSetBase' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Set (or reset) the base URI of a node, i.e. the value of the xml:base attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
      <arg name='uri' type='const xmlChar *' info='the new base URI'/>
    </function>
    <function name='xmlNodeSetContent' file='tree' module='tree'>
      <info>Replace the content of a node. NOTE: @content is supposed to be a piece of XML CDATA, so it allows entity references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant() resp. xmlEncodeSpecialChars().</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified'/>
      <arg name='content' type='const xmlChar *' info='the new value of the content'/>
    </function>
    <function name='xmlNodeSetContentLen' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Replace the content of a node. NOTE: @content is supposed to be a piece of XML CDATA, so it allows entity references, but XML special chars need to be escaped first by using xmlEncodeEntitiesReentrant() resp. xmlEncodeSpecialChars().</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being modified'/>
      <arg name='content' type='const xmlChar *' info='the new value of the content'/>
      <arg name='len' type='int' info='the size of @content'/>
    </function>
    <function name='xmlNodeSetLang' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Set the language of a node, i.e. the values of the xml:lang attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
      <arg name='lang' type='const xmlChar *' info='the language description'/>
    </function>
    <function name='xmlNodeSetName' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Set (or reset) the name of a node.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
      <arg name='name' type='const xmlChar *' info='the new tag name'/>
    </function>
    <function name='xmlNodeSetSpacePreserve' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Set (or reset) the space preserving behaviour of a node, i.e. the value of the xml:space attribute.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node being changed'/>
      <arg name='val' type='int' info='the xml:space value (&quot;0&quot;: default, 1: &quot;preserve&quot;)'/>
    </function>
    <function name='xmlNormalizeURIPath' file='uri' module='uri'>
      <info>Applies the 5 normalization steps to a path string--that is, RFC 2396 Section 5.2, steps 6.c through 6.g.  Normalization occurs directly on the string, no new allocation is done</info>
      <return type='int' info='0 or an error code'/>
      <arg name='path' type='char *' info='pointer to the path string'/>
    </function>
    <function name='xmlNormalizeWindowsPath' file='xmlIO' module='xmlIO'>
      <info>This function is obsolete. Please see xmlURIFromPath in uri.c for a better solution.</info>
      <return type='xmlChar *' info='a canonicalized version of the path'/>
      <arg name='path' type='const xmlChar *' info='the input file path'/>
    </function>
    <function name='xmlOutputBufferClose' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>flushes and close the output I/O channel and free up all the associated resources</info>
      <return type='int' info='the number of byte written or -1 in case of error.'/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered output'/>
    </function>
    <function name='xmlOutputBufferCreateBuffer' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered output for the progressive saving to a xmlBuffer</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL'/>
      <arg name='buffer' type='xmlBufferPtr' info='a xmlBufferPtr'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL'/>
    </function>
    <function name='xmlOutputBufferCreateFd' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered output for the progressive saving to a file descriptor</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL'/>
      <arg name='fd' type='int' info='a file descriptor number'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL'/>
    </function>
    <function name='xmlOutputBufferCreateFile' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered output for the progressive saving to a FILE * buffered C I/O</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL'/>
      <arg name='file' type='FILE *' info='a FILE*'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL'/>
    </function>
    <function name='xmlOutputBufferCreateFilename' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered  output for the progressive saving of a file If filename is &quot;-&apos; then we use stdout as the output. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. TODO: currently if compression is set, the library only support writing to a local file.</info>
      <return type='xmlOutputBufferPtr' info='the new output or NULL'/>
      <arg name='URI' type='const char *' info='a C string containing the URI or filename'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the encoding converter or NULL'/>
      <arg name='compression' type='int' info='the compression ration (0 none, 9 max).'/>
    </function>
    <function name='xmlOutputBufferCreateFilenameDefault' file='globals' module='xmlIO'>
      <info>Registers a callback for URI output file handling</info>
      <return type='xmlOutputBufferCreateFilenameFunc' info='the old value of the registration function'/>
      <arg name='func' type='xmlOutputBufferCreateFilenameFunc' info='function pointer to the new OutputBufferCreateFilenameFunc'/>
    </function>
    <functype name='xmlOutputBufferCreateFilenameFunc' file='globals' module='globals'>
      <info>Signature for the function doing the lookup for a suitable output method corresponding to an URI.</info>
      <return type='xmlOutputBufferPtr' info='the new xmlOutputBufferPtr in case of success or NULL if no method was found.'/>
      <arg name='URI' type='const char *' info='the URI to write to'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info=''/>
      <arg name='compression' type='int' info=''/>
    </functype>
    <function name='xmlOutputBufferCreateIO' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a buffered output for the progressive saving to an I/O handler</info>
      <return type='xmlOutputBufferPtr' info='the new parser output or NULL'/>
      <arg name='iowrite' type='xmlOutputWriteCallback' info='an I/O write function'/>
      <arg name='ioclose' type='xmlOutputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='encoder' type='xmlCharEncodingHandlerPtr' info='the charset encoding if known'/>
    </function>
    <function name='xmlOutputBufferFlush' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>flushes the output I/O channel</info>
      <return type='int' info='the number of byte written or -1 in case of error.'/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered output'/>
    </function>
    <function name='xmlOutputBufferGetContent' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Gives a pointer to the data currently held in the output buffer</info>
      <return type='const xmlChar *' info='a pointer to the data or NULL in case of error'/>
      <arg name='out' type='xmlOutputBufferPtr' info='an xmlOutputBufferPtr'/>
    </function>
    <function name='xmlOutputBufferGetSize' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Gives the length of the data currently held in the output buffer</info>
      <return type='size_t' info='0 in case or error or no data is held, the size otherwise'/>
      <arg name='out' type='xmlOutputBufferPtr' info='an xmlOutputBufferPtr'/>
    </function>
    <function name='xmlOutputBufferWrite' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Write the content of the array in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int' info='the number of chars immediately written, or -1 in case of error.'/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered parser output'/>
      <arg name='len' type='int' info='the size in bytes of the array.'/>
      <arg name='buf' type='const char *' info='an char array'/>
    </function>
    <function name='xmlOutputBufferWriteEscape' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Write the content of the string in the output I/O buffer This routine escapes the caracters and then handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int' info='the number of chars immediately written, or -1 in case of error.'/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered parser output'/>
      <arg name='str' type='const xmlChar *' info='a zero terminated UTF-8 string'/>
      <arg name='escaping' type='xmlCharEncodingOutputFunc' info='an optional escaping function (or NULL)'/>
    </function>
    <function name='xmlOutputBufferWriteString' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Write the content of the string in the output I/O buffer This routine handle the I18N transcoding from internal UTF-8 The buffer is lossless, i.e. will store in case of partial or delayed writes.</info>
      <return type='int' info='the number of chars immediately written, or -1 in case of error.'/>
      <arg name='out' type='xmlOutputBufferPtr' info='a buffered parser output'/>
      <arg name='str' type='const char *' info='a zero terminated C string'/>
    </function>
    <functype name='xmlOutputCloseCallback' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Callback used in the I/O Output API to close the resource</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='context' type='void *' info='an Output context'/>
    </functype>
    <functype name='xmlOutputMatchCallback' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Callback used in the I/O Output API to detect if the current handler can provide output fonctionnalities for this resource.</info>
      <return type='int' info='1 if yes and 0 if another Output module should be used'/>
      <arg name='filename' type='char const *' info='the filename or URI'/>
    </functype>
    <functype name='xmlOutputOpenCallback' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Callback used in the I/O Output API to open the resource</info>
      <return type='void *' info='an Output context or NULL in case or error'/>
      <arg name='filename' type='char const *' info='the filename or URI'/>
    </functype>
    <functype name='xmlOutputWriteCallback' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Callback used in the I/O Output API to write to the resource</info>
      <return type='int' info='the number of bytes written or -1 in case of error'/>
      <arg name='context' type='void *' info='an Output context'/>
      <arg name='buffer' type='const char *' info='the buffer of data to write'/>
      <arg name='len' type='int' info='the length of the buffer in bytes'/>
    </functype>
    <function name='xmlParseAttValue' file='parserInternals' module='parser'>
      <info>parse a value for an attribute Note: the parser won&apos;t do substitution of entities here, this will be handled later in xmlStringGetNodeList  [10] AttValue ::= &apos;&quot;&apos; ([^&lt;&amp;&quot;] | Reference)* &apos;&quot;&apos; | &quot;&apos;&quot; ([^&lt;&amp;&apos;] | Reference)* &quot;&apos;&quot;  3.3.3 Attribute-Value Normalization: Before the value of an attribute is passed to the application or checked for validity, the XML processor must normalize it as follows: - a character reference is processed by appending the referenced character to the attribute value - an entity reference is processed by recursively processing the replacement text of the entity - a whitespace character (#x20, #xD, #xA, #x9) is processed by appending #x20 to the normalized value, except that only a single #x20 is appended for a &quot;#xD#xA&quot; sequence that is part of an external parsed entity or the literal entity value of an internal parsed entity - other characters are processed by appending them to the normalized value If the declared value is not CDATA, then the XML processor must further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character. All attributes for which no declaration has been read should be treated by a non-validating parser as if declared CDATA.</info>
      <return type='xmlChar *' info='the AttValue parsed or NULL. The value has to be freed by the caller.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseAttribute' file='parserInternals' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an attribute  [41] Attribute ::= Name Eq AttValue  [ WFC: No External Entity References ] Attribute values cannot contain direct or indirect entity references to external entities.  [ WFC: No &lt; in Attribute Values ] The replacement text of any entity referred to directly or indirectly in an attribute value (other than &quot;&amp;lt;&quot;) must not contain a &lt;.  [ VC: Attribute Value Type ] The attribute must have been declared; the value must be of the type declared for it.  [25] Eq ::= S? &apos;=&apos; S?  With namespace:  [NS 11] Attribute ::= QName Eq AttValue  Also the case QName == xmlns:??? is handled independently as a namespace definition.</info>
      <return type='const xmlChar *' info='the attribute name, and the value in *value.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='value' type='xmlChar **' info='a xmlChar ** used to store the value of the attribute'/>
    </function>
    <function name='xmlParseAttributeListDecl' file='parserInternals' module='parser'>
      <info>: parse the Attribute list def for an element  [52] AttlistDecl ::= &apos;&lt;!ATTLIST&apos; S Name AttDef* S? &apos;&gt;&apos;  [53] AttDef ::= S Name S AttType S DefaultDecl</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseAttributeType' file='parserInternals' module='parser'>
      <info>parse the Attribute list def for an element  [54] AttType ::= StringType | TokenizedType | EnumeratedType  [55] StringType ::= &apos;CDATA&apos;  [56] TokenizedType ::= &apos;ID&apos; | &apos;IDREF&apos; | &apos;IDREFS&apos; | &apos;ENTITY&apos; | &apos;ENTITIES&apos; | &apos;NMTOKEN&apos; | &apos;NMTOKENS&apos;  Validity constraints for attribute values syntax are checked in xmlValidateAttributeValue()  [ VC: ID ] Values of type ID must match the Name production. A name must not appear more than once in an XML document as a value of this type; i.e., ID values must uniquely identify the elements which bear them.  [ VC: One ID per Element Type ] No element type may have more than one ID attribute specified.  [ VC: ID Attribute Default ] An ID attribute must have a declared default of #IMPLIED or #REQUIRED.  [ VC: IDREF ] Values of type IDREF must match the Name production, and values of type IDREFS must match Names; each IDREF Name must match the value of an ID attribute on some element in the XML document; i.e. IDREF values must match the value of some ID attribute.  [ VC: Entity Name ] Values of type ENTITY must match the Name production, values of type ENTITIES must match Names; each Entity Name must match the name of an unparsed entity declared in the DTD.  [ VC: Name Token ] Values of type NMTOKEN must match the Nmtoken production; values of type NMTOKENS must match Nmtokens.</info>
      <return type='int' info='the attribute type'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='tree' type='xmlEnumerationPtr *' info='the enumeration tree built while parsing'/>
    </function>
    <function name='xmlParseBalancedChunkMemory' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</info>
      <return type='int' info='0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise'/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL)'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL)'/>
      <arg name='depth' type='int' info='Used for loop detection, use 0'/>
      <arg name='string' type='const xmlChar *' info='the input string in UTF8 or ISO-Latin (zero terminated)'/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
    </function>
    <function name='xmlParseBalancedChunkMemoryRecover' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Parse a well-balanced chunk of an XML document called by the parser The allowed sequence for the Well Balanced Chunk is the one defined by the content production in the XML grammar:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</info>
      <return type='int' info='0 if the chunk is well balanced, -1 in case of args problem and the parser error code otherwise  In case recover is set to 1, the nodelist will not be empty even if the parsed chunk is not well balanced, assuming the parsing succeeded to some extent.'/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL)'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL)'/>
      <arg name='depth' type='int' info='Used for loop detection, use 0'/>
      <arg name='string' type='const xmlChar *' info='the input string in UTF8 or ISO-Latin (zero terminated)'/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
      <arg name='recover' type='int' info='return nodes even if the data is broken (use 0)'/>
    </function>
    <function name='xmlParseCDSect' file='parserInternals' module='parser'>
      <info>Parse escaped pure raw content.  [18] CDSect ::= CDStart CData CDEnd  [19] CDStart ::= &apos;&lt;![CDATA[&apos;  [20] Data ::= (Char* - (Char* &apos;]]&gt;&apos; Char*))  [21] CDEnd ::= &apos;]]&gt;&apos;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseCatalogFile' file='catalog' module='catalog'>
      <cond>defined(LIBXML_CATALOG_ENABLED)</cond>
      <info>parse an XML file and build a tree. It&apos;s like xmlParseFile() except it bypass all catalog lookups.</info>
      <return type='xmlDocPtr' info='the resulting document tree or NULL in case of error'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlParseCharData' file='parserInternals' module='parser'>
      <info>parse a CharData section. if we are within a CDATA section &apos;]]&gt;&apos; marks an end of section.  The right angle bracket (&gt;) may be represented using the string &quot;&amp;gt;&quot;, and must, for compatibility, be escaped using &quot;&amp;gt;&quot; or a character reference when it appears in the string &quot;]]&gt;&quot; in content, when that string is not marking the end of a CDATA section.  [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* &apos;]]&gt;&apos; [^&lt;&amp;]*)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='cdata' type='int' info='int indicating whether we are within a CDATA section'/>
    </function>
    <function name='xmlParseCharEncoding' file='encoding' module='encoding'>
      <info>Compare the string to the encoding schemes already known. Note that the comparison is case insensitive accordingly to the section [XML] 4.3.3 Character Encoding in Entities.</info>
      <return type='xmlCharEncoding' info='one of the XML_CHAR_ENCODING_... values or XML_CHAR_ENCODING_NONE if not recognized.'/>
      <arg name='name' type='const char *' info='the encoding name as parsed, in UTF-8 format (ASCII actually)'/>
    </function>
    <function name='xmlParseCharRef' file='parserInternals' module='parser'>
      <info>parse Reference declarations  [66] CharRef ::= &apos;&amp;#&apos; [0-9]+ &apos;;&apos; | &apos;&amp;#x&apos; [0-9a-fA-F]+ &apos;;&apos;  [ WFC: Legal Character ] Characters referred to using character references must match the production for Char.</info>
      <return type='int' info='the value parsed (as an int), 0 in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseChunk' file='parser' module='parser'>
      <cond>defined(LIBXML_PUSH_ENABLED)</cond>
      <info>Parse a Chunk of memory</info>
      <return type='int' info='zero if no error, the xmlParserErrors otherwise.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='chunk' type='const char *' info='an char array'/>
      <arg name='size' type='int' info='the size in byte of the chunk'/>
      <arg name='terminate' type='int' info='last chunk indicator'/>
    </function>
    <function name='xmlParseComment' file='parserInternals' module='parser'>
      <info>Skip an XML (SGML) comment &lt;!-- .... --&gt; The spec says that &quot;For compatibility, the string &quot;--&quot; (double-hyphen) must not occur within comments. &quot;  [15] Comment ::= &apos;&lt;!--&apos; ((Char - &apos;-&apos;) | (&apos;-&apos; (Char - &apos;-&apos;)))* &apos;--&gt;&apos;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseContent' file='parserInternals' module='parser'>
      <info>Parse a content:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseCtxtExternalEntity' file='parser' module='parser'>
      <info>Parse an external general entity within an existing parsing context An external general parsed entity is well-formed if it matches the production labeled extParsedEnt.  [78] extParsedEnt ::= TextDecl? content</info>
      <return type='int' info='0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise'/>
      <arg name='ctx' type='xmlParserCtxtPtr' info='the existing parsing context'/>
      <arg name='URL' type='const xmlChar *' info='the URL for the entity to load'/>
      <arg name='ID' type='const xmlChar *' info='the System ID for the entity to load'/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
    </function>
    <function name='xmlParseDTD' file='parser' module='parser'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr' info='the resulting xmlDtdPtr or NULL in case of error.'/>
      <arg name='ExternalID' type='const xmlChar *' info='a NAME* containing the External ID of the DTD'/>
      <arg name='SystemID' type='const xmlChar *' info='a NAME* containing the URL to the DTD'/>
    </function>
    <function name='xmlParseDefaultDecl' file='parserInternals' module='parser'>
      <info>Parse an attribute default declaration  [60] DefaultDecl ::= &apos;#REQUIRED&apos; | &apos;#IMPLIED&apos; | ((&apos;#FIXED&apos; S)? AttValue)  [ VC: Required Attribute ] if the default declaration is the keyword #REQUIRED, then the attribute must be specified for all elements of the type in the attribute-list declaration.  [ VC: Attribute Default Legal ] The declared default value must meet the lexical constraints of the declared attribute type c.f. xmlValidateAttributeDecl()  [ VC: Fixed Attribute Default ] if an attribute has a default value declared with the #FIXED keyword, instances of that attribute must match the default value.  [ WFC: No &lt; in Attribute Values ] handled in xmlParseAttValue()</info>
      <return type='int' info='XML_ATTRIBUTE_NONE, XML_ATTRIBUTE_REQUIRED, XML_ATTRIBUTE_IMPLIED or XML_ATTRIBUTE_FIXED.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='value' type='xmlChar **' info='Receive a possible fixed default value for the attribute'/>
    </function>
    <function name='xmlParseDoc' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to an array of xmlChar'/>
    </function>
    <function name='xmlParseDocTypeDecl' file='parserInternals' module='parser'>
      <info>parse a DOCTYPE declaration  [28] doctypedecl ::= &apos;&lt;!DOCTYPE&apos; S Name (S ExternalID)? S? (&apos;[&apos; (markupdecl | PEReference | S)* &apos;]&apos; S?)? &apos;&gt;&apos;  [ VC: Root Element Type ] The Name in the document type declaration must match the element type of the root element.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseDocument' file='parser' module='parser'>
      <info>parse an XML document (and build a tree if using the standard SAX interface).  [1] document ::= prolog element Misc*  [22] prolog ::= XMLDecl? Misc* (doctypedecl Misc*)?</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseElement' file='parserInternals' module='parser'>
      <info>parse an XML element, this is highly recursive  [39] element ::= EmptyElemTag | STag content ETag  [ WFC: Element Type Match ] The Name in an element&apos;s end-tag must match the element type in the start-tag.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseElementChildrenContentDecl' file='parserInternals' module='parser'>
      <info>parse the declaration for a Mixed Element content The leading &apos;(&apos; and spaces have been skipped in xmlParseElementContentDecl  [47] children ::= (choice | seq) (&apos;?&apos; | &apos;*&apos; | &apos;+&apos;)?  [48] cp ::= (Name | choice | seq) (&apos;?&apos; | &apos;*&apos; | &apos;+&apos;)?  [49] choice ::= &apos;(&apos; S? cp ( S? &apos;|&apos; S? cp )* S? &apos;)&apos;  [50] seq ::= &apos;(&apos; S? cp ( S? &apos;,&apos; S? cp )* S? &apos;)&apos;  [ VC: Proper Group/PE Nesting ] applies to [49] and [50] TODO Parameter-entity replacement text must be properly nested with parenthesized groups. That is to say, if either of the opening or closing parentheses in a choice, seq, or Mixed construct is contained in the replacement text for a parameter entity, both must be contained in the same replacement text. For interoperability, if a parameter-entity reference appears in a choice, seq, or Mixed construct, its replacement text should not be empty, and neither the first nor last non-blank character of the replacement text should be a connector (| or ,).</info>
      <return type='xmlElementContentPtr' info='the tree of xmlElementContentPtr describing the element hierarchy.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='inputchk' type='int' info='the input used for the current entity, needed for boundary checks'/>
    </function>
    <function name='xmlParseElementContentDecl' file='parserInternals' module='parser'>
      <info>parse the declaration for an Element content either Mixed or Children, the cases EMPTY and ANY are handled directly in xmlParseElementDecl  [46] contentspec ::= &apos;EMPTY&apos; | &apos;ANY&apos; | Mixed | children</info>
      <return type='int' info='the type of element content XML_ELEMENT_TYPE_xxx'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='name' type='const xmlChar *' info='the name of the element being defined.'/>
      <arg name='result' type='xmlElementContentPtr *' info='the Element Content pointer will be stored here if any'/>
    </function>
    <function name='xmlParseElementDecl' file='parserInternals' module='parser'>
      <info>parse an Element declaration.  [45] elementdecl ::= &apos;&lt;!ELEMENT&apos; S Name S contentspec S? &apos;&gt;&apos;  [ VC: Unique Element Type Declaration ] No element type may be declared more than once</info>
      <return type='int' info='the type of the element, or -1 in case of error'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseElementMixedContentDecl' file='parserInternals' module='parser'>
      <info>parse the declaration for a Mixed Element content The leading &apos;(&apos; and spaces have been skipped in xmlParseElementContentDecl  [51] Mixed ::= &apos;(&apos; S? &apos;#PCDATA&apos; (S? &apos;|&apos; S? Name)* S? &apos;)*&apos; | &apos;(&apos; S? &apos;#PCDATA&apos; S? &apos;)&apos;  [ VC: Proper Group/PE Nesting ] applies to [51] too (see [49])  [ VC: No Duplicate Types ] The same name must not appear more than once in a single mixed-content declaration.</info>
      <return type='xmlElementContentPtr' info='the list of the xmlElementContentPtr describing the element choices'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='inputchk' type='int' info='the input used for the current entity, needed for boundary checks'/>
    </function>
    <function name='xmlParseEncName' file='parserInternals' module='parser'>
      <info>parse the XML encoding name  [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | &apos;-&apos;)*</info>
      <return type='xmlChar *' info='the encoding name value or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseEncodingDecl' file='parserInternals' module='parser'>
      <info>parse the XML encoding declaration  [80] EncodingDecl ::= S &apos;encoding&apos; Eq (&apos;&quot;&apos; EncName &apos;&quot;&apos; |  &quot;&apos;&quot; EncName &quot;&apos;&quot;)  this setups the conversion filters.</info>
      <return type='const xmlChar *' info='the encoding value or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseEndTag' file='parserInternals' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an end of tag  [42] ETag ::= &apos;&lt;/&apos; Name S? &apos;&gt;&apos;  With namespace  [NS 9] ETag ::= &apos;&lt;/&apos; QName S? &apos;&gt;&apos;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseEntity' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML external entity out of context and build a tree.  [78] extParsedEnt ::= TextDecl? content  This correspond to a &quot;Well Balanced&quot; chunk</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlParseEntityDecl' file='parserInternals' module='parser'>
      <info>parse &lt;!ENTITY declarations  [70] EntityDecl ::= GEDecl | PEDecl  [71] GEDecl ::= &apos;&lt;!ENTITY&apos; S Name S EntityDef S? &apos;&gt;&apos;  [72] PEDecl ::= &apos;&lt;!ENTITY&apos; S &apos;%&apos; S Name S PEDef S? &apos;&gt;&apos;  [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)  [74] PEDef ::= EntityValue | ExternalID  [76] NDataDecl ::= S &apos;NDATA&apos; S Name  [ VC: Notation Declared ] The Name must match the declared name of a notation.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseEntityRef' file='parserInternals' module='parser'>
      <info>parse ENTITY references declarations  [68] EntityRef ::= &apos;&amp;&apos; Name &apos;;&apos;  [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with &quot;standalone=&apos;yes&apos;&quot;, the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot.  The declaration of a parameter entity must precede any reference to it.  Similarly, the declaration of a general entity must precede any reference to it which appears in a default value in an attribute-list declaration. Note that if entities are declared in the external subset or in external parameter entities, a non-validating processor is not obligated to read and process their declarations; for such documents, the rule that an entity must be declared is a well-formedness constraint only if standalone=&apos;yes&apos;.  [ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found, or NULL otherwise.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseEntityValue' file='parserInternals' module='parser'>
      <info>parse a value for ENTITY declarations  [9] EntityValue ::= &apos;&quot;&apos; ([^%&amp;&quot;] | PEReference | Reference)* &apos;&quot;&apos; | &quot;&apos;&quot; ([^%&amp;&apos;] | PEReference | Reference)* &quot;&apos;&quot;</info>
      <return type='xmlChar *' info='the EntityValue parsed with reference substituted or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='orig' type='xmlChar **' info='if non-NULL store a copy of the original entity value'/>
    </function>
    <function name='xmlParseEnumeratedType' file='parserInternals' module='parser'>
      <info>parse an Enumerated attribute type.  [57] EnumeratedType ::= NotationType | Enumeration  [58] NotationType ::= &apos;NOTATION&apos; S &apos;(&apos; S? Name (S? &apos;|&apos; S? Name)* S? &apos;)&apos;</info>
      <return type='int' info='XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='tree' type='xmlEnumerationPtr *' info='the enumeration tree built while parsing'/>
    </function>
    <function name='xmlParseEnumerationType' file='parserInternals' module='parser'>
      <info>parse an Enumeration attribute type.  [59] Enumeration ::= &apos;(&apos; S? Nmtoken (S? &apos;|&apos; S? Nmtoken)* S? &apos;)&apos;  [ VC: Enumeration ] Values of this type must match one of the Nmtoken tokens in the declaration</info>
      <return type='xmlEnumerationPtr' info='the enumeration attribute tree built while parsing'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseExtParsedEnt' file='parser' module='parser'>
      <info>parse a general parsed entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt.  [78] extParsedEnt ::= TextDecl? content</info>
      <return type='int' info='0, -1 in case of error. the parser context is augmented as a result of the parsing.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseExternalEntity' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Parse an external general entity An external general parsed entity is well-formed if it matches the production labeled extParsedEnt.  [78] extParsedEnt ::= TextDecl? content</info>
      <return type='int' info='0 if the entity is well formed, -1 in case of args problem and the parser error code otherwise'/>
      <arg name='doc' type='xmlDocPtr' info='the document the chunk pertains to'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler bloc (possibly NULL)'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks (possibly NULL)'/>
      <arg name='depth' type='int' info='Used for loop detection, use 0'/>
      <arg name='URL' type='const xmlChar *' info='the URL for the entity to load'/>
      <arg name='ID' type='const xmlChar *' info='the System ID for the entity to load'/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
    </function>
    <function name='xmlParseExternalID' file='parserInternals' module='parser'>
      <info>Parse an External ID or a Public ID  NOTE: Productions [75] and [83] interact badly since [75] can generate &apos;PUBLIC&apos; S PubidLiteral S SystemLiteral  [75] ExternalID ::= &apos;SYSTEM&apos; S SystemLiteral | &apos;PUBLIC&apos; S PubidLiteral S SystemLiteral  [83] PublicID ::= &apos;PUBLIC&apos; S PubidLiteral</info>
      <return type='xmlChar *' info='the function returns SystemLiteral and in the second case publicID receives PubidLiteral, is strict is off it is possible to return NULL and have publicID set.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='publicID' type='xmlChar **' info='a xmlChar** receiving PubidLiteral'/>
      <arg name='strict' type='int' info='indicate whether we should restrict parsing to only production [75], see NOTE below'/>
    </function>
    <function name='xmlParseExternalSubset' file='parserInternals' module='parser'>
      <info>parse Markup declarations from an external subset  [30] extSubset ::= textDecl? extSubsetDecl  [31] extSubsetDecl ::= (markupdecl | conditionalSect | PEReference | S) *</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external identifier'/>
      <arg name='SystemID' type='const xmlChar *' info='the system identifier (or URL)'/>
    </function>
    <function name='xmlParseFile' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time.</info>
      <return type='xmlDocPtr' info='the resulting document tree if the file was wellformed, NULL otherwise.'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlParseInNodeContext' file='parser' module='parser'>
      <info>Parse a well-balanced chunk of an XML document within the context (DTD, namespaces, etc ...) of the given node.  The allowed sequence for the data is a Well Balanced Chunk defined by the content production in the XML grammar:  [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*</info>
      <return type='xmlParserErrors' info='XML_ERR_OK if the chunk is well balanced, and the parser error code otherwise'/>
      <arg name='node' type='xmlNodePtr' info='the context node'/>
      <arg name='data' type='const char *' info='the input string'/>
      <arg name='datalen' type='int' info='the input string length in bytes'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
      <arg name='lst' type='xmlNodePtr *' info='the return value for the set of parsed nodes'/>
    </function>
    <function name='xmlParseMarkupDecl' file='parserInternals' module='parser'>
      <info>parse Markup declarations  [29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment  [ VC: Proper Declaration/PE Nesting ] Parameter-entity replacement text must be properly nested with markup declarations. That is to say, if either the first character or the last character of a markup declaration (markupdecl above) is contained in the replacement text for a parameter-entity reference, both must be contained in the same replacement text.  [ WFC: PEs in Internal Subset ] In the internal DTD subset, parameter-entity references can occur only where markup declarations can occur, not within markup declarations. (This does not apply to references that occur in external parameter entities or to the external subset.)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseMemory' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory block and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='buffer' type='const char *' info='an pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='xmlParseMisc' file='parserInternals' module='parser'>
      <info>parse an XML Misc* optional field.  [27] Misc ::= Comment | PI |  S</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseName' file='parserInternals' module='parser'>
      <info>parse an XML name.  [4] NameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | &apos;:&apos; | CombiningChar | Extender  [5] Name ::= (Letter | &apos;_&apos; | &apos;:&apos;) (NameChar)*  [6] Names ::= Name (#x20 Name)*</info>
      <return type='const xmlChar *' info='the Name parsed or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseNamespace' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>xmlParseNamespace: parse specific PI &apos;&lt;?namespace ...&apos; constructs.  This is what the older xml-name Working Draft specified, a bunch of other stuff may still rely on it, so support is still here as if it was declared on the root of the Tree:-(  TODO: remove from library  To be removed at next drop of binary compatibility</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseNmtoken' file='parserInternals' module='parser'>
      <info>parse an XML Nmtoken.  [7] Nmtoken ::= (NameChar)+  [8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*</info>
      <return type='xmlChar *' info='the Nmtoken parsed or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseNotationDecl' file='parserInternals' module='parser'>
      <info>parse a notation declaration  [82] NotationDecl ::= &apos;&lt;!NOTATION&apos; S Name S (ExternalID |  PublicID) S? &apos;&gt;&apos;  Hence there is actually 3 choices: &apos;PUBLIC&apos; S PubidLiteral &apos;PUBLIC&apos; S PubidLiteral S SystemLiteral and &apos;SYSTEM&apos; S SystemLiteral  See the NOTE on xmlParseExternalID().</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseNotationType' file='parserInternals' module='parser'>
      <info>parse an Notation attribute type.  Note: the leading &apos;NOTATION&apos; S part has already being parsed...  [58] NotationType ::= &apos;NOTATION&apos; S &apos;(&apos; S? Name (S? &apos;|&apos; S? Name)* S? &apos;)&apos;  [ VC: Notation Attributes ] Values of this type must match one of the notation names included in the declaration; all notation names in the declaration must be declared.</info>
      <return type='xmlEnumerationPtr' info='the notation attribute tree built while parsing'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParsePEReference' file='parserInternals' module='parser'>
      <info>parse PEReference declarations The entity content is handled directly by pushing it&apos;s content as a new input stream.  [69] PEReference ::= &apos;%&apos; Name &apos;;&apos;  [ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly.  [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with &quot;standalone=&apos;yes&apos;&quot;, ...  ... The declaration of a parameter entity must precede any reference to it...  [ VC: Entity Declared ] In a document with an external subset or external parameter entities with &quot;standalone=&apos;no&apos;&quot;, ...  ... The declaration of a parameter entity must precede any reference to it...  [ WFC: In DTD ] Parameter-entity references may only appear in the DTD. NOTE: misleading but this is handled.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParsePI' file='parserInternals' module='parser'>
      <info>parse an XML Processing Instruction.  [16] PI ::= &apos;&lt;?&apos; PITarget (S (Char* - (Char* &apos;?&gt;&apos; Char*)))? &apos;?&gt;&apos;  The processing is transfered to SAX once parsed.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParsePITarget' file='parserInternals' module='parser'>
      <info>parse the name of a PI  [17] PITarget ::= Name - ((&apos;X&apos; | &apos;x&apos;) (&apos;M&apos; | &apos;m&apos;) (&apos;L&apos; | &apos;l&apos;))</info>
      <return type='const xmlChar *' info='the PITarget name or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParsePubidLiteral' file='parserInternals' module='parser'>
      <info>parse an XML public literal  [12] PubidLiteral ::= &apos;&quot;&apos; PubidChar* &apos;&quot;&apos; | &quot;&apos;&quot; (PubidChar - &quot;&apos;&quot;)* &quot;&apos;&quot;</info>
      <return type='xmlChar *' info='the PubidLiteral parsed or NULL.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseQuotedString' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Parse and return a string between quotes or doublequotes  TODO: Deprecated, to  be removed at next drop of binary compatibility</info>
      <return type='xmlChar *' info='the string parser or NULL.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseReference' file='parserInternals' module='parser'>
      <info>parse and handle entity references in content, depending on the SAX interface, this may end-up in a call to character() if this is a CharRef, a predefined entity, if there is no reference() callback. or if the parser was asked to switch to that mode.  [67] Reference ::= EntityRef | CharRef</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseSDDecl' file='parserInternals' module='parser'>
      <info>parse the XML standalone declaration  [32] SDDecl ::= S &apos;standalone&apos; Eq ((&quot;&apos;&quot; (&apos;yes&apos; | &apos;no&apos;) &quot;&apos;&quot;) | (&apos;&quot;&apos; (&apos;yes&apos; | &apos;no&apos;)&apos;&quot;&apos;))  [ VC: Standalone Document Declaration ] TODO The standalone document declaration must have the value &quot;no&quot; if any external markup declarations contain declarations of: - attributes with default values, if elements to which these attributes apply appear in the document without specifications of values for these attributes, or - entities (other than amp, lt, gt, apos, quot), if references to those entities appear in the document, or - attributes with values subject to normalization, where the attribute appears in the document with a value which will change as a result of normalization, or - element types with element content, if white space occurs directly within any instance of those types.</info>
      <return type='int' info='1 if standalone=&quot;yes&quot; 0 if standalone=&quot;no&quot; -2 if standalone attribute is missing or invalid (A standalone value of -2 means that the XML declaration was found, but no value was specified for the standalone attribute).'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseStartTag' file='parserInternals' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse a start of tag either for rule element or EmptyElement. In both case we don&apos;t parse the tag closing chars.  [40] STag ::= &apos;&lt;&apos; Name (S Attribute)* S? &apos;&gt;&apos;  [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag.  [44] EmptyElemTag ::= &apos;&lt;&apos; Name (S Attribute)* S? &apos;/&gt;&apos;  [ WFC: Unique Att Spec ] No attribute name may appear more than once in the same start-tag or empty-element tag.  With namespace:  [NS 8] STag ::= &apos;&lt;&apos; QName (S Attribute)* S? &apos;&gt;&apos;  [NS 10] EmptyElement ::= &apos;&lt;&apos; QName (S Attribute)* S? &apos;/&gt;&apos;</info>
      <return type='const xmlChar *' info='the element name parsed'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseSystemLiteral' file='parserInternals' module='parser'>
      <info>parse an XML Literal  [11] SystemLiteral ::= (&apos;&quot;&apos; [^&quot;]* &apos;&quot;&apos;) | (&quot;&apos;&quot; [^&apos;]* &quot;&apos;&quot;)</info>
      <return type='xmlChar *' info='the SystemLiteral parsed or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseTextDecl' file='parserInternals' module='parser'>
      <info>parse an XML declaration header for external entities  [77] TextDecl ::= &apos;&lt;?xml&apos; VersionInfo? EncodingDecl S? &apos;?&gt;&apos;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseURI' file='uri' module='uri'>
      <info>Parse an URI based on RFC 3986  URI-reference = [ absoluteURI | relativeURI ] [ &quot;#&quot; fragment ]</info>
      <return type='xmlURIPtr' info='a newly built xmlURIPtr or NULL in case of error'/>
      <arg name='str' type='const char *' info='the URI string to analyze'/>
    </function>
    <function name='xmlParseURIRaw' file='uri' module='uri'>
      <info>Parse an URI but allows to keep intact the original fragments.  URI-reference = URI / relative-ref</info>
      <return type='xmlURIPtr' info='a newly built xmlURIPtr or NULL in case of error'/>
      <arg name='str' type='const char *' info='the URI string to analyze'/>
      <arg name='raw' type='int' info='if 1 unescaping of URI pieces are disabled'/>
    </function>
    <function name='xmlParseURIReference' file='uri' module='uri'>
      <info>Parse an URI reference string based on RFC 3986 and fills in the appropriate fields of the @uri structure  URI-reference = URI / relative-ref</info>
      <return type='int' info='0 or the error code'/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an URI structure'/>
      <arg name='str' type='const char *' info='the string to analyze'/>
    </function>
    <function name='xmlParseVersionInfo' file='parserInternals' module='parser'>
      <info>parse the XML version.  [24] VersionInfo ::= S &apos;version&apos; Eq (&apos; VersionNum &apos; | &quot; VersionNum &quot;)  [25] Eq ::= S? &apos;=&apos; S?</info>
      <return type='xmlChar *' info='the version string, e.g. &quot;1.0&quot;'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseVersionNum' file='parserInternals' module='parser'>
      <info>parse the XML version value.  [26] VersionNum ::= &apos;1.&apos; [0-9]+  In practice allow [0-9].[0-9]+ at that level</info>
      <return type='xmlChar *' info='the string giving the XML version number, or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParseXMLDecl' file='parserInternals' module='parser'>
      <info>parse an XML declaration header  [23] XMLDecl ::= &apos;&lt;?xml&apos; VersionInfo EncodingDecl? SDDecl? S? &apos;?&gt;&apos;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlParserAddNodeInfo' file='parser' module='parserInternals'>
      <info>Insert node info record into the sorted sequence</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='info' type='const xmlParserNodeInfoPtr' info='a node info sequence pointer'/>
    </function>
    <function name='xmlParserError' file='xmlerror' module='error'>
      <info>Display and format an error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <function name='xmlParserFindNodeInfo' file='parser' module='parserInternals'>
      <info>Find the parser node info struct for a given node</info>
      <return type='const xmlParserNodeInfo *' info='an xmlParserNodeInfo block pointer or NULL'/>
      <arg name='ctx' type='const xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='node' type='const xmlNodePtr' info='an XML node within the tree'/>
    </function>
    <function name='xmlParserFindNodeInfoIndex' file='parser' module='parserInternals'>
      <info>xmlParserFindNodeInfoIndex : Find the index that the info record for the given node is or should be at in a sorted sequence</info>
      <return type='unsigned long' info='a long indicating the position of the record'/>
      <arg name='seq' type='const xmlParserNodeInfoSeqPtr' info='a node info sequence pointer'/>
      <arg name='node' type='const xmlNodePtr' info='an XML node pointer'/>
    </function>
    <function name='xmlParserGetDirectory' file='xmlIO' module='xmlIO'>
      <info>lookup the directory for that file</info>
      <return type='char *' info='a new allocated string containing the directory, or NULL.'/>
      <arg name='filename' type='const char *' info='the path to a file'/>
    </function>
    <function name='xmlParserHandlePEReference' file='parserInternals' module='parser'>
      <info>[69] PEReference ::= &apos;%&apos; Name &apos;;&apos;  [ WFC: No Recursion ] A parsed entity must not contain a recursive reference to itself, either directly or indirectly.  [ WFC: Entity Declared ] In a document without any DTD, a document with only an internal DTD subset which contains no parameter entity references, or a document with &quot;standalone=&apos;yes&apos;&quot;, ...  ... The declaration of a parameter entity must precede any reference to it...  [ VC: Entity Declared ] In a document with an external subset or external parameter entities with &quot;standalone=&apos;no&apos;&quot;, ...  ... The declaration of a parameter entity must precede any reference to it...  [ WFC: In DTD ] Parameter-entity references may only appear in the DTD. NOTE: misleading but this is handled.  A PEReference may have been detected in the current input stream the handling is done accordingly to http://www.w3.org/TR/REC-xml#entproc i.e. - Included in literal in entity values - Included as Parameter Entity reference within DTDs</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
    </function>
    <function name='xmlParserHandleReference' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>TODO: Remove, now deprecated ... the test is done directly in the content parsing routines.  [67] Reference ::= EntityRef | CharRef  [68] EntityRef ::= &apos;&amp;&apos; Name &apos;;&apos;  [ WFC: Entity Declared ] the Name given in the entity reference must match that in an entity declaration, except that well-formed documents need not declare any of the following entities: amp, lt, gt, apos, quot.  [ WFC: Parsed Entity ] An entity reference must not contain the name of an unparsed entity  [66] CharRef ::= &apos;&amp;#&apos; [0-9]+ &apos;;&apos; | &apos;&amp;#x&apos; [0-9a-fA-F]+ &apos;;&apos;  A PEReference may have been detected in the current input stream the handling is done accordingly to http://www.w3.org/TR/REC-xml#entproc</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
    </function>
    <function name='xmlParserInputBufferCreateFd' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a file descriptor</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='fd' type='int' info='a file descriptor number'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferCreateFile' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a FILE * buffered C I/O</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='file' type='FILE *' info='a FILE*'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferCreateFilename' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing of a file If filename is &quot;-&apos; then we use stdin as the input. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. Do an encoding check if enc == XML_CHAR_ENCODING_NONE</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='URI' type='const char *' info='a C string containing the URI or filename'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferCreateFilenameDefault' file='globals' module='xmlIO'>
      <info>Registers a callback for URI input file handling</info>
      <return type='xmlParserInputBufferCreateFilenameFunc' info='the old value of the registration function'/>
      <arg name='func' type='xmlParserInputBufferCreateFilenameFunc' info='function pointer to the new ParserInputBufferCreateFilenameFunc'/>
    </function>
    <functype name='xmlParserInputBufferCreateFilenameFunc' file='globals' module='globals'>
      <info>Signature for the function doing the lookup for a suitable input method corresponding to an URI.</info>
      <return type='xmlParserInputBufferPtr' info='the new xmlParserInputBufferPtr in case of success or NULL if no method was found.'/>
      <arg name='URI' type='const char *' info='the URI to read from'/>
      <arg name='enc' type='xmlCharEncoding' info='the requested source encoding'/>
    </functype>
    <function name='xmlParserInputBufferCreateIO' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from an I/O handler</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferCreateMem' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from a memory area.</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='mem' type='const char *' info='the memory input'/>
      <arg name='size' type='int' info='the length of the memory block'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferCreateStatic' file='xmlIO' module='xmlIO'>
      <info>Create a buffered parser input for the progressive parsing for the input from an immutable memory area. This will not copy the memory area to the buffer, but the memory is expected to be available until the end of the parsing, this is useful for example when using mmap&apos;ed file.</info>
      <return type='xmlParserInputBufferPtr' info='the new parser input or NULL'/>
      <arg name='mem' type='const char *' info='the memory input'/>
      <arg name='size' type='int' info='the length of the memory block'/>
      <arg name='enc' type='xmlCharEncoding' info='the charset encoding if known'/>
    </function>
    <function name='xmlParserInputBufferGrow' file='xmlIO' module='xmlIO'>
      <info>Grow up the content of the input buffer, the old data are preserved This routine handle the I18N transcoding to internal UTF-8 This routine is used when operating the parser in normal (pull) mode  TODO: one should be able to remove one extra copy by copying directly onto in-&gt;buffer or in-&gt;raw</info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error.'/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input'/>
      <arg name='len' type='int' info='indicative value of the amount of chars to read'/>
    </function>
    <function name='xmlParserInputBufferPush' file='xmlIO' module='xmlIO'>
      <info>Push the content of the arry in the input buffer This routine handle the I18N transcoding to internal UTF-8 This is used when operating the parser in progressive (push) mode.</info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error.'/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input'/>
      <arg name='len' type='int' info='the size in bytes of the array.'/>
      <arg name='buf' type='const char *' info='an char array'/>
    </function>
    <function name='xmlParserInputBufferRead' file='xmlIO' module='xmlIO'>
      <info>Refresh the content of the input buffer, the old data are considered consumed This routine handle the I18N transcoding to internal UTF-8</info>
      <return type='int' info='the number of chars read and stored in the buffer, or -1 in case of error.'/>
      <arg name='in' type='xmlParserInputBufferPtr' info='a buffered parser input'/>
      <arg name='len' type='int' info='indicative value of the amount of chars to read'/>
    </function>
    <functype name='xmlParserInputDeallocate' file='parser' module='parser'>
      <info>Callback for freeing some parser input allocations.</info>
      <return type='void'/>
      <arg name='str' type='xmlChar *' info='the string to deallocate'/>
    </functype>
    <function name='xmlParserInputGrow' file='parser' module='parserInternals'>
      <info>This function increase the input for the parser. It tries to preserve pointers to the input buffer, and keep already read data</info>
      <return type='int' info='the amount of char read, or -1 in case of error, 0 indicate the end of this entity'/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input'/>
      <arg name='len' type='int' info='an indicative size for the lookahead'/>
    </function>
    <function name='xmlParserInputRead' file='parser' module='parserInternals'>
      <info>This function was internal and is deprecated.</info>
      <return type='int' info='-1 as this is an error to use it.'/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input'/>
      <arg name='len' type='int' info='an indicative size for the lookahead'/>
    </function>
    <function name='xmlParserInputShrink' file='parserInternals' module='parserInternals'>
      <info>This function removes used input for the parser.</info>
      <return type='void'/>
      <arg name='in' type='xmlParserInputPtr' info='an XML parser input'/>
    </function>
    <function name='xmlParserPrintFileContext' file='xmlerror' module='error'>
      <info>Displays current context within the input content for error tracking</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr input'/>
    </function>
    <function name='xmlParserPrintFileInfo' file='xmlerror' module='error'>
      <info>Displays the associated file and line informations for the current input</info>
      <return type='void'/>
      <arg name='input' type='xmlParserInputPtr' info='an xmlParserInputPtr input'/>
    </function>
    <function name='xmlParserValidityError' file='xmlerror' module='error'>
      <info>Display and format an validity error messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <function name='xmlParserValidityWarning' file='xmlerror' module='error'>
      <info>Display and format a validity warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <function name='xmlParserWarning' file='xmlerror' module='error'>
      <info>Display and format a warning messages, gives file, line, position and extra parameters.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='an XML parser context'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <function name='xmlPathToURI' file='uri' module='uri'>
      <info>Constructs an URI expressing the existing path</info>
      <return type='xmlChar *' info='a new URI, or a duplicate of the path parameter if the construction fails. The caller is responsible for freeing the memory occupied by the returned string. If there is insufficient memory available, or the argument is NULL, the function returns NULL.'/>
      <arg name='path' type='const xmlChar *' info='the resource locator in a filesystem notation'/>
    </function>
    <function name='xmlPatternFromRoot' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Check if the pattern must be looked at from the root.</info>
      <return type='int' info='1 if true, 0 if false and -1 in case of error'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
    </function>
    <function name='xmlPatternGetStreamCtxt' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Get a streaming context for that pattern Use xmlFreeStreamCtxt to free the context.</info>
      <return type='xmlStreamCtxtPtr' info='a pointer to the context or NULL in case of failure'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
    </function>
    <function name='xmlPatternMatch' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Test whether the node matches the pattern</info>
      <return type='int' info='1 if it matches, 0 if it doesn&apos;t and -1 in case of failure'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlPatternMaxDepth' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Check the maximum depth reachable by a pattern</info>
      <return type='int' info='-2 if no limit (using //), otherwise the depth, and -1 in case of error'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
    </function>
    <function name='xmlPatternMinDepth' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Check the minimum depth reachable by a pattern, 0 mean the / or . are part of the set.</info>
      <return type='int' info='-1 in case of error otherwise the depth,'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
    </function>
    <function name='xmlPatternStreamable' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Check if the pattern is streamable i.e. xmlPatternGetStreamCtxt() should work.</info>
      <return type='int' info='1 if streamable, 0 if not and -1 in case of error.'/>
      <arg name='comp' type='xmlPatternPtr' info='the precompiled pattern'/>
    </function>
    <function name='xmlPatterncompile' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Compile a pattern.</info>
      <return type='xmlPatternPtr' info='the compiled form of the pattern or NULL in case of error'/>
      <arg name='pattern' type='const xmlChar *' info='the pattern to compile'/>
      <arg name='dict' type='xmlDict *' info='an optional dictionary for interned strings'/>
      <arg name='flags' type='int' info='compilation flags, see xmlPatternFlags'/>
      <arg name='namespaces' type='const xmlChar **' info='the prefix definitions, array of [URI, prefix] or NULL'/>
    </function>
    <function name='xmlPedanticParserDefault' file='parser' module='parserInternals'>
      <info>Set and return the previous value for enabling pedantic warnings.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution.'/>
      <arg name='val' type='int' info='int 0 or 1'/>
    </function>
    <function name='xmlPopInput' file='parserInternals' module='parser'>
      <info>xmlPopInput: the current input pointed by ctxt-&gt;input came to an end pop it and return the next char.</info>
      <return type='xmlChar' info='the current xmlChar in the parser context'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlPopInputCallbacks' file='xmlIO' module='xmlIO'>
      <info>Clear the top input callback from the input stack. this includes the compiled-in I/O.</info>
      <return type='int' info='the number of input callback registered or -1 in case of error.'/>
    </function>
    <function name='xmlPreviousElementSibling' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>Finds the first closest previous sibling of the node which is an element node. Note the handling of entities references is different than in the W3C DOM element traversal spec since we don&apos;t have back reference from entities content to entities references.</info>
      <return type='xmlNodePtr' info='the previous element sibling or NULL if not available'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
    </function>
    <function name='xmlPrintURI' file='uri' module='uri'>
      <info>Prints the URI in the stream @stream.</info>
      <return type='void'/>
      <arg name='stream' type='FILE *' info='a FILE* for the output'/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI'/>
    </function>
    <function name='xmlPushInput' file='parserInternals' module='parser'>
      <info>xmlPushInput: switch to a new input stream which is stacked on top of the previous one(s).</info>
      <return type='int' info='-1 in case of error or the index in the input stack'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='input' type='xmlParserInputPtr' info='an XML parser input fragment (entity, XML fragment ...).'/>
    </function>
    <function name='xmlRMutexLock' file='threads' module='threads'>
      <info>xmlRMutexLock() is used to lock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr' info='the reentrant mutex'/>
    </function>
    <function name='xmlRMutexUnlock' file='threads' module='threads'>
      <info>xmlRMutexUnlock() is used to unlock a libxml2 token_r.</info>
      <return type='void'/>
      <arg name='tok' type='xmlRMutexPtr' info='the reentrant mutex'/>
    </function>
    <function name='xmlReadDoc' file='parser' module='parser'>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReadFd' file='parser' module='parser'>
      <info>parse an XML from a file descriptor and build a tree. NOTE that the file descriptor will not be closed when the reader is closed or reset.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReadFile' file='parser' module='parser'>
      <info>parse an XML file from the filesystem or the network.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReadIO' file='parser' module='parser'>
      <info>parse an XML document from I/O functions and source and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReadMemory' file='parser' module='parser'>
      <info>parse an XML in-memory document and build a tree.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderForDoc' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmltextReader for an XML in-memory document. The parsing flags @options are a combination of xmlParserOption.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderForFd' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmltextReader for an XML from a file descriptor. The parsing flags @options are a combination of xmlParserOption. NOTE that the file descriptor will not be closed when the reader is closed or reset.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderForFile' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>parse an XML file from the filesystem or the network. The parsing flags @options are a combination of xmlParserOption.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderForIO' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmltextReader for an XML document from I/O functions and source. The parsing flags @options are a combination of xmlParserOption.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderForMemory' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmltextReader for an XML in-memory document. The parsing flags @options are a combination of xmlParserOption.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewDoc' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an xmltextReader to parse an XML in-memory document. The parsing flags @options are a combination of xmlParserOption. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to a zero terminated string'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewFd' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an xmltextReader to parse an XML from a file descriptor. NOTE that the file descriptor will not be closed when the reader is closed or reset. The parsing flags @options are a combination of xmlParserOption. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='fd' type='int' info='an open file descriptor'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewFile' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>parse an XML file from the filesystem or the network. The parsing flags @options are a combination of xmlParserOption. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='filename' type='const char *' info='a file or URL'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewIO' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an xmltextReader to parse an XML document from I/O functions and source. The parsing flags @options are a combination of xmlParserOption. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='ioread' type='xmlInputReadCallback' info='an I/O read function'/>
      <arg name='ioclose' type='xmlInputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewMemory' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an xmltextReader to parse an XML in-memory document. The parsing flags @options are a combination of xmlParserOption. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlReaderNewWalker' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an xmltextReader to parse a preparsed XML document. This reuses the existing @reader xmlTextReader.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='doc' type='xmlDocPtr' info='a preparsed document'/>
    </function>
    <function name='xmlReaderWalker' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Create an xmltextReader for a preparsed document.</info>
      <return type='xmlTextReaderPtr' info='the new reader or NULL in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='a preparsed document'/>
    </function>
    <functype name='xmlReallocFunc' file='xmlmemory' module='xmlmemory'>
      <info>Signature for a realloc() implementation.</info>
      <return type='void *' info='a pointer to the newly reallocated block or NULL in case of error.'/>
      <arg name='mem' type='void *' info='an already allocated block of memory'/>
      <arg name='size' type='size_t' info='the new size requested in bytes'/>
    </functype>
    <function name='xmlReallocLoc' file='xmlmemory' module='xmlmemory'>
      <info>a realloc() equivalent, with logging of the allocation info.</info>
      <return type='void *' info='a pointer to the allocated area or NULL in case of lack of memory.'/>
      <arg name='ptr' type='void *' info='the initial memory block pointer'/>
      <arg name='size' type='size_t' info='an int specifying the size in byte to allocate.'/>
      <arg name='file' type='const char *' info='the file name or NULL'/>
      <arg name='line' type='int' info='the line number'/>
    </function>
    <function name='xmlReconciliateNs' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED)</cond>
      <info>This function checks that all the namespaces declared within the given tree are properly declared. This is needed for example after Copy or Cut and then paste operations. The subtree may still hold pointers to namespace declarations outside the subtree or invalid/masked. As much as possible the function try to reuse the existing namespaces found in the new environment. If not possible the new namespaces are redeclared on @tree at the top of the given subtree.</info>
      <return type='int' info='the number of namespace declarations created or -1 in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='tree' type='xmlNodePtr' info='a node defining the subtree to reconciliate'/>
    </function>
    <function name='xmlRecoverDoc' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree. In the case the document is not Well Formed, a attempt to build a tree is tried anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree or NULL in case of failure'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to an array of xmlChar'/>
    </function>
    <function name='xmlRecoverFile' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. In the case the document is not Well Formed, it attempts to build a tree anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree or NULL in case of failure'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlRecoverMemory' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory block and build a tree. In the case the document is not Well Formed, an attempt to build a tree is tried anyway</info>
      <return type='xmlDocPtr' info='the resulting document tree or NULL in case of error'/>
      <arg name='buffer' type='const char *' info='an pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <functype name='xmlRegExecCallbacks' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Callback function when doing a transition in the automata</info>
      <return type='void'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='the regular expression context'/>
      <arg name='token' type='const xmlChar *' info='the current token string'/>
      <arg name='transdata' type='void *' info='transition data'/>
      <arg name='inputdata' type='void *' info='input data'/>
    </functype>
    <function name='xmlRegExecErrInfo' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Extract error informations from the regexp execution, the parameter @string will be updated with the value pushed and not accepted, the parameter @values must point to an array of @nbval string pointers on return nbval will contain the number of possible strings in that state and the @values array will be updated with them. The string values</info>
      <return type='int' info='will be freed with the @exec context and don&apos;t need to be deallocated.  Returns: 0 in case of success or -1 in case of error.'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regexp execution context generating an error'/>
      <arg name='string' type='const xmlChar **' info='return value for the error string'/>
      <arg name='nbval' type='int *' info='pointer to the number of accepted values IN/OUT'/>
      <arg name='nbneg' type='int *' info='return number of negative transitions'/>
      <arg name='values' type='xmlChar **' info='pointer to the array of acceptable values'/>
      <arg name='terminal' type='int *' info='return value if this was a terminal state'/>
    </function>
    <function name='xmlRegExecNextValues' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Extract informations from the regexp execution, the parameter @values must point to an array of @nbval string pointers on return nbval will contain the number of possible strings in that state and the @values array will be updated with them. The string values</info>
      <return type='int' info='will be freed with the @exec context and don&apos;t need to be deallocated.  Returns: 0 in case of success or -1 in case of error.'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regexp execution context'/>
      <arg name='nbval' type='int *' info='pointer to the number of accepted values IN/OUT'/>
      <arg name='nbneg' type='int *' info='return number of negative transitions'/>
      <arg name='values' type='xmlChar **' info='pointer to the array of acceptable values'/>
      <arg name='terminal' type='int *' info='return value if this was a terminal state'/>
    </function>
    <function name='xmlRegExecPushString' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Push one input token in the execution context</info>
      <return type='int' info='1 if the regexp reached a final state, 0 if non-final, and a negative value in case of error.'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regexp execution context or NULL to indicate the end'/>
      <arg name='value' type='const xmlChar *' info='a string token input'/>
      <arg name='data' type='void *' info='data associated to the token to reuse in callbacks'/>
    </function>
    <function name='xmlRegExecPushString2' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Push one input token in the execution context</info>
      <return type='int' info='1 if the regexp reached a final state, 0 if non-final, and a negative value in case of error.'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regexp execution context or NULL to indicate the end'/>
      <arg name='value' type='const xmlChar *' info='the first string token input'/>
      <arg name='value2' type='const xmlChar *' info='the second string token input'/>
      <arg name='data' type='void *' info='data associated to the token to reuse in callbacks'/>
    </function>
    <function name='xmlRegFreeExecCtxt' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Free the structures associated to a regular expression evaulation context.</info>
      <return type='void'/>
      <arg name='exec' type='xmlRegExecCtxtPtr' info='a regular expression evaulation context'/>
    </function>
    <function name='xmlRegFreeRegexp' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Free a regexp</info>
      <return type='void'/>
      <arg name='regexp' type='xmlRegexpPtr' info='the regexp'/>
    </function>
    <function name='xmlRegNewExecCtxt' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Build a context used for progressive evaluation of a regexp.</info>
      <return type='xmlRegExecCtxtPtr' info='the new context'/>
      <arg name='comp' type='xmlRegexpPtr' info='a precompiled regular expression'/>
      <arg name='callback' type='xmlRegExecCallbacks' info='a callback function used for handling progresses in the automata matching phase'/>
      <arg name='data' type='void *' info='the context data associated to the callback in this context'/>
    </function>
    <function name='xmlRegexpCompile' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Parses a regular expression conforming to XML Schemas Part 2 Datatype Appendix F and builds an automata suitable for testing strings against that regular expression</info>
      <return type='xmlRegexpPtr' info='the compiled expression or NULL in case of error'/>
      <arg name='regexp' type='const xmlChar *' info='a regular expression string'/>
    </function>
    <function name='xmlRegexpExec' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Check if the regular expression generates the value</info>
      <return type='int' info='1 if it matches, 0 if not and a negative value in case of error'/>
      <arg name='comp' type='xmlRegexpPtr' info='the compiled regular expression'/>
      <arg name='content' type='const xmlChar *' info='the value to check against the regular expression'/>
    </function>
    <function name='xmlRegexpIsDeterminist' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Check if the regular expression is determinist</info>
      <return type='int' info='1 if it yes, 0 if not and a negative value in case of error'/>
      <arg name='comp' type='xmlRegexpPtr' info='the compiled regular expression'/>
    </function>
    <function name='xmlRegexpPrint' file='xmlregexp' module='xmlregexp'>
      <cond>defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Print the content of the compiled regular expression</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the file for the output debug'/>
      <arg name='regexp' type='xmlRegexpPtr' info='the compiled regexp'/>
    </function>
    <function name='xmlRegisterCharEncodingHandler' file='encoding' module='encoding'>
      <info>Register the char encoding handler, surprising, isn&apos;t it ?</info>
      <return type='void'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the xmlCharEncodingHandlerPtr handler block'/>
    </function>
    <function name='xmlRegisterDefaultInputCallbacks' file='xmlIO' module='xmlIO'>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterDefaultOutputCallbacks' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Registers the default compiled-in I/O handlers.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterHTTPPostCallbacks' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED) &amp;&amp; defined(LIBXML_HTTP_ENABLED)</cond>
      <info>By default, libxml submits HTTP output requests using the &quot;PUT&quot; method. Calling this method changes the HTTP output method to use the &quot;POST&quot; method instead.</info>
      <return type='void'/>
    </function>
    <function name='xmlRegisterInputCallbacks' file='xmlIO' module='xmlIO'>
      <info>Register a new set of I/O callback for handling parser input.</info>
      <return type='int' info='the registered handler number or -1 in case of error'/>
      <arg name='matchFunc' type='xmlInputMatchCallback' info='the xmlInputMatchCallback'/>
      <arg name='openFunc' type='xmlInputOpenCallback' info='the xmlInputOpenCallback'/>
      <arg name='readFunc' type='xmlInputReadCallback' info='the xmlInputReadCallback'/>
      <arg name='closeFunc' type='xmlInputCloseCallback' info='the xmlInputCloseCallback'/>
    </function>
    <function name='xmlRegisterNodeDefault' file='globals' module='globals'>
      <info>Registers a callback for node creation</info>
      <return type='xmlRegisterNodeFunc' info='the old value of the registration function'/>
      <arg name='func' type='xmlRegisterNodeFunc' info='function pointer to the new RegisterNodeFunc'/>
    </function>
    <functype name='xmlRegisterNodeFunc' file='globals' module='globals'>
      <info>Signature for the registration callback of a created node</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
    </functype>
    <function name='xmlRegisterOutputCallbacks' file='xmlIO' module='xmlIO'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Register a new set of I/O callback for handling output.</info>
      <return type='int' info='the registered handler number or -1 in case of error'/>
      <arg name='matchFunc' type='xmlOutputMatchCallback' info='the xmlOutputMatchCallback'/>
      <arg name='openFunc' type='xmlOutputOpenCallback' info='the xmlOutputOpenCallback'/>
      <arg name='writeFunc' type='xmlOutputWriteCallback' info='the xmlOutputWriteCallback'/>
      <arg name='closeFunc' type='xmlOutputCloseCallback' info='the xmlOutputCloseCallback'/>
    </function>
    <function name='xmlRelaxNGCleanupTypes' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Cleanup the default Schemas type library associated to RelaxNG</info>
      <return type='void'/>
    </function>
    <function name='xmlRelaxNGDump' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump a RelaxNG structure back</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the file output'/>
      <arg name='schema' type='xmlRelaxNGPtr' info='a schema structure'/>
    </function>
    <function name='xmlRelaxNGDumpTree' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump the transformed RelaxNG tree.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the file output'/>
      <arg name='schema' type='xmlRelaxNGPtr' info='a schema structure'/>
    </function>
    <function name='xmlRelaxNGFree' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Deallocate a RelaxNG structure.</info>
      <return type='void'/>
      <arg name='schema' type='xmlRelaxNGPtr' info='a schema structure'/>
    </function>
    <function name='xmlRelaxNGFreeParserCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Free the resources associated to the schema parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='the schema parser context'/>
    </function>
    <function name='xmlRelaxNGFreeValidCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Free the resources associated to the schema validation context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the schema validation context'/>
    </function>
    <function name='xmlRelaxNGGetParserErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the callback information used to handle errors for a validation context</info>
      <return type='int' info='-1 in case of failure, 0 otherwise.'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='err' type='xmlRelaxNGValidityErrorFunc *' info='the error callback result'/>
      <arg name='warn' type='xmlRelaxNGValidityWarningFunc *' info='the warning callback result'/>
      <arg name='ctx' type='void **' info='contextual data for the callbacks result'/>
    </function>
    <function name='xmlRelaxNGGetValidErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the error and warning callback informations</info>
      <return type='int' info='-1 in case of error and 0 otherwise'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='err' type='xmlRelaxNGValidityErrorFunc *' info='the error function result'/>
      <arg name='warn' type='xmlRelaxNGValidityWarningFunc *' info='the warning function result'/>
      <arg name='ctx' type='void **' info='the functions context result'/>
    </function>
    <function name='xmlRelaxNGInitTypes' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Initilize the default type libraries.</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
    </function>
    <function name='xmlRelaxNGNewDocParserCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML RelaxNGs parser context for that document. Note: since the process of compiling a RelaxNG schemas modifies the document, the @doc parameter is duplicated internally.</info>
      <return type='xmlRelaxNGParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='a preparsed document tree'/>
    </function>
    <function name='xmlRelaxNGNewMemParserCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML RelaxNGs parse context for that memory buffer expected to contain an XML RelaxNGs file.</info>
      <return type='xmlRelaxNGParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array containing the schemas'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='xmlRelaxNGNewParserCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML RelaxNGs parse context for that file/resource expected to contain an XML RelaxNGs file.</info>
      <return type='xmlRelaxNGParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='URL' type='const char *' info='the location of the schema'/>
    </function>
    <function name='xmlRelaxNGNewValidCtxt' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML RelaxNGs validation context based on the given schema</info>
      <return type='xmlRelaxNGValidCtxtPtr' info='the validation context or NULL in case of error'/>
      <arg name='schema' type='xmlRelaxNGPtr' info='a precompiled XML RelaxNGs'/>
    </function>
    <function name='xmlRelaxNGParse' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>parse a schema definition resource and build an internal XML Shema struture which can be used to validate instances.</info>
      <return type='xmlRelaxNGPtr' info='the internal XML RelaxNG structure built from the resource or NULL in case of error'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a Relax-NG parser context'/>
    </function>
    <function name='xmlRelaxNGSetParserErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the callback functions used to handle errors for a validation context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='err' type='xmlRelaxNGValidityErrorFunc' info='the error callback'/>
      <arg name='warn' type='xmlRelaxNGValidityWarningFunc' info='the warning callback'/>
      <arg name='ctx' type='void *' info='contextual data for the callbacks'/>
    </function>
    <function name='xmlRelaxNGSetParserStructuredErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the callback functions used to handle errors for a parsing context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a Relax-NG parser context'/>
      <arg name='serror' type='xmlStructuredErrorFunc' info='the error callback'/>
      <arg name='ctx' type='void *' info='contextual data for the callbacks'/>
    </function>
    <function name='xmlRelaxNGSetValidErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the error and warning callback informations</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='err' type='xmlRelaxNGValidityErrorFunc' info='the error function'/>
      <arg name='warn' type='xmlRelaxNGValidityWarningFunc' info='the warning function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlRelaxNGSetValidStructuredErrors' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the structured error callback</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='serror' type='xmlStructuredErrorFunc' info='the structured error function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlRelaxNGValidateDoc' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate a document tree in memory.</info>
      <return type='int' info='0 if the document is valid, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='a Relax-NG validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed document tree'/>
    </function>
    <function name='xmlRelaxNGValidateFullElement' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate a full subtree when xmlRelaxNGValidatePushElement() returned 0 and the content of the node has been expanded.</info>
      <return type='int' info='1 if no validation problem was found or -1 in case of error.'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
    </function>
    <function name='xmlRelaxNGValidatePopElement' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Pop the element end from the RelaxNG validation stack.</info>
      <return type='int' info='1 if no validation problem was found or 0 otherwise'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the RelaxNG validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
    </function>
    <function name='xmlRelaxNGValidatePushCData' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>check the CData parsed for validation in the current stack</info>
      <return type='int' info='1 if no validation problem was found or -1 otherwise'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the RelaxNG validation context'/>
      <arg name='data' type='const xmlChar *' info='some character data read'/>
      <arg name='len' type='int' info='the length of the data'/>
    </function>
    <function name='xmlRelaxNGValidatePushElement' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Push a new element start on the RelaxNG validation stack.</info>
      <return type='int' info='1 if no validation problem was found or 0 if validating the element requires a full node, and -1 in case of error.'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
    </function>
    <functype name='xmlRelaxNGValidityErrorFunc' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Signature of an error callback from a Relax-NG validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <functype name='xmlRelaxNGValidityWarningFunc' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Signature of a warning callback from a Relax-NG validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <function name='xmlRelaxParserSetFlag' file='relaxng' module='relaxng'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Semi private function used to pass informations to a parser context which are a combination of xmlRelaxNGParserFlag .</info>
      <return type='int' info='0 if success and -1 in case of error'/>
      <arg name='ctxt' type='xmlRelaxNGParserCtxtPtr' info='a RelaxNG parser context'/>
      <arg name='flags' type='int' info='a set of flags values'/>
    </function>
    <function name='xmlRemoveID' file='valid' module='valid'>
      <info>Remove the given attribute from the ID table maintained internally.</info>
      <return type='int' info='-1 if the lookup failed and 0 otherwise'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
    </function>
    <function name='xmlRemoveProp' file='tree' module='tree'>
      <info>Unlink and free one attribute, all the content is freed too Note this doesn&apos;t work for namespace definition attributes</info>
      <return type='int' info='0 if success and -1 in case of error.'/>
      <arg name='cur' type='xmlAttrPtr' info='an attribute'/>
    </function>
    <function name='xmlRemoveRef' file='valid' module='valid'>
      <info>Remove the given attribute from the Ref table maintained internally.</info>
      <return type='int' info='-1 if the lookup failed and 0 otherwise'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='attr' type='xmlAttrPtr' info='the attribute'/>
    </function>
    <function name='xmlReplaceNode' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Unlink the old node from its current context, prune the new one at the same place. If @cur was already inserted in a document it is first unlinked from its existing context.</info>
      <return type='xmlNodePtr' info='the @old node'/>
      <arg name='old' type='xmlNodePtr' info='the old node'/>
      <arg name='cur' type='xmlNodePtr' info='the node'/>
    </function>
    <function name='xmlResetError' file='xmlerror' module='error'>
      <info>Cleanup the error.</info>
      <return type='void'/>
      <arg name='err' type='xmlErrorPtr' info='pointer to the error.'/>
    </function>
    <function name='xmlResetLastError' file='xmlerror' module='error'>
      <info>Cleanup the last global error registered. For parsing error this does not change the well-formedness result.</info>
      <return type='void'/>
    </function>
    <function name='xmlSAX2AttributeDecl' file='SAX2' module='SAX2'>
      <info>An attribute definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='elem' type='const xmlChar *' info='the name of the element'/>
      <arg name='fullname' type='const xmlChar *' info='the attribute name'/>
      <arg name='type' type='int' info='the attribute type'/>
      <arg name='def' type='int' info='the type of default value'/>
      <arg name='defaultValue' type='const xmlChar *' info='the attribute default value'/>
      <arg name='tree' type='xmlEnumerationPtr' info='the tree of enumerated value set'/>
    </function>
    <function name='xmlSAX2CDataBlock' file='SAX2' module='SAX2'>
      <info>called when a pcdata block has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='The pcdata content'/>
      <arg name='len' type='int' info='the block length'/>
    </function>
    <function name='xmlSAX2Characters' file='SAX2' module='SAX2'>
      <info>receiving some chars from the parser.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </function>
    <function name='xmlSAX2Comment' file='SAX2' module='SAX2'>
      <info>A xmlSAX2Comment has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='value' type='const xmlChar *' info='the xmlSAX2Comment content'/>
    </function>
    <function name='xmlSAX2ElementDecl' file='SAX2' module='SAX2'>
      <info>An element definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='type' type='int' info='the element type'/>
      <arg name='content' type='xmlElementContentPtr' info='the element value tree'/>
    </function>
    <function name='xmlSAX2EndDocument' file='SAX2' module='SAX2'>
      <info>called when the document end has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2EndElement' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when the end of an element has been detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The element name'/>
    </function>
    <function name='xmlSAX2EndElementNs' file='SAX2' module='SAX2'>
      <info>SAX2 callback when an element end has been detected by the parser. It provides the namespace informations for the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='localname' type='const xmlChar *' info='the local name of the element'/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix if available'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace name if available'/>
    </function>
    <function name='xmlSAX2EntityDecl' file='SAX2' module='SAX2'>
      <info>An entity definition has been parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the entity name'/>
      <arg name='type' type='int' info='the entity type'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='content' type='xmlChar *' info='the entity value (without processing).'/>
    </function>
    <function name='xmlSAX2ExternalSubset' file='SAX2' module='SAX2'>
      <info>Callback on external subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </function>
    <function name='xmlSAX2GetColumnNumber' file='SAX2' module='SAX2'>
      <info>Provide the column number of the current parsing point.</info>
      <return type='int' info='an int'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2GetEntity' file='SAX2' module='SAX2'>
      <info>Get an entity by name</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <function name='xmlSAX2GetLineNumber' file='SAX2' module='SAX2'>
      <info>Provide the line number of the current parsing point.</info>
      <return type='int' info='an int'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2GetParameterEntity' file='SAX2' module='SAX2'>
      <info>Get a parameter entity by name</info>
      <return type='xmlEntityPtr' info='the xmlEntityPtr if found.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <function name='xmlSAX2GetPublicId' file='SAX2' module='SAX2'>
      <info>Provides the public ID e.g. &quot;-//SGMLSOURCE//DTD DEMO//EN&quot;</info>
      <return type='const xmlChar *' info='a xmlChar *'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2GetSystemId' file='SAX2' module='SAX2'>
      <info>Provides the system ID, basically URL or filename e.g. http://www.sgmlsource.com/dtds/memo.dtd</info>
      <return type='const xmlChar *' info='a xmlChar *'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2HasExternalSubset' file='SAX2' module='SAX2'>
      <info>Does this document has an external subset</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2HasInternalSubset' file='SAX2' module='SAX2'>
      <info>Does this document has an internal subset</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2IgnorableWhitespace' file='SAX2' module='SAX2'>
      <info>receiving some ignorable whitespaces from the parser. UNUSED: by default the DOM building will use xmlSAX2Characters</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='ch' type='const xmlChar *' info='a xmlChar string'/>
      <arg name='len' type='int' info='the number of xmlChar'/>
    </function>
    <function name='xmlSAX2InitDefaultSAXHandler' file='SAX2' module='SAX2'>
      <info>Initialize the default XML SAX2 handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler'/>
      <arg name='warning' type='int' info='flag if non-zero sets the handler warning procedure'/>
    </function>
    <function name='xmlSAX2InitDocbDefaultSAXHandler' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_DOCB_ENABLED)</cond>
      <info>Initialize the default DocBook SAX2 handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler'/>
    </function>
    <function name='xmlSAX2InitHtmlDefaultSAXHandler' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_HTML_ENABLED)</cond>
      <info>Initialize the default HTML SAX2 handler</info>
      <return type='void'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler'/>
    </function>
    <function name='xmlSAX2InternalSubset' file='SAX2' module='SAX2'>
      <info>Callback on internal subset declaration.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='the root element name'/>
      <arg name='ExternalID' type='const xmlChar *' info='the external ID'/>
      <arg name='SystemID' type='const xmlChar *' info='the SYSTEM ID (e.g. filename or URL)'/>
    </function>
    <function name='xmlSAX2IsStandalone' file='SAX2' module='SAX2'>
      <info>Is this document tagged standalone ?</info>
      <return type='int' info='1 if true'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2NotationDecl' file='SAX2' module='SAX2'>
      <info>What to do when a notation declaration has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the notation'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </function>
    <function name='xmlSAX2ProcessingInstruction' file='SAX2' module='SAX2'>
      <info>A processing instruction has been parsed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='target' type='const xmlChar *' info='the target name'/>
      <arg name='data' type='const xmlChar *' info='the PI data&apos;s'/>
    </function>
    <function name='xmlSAX2Reference' file='SAX2' module='SAX2'>
      <info>called when an entity xmlSAX2Reference is detected.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The entity name'/>
    </function>
    <function name='xmlSAX2ResolveEntity' file='SAX2' module='SAX2'>
      <info>The entity loader, to control the loading of external entities, the application can either: - override this xmlSAX2ResolveEntity() callback in the SAX block - or better use the xmlSetExternalEntityLoader() function to set up it&apos;s own entity resolution routine</info>
      <return type='xmlParserInputPtr' info='the xmlParserInputPtr if inlined or NULL for DOM behaviour.'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
    </function>
    <function name='xmlSAX2SetDocumentLocator' file='SAX2' module='SAX2'>
      <info>Receive the document locator at startup, actually xmlDefaultSAXLocator Everything is available on the context, so this is useless in our case.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='loc' type='xmlSAXLocatorPtr' info='A SAX Locator'/>
    </function>
    <function name='xmlSAX2StartDocument' file='SAX2' module='SAX2'>
      <info>called when the document start being processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
    </function>
    <function name='xmlSAX2StartElement' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>called when an opening tag has been processed.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='fullname' type='const xmlChar *' info='The element name, including namespace prefix'/>
      <arg name='atts' type='const xmlChar **' info='An array of name/value attributes pairs, NULL terminated'/>
    </function>
    <function name='xmlSAX2StartElementNs' file='SAX2' module='SAX2'>
      <info>SAX2 callback when an element start has been detected by the parser. It provides the namespace informations for the element, as well as the new namespace declarations on the element.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='localname' type='const xmlChar *' info='the local name of the element'/>
      <arg name='prefix' type='const xmlChar *' info='the element namespace prefix if available'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace name if available'/>
      <arg name='nb_namespaces' type='int' info='number of namespace definitions on that node'/>
      <arg name='namespaces' type='const xmlChar **' info='pointer to the array of prefix/URI pairs namespace definitions'/>
      <arg name='nb_attributes' type='int' info='the number of attributes on that node'/>
      <arg name='nb_defaulted' type='int' info='the number of defaulted attributes.'/>
      <arg name='attributes' type='const xmlChar **' info='pointer to the array of (localname/prefix/URI/value/end) attribute values.'/>
    </function>
    <function name='xmlSAX2UnparsedEntityDecl' file='SAX2' module='SAX2'>
      <info>What to do when an unparsed entity declaration is parsed</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the user data (XML parser context)'/>
      <arg name='name' type='const xmlChar *' info='The name of the entity'/>
      <arg name='publicId' type='const xmlChar *' info='The public ID of the entity'/>
      <arg name='systemId' type='const xmlChar *' info='The system ID of the entity'/>
      <arg name='notationName' type='const xmlChar *' info='the name of the notation'/>
    </function>
    <function name='xmlSAXDefaultVersion' file='SAX2' module='SAX2'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Set the default version of SAX used globally by the library. By default, during initialization the default is set to 2. Note that it is generally a better coding style to use xmlSAXVersion() to set up the version explicitly for a given parsing context.</info>
      <return type='int' info='the previous value in case of success and -1 in case of error.'/>
      <arg name='version' type='int' info='the version, 1 or 2'/>
    </function>
    <function name='xmlSAXParseDTD' file='parser' module='parser'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Load and parse an external subset.</info>
      <return type='xmlDtdPtr' info='the resulting xmlDtdPtr or NULL in case of error.'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='ExternalID' type='const xmlChar *' info='a NAME* containing the External ID of the DTD'/>
      <arg name='SystemID' type='const xmlChar *' info='a NAME* containing the URL to the DTD'/>
    </function>
    <function name='xmlSAXParseDoc' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory document and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='cur' type='const xmlChar *' info='a pointer to an array of xmlChar'/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents'/>
    </function>
    <function name='xmlSAXParseEntity' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML external entity out of context and build a tree. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.  [78] extParsedEnt ::= TextDecl? content  This correspond to a &quot;Well Balanced&quot; chunk</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='filename' type='const char *' info='the filename'/>
    </function>
    <function name='xmlSAXParseFile' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents'/>
    </function>
    <function name='xmlSAXParseFileWithData' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML file and build a tree. Automatic support for ZLIB/Compress compressed document is provided by default if found at compile-time. It use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.  User data (void *) is stored within the parser context in the context&apos;s _private member, so it is available nearly everywhere in libxml</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='filename' type='const char *' info='the filename'/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents'/>
      <arg name='data' type='void *' info='the userdata'/>
    </function>
    <function name='xmlSAXParseMemory' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='buffer' type='const char *' info='an pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read not Well Formed documents'/>
    </function>
    <function name='xmlSAXParseMemoryWithData' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML in-memory block and use the given SAX function block to handle the parsing callback. If sax is NULL, fallback to the default DOM tree building routines.  User data (void *) is stored within the parser context in the context&apos;s _private member, so it is available nearly everywhere in libxml</info>
      <return type='xmlDocPtr' info='the resulting document tree'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='the SAX handler block'/>
      <arg name='buffer' type='const char *' info='an pointer to a char array'/>
      <arg name='size' type='int' info='the size of the array'/>
      <arg name='recovery' type='int' info='work in recovery mode, i.e. tries to read no Well Formed documents'/>
      <arg name='data' type='void *' info='the userdata'/>
    </function>
    <function name='xmlSAXUserParseFile' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>parse an XML file and call the given SAX handler routines. Automatic support for ZLIB/Compress compressed document is provided</info>
      <return type='int' info='0 in case of success or a error number otherwise'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='filename' type='const char *' info='a file name'/>
    </function>
    <function name='xmlSAXUserParseMemory' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>A better SAX parsing routine. parse an XML in-memory buffer and call the given SAX handler routines.</info>
      <return type='int' info='0 in case of success or a error number otherwise'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler'/>
      <arg name='user_data' type='void *' info='The user data returned on SAX callbacks'/>
      <arg name='buffer' type='const char *' info='an in-memory XML document input'/>
      <arg name='size' type='int' info='the length of the XML document in bytes'/>
    </function>
    <function name='xmlSAXVersion' file='SAX2' module='SAX2'>
      <info>Initialize the default XML SAX handler according to the version</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='hdlr' type='xmlSAXHandler *' info='the SAX handler'/>
      <arg name='version' type='int' info='the version, 1 or 2'/>
    </function>
    <function name='xmlSaveClose' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Close a document saving context, i.e. make sure that all bytes have been output and free the associated data.</info>
      <return type='int' info='the number of byte written or -1 in case of error.'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
    </function>
    <function name='xmlSaveDoc' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Save a full document to a saving context TODO: The function is not fully implemented yet as it does not return the byte count but 0 instead</info>
      <return type='long' info='the number of byte written or -1 in case of error'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
      <arg name='doc' type='xmlDocPtr' info='a document'/>
    </function>
    <function name='xmlSaveFile' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If @filename is &quot;-&quot; the stdout file is used.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename (or URL)'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlSaveFileEnc' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document, converting it to the given encoding</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename (or URL)'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the name of an encoding (or NULL)'/>
    </function>
    <function name='xmlSaveFileTo' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to an I/O buffer. Warning ! This call xmlOutputBufferClose() on buf which is not available after this call.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output I/O buffer'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the encoding if any assuming the I/O layer handles the trancoding'/>
    </function>
    <function name='xmlSaveFlush' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Flush a document saving context, i.e. make sure that all bytes have been output.</info>
      <return type='int' info='the number of byte written or -1 in case of error.'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
    </function>
    <function name='xmlSaveFormatFile' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to a file. Will use compression if compiled in and enabled. If @filename is &quot;-&quot; the stdout file is used. If @format is set then the document will be indented on output. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='filename' type='const char *' info='the filename (or URL)'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='xmlSaveFormatFileEnc' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to a file or an URL.</info>
      <return type='int' info='the number of bytes written or -1 in case of error. Note that @format = 1 provide node indenting only if xmlIndentTreeOutput = 1 or xmlKeepBlanksDefault(0) was called'/>
      <arg name='filename' type='const char *' info='the filename or URL to output'/>
      <arg name='cur' type='xmlDocPtr' info='the document being saved'/>
      <arg name='encoding' type='const char *' info='the name of the encoding to use or NULL.'/>
      <arg name='format' type='int' info='should formatting spaces be added.'/>
    </function>
    <function name='xmlSaveFormatFileTo' file='tree' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump an XML document to an I/O buffer. Warning ! This call xmlOutputBufferClose() on buf which is not available after this call.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output I/O buffer'/>
      <arg name='cur' type='xmlDocPtr' info='the document'/>
      <arg name='encoding' type='const char *' info='the encoding if any assuming the I/O layer handles the trancoding'/>
      <arg name='format' type='int' info='should formatting spaces been added'/>
    </function>
    <function name='xmlSaveSetAttrEscape' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Set a custom escaping function to be used for text in attribute content</info>
      <return type='int' info='0 if successful or -1 in case of error.'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
      <arg name='escape' type='xmlCharEncodingOutputFunc' info='the escaping function'/>
    </function>
    <function name='xmlSaveSetEscape' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Set a custom escaping function to be used for text in element content</info>
      <return type='int' info='0 if successful or -1 in case of error.'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
      <arg name='escape' type='xmlCharEncodingOutputFunc' info='the escaping function'/>
    </function>
    <function name='xmlSaveToBuffer' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a document saving context serializing to a buffer with the encoding and the options given</info>
      <return type='xmlSaveCtxtPtr' info='a new serialization context or NULL in case of error.'/>
      <arg name='buffer' type='xmlBufferPtr' info='a buffer'/>
      <arg name='encoding' type='const char *' info='the encoding name to use or NULL'/>
      <arg name='options' type='int' info='a set of xmlSaveOptions'/>
    </function>
    <function name='xmlSaveToFd' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a document saving context serializing to a file descriptor with the encoding and the options given.</info>
      <return type='xmlSaveCtxtPtr' info='a new serialization context or NULL in case of error.'/>
      <arg name='fd' type='int' info='a file descriptor number'/>
      <arg name='encoding' type='const char *' info='the encoding name to use or NULL'/>
      <arg name='options' type='int' info='a set of xmlSaveOptions'/>
    </function>
    <function name='xmlSaveToFilename' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a document saving context serializing to a filename or possibly to an URL (but this is less reliable) with the encoding and the options given.</info>
      <return type='xmlSaveCtxtPtr' info='a new serialization context or NULL in case of error.'/>
      <arg name='filename' type='const char *' info='a file name or an URL'/>
      <arg name='encoding' type='const char *' info='the encoding name to use or NULL'/>
      <arg name='options' type='int' info='a set of xmlSaveOptions'/>
    </function>
    <function name='xmlSaveToIO' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Create a document saving context serializing to a file descriptor with the encoding and the options given</info>
      <return type='xmlSaveCtxtPtr' info='a new serialization context or NULL in case of error.'/>
      <arg name='iowrite' type='xmlOutputWriteCallback' info='an I/O write function'/>
      <arg name='ioclose' type='xmlOutputCloseCallback' info='an I/O close function'/>
      <arg name='ioctx' type='void *' info='an I/O handler'/>
      <arg name='encoding' type='const char *' info='the encoding name to use or NULL'/>
      <arg name='options' type='int' info='a set of xmlSaveOptions'/>
    </function>
    <function name='xmlSaveTree' file='xmlsave' module='xmlsave'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Save a subtree starting at the node parameter to a saving context TODO: The function is not fully implemented yet as it does not return the byte count but 0 instead</info>
      <return type='long' info='the number of byte written or -1 in case of error'/>
      <arg name='ctxt' type='xmlSaveCtxtPtr' info='a document saving context'/>
      <arg name='node' type='xmlNodePtr' info='the top node of the subtree to save'/>
    </function>
    <function name='xmlSaveUri' file='uri' module='uri'>
      <info>Save the URI as an escaped string</info>
      <return type='xmlChar *' info='a new string (to be deallocated by caller)'/>
      <arg name='uri' type='xmlURIPtr' info='pointer to an xmlURI'/>
    </function>
    <function name='xmlScanName' file='parserInternals' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Trickery: parse an XML name but without consuming the input flow Needed for rollback cases. Used only when parsing entities references.  TODO: seems deprecated now, only used in the default part of xmlParserHandleReference  [4] NameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | &apos;:&apos; | CombiningChar | Extender  [5] Name ::= (Letter | &apos;_&apos; | &apos;:&apos;) (NameChar)*  [6] Names ::= Name (S Name)*</info>
      <return type='xmlChar *' info='the Name parsed or NULL'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlSchemaCheckFacet' file='xmlschemastypes' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Checks and computes the values of facets.</info>
      <return type='int' info='0 if valid, a positive error code if not valid and -1 in case of an internal or API error.'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet'/>
      <arg name='typeDecl' type='xmlSchemaTypePtr' info='the schema type definition'/>
      <arg name='pctxt' type='xmlSchemaParserCtxtPtr' info='the schema parser context or NULL'/>
      <arg name='name' type='const xmlChar *' info='the optional name of the type'/>
    </function>
    <function name='xmlSchemaCleanupTypes' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Cleanup the default XML Schemas type library</info>
      <return type='void'/>
    </function>
    <function name='xmlSchemaCollapseString' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Removes and normalize white spaces in the string</info>
      <return type='xmlChar *' info='the new string or NULL if no change was required.'/>
      <arg name='value' type='const xmlChar *' info='a value'/>
    </function>
    <function name='xmlSchemaCompareValues' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Compare 2 values</info>
      <return type='int' info='-1 if x &lt; y, 0 if x == y, 1 if x &gt; y, 2 if x &lt;&gt; y, and -2 in case of error'/>
      <arg name='x' type='xmlSchemaValPtr' info='a first value'/>
      <arg name='y' type='xmlSchemaValPtr' info='a second value'/>
    </function>
    <function name='xmlSchemaCompareValuesWhtsp' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Compare 2 values</info>
      <return type='int' info='-1 if x &lt; y, 0 if x == y, 1 if x &gt; y, 2 if x &lt;&gt; y, and -2 in case of error'/>
      <arg name='x' type='xmlSchemaValPtr' info='a first value'/>
      <arg name='xws' type='xmlSchemaWhitespaceValueType' info='the whitespace value of x'/>
      <arg name='y' type='xmlSchemaValPtr' info='a second value'/>
      <arg name='yws' type='xmlSchemaWhitespaceValueType' info='the whitespace value of y'/>
    </function>
    <function name='xmlSchemaCopyValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Copies the precomputed value. This duplicates any string within.</info>
      <return type='xmlSchemaValPtr' info='the copy or NULL if a copy for a data-type is not implemented.'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value to be copied'/>
    </function>
    <function name='xmlSchemaDump' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Dump a Schema structure.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the file output'/>
      <arg name='schema' type='xmlSchemaPtr' info='a schema structure'/>
    </function>
    <function name='xmlSchemaFree' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Deallocate a Schema structure.</info>
      <return type='void'/>
      <arg name='schema' type='xmlSchemaPtr' info='a schema structure'/>
    </function>
    <function name='xmlSchemaFreeFacet' file='xmlschemastypes' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Deallocate a Schema Facet structure.</info>
      <return type='void'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='a schema facet structure'/>
    </function>
    <function name='xmlSchemaFreeParserCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Free the resources associated to the schema parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='the schema parser context'/>
    </function>
    <function name='xmlSchemaFreeType' file='schemasInternals' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Deallocate a Schema Type structure.</info>
      <return type='void'/>
      <arg name='type' type='xmlSchemaTypePtr' info='a schema type structure'/>
    </function>
    <function name='xmlSchemaFreeValidCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Free the resources associated to the schema validation context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='the schema validation context'/>
    </function>
    <function name='xmlSchemaFreeValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Cleanup the default XML Schemas type library</info>
      <return type='void'/>
      <arg name='value' type='xmlSchemaValPtr' info='the value to free'/>
    </function>
    <function name='xmlSchemaFreeWildcard' file='schemasInternals' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Deallocates a wildcard structure.</info>
      <return type='void'/>
      <arg name='wildcard' type='xmlSchemaWildcardPtr' info='a wildcard structure'/>
    </function>
    <function name='xmlSchemaGetBuiltInListSimpleTypeItemType' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Lookup function</info>
      <return type='xmlSchemaTypePtr' info='the item type of @type as defined by the built-in datatype hierarchy of XML Schema Part 2: Datatypes, or NULL in case of an error.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the built-in simple type.'/>
    </function>
    <function name='xmlSchemaGetBuiltInType' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Gives you the type struct for a built-in type by its type id.</info>
      <return type='xmlSchemaTypePtr' info='the type if found, NULL otherwise.'/>
      <arg name='type' type='xmlSchemaValType' info='the type of the built in type'/>
    </function>
    <function name='xmlSchemaGetCanonValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the canonical lexical representation of the value. The caller has to FREE the returned retValue.  WARNING: Some value types are not supported yet, resulting in a @retValue of &quot;???&quot;.  TODO: XML Schema 1.0 does not define canonical representations for: duration, gYearMonth, gYear, gMonthDay, gMonth, gDay, anyURI, QName, NOTATION. This will be fixed in XML Schema 1.1.</info>
      <return type='int' info='0 if the value could be built, 1 if the value type is not supported yet and -1 in case of API errors.'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
      <arg name='retValue' type='const xmlChar **' info='the returned value'/>
    </function>
    <function name='xmlSchemaGetCanonValueWhtsp' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the canonical representation of the value. The caller has to free the returned @retValue.</info>
      <return type='int' info='0 if the value could be built, 1 if the value type is not supported yet and -1 in case of API errors.'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
      <arg name='retValue' type='const xmlChar **' info='the returned value'/>
      <arg name='ws' type='xmlSchemaWhitespaceValueType' info='the whitespace type of the value'/>
    </function>
    <function name='xmlSchemaGetFacetValueAsULong' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Extract the value of a facet</info>
      <return type='unsigned long' info='the value as a long'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='an schemas type facet'/>
    </function>
    <function name='xmlSchemaGetParserErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the callback information used to handle errors for a parser context</info>
      <return type='int' info='-1 in case of failure, 0 otherwise'/>
      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='a XMl-Schema parser context'/>
      <arg name='err' type='xmlSchemaValidityErrorFunc *' info='the error callback result'/>
      <arg name='warn' type='xmlSchemaValidityWarningFunc *' info='the warning callback result'/>
      <arg name='ctx' type='void **' info='contextual data for the callbacks result'/>
    </function>
    <function name='xmlSchemaGetPredefinedType' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Lookup a type in the default XML Schemas type library</info>
      <return type='xmlSchemaTypePtr' info='the type if found, NULL otherwise'/>
      <arg name='name' type='const xmlChar *' info='the type name'/>
      <arg name='ns' type='const xmlChar *' info='the URI of the namespace usually &quot;http://www.w3.org/2001/XMLSchema&quot;'/>
    </function>
    <function name='xmlSchemaGetValType' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Accessor for the type of a value</info>
      <return type='xmlSchemaValType' info='the xmlSchemaValType of the value'/>
      <arg name='val' type='xmlSchemaValPtr' info='a schemas value'/>
    </function>
    <function name='xmlSchemaGetValidErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the error and warning callback informations</info>
      <return type='int' info='-1 in case of error and 0 otherwise'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a XML-Schema validation context'/>
      <arg name='err' type='xmlSchemaValidityErrorFunc *' info='the error function result'/>
      <arg name='warn' type='xmlSchemaValidityWarningFunc *' info='the warning function result'/>
      <arg name='ctx' type='void **' info='the functions context result'/>
    </function>
    <function name='xmlSchemaInitTypes' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Initialize the default XML Schemas type library</info>
      <return type='void'/>
    </function>
    <function name='xmlSchemaIsBuiltInTypeFacet' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Evaluates if a specific facet can be used in conjunction with a type.</info>
      <return type='int' info='1 if the facet can be used with the given built-in type, 0 otherwise and -1 in case the type is not a built-in type.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the built-in type'/>
      <arg name='facetType' type='int' info='the facet type'/>
    </function>
    <function name='xmlSchemaIsValid' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check if any error was detected during validation.</info>
      <return type='int' info='1 if valid so far, 0 if errors were detected, and -1 in case of internal error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='the schema validation context'/>
    </function>
    <function name='xmlSchemaNewDocParserCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML Schemas parse context for that document. NB. The document may be modified during the parsing process.</info>
      <return type='xmlSchemaParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='a preparsed document tree'/>
    </function>
    <function name='xmlSchemaNewFacet' file='xmlschemastypes' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Allocate a new Facet structure.</info>
      <return type='xmlSchemaFacetPtr' info='the newly allocated structure or NULL in case or error'/>
    </function>
    <function name='xmlSchemaNewMemParserCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML Schemas parse context for that memory buffer expected to contain an XML Schemas file.</info>
      <return type='xmlSchemaParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array containing the schemas'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='xmlSchemaNewNOTATIONValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Allocate a new NOTATION value. The given values are consumed and freed with the struct.</info>
      <return type='xmlSchemaValPtr' info='a pointer to the new value or NULL in case of error'/>
      <arg name='name' type='const xmlChar *' info='the notation name'/>
      <arg name='ns' type='const xmlChar *' info='the notation namespace name or NULL'/>
    </function>
    <function name='xmlSchemaNewParserCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML Schemas parse context for that file/resource expected to contain an XML Schemas file.</info>
      <return type='xmlSchemaParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='URL' type='const char *' info='the location of the schema'/>
    </function>
    <function name='xmlSchemaNewQNameValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Allocate a new QName value. The given values are consumed and freed with the struct.</info>
      <return type='xmlSchemaValPtr' info='a pointer to the new value or NULL in case of an error.'/>
      <arg name='namespaceName' type='const xmlChar *' info='the namespace name'/>
      <arg name='localName' type='const xmlChar *' info='the local name'/>
    </function>
    <function name='xmlSchemaNewStringValue' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Allocate a new simple type value. The type can be of XML_SCHEMAS_STRING. WARNING: This one is intended to be expanded for other string based types. We need this for anySimpleType as well. The given value is consumed and freed with the struct.</info>
      <return type='xmlSchemaValPtr' info='a pointer to the new value or NULL in case of error'/>
      <arg name='type' type='xmlSchemaValType' info='the value type'/>
      <arg name='value' type='const xmlChar *' info='the value'/>
    </function>
    <function name='xmlSchemaNewValidCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Create an XML Schemas validation context based on the given schema.</info>
      <return type='xmlSchemaValidCtxtPtr' info='the validation context or NULL in case of error'/>
      <arg name='schema' type='xmlSchemaPtr' info='a precompiled XML Schemas'/>
    </function>
    <function name='xmlSchemaParse' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>parse a schema definition resource and build an internal XML Shema struture which can be used to validate instances.</info>
      <return type='xmlSchemaPtr' info='the internal XML Schema structure built from the resource or NULL in case of error'/>
      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='a schema validation context'/>
    </function>
    <function name='xmlSchemaSAXPlug' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Plug a SAX based validation layer in a SAX parsing event flow. The original @saxptr and @dataptr data are replaced by new pointers but the calls to the original will be maintained.</info>
      <return type='xmlSchemaSAXPlugPtr' info='a pointer to a data structure needed to unplug the validation layer or NULL in case of errors.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='sax' type='xmlSAXHandlerPtr *' info='a pointer to the original xmlSAXHandlerPtr'/>
      <arg name='user_data' type='void **' info='a pointer to the original SAX user data pointer'/>
    </function>
    <function name='xmlSchemaSAXUnplug' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Unplug a SAX based validation layer in a SAX parsing event flow. The original pointers used in the call are restored.</info>
      <return type='int' info='0 in case of success and -1 in case of failure.'/>
      <arg name='plug' type='xmlSchemaSAXPlugPtr' info='a data structure returned by xmlSchemaSAXPlug'/>
    </function>
    <function name='xmlSchemaSetParserErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the callback functions used to handle errors for a validation context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='a schema validation context'/>
      <arg name='err' type='xmlSchemaValidityErrorFunc' info='the error callback'/>
      <arg name='warn' type='xmlSchemaValidityWarningFunc' info='the warning callback'/>
      <arg name='ctx' type='void *' info='contextual data for the callbacks'/>
    </function>
    <function name='xmlSchemaSetParserStructuredErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the structured error callback</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaParserCtxtPtr' info='a schema parser context'/>
      <arg name='serror' type='xmlStructuredErrorFunc' info='the structured error function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlSchemaSetValidErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the error and warning callback informations</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='err' type='xmlSchemaValidityErrorFunc' info='the error function'/>
      <arg name='warn' type='xmlSchemaValidityWarningFunc' info='the warning function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlSchemaSetValidOptions' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Sets the options to be used during the validation.</info>
      <return type='int' info='0 in case of success, -1 in case of an API error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='options' type='int' info='a combination of xmlSchemaValidOption'/>
    </function>
    <function name='xmlSchemaSetValidStructuredErrors' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Set the structured error callback</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='serror' type='xmlStructuredErrorFunc' info='the structured error function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlSchemaValPredefTypeNode' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val.</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the predefined type'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='val' type='xmlSchemaValPtr *' info='the return computed value'/>
      <arg name='node' type='xmlNodePtr' info='the node containing the value'/>
    </function>
    <function name='xmlSchemaValPredefTypeNodeNoNorm' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val. This one does apply any normalization to the value.</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the predefined type'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='val' type='xmlSchemaValPtr *' info='the return computed value'/>
      <arg name='node' type='xmlNodePtr' info='the node containing the value'/>
    </function>
    <function name='xmlSchemaValidCtxtGetOptions' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Get the validation context options.</info>
      <return type='int' info='the option combination or -1 on error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
    </function>
    <function name='xmlSchemaValidCtxtGetParserCtxt' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>allow access to the parser context of the schema validation context</info>
      <return type='xmlParserCtxtPtr' info='the parser context of the schema validation context or NULL in case of error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
    </function>
    <function name='xmlSchemaValidateDoc' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate a document tree in memory.</info>
      <return type='int' info='0 if the document is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed document tree'/>
    </function>
    <function name='xmlSchemaValidateFacet' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check a value against a facet condition</info>
      <return type='int' info='0 if the element is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='base' type='xmlSchemaTypePtr' info='the base type'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet to check'/>
      <arg name='value' type='const xmlChar *' info='the lexical repr of the value to validate'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
    </function>
    <function name='xmlSchemaValidateFacetWhtsp' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check a value against a facet condition. This takes value normalization according to the specified whitespace types into account. Note that @value needs to be the *normalized* value if the facet is of type &quot;pattern&quot;.</info>
      <return type='int' info='0 if the element is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet to check'/>
      <arg name='fws' type='xmlSchemaWhitespaceValueType' info='the whitespace type of the facet&apos;s value'/>
      <arg name='valType' type='xmlSchemaValType' info='the built-in type of the value'/>
      <arg name='value' type='const xmlChar *' info='the lexical (or normalized for pattern) repr of the value to validate'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
      <arg name='ws' type='xmlSchemaWhitespaceValueType' info='the whitespace type of the value'/>
    </function>
    <function name='xmlSchemaValidateFile' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Do a schemas validation of the given resource, it will use the SAX streamable validation internally.</info>
      <return type='int' info='0 if the document is valid, a positive error code number otherwise and -1 in case of an internal or API error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='filename' type='const char *' info='the URI of the instance'/>
      <arg name='options' type='int' info='a future set of options, currently unused'/>
    </function>
    <function name='xmlSchemaValidateLengthFacet' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Checka a value against a &quot;length&quot;, &quot;minLength&quot; and &quot;maxLength&quot; facet; sets @length to the computed length of @value.</info>
      <return type='int' info='0 if the value is valid, a positive error code otherwise and -1 in case of an internal or API error.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the built-in type'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet to check'/>
      <arg name='value' type='const xmlChar *' info='the lexical repr. of the value to be validated'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
      <arg name='length' type='unsigned long *' info='the actual length of the value'/>
    </function>
    <function name='xmlSchemaValidateLengthFacetWhtsp' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Checka a value against a &quot;length&quot;, &quot;minLength&quot; and &quot;maxLength&quot; facet; sets @length to the computed length of @value.</info>
      <return type='int' info='0 if the value is valid, a positive error code otherwise and -1 in case of an internal or API error.'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet to check'/>
      <arg name='valType' type='xmlSchemaValType' info='the built-in type'/>
      <arg name='value' type='const xmlChar *' info='the lexical repr. of the value to be validated'/>
      <arg name='val' type='xmlSchemaValPtr' info='the precomputed value'/>
      <arg name='length' type='unsigned long *' info='the actual length of the value'/>
      <arg name='ws' type='xmlSchemaWhitespaceValueType' info='the whitespace type of the value'/>
    </function>
    <function name='xmlSchemaValidateListSimpleTypeFacet' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Checks the value of a list simple type against a facet.</info>
      <return type='int' info='0 if the value is valid, a positive error code number otherwise and -1 in case of an internal error.'/>
      <arg name='facet' type='xmlSchemaFacetPtr' info='the facet to check'/>
      <arg name='value' type='const xmlChar *' info='the lexical repr of the value to validate'/>
      <arg name='actualLen' type='unsigned long' info='the number of list items'/>
      <arg name='expectedLen' type='unsigned long *' info='the resulting expected number of list items'/>
    </function>
    <function name='xmlSchemaValidateOneElement' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate a branch of a tree, starting with the given @elem.</info>
      <return type='int' info='0 if the element and its subtree is valid, a positive error code number otherwise and -1 in case of an internal or API error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='elem' type='xmlNodePtr' info='an element node'/>
    </function>
    <function name='xmlSchemaValidatePredefinedType' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of the predefined type. if true a value is computed and returned in @val.</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='type' type='xmlSchemaTypePtr' info='the predefined type'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='val' type='xmlSchemaValPtr *' info='the return computed value'/>
    </function>
    <function name='xmlSchemaValidateSetFilename' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Workaround to provide file error reporting information when this is not provided by current APIs</info>
      <return type='void'/>
      <arg name='vctxt' type='xmlSchemaValidCtxtPtr' info='the schema validation context'/>
      <arg name='filename' type='const char *' info='the file name'/>
    </function>
    <function name='xmlSchemaValidateSetLocator' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Allows to set a locator function to the validation context, which will be used to provide file and line information since those are not provided as part of the SAX validation flow Setting @f to NULL disable the locator.</info>
      <return type='void'/>
      <arg name='vctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='f' type='xmlSchemaValidityLocatorFunc' info='the locator function pointer'/>
      <arg name='ctxt' type='void *' info='the locator context'/>
    </function>
    <function name='xmlSchemaValidateStream' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate an input based on a flow of SAX event from the parser and forward the events to the @sax handler with the provided @user_data the user provided @sax handler must be a SAX2 one.</info>
      <return type='int' info='0 if the document is schemas valid, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='a schema validation context'/>
      <arg name='input' type='xmlParserInputBufferPtr' info='the input to use for reading the data'/>
      <arg name='enc' type='xmlCharEncoding' info='an optional encoding information'/>
      <arg name='sax' type='xmlSAXHandlerPtr' info='a SAX handler for the resulting events'/>
      <arg name='user_data' type='void *' info='the context to provide to the SAX handler.'/>
    </function>
    <functype name='xmlSchemaValidityErrorFunc' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Signature of an error callback from an XSD validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <functype name='xmlSchemaValidityLocatorFunc' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>A schemas validation locator, a callback called by the validator. This is used when file or node informations are not available to find out what file and line number are affected</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='ctx' type='void *' info='user provided context'/>
      <arg name='file' type='const char **' info='returned file information'/>
      <arg name='line' type='unsigned long *' info='returned line information'/>
    </functype>
    <functype name='xmlSchemaValidityWarningFunc' file='xmlschemas' module='xmlschemas'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Signature of a warning callback from an XSD validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <function name='xmlSchemaValueAppend' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Appends a next sibling to a list of computed values.</info>
      <return type='int' info='0 if succeeded and -1 on API errors.'/>
      <arg name='prev' type='xmlSchemaValPtr' info='the value'/>
      <arg name='cur' type='xmlSchemaValPtr' info='the value to be appended'/>
    </function>
    <function name='xmlSchemaValueGetAsBoolean' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Accessor for the boolean value of a computed value.</info>
      <return type='int' info='1 if true and 0 if false, or in case of an error. Hmm.'/>
      <arg name='val' type='xmlSchemaValPtr' info='the value'/>
    </function>
    <function name='xmlSchemaValueGetAsString' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Accessor for the string value of a computed value.</info>
      <return type='const xmlChar *' info='the string value or NULL if there was none, or on API errors.'/>
      <arg name='val' type='xmlSchemaValPtr' info='the value'/>
    </function>
    <function name='xmlSchemaValueGetNext' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Accessor for the next sibling of a list of computed values.</info>
      <return type='xmlSchemaValPtr' info='the next value or NULL if there was none, or on API errors.'/>
      <arg name='cur' type='xmlSchemaValPtr' info='the value'/>
    </function>
    <function name='xmlSchemaWhiteSpaceReplace' file='xmlschemastypes' module='xmlschemastypes'>
      <cond>defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Replaces 0xd, 0x9 and 0xa with a space.</info>
      <return type='xmlChar *' info='the new string or NULL if no change was required.'/>
      <arg name='value' type='const xmlChar *' info='a value'/>
    </function>
    <function name='xmlSchematronFree' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Deallocate a Schematron structure.</info>
      <return type='void'/>
      <arg name='schema' type='xmlSchematronPtr' info='a schema structure'/>
    </function>
    <function name='xmlSchematronFreeParserCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Free the resources associated to the schema parser context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchematronParserCtxtPtr' info='the schema parser context'/>
    </function>
    <function name='xmlSchematronFreeValidCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Free the resources associated to the schema validation context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchematronValidCtxtPtr' info='the schema validation context'/>
    </function>
    <function name='xmlSchematronNewDocParserCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Create an XML Schematrons parse context for that document. NB. The document may be modified during the parsing process.</info>
      <return type='xmlSchematronParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='doc' type='xmlDocPtr' info='a preparsed document tree'/>
    </function>
    <function name='xmlSchematronNewMemParserCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Create an XML Schematrons parse context for that memory buffer expected to contain an XML Schematrons file.</info>
      <return type='xmlSchematronParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='buffer' type='const char *' info='a pointer to a char array containing the schemas'/>
      <arg name='size' type='int' info='the size of the array'/>
    </function>
    <function name='xmlSchematronNewParserCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Create an XML Schematrons parse context for that file/resource expected to contain an XML Schematrons file.</info>
      <return type='xmlSchematronParserCtxtPtr' info='the parser context or NULL in case of error'/>
      <arg name='URL' type='const char *' info='the location of the schema'/>
    </function>
    <function name='xmlSchematronNewValidCtxt' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Create an XML Schematrons validation context based on the given schema.</info>
      <return type='xmlSchematronValidCtxtPtr' info='the validation context or NULL in case of error'/>
      <arg name='schema' type='xmlSchematronPtr' info='a precompiled XML Schematrons'/>
      <arg name='options' type='int' info='a set of xmlSchematronValidOptions'/>
    </function>
    <function name='xmlSchematronParse' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>parse a schema definition resource and build an internal XML Shema struture which can be used to validate instances.</info>
      <return type='xmlSchematronPtr' info='the internal XML Schematron structure built from the resource or NULL in case of error'/>
      <arg name='ctxt' type='xmlSchematronParserCtxtPtr' info='a schema validation context'/>
    </function>
    <function name='xmlSchematronSetValidStructuredErrors' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Set the structured error callback</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlSchematronValidCtxtPtr' info='a Schematron validation context'/>
      <arg name='serror' type='xmlStructuredErrorFunc' info='the structured error function'/>
      <arg name='ctx' type='void *' info='the functions context'/>
    </function>
    <function name='xmlSchematronValidateDoc' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Validate a tree instance against the schematron</info>
      <return type='int' info='0 in case of success, -1 in case of internal error and an error count otherwise.'/>
      <arg name='ctxt' type='xmlSchematronValidCtxtPtr' info='the schema validation context'/>
      <arg name='instance' type='xmlDocPtr' info='the document instace tree'/>
    </function>
    <functype name='xmlSchematronValidityErrorFunc' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Signature of an error callback from a Schematron validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <functype name='xmlSchematronValidityWarningFunc' file='schematron' module='schematron'>
      <cond>defined(LIBXML_SCHEMATRON_ENABLED)</cond>
      <info>Signature of a warning callback from a Schematron validation</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the validation context'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='...' type='...' info='extra arguments'/>
    </functype>
    <function name='xmlSearchNs' file='tree' module='tree'>
      <info>Search a Ns registered under a given name space for a document. recurse on the parents until it finds the defined namespace or return NULL otherwise. @nameSpace can be NULL, this is a search for the default namespace. We don&apos;t allow to cross entities boundaries. If you don&apos;t declare the namespace within those you will be in troubles !!! A warning is generated to cover this case.</info>
      <return type='xmlNsPtr' info='the namespace pointer or NULL.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
      <arg name='nameSpace' type='const xmlChar *' info='the namespace prefix'/>
    </function>
    <function name='xmlSearchNsByHref' file='tree' module='tree'>
      <info>Search a Ns aliasing a given URI. Recurse on the parents until it finds the defined namespace or return NULL otherwise.</info>
      <return type='xmlNsPtr' info='the namespace pointer or NULL.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='node' type='xmlNodePtr' info='the current node'/>
      <arg name='href' type='const xmlChar *' info='the namespace value'/>
    </function>
    <function name='xmlSetBufferAllocationScheme' file='tree' module='tree'>
      <info>Set the buffer allocation method.  Types are XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed, improves performance</info>
      <return type='void'/>
      <arg name='scheme' type='xmlBufferAllocationScheme' info='allocation method to use'/>
    </function>
    <function name='xmlSetCompressMode' file='tree' module='tree'>
      <info>set the default compression mode used, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='mode' type='int' info='the compression ratio'/>
    </function>
    <function name='xmlSetDocCompressMode' file='tree' module='tree'>
      <info>set the compression ratio for a document, ZLIB based Correct values: 0 (uncompressed) to 9 (max compression)</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='mode' type='int' info='the compression ratio'/>
    </function>
    <function name='xmlSetEntityReferenceFunc' file='parserInternals' module='parser'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Set the function to call call back when a xml reference has been made</info>
      <return type='void'/>
      <arg name='func' type='xmlEntityReferenceFunc' info='A valid function'/>
    </function>
    <function name='xmlSetExternalEntityLoader' file='parser' module='xmlIO'>
      <info>Changes the defaultexternal entity resolver function for the application</info>
      <return type='void'/>
      <arg name='f' type='xmlExternalEntityLoader' info='the new entity resolver function'/>
    </function>
    <function name='xmlSetFeature' file='parser' module='legacy'>
      <cond>defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Change the current value of one feature of this parser instance</info>
      <return type='int' info='-1 in case or error, 0 otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML/HTML parser context'/>
      <arg name='name' type='const char *' info='the feature name'/>
      <arg name='value' type='void *' info='pointer to the location of the new value'/>
    </function>
    <function name='xmlSetGenericErrorFunc' file='xmlerror' module='error'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE * than stderr by setting @ctx to this file handle and @handler to NULL. For multi-threaded applications, this must be set separately for each thread.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xmlSetListDoc' file='tree' module='tree'>
      <info>update all nodes in the list to point to the right document</info>
      <return type='void'/>
      <arg name='list' type='xmlNodePtr' info='the first element'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlSetNs' file='tree' module='tree'>
      <info>Associate a namespace to a node, a posteriori.</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='a node in the document'/>
      <arg name='ns' type='xmlNsPtr' info='a namespace pointer'/>
    </function>
    <function name='xmlSetNsProp' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)</cond>
      <info>Set (or reset) an attribute carried by a node. The ns structure must be in scope, this is not checked</info>
      <return type='xmlAttrPtr' info='the attribute pointer.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace definition'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='value' type='const xmlChar *' info='the attribute value'/>
    </function>
    <function name='xmlSetProp' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)</cond>
      <info>Set (or reset) an attribute carried by a node. If @name has a prefix, then the corresponding namespace-binding will be used, if in scope; it is an error it there&apos;s no such ns-binding for the prefix in scope.</info>
      <return type='xmlAttrPtr' info='the attribute pointer.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name (a QName)'/>
      <arg name='value' type='const xmlChar *' info='the attribute value'/>
    </function>
    <function name='xmlSetStructuredErrorFunc' file='xmlerror' module='error'>
      <info>Function to reset the handler and the error context for out of context structured error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler For multi-threaded applications, this must be set separately for each thread.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlStructuredErrorFunc' info='the new handler function'/>
    </function>
    <function name='xmlSetTreeDoc' file='tree' module='tree'>
      <info>update all nodes under the tree to point to the right document</info>
      <return type='void'/>
      <arg name='tree' type='xmlNodePtr' info='the top element'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
    </function>
    <function name='xmlSetupParserForBuffer' file='parser' module='parser'>
      <cond>defined(LIBXML_SAX1_ENABLED)</cond>
      <info>Setup the parser context to parse a new buffer; Clears any prior contents from the parser context. The buffer parameter must not be NULL, but the filename parameter can be</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='buffer' type='const xmlChar *' info='a xmlChar * buffer'/>
      <arg name='filename' type='const char *' info='a file name'/>
    </function>
    <function name='xmlShell' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell This allow to load, validate, view, modify and save a document using a environment similar to a UNIX commandline.</info>
      <return type='void'/>
      <arg name='doc' type='xmlDocPtr' info='the initial document'/>
      <arg name='filename' type='char *' info='the output buffer'/>
      <arg name='input' type='xmlShellReadlineFunc' info='the line reading function'/>
      <arg name='output' type='FILE *' info='the output FILE*, defaults to stdout if NULL'/>
    </function>
    <function name='xmlShellBase' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;base&quot; dumps the current XML base of the node</info>
      <return type='int' info='0'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='arg' type='char *' info='unused'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellCat' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Implements the XML shell function &quot;cat&quot; dumps the serialization node content (XML or HTML).</info>
      <return type='int' info='0'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='arg' type='char *' info='unused'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <functype name='xmlShellCmd' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>This is a generic signature for the XML shell functions.</info>
      <return type='int' info='an int, negative returns indicating errors.'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='a shell context'/>
      <arg name='arg' type='char *' info='a string argument'/>
      <arg name='node' type='xmlNodePtr' info='a first node'/>
      <arg name='node2' type='xmlNodePtr' info='a second node'/>
    </functype>
    <function name='xmlShellDir' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;dir&quot; dumps informations about the node (namespace, attributes, content).</info>
      <return type='int' info='0'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='arg' type='char *' info='unused'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellDu' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;du&quot; show the structure of the subtree under node @tree If @tree is null, the command works on the current node.</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='arg' type='char *' info='unused'/>
      <arg name='tree' type='xmlNodePtr' info='a node defining a subtree'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellList' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;ls&quot; Does an Unix like listing of the given node (like a directory)</info>
      <return type='int' info='0'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='arg' type='char *' info='unused'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellLoad' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;load&quot; loads a new document specified by the filename</info>
      <return type='int' info='0 or -1 if loading failed'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='filename' type='char *' info='the file name'/>
      <arg name='node' type='xmlNodePtr' info='unused'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellPrintNode' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Print node to the output FILE</info>
      <return type='void'/>
      <arg name='node' type='xmlNodePtr' info='a non-null node to print to the output FILE'/>
    </function>
    <function name='xmlShellPrintXPathError' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Print the xpath error to libxml default error channel</info>
      <return type='void'/>
      <arg name='errorType' type='int' info='valid xpath error id'/>
      <arg name='arg' type='const char *' info='the argument that cause xpath to fail'/>
    </function>
    <function name='xmlShellPrintXPathResult' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Prints result to the output FILE</info>
      <return type='void'/>
      <arg name='list' type='xmlXPathObjectPtr' info='a valid result generated by an xpath evaluation'/>
    </function>
    <function name='xmlShellPwd' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the XML shell function &quot;pwd&quot; Show the full path from the root to the node, if needed building thumblers when similar elements exists at a given ancestor level. The output is compatible with XPath commands.</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='buffer' type='char *' info='the output buffer'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <functype name='xmlShellReadlineFunc' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED)</cond>
      <info>This is a generic signature for the XML shell input function.</info>
      <return type='char *' info='a string which will be freed by the Shell.'/>
      <arg name='prompt' type='char *' info='a string prompt'/>
    </functype>
    <function name='xmlShellSave' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Implements the XML shell function &quot;save&quot; Write the current document to the filename, or it&apos;s original name</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='filename' type='char *' info='the file name (optional)'/>
      <arg name='node' type='xmlNodePtr' info='unused'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellValidate' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_VALID_ENABLED)</cond>
      <info>Implements the XML shell function &quot;validate&quot; Validate the document, if a DTD path is provided, then the validation is done against the given DTD.</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='dtd' type='char *' info='the DTD URI (optional)'/>
      <arg name='node' type='xmlNodePtr' info='unused'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlShellWrite' file='debugXML' module='debugXML'>
      <cond>defined(LIBXML_DEBUG_ENABLED) &amp;&amp; defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Implements the XML shell function &quot;write&quot; Write the current node to the filename, it saves the serialization of the subtree under the @node specified</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='ctxt' type='xmlShellCtxtPtr' info='the shell context'/>
      <arg name='filename' type='char *' info='the file name'/>
      <arg name='node' type='xmlNodePtr' info='a node in the tree'/>
      <arg name='node2' type='xmlNodePtr' info='unused'/>
    </function>
    <function name='xmlSkipBlankChars' file='parserInternals' module='parser'>
      <info>skip all blanks character found at that point in the input streams. It pops up finished entities in the process if allowable at that point.</info>
      <return type='int' info='the number of space chars skipped'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context'/>
    </function>
    <function name='xmlSnprintfElementContent' file='valid' module='valid'>
      <info>This will dump the content of the element content definition Intended just for the debug routine</info>
      <return type='void'/>
      <arg name='buf' type='char *' info='an output buffer'/>
      <arg name='size' type='int' info='the buffer size'/>
      <arg name='content' type='xmlElementContentPtr' info='An element table'/>
      <arg name='englob' type='int' info='1 if one must print the englobing parenthesis, 0 otherwise'/>
    </function>
    <function name='xmlSplitQName' file='parserInternals' module='parser'>
      <info>parse an UTF8 encoded XML qualified name string  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
      <return type='xmlChar *' info='the local part, and prefix is updated to get the Prefix if any.'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
      <arg name='name' type='const xmlChar *' info='an XML parser context'/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar **'/>
    </function>
    <function name='xmlSplitQName2' file='tree' module='tree'>
      <info>parse an XML qualified name string  [NS 5] QName ::= (Prefix &apos;:&apos;)? LocalPart  [NS 6] Prefix ::= NCName  [NS 7] LocalPart ::= NCName</info>
      <return type='xmlChar *' info='NULL if not a QName, otherwise the local part, and prefix is updated to get the Prefix if any.'/>
      <arg name='name' type='const xmlChar *' info='the full QName'/>
      <arg name='prefix' type='xmlChar **' info='a xmlChar **'/>
    </function>
    <function name='xmlSplitQName3' file='tree' module='tree'>
      <info>parse an XML qualified name string,i</info>
      <return type='const xmlChar *' info='NULL if it is not a Qualified Name, otherwise, update len with the length in byte of the prefix and return a pointer to the start of the name without the prefix'/>
      <arg name='name' type='const xmlChar *' info='the full QName'/>
      <arg name='len' type='int *' info='an int *'/>
    </function>
    <function name='xmlSprintfElementContent' file='valid' module='valid'>
      <cond>defined(LIBXML_OUTPUT_ENABLED)</cond>
      <info>Deprecated, unsafe, use xmlSnprintfElementContent</info>
      <return type='void'/>
      <arg name='buf' type='char *' info='an output buffer'/>
      <arg name='content' type='xmlElementContentPtr' info='An element table'/>
      <arg name='englob' type='int' info='1 if one must print the englobing parenthesis, 0 otherwise'/>
    </function>
    <function name='xmlStopParser' file='parser' module='parser'>
      <info>Blocks further parser processing</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='an XML parser context'/>
    </function>
    <function name='xmlStrEqual' file='xmlstring' module='xmlstring'>
      <info>Check if both strings are equal of have same content. Should be a bit more readable and faster than xmlStrcmp()</info>
      <return type='int' info='1 if they are equal, 0 if they are different'/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar *'/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar *'/>
    </function>
    <function name='xmlStrPrintf' file='xmlstring' module='xmlstring'>
      <info>Formats @msg and places result into @buf.</info>
      <return type='int' info='the number of characters written to @buf or -1 if an error occurs.'/>
      <arg name='buf' type='xmlChar *' info='the result buffer.'/>
      <arg name='len' type='int' info='the result buffer length.'/>
      <arg name='msg' type='const xmlChar *' info='the message with printf formatting.'/>
      <arg name='...' type='...' info='extra parameters for the message.'/>
    </function>
    <function name='xmlStrQEqual' file='xmlstring' module='xmlstring'>
      <info>Check if a QName is Equal to a given string</info>
      <return type='int' info='1 if they are equal, 0 if they are different'/>
      <arg name='pref' type='const xmlChar *' info='the prefix of the QName'/>
      <arg name='name' type='const xmlChar *' info='the localname of the QName'/>
      <arg name='str' type='const xmlChar *' info='the second xmlChar *'/>
    </function>
    <function name='xmlStrVPrintf' file='xmlstring' module='xmlstring'>
      <info>Formats @msg and places result into @buf.</info>
      <return type='int' info='the number of characters written to @buf or -1 if an error occurs.'/>
      <arg name='buf' type='xmlChar *' info='the result buffer.'/>
      <arg name='len' type='int' info='the result buffer length.'/>
      <arg name='msg' type='const xmlChar *' info='the message with printf formatting.'/>
      <arg name='ap' type='va_list' info='extra parameters for the message.'/>
    </function>
    <function name='xmlStrcasecmp' file='xmlstring' module='xmlstring'>
      <info>a strcasecmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison'/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar *'/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar *'/>
    </function>
    <function name='xmlStrcasestr' file='xmlstring' module='xmlstring'>
      <info>a case-ignoring strstr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL.'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack)'/>
      <arg name='val' type='const xmlChar *' info='the xmlChar to search (needle)'/>
    </function>
    <function name='xmlStrcat' file='xmlstring' module='xmlstring'>
      <info>a strcat for array of xmlChar&apos;s. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of &apos;0&apos;.</info>
      <return type='xmlChar *' info='a new xmlChar * containing the concatenated string.'/>
      <arg name='cur' type='xmlChar *' info='the original xmlChar * array'/>
      <arg name='add' type='const xmlChar *' info='the xmlChar * array added'/>
    </function>
    <function name='xmlStrchr' file='xmlstring' module='xmlstring'>
      <info>a strchr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL.'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array'/>
      <arg name='val' type='xmlChar' info='the xmlChar to search'/>
    </function>
    <function name='xmlStrcmp' file='xmlstring' module='xmlstring'>
      <info>a strcmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison'/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar *'/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar *'/>
    </function>
    <function name='xmlStrdup' file='xmlstring' module='xmlstring'>
      <info>a strdup for array of xmlChar&apos;s. Since they are supposed to be encoded in UTF-8 or an encoding with 8bit based chars, we assume a termination mark of &apos;0&apos;.</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL'/>
      <arg name='cur' type='const xmlChar *' info='the input xmlChar *'/>
    </function>
    <functype name='xmlStrdupFunc' file='xmlmemory' module='xmlmemory'>
      <info>Signature for an strdup() implementation.</info>
      <return type='char *' info='the copy of the string or NULL in case of error.'/>
      <arg name='str' type='const char *' info='a zero terminated string'/>
    </functype>
    <function name='xmlStreamPop' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>push one level from the stream.</info>
      <return type='int' info='-1 in case of error, 0 otherwise.'/>
      <arg name='stream' type='xmlStreamCtxtPtr' info='the stream context'/>
    </function>
    <function name='xmlStreamPush' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Push new data onto the stream. NOTE: if the call xmlPatterncompile() indicated a dictionary, then strings for name and ns will be expected to come from the dictionary. Both @name and @ns being NULL means the / i.e. the root of the document. This can also act as a reset. Otherwise the function will act as if it has been given an element-node.</info>
      <return type='int' info='-1 in case of error, 1 if the current state in the stream is a match and 0 otherwise.'/>
      <arg name='stream' type='xmlStreamCtxtPtr' info='the stream context'/>
      <arg name='name' type='const xmlChar *' info='the current name'/>
      <arg name='ns' type='const xmlChar *' info='the namespace name'/>
    </function>
    <function name='xmlStreamPushAttr' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Push new attribute data onto the stream. NOTE: if the call xmlPatterncompile() indicated a dictionary, then strings for name and ns will be expected to come from the dictionary. Both @name and @ns being NULL means the / i.e. the root of the document. This can also act as a reset. Otherwise the function will act as if it has been given an attribute-node.</info>
      <return type='int' info='-1 in case of error, 1 if the current state in the stream is a match and 0 otherwise.'/>
      <arg name='stream' type='xmlStreamCtxtPtr' info='the stream context'/>
      <arg name='name' type='const xmlChar *' info='the current name'/>
      <arg name='ns' type='const xmlChar *' info='the namespace name'/>
    </function>
    <function name='xmlStreamPushNode' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Push new data onto the stream. NOTE: if the call xmlPatterncompile() indicated a dictionary, then strings for name and ns will be expected to come from the dictionary. Both @name and @ns being NULL means the / i.e. the root of the document. This can also act as a reset. Different from xmlStreamPush() this function can be fed with nodes of type: element-, attribute-, text-, cdata-section-, comment- and processing-instruction-node.</info>
      <return type='int' info='-1 in case of error, 1 if the current state in the stream is a match and 0 otherwise.'/>
      <arg name='stream' type='xmlStreamCtxtPtr' info='the stream context'/>
      <arg name='name' type='const xmlChar *' info='the current name'/>
      <arg name='ns' type='const xmlChar *' info='the namespace name'/>
      <arg name='nodeType' type='int' info='the type of the node being pushed'/>
    </function>
    <function name='xmlStreamWantsAnyNode' file='pattern' module='pattern'>
      <cond>defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>Query if the streaming pattern additionally needs to be fed with text-, cdata-section-, comment- and processing-instruction-nodes. If the result is 0 then only element-nodes and attribute-nodes need to be pushed.</info>
      <return type='int' info='1 in case of need of nodes of the above described types, 0 otherwise. -1 on API errors.'/>
      <arg name='streamCtxt' type='xmlStreamCtxtPtr' info='the stream context'/>
    </function>
    <function name='xmlStringCurrentChar' file='parserInternals' module='parserInternals'>
      <info>The current char value, if using UTF-8 this may actually span multiple bytes in the input buffer.</info>
      <return type='int' info='the current char value and its length'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the XML parser context'/>
      <arg name='cur' type='const xmlChar *' info='pointer to the beginning of the char'/>
      <arg name='len' type='int *' info='pointer to the length of the char read'/>
    </function>
    <function name='xmlStringDecodeEntities' file='parserInternals' module='parser'>
      <info>Takes a entity string content and process to do the adequate substitutions.  [67] Reference ::= EntityRef | CharRef  [69] PEReference ::= &apos;%&apos; Name &apos;;&apos;</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it !'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='str' type='const xmlChar *' info='the input string'/>
      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF'/>
      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
    </function>
    <function name='xmlStringGetNodeList' file='tree' module='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr' info='a pointer to the first child'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='value' type='const xmlChar *' info='the value of the attribute'/>
    </function>
    <function name='xmlStringLenDecodeEntities' file='parserInternals' module='parser'>
      <info>Takes a entity string content and process to do the adequate substitutions.  [67] Reference ::= EntityRef | CharRef  [69] PEReference ::= &apos;%&apos; Name &apos;;&apos;</info>
      <return type='xmlChar *' info='A newly allocated string with the substitution done. The caller must deallocate it !'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='str' type='const xmlChar *' info='the input string'/>
      <arg name='len' type='int' info='the string length'/>
      <arg name='what' type='int' info='combination of XML_SUBSTITUTE_REF and XML_SUBSTITUTE_PEREF'/>
      <arg name='end' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end2' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
      <arg name='end3' type='xmlChar' info='an end marker xmlChar, 0 if none'/>
    </function>
    <function name='xmlStringLenGetNodeList' file='tree' module='tree'>
      <info>Parse the value string and build the node list associated. Should produce a flat tree with only TEXTs and ENTITY_REFs.</info>
      <return type='xmlNodePtr' info='a pointer to the first child'/>
      <arg name='doc' type='const xmlDoc *' info='the document'/>
      <arg name='value' type='const xmlChar *' info='the value of the text'/>
      <arg name='len' type='int' info='the length of the string value'/>
    </function>
    <function name='xmlStrlen' file='xmlstring' module='xmlstring'>
      <info>length of a xmlChar&apos;s string</info>
      <return type='int' info='the number of xmlChar contained in the ARRAY.'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array'/>
    </function>
    <function name='xmlStrncasecmp' file='xmlstring' module='xmlstring'>
      <info>a strncasecmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison'/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar *'/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar *'/>
      <arg name='len' type='int' info='the max comparison length'/>
    </function>
    <function name='xmlStrncat' file='xmlstring' module='xmlstring'>
      <info>a strncat for array of xmlChar&apos;s, it will extend @cur with the len first bytes of @add. Note that if @len &lt; 0 then this is an API error and NULL will be returned.</info>
      <return type='xmlChar *' info='a new xmlChar *, the original @cur is reallocated if needed and should not be freed'/>
      <arg name='cur' type='xmlChar *' info='the original xmlChar * array'/>
      <arg name='add' type='const xmlChar *' info='the xmlChar * array added'/>
      <arg name='len' type='int' info='the length of @add'/>
    </function>
    <function name='xmlStrncatNew' file='xmlstring' module='xmlstring'>
      <info>same as xmlStrncat, but creates a new string.  The original two strings are not freed. If @len is &lt; 0 then the length will be calculated automatically.</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL'/>
      <arg name='str1' type='const xmlChar *' info='first xmlChar string'/>
      <arg name='str2' type='const xmlChar *' info='second xmlChar string'/>
      <arg name='len' type='int' info='the len of @str2 or &lt; 0'/>
    </function>
    <function name='xmlStrncmp' file='xmlstring' module='xmlstring'>
      <info>a strncmp for xmlChar&apos;s</info>
      <return type='int' info='the integer result of the comparison'/>
      <arg name='str1' type='const xmlChar *' info='the first xmlChar *'/>
      <arg name='str2' type='const xmlChar *' info='the second xmlChar *'/>
      <arg name='len' type='int' info='the max comparison length'/>
    </function>
    <function name='xmlStrndup' file='xmlstring' module='xmlstring'>
      <info>a strndup for array of xmlChar&apos;s</info>
      <return type='xmlChar *' info='a new xmlChar * or NULL'/>
      <arg name='cur' type='const xmlChar *' info='the input xmlChar *'/>
      <arg name='len' type='int' info='the len of @cur'/>
    </function>
    <function name='xmlStrstr' file='xmlstring' module='xmlstring'>
      <info>a strstr for xmlChar&apos;s</info>
      <return type='const xmlChar *' info='the xmlChar * for the first occurrence or NULL.'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack)'/>
      <arg name='val' type='const xmlChar *' info='the xmlChar to search (needle)'/>
    </function>
    <function name='xmlStrsub' file='xmlstring' module='xmlstring'>
      <info>Extract a substring of a given string</info>
      <return type='xmlChar *' info='the xmlChar * for the first occurrence or NULL.'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar * array (haystack)'/>
      <arg name='start' type='int' info='the index of the first char (zero based)'/>
      <arg name='len' type='int' info='the length of the substring'/>
    </function>
    <functype name='xmlStructuredErrorFunc' file='xmlerror' module='xmlerror'>
      <info>Signature of the function to use when there is an error and the module handles the new error reporting mechanism.</info>
      <return type='void'/>
      <arg name='userData' type='void *' info='user provided data for the error callback'/>
      <arg name='error' type='xmlErrorPtr' info='the error being raised.'/>
    </functype>
    <function name='xmlSubstituteEntitiesDefault' file='parser' module='parserInternals'>
      <info>Set and return the previous value for default entity support. Initially the parser always keep entity references instead of substituting entity values in the output. This function has to be used to change the default parser behavior SAX::substituteEntities() has to be used for changing that on a file by file basis.</info>
      <return type='int' info='the last value for 0 for no substitution, 1 for substitution.'/>
      <arg name='val' type='int' info='int 0 or 1'/>
    </function>
    <function name='xmlSwitchEncoding' file='parserInternals' module='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int' info='0 in case of success, -1 otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='enc' type='xmlCharEncoding' info='the encoding value (number)'/>
    </function>
    <function name='xmlSwitchInputEncoding' file='parserInternals' module='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int' info='0 in case of success, -1 otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='input' type='xmlParserInputPtr' info='the input stream'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the encoding handler'/>
    </function>
    <function name='xmlSwitchToEncoding' file='parserInternals' module='parserInternals'>
      <info>change the input functions when discovering the character encoding of a given entity.</info>
      <return type='int' info='0 in case of success, -1 otherwise'/>
      <arg name='ctxt' type='xmlParserCtxtPtr' info='the parser context'/>
      <arg name='handler' type='xmlCharEncodingHandlerPtr' info='the encoding handler'/>
    </function>
    <function name='xmlTextConcat' file='tree' module='tree'>
      <info>Concat the given string at the end of the existing node content</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='content' type='const xmlChar *' info='the content'/>
      <arg name='len' type='int' info='@content length'/>
    </function>
    <function name='xmlTextMerge' file='tree' module='tree'>
      <info>Merge two text nodes into one</info>
      <return type='xmlNodePtr' info='the first text node augmented'/>
      <arg name='first' type='xmlNodePtr' info='the first text node'/>
      <arg name='second' type='xmlNodePtr' info='the second text node being merged'/>
    </function>
    <function name='xmlTextReaderAttributeCount' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the number of attributes of the current node</info>
      <return type='int' info='0 i no attributes, -1 in case of error or the attribute count'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderBaseUri' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The base URI of the node.</info>
      <return type='xmlChar *' info='the base URI or NULL if not available, if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderByteConsumed' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>This function provides the current index of the parser used by the reader, relative to the start of the current entity. This function actually just wraps a call to xmlBytesConsumed() for the parser context associated with the reader. See xmlBytesConsumed() for more information.</info>
      <return type='long' info='the index in bytes from the beginning of the entity or -1 in case the index could not be computed.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
    </function>
    <function name='xmlTextReaderClose' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>This method releases any resources allocated by the current instance changes the state to Closed and close any underlying input.</info>
      <return type='int' info='0 or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstBaseUri' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The base URI of the node.</info>
      <return type='const xmlChar *' info='the base URI or NULL if not available, the string will be deallocated with the reader'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstEncoding' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Determine the encoding of the document being read.</info>
      <return type='const xmlChar *' info='a string containing the encoding of the document or NULL in case of error.  The string is deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstLocalName' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The local name of the node.</info>
      <return type='const xmlChar *' info='the local name or NULL if not available, the string will be deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstName' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The qualified name of the node, equal to Prefix :LocalName.</info>
      <return type='const xmlChar *' info='the local name or NULL if not available, the string is deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstNamespaceUri' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The URI defining the namespace associated with the node.</info>
      <return type='const xmlChar *' info='the namespace URI or NULL if not available, the string will be deallocated with the reader'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstPrefix' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>A shorthand reference to the namespace associated with the node.</info>
      <return type='const xmlChar *' info='the prefix or NULL if not available, the string is deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstString' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Get an interned string from the reader, allows for example to speedup string name comparisons</info>
      <return type='const xmlChar *' info='an interned copy of the string or NULL in case of error. The string will be deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='str' type='const xmlChar *' info='the string to intern.'/>
    </function>
    <function name='xmlTextReaderConstValue' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the text value of the node if present</info>
      <return type='const xmlChar *' info='the string or NULL if not available. The result will be deallocated on the next Read() operation.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstXmlLang' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The xml:lang scope within which the node resides.</info>
      <return type='const xmlChar *' info='the xml:lang value or NULL if none exists.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderConstXmlVersion' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Determine the XML version of the document being read.</info>
      <return type='const xmlChar *' info='a string containing the XML version of the document or NULL in case of error.  The string is deallocated with the reader.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderCurrentDoc' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Hacking interface allowing to get the xmlDocPtr correponding to the current document being accessed by the xmlTextReader. NOTE: as a result of this call, the reader will not destroy the associated XML document and calling xmlFreeDoc() on the result is needed once the reader parsing has finished.</info>
      <return type='xmlDocPtr' info='the xmlDocPtr or NULL in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderCurrentNode' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Hacking interface allowing to get the xmlNodePtr correponding to the current node being accessed by the xmlTextReader. This is dangerous because the underlying node may be destroyed on the next Reads.</info>
      <return type='xmlNodePtr' info='the xmlNodePtr or NULL in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderDepth' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The depth of the node in the tree.</info>
      <return type='int' info='the depth or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <functype name='xmlTextReaderErrorFunc' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Signature of an error callback from a reader parser</info>
      <return type='void'/>
      <arg name='arg' type='void *' info='the user argument'/>
      <arg name='msg' type='const char *' info='the message'/>
      <arg name='severity' type='xmlParserSeverities' info='the severity of the error'/>
      <arg name='locator' type='xmlTextReaderLocatorPtr' info='a locator indicating where the error occured'/>
    </functype>
    <function name='xmlTextReaderExpand' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Reads the contents of the current node and the full subtree. It then makes the subtree available until the next xmlTextReaderRead() call</info>
      <return type='xmlNodePtr' info='a node pointer valid until the next xmlTextReaderRead() call or NULL in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderGetAttribute' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the value of the attribute with the specified qualified name.</info>
      <return type='xmlChar *' info='a string containing the value of the specified attribute, or NULL in case of error. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='name' type='const xmlChar *' info='the qualified name of the attribute.'/>
    </function>
    <function name='xmlTextReaderGetAttributeNo' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the value of the attribute with the specified index relative to the containing element.</info>
      <return type='xmlChar *' info='a string containing the value of the specified attribute, or NULL in case of error. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='no' type='int' info='the zero-based index of the attribute relative to the containing element'/>
    </function>
    <function name='xmlTextReaderGetAttributeNs' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the value of the specified attribute</info>
      <return type='xmlChar *' info='a string containing the value of the specified attribute, or NULL in case of error. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='localName' type='const xmlChar *' info='the local name of the attribute.'/>
      <arg name='namespaceURI' type='const xmlChar *' info='the namespace URI of the attribute.'/>
    </function>
    <function name='xmlTextReaderGetErrorHandler' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Retrieve the error callback function and user argument.</info>
      <return type='void'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='f' type='xmlTextReaderErrorFunc *' info='the callback function or NULL is no callback has been registered'/>
      <arg name='arg' type='void **' info='a user argument'/>
    </function>
    <function name='xmlTextReaderGetParserColumnNumber' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provide the column number of the current parsing point.</info>
      <return type='int' info='an int or 0 if not available'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the user data (XML reader context)'/>
    </function>
    <function name='xmlTextReaderGetParserLineNumber' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provide the line number of the current parsing point.</info>
      <return type='int' info='an int or 0 if not available'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the user data (XML reader context)'/>
    </function>
    <function name='xmlTextReaderGetParserProp' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Read the parser internal property.</info>
      <return type='int' info='the value, usually 0 or 1, or -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='prop' type='int' info='the xmlParserProperties to get'/>
    </function>
    <function name='xmlTextReaderGetRemainder' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Method to get the remainder of the buffered XML. this method stops the parser, set its state to End Of File and return the input stream with what is left that the parser did not use.  The implementation is not good, the parser certainly procgressed past what&apos;s left in reader-&gt;input, and there is an allocation problem. Best would be to rewrite it differently.</info>
      <return type='xmlParserInputBufferPtr' info='the xmlParserInputBufferPtr attached to the XML or NULL in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderHasAttributes' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Whether the node has attributes.</info>
      <return type='int' info='1 if true, 0 if false, and -1 in case or error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderHasValue' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Whether the node can have a text value.</info>
      <return type='int' info='1 if true, 0 if false, and -1 in case or error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderIsDefault' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Whether an Attribute  node was generated from the default value defined in the DTD or schema.</info>
      <return type='int' info='0 if not defaulted, 1 if defaulted, and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderIsEmptyElement' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Check if the current node is empty</info>
      <return type='int' info='1 if empty, 0 if not and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderIsNamespaceDecl' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Determine whether the current node is a namespace declaration rather than a regular attribute.</info>
      <return type='int' info='1 if the current node is a namespace declaration, 0 if it is a regular attribute or other type of node, or -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderIsValid' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Retrieve the validity status from the parser context</info>
      <return type='int' info='the flag value 1 if valid, 0 if no, and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderLocalName' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The local name of the node.</info>
      <return type='xmlChar *' info='the local name or NULL if not available, if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderLocatorBaseURI' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Obtain the base URI for the given locator.</info>
      <return type='xmlChar *' info='the base URI or NULL in case of error, if non NULL it need to be freed by the caller.'/>
      <arg name='locator' type='xmlTextReaderLocatorPtr' info='the xmlTextReaderLocatorPtr used'/>
    </function>
    <function name='xmlTextReaderLocatorLineNumber' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Obtain the line number for the given locator.</info>
      <return type='int' info='the line number or -1 in case of error.'/>
      <arg name='locator' type='xmlTextReaderLocatorPtr' info='the xmlTextReaderLocatorPtr used'/>
    </function>
    <function name='xmlTextReaderLookupNamespace' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Resolves a namespace prefix in the scope of the current element.</info>
      <return type='xmlChar *' info='a string containing the namespace URI to which the prefix maps or NULL in case of error. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix whose namespace URI is to be resolved. To return the default namespace, specify NULL'/>
    </function>
    <function name='xmlTextReaderMoveToAttribute' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the attribute with the specified qualified name.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not found'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='name' type='const xmlChar *' info='the qualified name of the attribute.'/>
    </function>
    <function name='xmlTextReaderMoveToAttributeNo' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the attribute with the specified index relative to the containing element.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not found'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='no' type='int' info='the zero-based index of the attribute relative to the containing element.'/>
    </function>
    <function name='xmlTextReaderMoveToAttributeNs' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the attribute with the specified local name and namespace URI.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not found'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='localName' type='const xmlChar *' info='the local name of the attribute.'/>
      <arg name='namespaceURI' type='const xmlChar *' info='the namespace URI of the attribute.'/>
    </function>
    <function name='xmlTextReaderMoveToElement' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the node that contains the current Attribute  node.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not moved'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderMoveToFirstAttribute' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the first attribute associated with the current node.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not found'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderMoveToNextAttribute' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the next attribute associated with the current node.</info>
      <return type='int' info='1 in case of success, -1 in case of error, 0 if not found'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderName' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The qualified name of the node, equal to Prefix :LocalName.</info>
      <return type='xmlChar *' info='the local name or NULL if not available, if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderNamespaceUri' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The URI defining the namespace associated with the node.</info>
      <return type='xmlChar *' info='the namespace URI or NULL if not available, if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderNext' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Skip to the node following the current one in document order while avoiding the subtree if any.</info>
      <return type='int' info='1 if the node was read successfully, 0 if there is no more nodes to read, or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderNextSibling' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Skip to the node following the current one in document order while avoiding the subtree if any. Currently implemented only for Readers built on a document</info>
      <return type='int' info='1 if the node was read successfully, 0 if there is no more nodes to read, or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderNodeType' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Get the node type of the current node Reference: http://www.gnu.org/software/dotgnu/pnetlib-doc/System/Xml/XmlNodeType.html</info>
      <return type='int' info='the xmlNodeType of the current node or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderNormalization' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The value indicating whether to normalize white space and attribute values. Since attribute value and end of line normalizations are a MUST in the XML specification only the value true is accepted. The broken bahaviour of accepting out of range character entities like &amp;#0; is of course not supported either.</info>
      <return type='int' info='1 or -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderPrefix' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>A shorthand reference to the namespace associated with the node.</info>
      <return type='xmlChar *' info='the prefix or NULL if not available, if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderPreserve' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>This tells the XML Reader to preserve the current node. The caller must also use xmlTextReaderCurrentDoc() to keep an handle on the resulting document once parsing has finished</info>
      <return type='xmlNodePtr' info='the xmlNodePtr or NULL in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderPreservePattern' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_PATTERN_ENABLED)</cond>
      <info>This tells the XML Reader to preserve all nodes matched by the pattern. The caller must also use xmlTextReaderCurrentDoc() to keep an handle on the resulting document once parsing has finished</info>
      <return type='int' info='a positive number in case of success and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='pattern' type='const xmlChar *' info='an XPath subset pattern'/>
      <arg name='namespaces' type='const xmlChar **' info='the prefix definitions, array of [URI, prefix] or NULL'/>
    </function>
    <function name='xmlTextReaderQuoteChar' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The quotation mark character used to enclose the value of an attribute.</info>
      <return type='int' info='&quot; or &apos; and -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderRead' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Moves the position of the current instance to the next node in the stream, exposing its properties.</info>
      <return type='int' info='1 if the node was read successfully, 0 if there is no more nodes to read, or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderReadAttributeValue' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Parses an attribute value into one or more Text and EntityReference nodes.</info>
      <return type='int' info='1 in case of success, 0 if the reader was not positionned on an ttribute node or all the attribute values have been read, or -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderReadInnerXml' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Reads the contents of the current node, including child nodes and markup.</info>
      <return type='xmlChar *' info='a string containing the XML content, or NULL if the current node is neither an element nor attribute, or has no child nodes. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderReadOuterXml' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Reads the contents of the current node, including child nodes and markup.</info>
      <return type='xmlChar *' info='a string containing the node and any XML content, or NULL if the current node cannot be serialized. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderReadState' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Gets the read state of the reader.</info>
      <return type='int' info='the state value, or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderReadString' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Reads the contents of an element or a text node as a string.</info>
      <return type='xmlChar *' info='a string containing the contents of the Element or Text node, or NULL if the reader is positioned on any other type of node. The string must be deallocated by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderRelaxNGSetSchema' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use RelaxNG to validate the document as it is processed. Activation is only possible before the first Read(). if @schema is NULL, then RelaxNG validation is desactivated. @ The @schema should not be freed until the reader is deallocated or its use has been deactivated.</info>
      <return type='int' info='0 in case the RelaxNG validation could be (des)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='schema' type='xmlRelaxNGPtr' info='a precompiled RelaxNG schema'/>
    </function>
    <function name='xmlTextReaderRelaxNGValidate' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use RelaxNG schema to validate the document as it is processed. Activation is only possible before the first Read(). If @rng is NULL, then RelaxNG schema validation is deactivated.</info>
      <return type='int' info='0 in case the schemas validation could be (de)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='rng' type='const char *' info='the path to a RelaxNG schema or NULL'/>
    </function>
    <function name='xmlTextReaderRelaxNGValidateCtxt' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use RelaxNG schema context to validate the document as it is processed. Activation is only possible before the first Read(). If @ctxt is NULL, then RelaxNG schema validation is deactivated.</info>
      <return type='int' info='0 in case the schemas validation could be (de)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='ctxt' type='xmlRelaxNGValidCtxtPtr' info='the RelaxNG schema validation context or NULL'/>
      <arg name='options' type='int' info='options (not used yet)'/>
    </function>
    <function name='xmlTextReaderSchemaValidate' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use W3C XSD schema to validate the document as it is processed. Activation is only possible before the first Read(). If @xsd is NULL, then XML Schema validation is deactivated.</info>
      <return type='int' info='0 in case the schemas validation could be (de)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='xsd' type='const char *' info='the path to a W3C XSD schema or NULL'/>
    </function>
    <function name='xmlTextReaderSchemaValidateCtxt' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use W3C XSD schema context to validate the document as it is processed. Activation is only possible before the first Read(). If @ctxt is NULL, then XML Schema validation is deactivated.</info>
      <return type='int' info='0 in case the schemas validation could be (de)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='ctxt' type='xmlSchemaValidCtxtPtr' info='the XML Schema validation context or NULL'/>
      <arg name='options' type='int' info='options (not used yet)'/>
    </function>
    <function name='xmlTextReaderSetErrorHandler' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Register a callback function that will be called on error and warnings.  If @f is NULL, the default error and warning handlers are restored.</info>
      <return type='void'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='f' type='xmlTextReaderErrorFunc' info='the callback function to call on error and warnings'/>
      <arg name='arg' type='void *' info='a user argument to pass to the callback function'/>
    </function>
    <function name='xmlTextReaderSetParserProp' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Change the parser processing behaviour by changing some of its internal properties. Note that some properties can only be changed before any read has been done.</info>
      <return type='int' info='0 if the call was successful, or -1 in case of error'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='prop' type='int' info='the xmlParserProperties to set'/>
      <arg name='value' type='int' info='usually 0 or 1 to (de)activate it'/>
    </function>
    <function name='xmlTextReaderSetSchema' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED) &amp;&amp; defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Use XSD Schema to validate the document as it is processed. Activation is only possible before the first Read(). if @schema is NULL, then Schema validation is desactivated. @ The @schema should not be freed until the reader is deallocated or its use has been deactivated.</info>
      <return type='int' info='0 in case the Schema validation could be (des)activated and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='schema' type='xmlSchemaPtr' info='a precompiled Schema schema'/>
    </function>
    <function name='xmlTextReaderSetStructuredErrorHandler' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Register a callback function that will be called on error and warnings.  If @f is NULL, the default error and warning handlers are restored.</info>
      <return type='void'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
      <arg name='f' type='xmlStructuredErrorFunc' info='the callback function to call on error and warnings'/>
      <arg name='arg' type='void *' info='a user argument to pass to the callback function'/>
    </function>
    <function name='xmlTextReaderSetup' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Setup an XML reader with new options</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='an XML reader'/>
      <arg name='input' type='xmlParserInputBufferPtr' info='xmlParserInputBufferPtr used to feed the reader, will be destroyed with it.'/>
      <arg name='URL' type='const char *' info='the base URL to use for the document'/>
      <arg name='encoding' type='const char *' info='the document encoding, or NULL'/>
      <arg name='options' type='int' info='a combination of xmlParserOption'/>
    </function>
    <function name='xmlTextReaderStandalone' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Determine the standalone status of the document being read.</info>
      <return type='int' info='1 if the document was declared to be standalone, 0 if it was declared to be not standalone, or -1 if the document did not specify its standalone status or in case of error.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderValue' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>Provides the text value of the node if present</info>
      <return type='xmlChar *' info='the string or NULL if not available. The result must be deallocated with xmlFree()'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextReaderXmlLang' file='xmlreader' module='xmlreader'>
      <cond>defined(LIBXML_READER_ENABLED)</cond>
      <info>The xml:lang scope within which the node resides.</info>
      <return type='xmlChar *' info='the xml:lang value or NULL if none exists., if non NULL it need to be freed by the caller.'/>
      <arg name='reader' type='xmlTextReaderPtr' info='the xmlTextReaderPtr used'/>
    </function>
    <function name='xmlTextWriterEndAttribute' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End the current xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndCDATA' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml CDATA section.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndComment' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End the current xml coment.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndDTD' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml DTD.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndDTDAttlist' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml DTD attribute list.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndDTDElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml DTD element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndDTDEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml DTD entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndDocument' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End an xml document. All open elements are closed, and the content is flushed to the output.</info>
      <return type='int' info='the bytes written or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End the current xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterEndPI' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End the current xml PI.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterFlush' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Flush the output buffer.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterFullEndElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>End the current xml element. Writes an end tag even if the element is empty</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterSetIndent' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Set indentation output. indent = 0 do not indentation. indent &gt; 0 do indentation.</info>
      <return type='int' info='-1 on error or 0 otherwise.'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='indent' type='int' info='do indentation?'/>
    </function>
    <function name='xmlTextWriterSetIndentString' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Set string indentation.</info>
      <return type='int' info='-1 on error or 0 otherwise.'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='str' type='const xmlChar *' info='the xmlChar string'/>
    </function>
    <function name='xmlTextWriterSetQuoteChar' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Set the character used for quoting attributes.</info>
      <return type='int' info='-1 on error or 0 otherwise.'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='quotechar' type='xmlChar' info='the quote character'/>
    </function>
    <function name='xmlTextWriterStartAttribute' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml attribute.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='element name'/>
    </function>
    <function name='xmlTextWriterStartAttributeNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml attribute with namespace support.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix or NULL'/>
      <arg name='name' type='const xmlChar *' info='element local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI or NULL'/>
    </function>
    <function name='xmlTextWriterStartCDATA' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml CDATA section.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterStartComment' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml comment.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
    </function>
    <function name='xmlTextWriterStartDTD' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml DTD.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
    </function>
    <function name='xmlTextWriterStartDTDAttlist' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml DTD ATTLIST.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD ATTLIST'/>
    </function>
    <function name='xmlTextWriterStartDTDElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml DTD element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD element'/>
    </function>
    <function name='xmlTextWriterStartDTDEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml DTD ATTLIST.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD ATTLIST'/>
    </function>
    <function name='xmlTextWriterStartDocument' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start a new xml document</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='version' type='const char *' info='the xml version (&quot;1.0&quot;) or NULL for default (&quot;1.0&quot;)'/>
      <arg name='encoding' type='const char *' info='the encoding or NULL for default'/>
      <arg name='standalone' type='const char *' info='&quot;yes&quot; or &quot;no&quot; or NULL for default'/>
    </function>
    <function name='xmlTextWriterStartElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='element name'/>
    </function>
    <function name='xmlTextWriterStartElementNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml element with namespace support.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix or NULL'/>
      <arg name='name' type='const xmlChar *' info='element local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI or NULL'/>
    </function>
    <function name='xmlTextWriterStartPI' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Start an xml PI.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='target' type='const xmlChar *' info='PI target'/>
    </function>
    <function name='xmlTextWriterWriteAttribute' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml attribute.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='attribute name'/>
      <arg name='content' type='const xmlChar *' info='attribute content'/>
    </function>
    <function name='xmlTextWriterWriteAttributeNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml attribute.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='attribute local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='content' type='const xmlChar *' info='attribute content'/>
    </function>
    <function name='xmlTextWriterWriteBase64' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an base64 encoded xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='data' type='const char *' info='binary data'/>
      <arg name='start' type='int' info='the position within the data of the first byte to encode'/>
      <arg name='len' type='int' info='the number of bytes to encode'/>
    </function>
    <function name='xmlTextWriterWriteBinHex' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a BinHex encoded xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='data' type='const char *' info='binary data'/>
      <arg name='start' type='int' info='the position within the data of the first byte to encode'/>
      <arg name='len' type='int' info='the number of bytes to encode'/>
    </function>
    <function name='xmlTextWriterWriteCDATA' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml CDATA.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='content' type='const xmlChar *' info='CDATA content'/>
    </function>
    <function name='xmlTextWriterWriteComment' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml comment.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='content' type='const xmlChar *' info='comment string'/>
    </function>
    <function name='xmlTextWriterWriteDTD' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='subset' type='const xmlChar *' info='string content of the DTD'/>
    </function>
    <function name='xmlTextWriterWriteDTDAttlist' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD ATTLIST.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD ATTLIST'/>
      <arg name='content' type='const xmlChar *' info='content of the ATTLIST'/>
    </function>
    <function name='xmlTextWriterWriteDTDElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD element'/>
      <arg name='content' type='const xmlChar *' info='content of the element'/>
    </function>
    <function name='xmlTextWriterWriteDTDEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD entity'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='ndataid' type='const xmlChar *' info='the xml notation name.'/>
      <arg name='content' type='const xmlChar *' info='content of the entity'/>
    </function>
    <function name='xmlTextWriterWriteDTDExternalEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD external entity. The entity must have been started with xmlTextWriterStartDTDEntity</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD entity'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='ndataid' type='const xmlChar *' info='the xml notation name.'/>
    </function>
    <function name='xmlTextWriterWriteDTDExternalEntityContents' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write the contents of a DTD external entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='ndataid' type='const xmlChar *' info='the xml notation name.'/>
    </function>
    <function name='xmlTextWriterWriteDTDInternalEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD internal entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD entity'/>
      <arg name='content' type='const xmlChar *' info='content of the entity'/>
    </function>
    <function name='xmlTextWriterWriteDTDNotation' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the xml notation'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
    </function>
    <function name='xmlTextWriterWriteElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='element name'/>
      <arg name='content' type='const xmlChar *' info='element content'/>
    </function>
    <function name='xmlTextWriterWriteElementNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml element with namespace support.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='element local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='content' type='const xmlChar *' info='element content'/>
    </function>
    <function name='xmlTextWriterWriteFormatAttribute' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml attribute.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='attribute name'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatAttributeNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml attribute.with namespace support</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='attribute local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatCDATA' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml CDATA.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatComment' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml comment.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatDTD' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD with a formatted markup declarations part.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatDTDAttlist' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD ATTLIST.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD ATTLIST'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatDTDElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD element'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatDTDInternalEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD internal entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD entity'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='element name'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatElementNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml element with namespace support.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='element local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatPI' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted PI.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='target' type='const xmlChar *' info='PI target'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatRaw' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted raw xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWriteFormatString' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='...' type='...' info='extra parameters for the format'/>
    </function>
    <function name='xmlTextWriterWritePI' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml PI.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='target' type='const xmlChar *' info='PI target'/>
      <arg name='content' type='const xmlChar *' info='PI content'/>
    </function>
    <function name='xmlTextWriterWriteRaw' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a raw xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='content' type='const xmlChar *' info='text string'/>
    </function>
    <function name='xmlTextWriterWriteRawLen' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml text. TODO: what about entities and special chars??</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='content' type='const xmlChar *' info='text string'/>
      <arg name='len' type='int' info='length of the text string'/>
    </function>
    <function name='xmlTextWriterWriteString' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='content' type='const xmlChar *' info='text string'/>
    </function>
    <function name='xmlTextWriterWriteVFormatAttribute' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml attribute.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='attribute name'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatAttributeNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml attribute.with namespace support</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='attribute local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatCDATA' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml CDATA.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatComment' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write an xml comment.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatDTD' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a DTD with a formatted markup declarations part.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD'/>
      <arg name='pubid' type='const xmlChar *' info='the public identifier, which is an alternative to the system identifier'/>
      <arg name='sysid' type='const xmlChar *' info='the system identifier, which is the URI of the DTD'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatDTDAttlist' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD ATTLIST.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD ATTLIST'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatDTDElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD element'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatDTDInternalEntity' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted DTD internal entity.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='pe' type='int' info='TRUE if this is a parameter entity, FALSE if not'/>
      <arg name='name' type='const xmlChar *' info='the name of the DTD entity'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatElement' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml element.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='name' type='const xmlChar *' info='element name'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatElementNS' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml element with namespace support.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='prefix' type='const xmlChar *' info='namespace prefix'/>
      <arg name='name' type='const xmlChar *' info='element local name'/>
      <arg name='namespaceURI' type='const xmlChar *' info='namespace URI'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatPI' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml PI.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='target' type='const xmlChar *' info='PI target'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatRaw' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted raw xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlTextWriterWriteVFormatString' file='xmlwriter' module='xmlwriter'>
      <cond>defined(LIBXML_WRITER_ENABLED)</cond>
      <info>Write a formatted xml text.</info>
      <return type='int' info='the bytes written (may be 0 because of buffering) or -1 in case of error'/>
      <arg name='writer' type='xmlTextWriterPtr' info='the xmlTextWriterPtr'/>
      <arg name='format' type='const char *' info='format string (see printf)'/>
      <arg name='argptr' type='va_list' info='pointer to the first member of the variable argument list.'/>
    </function>
    <function name='xmlThrDefBufferAllocScheme' file='globals' module='globals'>
      <info></info>
      <return type='xmlBufferAllocationScheme' info=''/>
      <arg name='v' type='xmlBufferAllocationScheme' info=''/>
    </function>
    <function name='xmlThrDefDefaultBufferSize' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefDeregisterNodeDefault' file='globals' module='globals'>
      <info></info>
      <return type='xmlDeregisterNodeFunc' info=''/>
      <arg name='func' type='xmlDeregisterNodeFunc' info=''/>
    </function>
    <function name='xmlThrDefDoValidityCheckingDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefGetWarningsDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefIndentTreeOutput' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefKeepBlanksDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefLineNumbersDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefLoadExtDtdDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefOutputBufferCreateFilenameDefault' file='globals' module='globals'>
      <info></info>
      <return type='xmlOutputBufferCreateFilenameFunc' info=''/>
      <arg name='func' type='xmlOutputBufferCreateFilenameFunc' info=''/>
    </function>
    <function name='xmlThrDefParserDebugEntities' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefParserInputBufferCreateFilenameDefault' file='globals' module='globals'>
      <info></info>
      <return type='xmlParserInputBufferCreateFilenameFunc' info=''/>
      <arg name='func' type='xmlParserInputBufferCreateFilenameFunc' info=''/>
    </function>
    <function name='xmlThrDefPedanticParserDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefRegisterNodeDefault' file='globals' module='globals'>
      <info></info>
      <return type='xmlRegisterNodeFunc' info=''/>
      <arg name='func' type='xmlRegisterNodeFunc' info=''/>
    </function>
    <function name='xmlThrDefSaveNoEmptyTags' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefSetGenericErrorFunc' file='globals' module='globals'>
      <info></info>
      <return type='void'/>
      <arg name='ctx' type='void *' info=''/>
      <arg name='handler' type='xmlGenericErrorFunc' info=''/>
    </function>
    <function name='xmlThrDefSetStructuredErrorFunc' file='globals' module='globals'>
      <info></info>
      <return type='void'/>
      <arg name='ctx' type='void *' info=''/>
      <arg name='handler' type='xmlStructuredErrorFunc' info=''/>
    </function>
    <function name='xmlThrDefSubstituteEntitiesDefaultValue' file='globals' module='globals'>
      <info></info>
      <return type='int' info=''/>
      <arg name='v' type='int' info=''/>
    </function>
    <function name='xmlThrDefTreeIndentString' file='globals' module='globals'>
      <info></info>
      <return type='const char *' info=''/>
      <arg name='v' type='const char *' info=''/>
    </function>
    <function name='xmlUCSIsAegeanNumbers' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of AegeanNumbers UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsAlphabeticPresentationForms' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of AlphabeticPresentationForms UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsArabic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Arabic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsArabicPresentationFormsA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of ArabicPresentationForms-A UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsArabicPresentationFormsB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of ArabicPresentationForms-B UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsArmenian' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Armenian UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsArrows' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Arrows UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBasicLatin' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of BasicLatin UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBengali' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Bengali UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBlock' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of the UCS Block</info>
      <return type='int' info='1 if true, 0 if false and -1 on unknown block'/>
      <arg name='code' type='int' info='UCS code point'/>
      <arg name='block' type='const char *' info='UCS block name'/>
    </function>
    <function name='xmlUCSIsBlockElements' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of BlockElements UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBopomofo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Bopomofo UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBopomofoExtended' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of BopomofoExtended UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBoxDrawing' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of BoxDrawing UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBraillePatterns' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of BraillePatterns UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsBuhid' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Buhid UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsByzantineMusicalSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of ByzantineMusicalSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKCompatibility' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKCompatibility UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityForms' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKCompatibilityForms UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityIdeographs' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKCompatibilityIdeographs UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKCompatibilityIdeographsSupplement' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKCompatibilityIdeographsSupplement UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKRadicalsSupplement' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKRadicalsSupplement UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKSymbolsandPunctuation' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKSymbolsandPunctuation UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographs' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKUnifiedIdeographs UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographsExtensionA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKUnifiedIdeographsExtensionA UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCJKUnifiedIdeographsExtensionB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CJKUnifiedIdeographsExtensionB UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCat' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of the UCS Category</info>
      <return type='int' info='1 if true, 0 if false and -1 on unknown category'/>
      <arg name='code' type='int' info='UCS code point'/>
      <arg name='cat' type='const char *' info='UCS Category name'/>
    </function>
    <function name='xmlUCSIsCatC' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of C UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatCc' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Cc UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatCf' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Cf UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatCo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Co UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatCs' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Cs UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatL' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of L UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatLl' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Ll UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatLm' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Lm UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatLo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Lo UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatLt' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Lt UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatLu' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Lu UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatM' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of M UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatMc' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Mc UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatMe' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Me UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatMn' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Mn UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatN' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of N UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatNd' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Nd UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatNl' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Nl UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatNo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of No UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatP' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of P UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPc' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Pc UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPd' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Pd UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPe' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Pe UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPf' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Pf UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPi' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Pi UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Po UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatPs' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Ps UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatS' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of S UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatSc' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Sc UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatSk' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Sk UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatSm' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Sm UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatSo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of So UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatZ' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Z UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatZl' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Zl UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatZp' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Zp UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCatZs' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Zs UCS Category</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCherokee' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Cherokee UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCombiningDiacriticalMarks' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CombiningDiacriticalMarks UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCombiningDiacriticalMarksforSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CombiningDiacriticalMarksforSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCombiningHalfMarks' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CombiningHalfMarks UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCombiningMarksforSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CombiningMarksforSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsControlPictures' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of ControlPictures UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCurrencySymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CurrencySymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCypriotSyllabary' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CypriotSyllabary UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCyrillic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Cyrillic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsCyrillicSupplement' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of CyrillicSupplement UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsDeseret' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Deseret UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsDevanagari' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Devanagari UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsDingbats' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Dingbats UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsEnclosedAlphanumerics' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of EnclosedAlphanumerics UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsEnclosedCJKLettersandMonths' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of EnclosedCJKLettersandMonths UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsEthiopic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Ethiopic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGeneralPunctuation' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of GeneralPunctuation UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGeometricShapes' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of GeometricShapes UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGeorgian' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Georgian UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGothic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Gothic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGreek' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Greek UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGreekExtended' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of GreekExtended UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGreekandCoptic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of GreekandCoptic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGujarati' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Gujarati UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsGurmukhi' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Gurmukhi UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHalfwidthandFullwidthForms' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HalfwidthandFullwidthForms UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHangulCompatibilityJamo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HangulCompatibilityJamo UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHangulJamo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HangulJamo UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHangulSyllables' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HangulSyllables UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHanunoo' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Hanunoo UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHebrew' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Hebrew UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHighPrivateUseSurrogates' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HighPrivateUseSurrogates UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHighSurrogates' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of HighSurrogates UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsHiragana' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Hiragana UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsIPAExtensions' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of IPAExtensions UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsIdeographicDescriptionCharacters' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of IdeographicDescriptionCharacters UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKanbun' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Kanbun UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKangxiRadicals' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of KangxiRadicals UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKannada' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Kannada UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKatakana' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Katakana UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKatakanaPhoneticExtensions' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of KatakanaPhoneticExtensions UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKhmer' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Khmer UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsKhmerSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of KhmerSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLao' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Lao UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLatin1Supplement' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Latin-1Supplement UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLatinExtendedA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LatinExtended-A UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLatinExtendedAdditional' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LatinExtendedAdditional UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLatinExtendedB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LatinExtended-B UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLetterlikeSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LetterlikeSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLimbu' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Limbu UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLinearBIdeograms' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LinearBIdeograms UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLinearBSyllabary' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LinearBSyllabary UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsLowSurrogates' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of LowSurrogates UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMalayalam' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Malayalam UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMathematicalAlphanumericSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MathematicalAlphanumericSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMathematicalOperators' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MathematicalOperators UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMiscellaneousMathematicalSymbolsA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MiscellaneousMathematicalSymbols-A UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMiscellaneousMathematicalSymbolsB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MiscellaneousMathematicalSymbols-B UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMiscellaneousSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MiscellaneousSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMiscellaneousSymbolsandArrows' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MiscellaneousSymbolsandArrows UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMiscellaneousTechnical' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MiscellaneousTechnical UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMongolian' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Mongolian UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMusicalSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of MusicalSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsMyanmar' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Myanmar UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsNumberForms' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of NumberForms UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsOgham' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Ogham UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsOldItalic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of OldItalic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsOpticalCharacterRecognition' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of OpticalCharacterRecognition UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsOriya' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Oriya UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsOsmanya' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Osmanya UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsPhoneticExtensions' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of PhoneticExtensions UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsPrivateUse' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of PrivateUse UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsPrivateUseArea' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of PrivateUseArea UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsRunic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Runic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsShavian' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Shavian UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSinhala' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Sinhala UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSmallFormVariants' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SmallFormVariants UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSpacingModifierLetters' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SpacingModifierLetters UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSpecials' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Specials UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSuperscriptsandSubscripts' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SuperscriptsandSubscripts UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSupplementalArrowsA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SupplementalArrows-A UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSupplementalArrowsB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SupplementalArrows-B UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSupplementalMathematicalOperators' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SupplementalMathematicalOperators UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSupplementaryPrivateUseAreaA' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SupplementaryPrivateUseArea-A UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSupplementaryPrivateUseAreaB' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of SupplementaryPrivateUseArea-B UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsSyriac' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Syriac UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTagalog' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Tagalog UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTagbanwa' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Tagbanwa UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTags' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Tags UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTaiLe' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of TaiLe UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTaiXuanJingSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of TaiXuanJingSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTamil' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Tamil UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTelugu' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Telugu UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsThaana' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Thaana UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsThai' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Thai UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsTibetan' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Tibetan UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsUgaritic' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of Ugaritic UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsUnifiedCanadianAboriginalSyllabics' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of UnifiedCanadianAboriginalSyllabics UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsVariationSelectors' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of VariationSelectors UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsVariationSelectorsSupplement' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of VariationSelectorsSupplement UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsYiRadicals' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of YiRadicals UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsYiSyllables' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of YiSyllables UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlUCSIsYijingHexagramSymbols' file='xmlunicode' module='xmlunicode'>
      <cond>defined(LIBXML_UNICODE_ENABLED)</cond>
      <info>Check whether the character is part of YijingHexagramSymbols UCS Block</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='code' type='int' info='UCS code point'/>
    </function>
    <function name='xmlURIEscape' file='uri' module='uri'>
      <info>Escaping routine, does not do validity checks ! It will try to escape the chars needing this, but this is heuristic based it&apos;s impossible to be sure.</info>
      <return type='xmlChar *' info='an copy of the string, but escaped  25 May 2001 Uses xmlParseURI and xmlURIEscapeStr to try to escape correctly according to RFC2396. - Carl Douglas'/>
      <arg name='str' type='const xmlChar *' info='the string of the URI to escape'/>
    </function>
    <function name='xmlURIEscapeStr' file='uri' module='uri'>
      <info>This routine escapes a string to hex, ignoring reserved characters (a-z) and the characters in the exception list.</info>
      <return type='xmlChar *' info='a new escaped string or NULL in case of error.'/>
      <arg name='str' type='const xmlChar *' info='string to escape'/>
      <arg name='list' type='const xmlChar *' info='exception list string of chars not to escape'/>
    </function>
    <function name='xmlURIUnescapeString' file='uri' module='uri'>
      <info>Unescaping routine, but does not check that the string is an URI. The output is a direct unsigned char translation of %XX values (no encoding) Note that the length of the result can only be smaller or same size as the input string.</info>
      <return type='char *' info='a copy of the string, but unescaped, will return NULL only in case of error'/>
      <arg name='str' type='const char *' info='the string to unescape'/>
      <arg name='len' type='int' info='the length in bytes to unescape (or &lt;= 0 to indicate full string)'/>
      <arg name='target' type='char *' info='optional destination buffer'/>
    </function>
    <function name='xmlUTF8Charcmp' file='xmlstring' module='xmlstring'>
      <info>compares the two UCS4 values</info>
      <return type='int' info='result of the compare as with xmlStrncmp'/>
      <arg name='utf1' type='const xmlChar *' info='pointer to first UTF8 char'/>
      <arg name='utf2' type='const xmlChar *' info='pointer to second UTF8 char'/>
    </function>
    <function name='xmlUTF8Size' file='xmlstring' module='xmlstring'>
      <info>calculates the internal size of a UTF8 character</info>
      <return type='int' info='the numbers of bytes in the character, -1 on format error'/>
      <arg name='utf' type='const xmlChar *' info='pointer to the UTF8 character'/>
    </function>
    <function name='xmlUTF8Strlen' file='xmlstring' module='xmlstring'>
      <info>compute the length of an UTF8 string, it doesn&apos;t do a full UTF8 checking of the content of the string.</info>
      <return type='int' info='the number of characters in the string or -1 in case of error'/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes'/>
    </function>
    <function name='xmlUTF8Strloc' file='xmlstring' module='xmlstring'>
      <info>a function to provide the relative location of a UTF8 char</info>
      <return type='int' info='the relative character position of the desired char or -1 if not found'/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 *'/>
      <arg name='utfchar' type='const xmlChar *' info='the UTF8 character to be found'/>
    </function>
    <function name='xmlUTF8Strndup' file='xmlstring' module='xmlstring'>
      <info>a strndup for array of UTF8&apos;s</info>
      <return type='xmlChar *' info='a new UTF8 * or NULL'/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 *'/>
      <arg name='len' type='int' info='the len of @utf (in chars)'/>
    </function>
    <function name='xmlUTF8Strpos' file='xmlstring' module='xmlstring'>
      <info>a function to provide the equivalent of fetching a character from a string array</info>
      <return type='const xmlChar *' info='a pointer to the UTF8 character or NULL'/>
      <arg name='utf' type='const xmlChar *' info='the input UTF8 *'/>
      <arg name='pos' type='int' info='the position of the desired UTF8 char (in chars)'/>
    </function>
    <function name='xmlUTF8Strsize' file='xmlstring' module='xmlstring'>
      <info>storage size of an UTF8 string the behaviour is not garanteed if the input string is not UTF-8</info>
      <return type='int' info='the storage size of the first &apos;len&apos; characters of ARRAY'/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes'/>
      <arg name='len' type='int' info='the number of characters in the array'/>
    </function>
    <function name='xmlUTF8Strsub' file='xmlstring' module='xmlstring'>
      <info>Create a substring from a given UTF-8 string Note:  positions are given in units of UTF-8 chars</info>
      <return type='xmlChar *' info='a pointer to a newly created string or NULL if any problem'/>
      <arg name='utf' type='const xmlChar *' info='a sequence of UTF-8 encoded bytes'/>
      <arg name='start' type='int' info='relative pos of first char'/>
      <arg name='len' type='int' info='total number to copy'/>
    </function>
    <function name='xmlUnlinkNode' file='tree' module='tree'>
      <info>Unlink a node from it&apos;s current context, the node is not freed If one need to free the node, use xmlFreeNode() routine after the unlink to discard it. Note that namespace nodes can&apos;t be unlinked as they do not have pointer to their parent.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='the node'/>
    </function>
    <function name='xmlUnlockLibrary' file='threads' module='threads'>
      <info>xmlUnlockLibrary() is used to release a re-entrant lock on the libxml2 library.</info>
      <return type='void'/>
    </function>
    <function name='xmlUnsetNsProp' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Remove an attribute carried by a node.</info>
      <return type='int' info='0 if successful, -1 if not found'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace definition'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlUnsetProp' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Remove an attribute carried by a node. This handles only attributes in no namespace.</info>
      <return type='int' info='0 if successful, -1 if not found'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
    </function>
    <function name='xmlValidBuildContentModel' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED) &amp;&amp; defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>(Re)Build the automata associated to the content model of this element</info>
      <return type='int' info='1 in case of success, 0 in case of error'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='a validation context'/>
      <arg name='elem' type='xmlElementPtr' info='an element declaration node'/>
    </function>
    <function name='xmlValidCtxtNormalizeAttributeValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Does the validation related extra step of the normalization of attribute values:  If the declared value is not CDATA, then the XML processor must further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by single space (#x20) character.  Also  check VC: Standalone Document Declaration in P32, and update ctxt-&gt;valid accordingly</info>
      <return type='xmlChar *' info='a new normalized string if normalization is needed, NULL otherwise the caller must free the returned value.'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context or NULL'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='elem' type='xmlNodePtr' info='the parent'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='value' type='const xmlChar *' info='the attribute value'/>
    </function>
    <function name='xmlValidGetPotentialChildren' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Build/extend a list of  potential children allowed by the content tree</info>
      <return type='int' info='the number of element in the list, or -1 in case of error.'/>
      <arg name='ctree' type='xmlElementContent *' info='an element content tree'/>
      <arg name='names' type='const xmlChar **' info='an array to store the list of child names'/>
      <arg name='len' type='int *' info='a pointer to the number of element in the list'/>
      <arg name='max' type='int' info='the size of the array'/>
    </function>
    <function name='xmlValidGetValidElements' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>This function returns the list of authorized children to insert within an existing tree while respecting the validity constraints forced by the Dtd. The insertion point is defined using @prev and @next in the following ways: to insert before &apos;node&apos;: xmlValidGetValidElements(node-&gt;prev, node, ... to insert next &apos;node&apos;: xmlValidGetValidElements(node, node-&gt;next, ... to replace &apos;node&apos;: xmlValidGetValidElements(node-&gt;prev, node-&gt;next, ... to prepend a child to &apos;node&apos;: xmlValidGetValidElements(NULL, node-&gt;childs, to append a child to &apos;node&apos;: xmlValidGetValidElements(node-&gt;last, NULL, ...  pointers to the element names are inserted at the beginning of the array and do not need to be freed.</info>
      <return type='int' info='the number of element in the list, or -1 in case of error. If the function returns the value @max the caller is invited to grow the receiving array and retry.'/>
      <arg name='prev' type='xmlNode *' info='an element to insert after'/>
      <arg name='next' type='xmlNode *' info='an element to insert next'/>
      <arg name='names' type='const xmlChar **' info='an array to store the list of child names'/>
      <arg name='max' type='int' info='the size of the array'/>
    </function>
    <function name='xmlValidNormalizeAttributeValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Does the validation related extra step of the normalization of attribute values:  If the declared value is not CDATA, then the XML processor must further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by single space (#x20) character.</info>
      <return type='xmlChar *' info='a new normalized string if normalization is needed, NULL otherwise the caller must free the returned value.'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='elem' type='xmlNodePtr' info='the parent'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='value' type='const xmlChar *' info='the attribute value'/>
    </function>
    <function name='xmlValidateAttributeDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single attribute definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Default Legal ] - [ VC: Enumeration ] - [ VC: ID Attribute Default ]  The ID/IDREF uniqueness and matching are done separately</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='attr' type='xmlAttributePtr' info='an attribute definition'/>
    </function>
    <function name='xmlValidateAttributeValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Validate that the given attribute value match  the proper production  [ VC: ID ] Values of type ID must match the Name production....  [ VC: IDREF ] Values of type IDREF must match the Name production, and values of type IDREFS must match Names ...  [ VC: Entity Name ] Values of type ENTITY must match the Name production, values of type ENTITIES must match Names ...  [ VC: Name Token ] Values of type NMTOKEN must match the Nmtoken production; values of type NMTOKENS must match Nmtokens.</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='type' type='xmlAttributeType' info='an attribute type'/>
      <arg name='value' type='const xmlChar *' info='an attribute value'/>
    </function>
    <function name='xmlValidateDocument' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate the document instance  basically it does the all the checks described by the XML Rec i.e. validates the internal and external subset (if present) and validate the document tree.</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
    </function>
    <function name='xmlValidateDocumentFinal' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Does the final step for the document validation once all the incremental validation steps have been completed  basically it does the following checks described by the XML Rec  Check all the IDREF/IDREFS attributes definition for validity</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
    </function>
    <function name='xmlValidateDtd' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate the document against the dtd instance  Basically it does check all the definitions in the DtD. Note the the internal subset (if present) is de-coupled (i.e. not used), which could give problems if ID or IDREF is present.</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='dtd' type='xmlDtdPtr' info='a dtd instance'/>
    </function>
    <function name='xmlValidateDtdFinal' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Does the final step for the dtds validation once all the subsets have been parsed  basically it does the following checks described by the XML Rec - check that ENTITY and ENTITIES type attributes default or possible values matches one of the defined entities. - check that NOTATION type attributes default or possible values matches one of the defined notations.</info>
      <return type='int' info='1 if valid or 0 if invalid and -1 if not well-formed'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
    </function>
    <function name='xmlValidateElement' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate the subtree under an element</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
    </function>
    <function name='xmlValidateElementDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single element definition basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: One ID per Element Type ] - [ VC: No Duplicate Types ] - [ VC: Unique Element Type Declaration ]</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlElementPtr' info='an element definition'/>
    </function>
    <function name='xmlValidateNCName' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED) || defined(LIBXML_LEGACY_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of NCName</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='space' type='int' info='allow spaces in front and end of the string'/>
    </function>
    <function name='xmlValidateNMToken' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of NMToken</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='space' type='int' info='allow spaces in front and end of the string'/>
    </function>
    <function name='xmlValidateName' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of Name</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='space' type='int' info='allow spaces in front and end of the string'/>
    </function>
    <function name='xmlValidateNameValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Validate that the given value match Name production</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='value' type='const xmlChar *' info='an Name value'/>
    </function>
    <function name='xmlValidateNamesValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Validate that the given value match Names production</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='value' type='const xmlChar *' info='an Names value'/>
    </function>
    <function name='xmlValidateNmtokenValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Validate that the given value match Nmtoken production  [ VC: Name Token ]</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='value' type='const xmlChar *' info='an Nmtoken value'/>
    </function>
    <function name='xmlValidateNmtokensValue' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Validate that the given value match Nmtokens production  [ VC: Name Token ]</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='value' type='const xmlChar *' info='an Nmtokens value'/>
    </function>
    <function name='xmlValidateNotationDecl' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single notation definition basically it does the following checks as described by the XML-1.0 recommendation: - it seems that no validity constraint exists on notation declarations But this function get called anyway ...</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='nota' type='xmlNotationPtr' info='a notation definition'/>
    </function>
    <function name='xmlValidateNotationUse' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Validate that the given name match a notation declaration. - [ VC: Notation Declared ]</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='the document'/>
      <arg name='notationName' type='const xmlChar *' info='the notation name to check'/>
    </function>
    <function name='xmlValidateOneAttribute' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single attribute for an element basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Value Type ] - [ VC: Fixed Attribute Default ] - [ VC: Entity Name ] - [ VC: Name Token ] - [ VC: ID ] - [ VC: IDREF ] - [ VC: Entity Name ] - [ VC: Notation Attributes ]  The ID/IDREF uniqueness and matching are done separately</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
      <arg name='attr' type='xmlAttrPtr' info='an attribute instance'/>
      <arg name='value' type='const xmlChar *' info='the attribute value (without entities processing)'/>
    </function>
    <function name='xmlValidateOneElement' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single element and it&apos;s attributes, basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Element Valid ] - [ VC: Required Attribute ] Then call xmlValidateOneAttribute() for each attribute present.  The ID/IDREF checkings are done separately</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
    </function>
    <function name='xmlValidateOneNamespace' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a single namespace declaration for an element basically it does the following checks as described by the XML-1.0 recommendation: - [ VC: Attribute Value Type ] - [ VC: Fixed Attribute Default ] - [ VC: Entity Name ] - [ VC: Name Token ] - [ VC: ID ] - [ VC: IDREF ] - [ VC: Entity Name ] - [ VC: Notation Attributes ]  The ID/IDREF uniqueness and matching are done separately</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix'/>
      <arg name='ns' type='xmlNsPtr' info='an namespace declaration instance'/>
      <arg name='value' type='const xmlChar *' info='the attribute value (without entities processing)'/>
    </function>
    <function name='xmlValidatePopElement' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED) &amp;&amp; defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Pop the element end from the validation stack.</info>
      <return type='int' info='1 if no validation problem was found or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
      <arg name='qname' type='const xmlChar *' info='the qualified name as appearing in the serialization'/>
    </function>
    <function name='xmlValidatePushCData' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED) &amp;&amp; defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>check the CData parsed for validation in the current stack</info>
      <return type='int' info='1 if no validation problem was found or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='data' type='const xmlChar *' info='some character data read'/>
      <arg name='len' type='int' info='the length of the data'/>
    </function>
    <function name='xmlValidatePushElement' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED) &amp;&amp; defined(LIBXML_REGEXP_ENABLED)</cond>
      <info>Push a new element start on the validation stack.</info>
      <return type='int' info='1 if no validation problem was found or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
      <arg name='elem' type='xmlNodePtr' info='an element instance'/>
      <arg name='qname' type='const xmlChar *' info='the qualified name as appearing in the serialization'/>
    </function>
    <function name='xmlValidateQName' file='tree' module='tree'>
      <cond>defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Check that a value conforms to the lexical space of QName</info>
      <return type='int' info='0 if this validates, a positive error code number otherwise and -1 in case of internal or API error.'/>
      <arg name='value' type='const xmlChar *' info='the value to check'/>
      <arg name='space' type='int' info='allow spaces in front and end of the string'/>
    </function>
    <function name='xmlValidateRoot' file='valid' module='valid'>
      <cond>defined(LIBXML_VALID_ENABLED)</cond>
      <info>Try to validate a the root element basically it does the following check as described by the XML-1.0 recommendation: - [ VC: Root Element Type ] it doesn&apos;t try to recurse or apply other check to the element</info>
      <return type='int' info='1 if valid or 0 otherwise'/>
      <arg name='ctxt' type='xmlValidCtxtPtr' info='the validation context'/>
      <arg name='doc' type='xmlDocPtr' info='a document instance'/>
    </function>
    <functype name='xmlValidityErrorFunc' file='valid' module='valid'>
      <info>Callback called when a validity error is found. This is a message oriented function similar to an *printf function.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='usually an xmlValidCtxtPtr to a validity error context, but comes from ctxt-&gt;userData (which normally contains such a pointer); ctxt-&gt;userData can be changed by the user.'/>
      <arg name='msg' type='const char *' info='the string to format *printf like vararg'/>
      <arg name='...' type='...' info='remaining arguments to the format'/>
    </functype>
    <functype name='xmlValidityWarningFunc' file='valid' module='valid'>
      <info>Callback called when a validity warning is found. This is a message oriented function similar to an *printf function.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='usually an xmlValidCtxtPtr to a validity error context, but comes from ctxt-&gt;userData (which normally contains such a pointer); ctxt-&gt;userData can be changed by the user.'/>
      <arg name='msg' type='const char *' info='the string to format *printf like vararg'/>
      <arg name='...' type='...' info='remaining arguments to the format'/>
    </functype>
    <function name='xmlXIncludeFreeContext' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Free an XInclude context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXIncludeCtxtPtr' info='the XInclude context'/>
    </function>
    <function name='xmlXIncludeNewContext' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Creates a new XInclude context</info>
      <return type='xmlXIncludeCtxtPtr' info='the new set'/>
      <arg name='doc' type='xmlDocPtr' info='an XML Document'/>
    </function>
    <function name='xmlXIncludeProcess' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution on the XML document @doc</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='doc' type='xmlDocPtr' info='an XML document'/>
    </function>
    <function name='xmlXIncludeProcessFlags' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution on the XML document @doc</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='doc' type='xmlDocPtr' info='an XML document'/>
      <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
    </function>
    <function name='xmlXIncludeProcessFlagsData' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution on the XML document @doc</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='doc' type='xmlDocPtr' info='an XML document'/>
      <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
      <arg name='data' type='void *' info='application data that will be passed to the parser context in the _private field of the parser context(s)'/>
    </function>
    <function name='xmlXIncludeProcessNode' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution for the given subtree reusing the informations and data coming from the given context.</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='ctxt' type='xmlXIncludeCtxtPtr' info='an existing XInclude context'/>
      <arg name='node' type='xmlNodePtr' info='a node in an XML document'/>
    </function>
    <function name='xmlXIncludeProcessTree' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution for the given subtree</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='tree' type='xmlNodePtr' info='a node in an XML document'/>
    </function>
    <function name='xmlXIncludeProcessTreeFlags' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution for the given subtree</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='tree' type='xmlNodePtr' info='a node in an XML document'/>
      <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
    </function>
    <function name='xmlXIncludeProcessTreeFlagsData' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Implement the XInclude substitution on the XML node @tree</info>
      <return type='int' info='0 if no substitution were done, -1 if some processing failed or the number of substitutions done.'/>
      <arg name='tree' type='xmlNodePtr' info='an XML node'/>
      <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
      <arg name='data' type='void *' info='application data that will be passed to the parser context in the _private field of the parser context(s)'/>
    </function>
    <function name='xmlXIncludeSetFlags' file='xinclude' module='xinclude'>
      <cond>defined(LIBXML_XINCLUDE_ENABLED)</cond>
      <info>Set the flags used for further processing of XML resources.</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='ctxt' type='xmlXIncludeCtxtPtr' info='an XInclude processing context'/>
      <arg name='flags' type='int' info='a set of xmlParserOption used for parsing XML includes'/>
    </function>
    <function name='xmlXPathAddValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the add operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <functype name='xmlXPathAxisFunc' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>An axis traversal function. To traverse an axis, the engine calls the first time with cur == NULL and repeat until the function returns NULL indicating the end of the axis traversal.</info>
      <return type='xmlXPathObjectPtr' info='the next node in that axis or NULL if at the end of the axis.'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath interpreter context'/>
      <arg name='cur' type='xmlXPathObjectPtr' info='the previous node being explored on that axis'/>
    </functype>
    <function name='xmlXPathBooleanFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the boolean() XPath function boolean boolean(object) The boolean function converts its argument to a boolean as follows: - a number is true if and only if it is neither positive or negative zero nor NaN - a node-set is true if and only if it is non-empty - a string is true if and only if its length is non-zero</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathCastBooleanToNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a boolean to its number value</info>
      <return type='double' info='the number value'/>
      <arg name='val' type='int' info='a boolean'/>
    </function>
    <function name='xmlXPathCastBooleanToString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a boolean to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string.'/>
      <arg name='val' type='int' info='a boolean'/>
    </function>
    <function name='xmlXPathCastNodeSetToBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a node-set to its boolean value</info>
      <return type='int' info='the boolean value'/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathCastNodeSetToNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a node-set to its number value</info>
      <return type='double' info='the number value'/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathCastNodeSetToString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a node-set to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string.'/>
      <arg name='ns' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathCastNodeToNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a node to its number value</info>
      <return type='double' info='the number value'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathCastNodeToString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a node to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string.'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathCastNumberToBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a number to its boolean value</info>
      <return type='int' info='the boolean value'/>
      <arg name='val' type='double' info='a number'/>
    </function>
    <function name='xmlXPathCastNumberToString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a number to its string value.</info>
      <return type='xmlChar *' info='a newly allocated string.'/>
      <arg name='val' type='double' info='a number'/>
    </function>
    <function name='xmlXPathCastStringToBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a string to its boolean value</info>
      <return type='int' info='the boolean value'/>
      <arg name='val' type='const xmlChar *' info='a string'/>
    </function>
    <function name='xmlXPathCastStringToNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts a string to its number value</info>
      <return type='double' info='the number value'/>
      <arg name='val' type='const xmlChar *' info='a string'/>
    </function>
    <function name='xmlXPathCastToBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an XPath object to its boolean value</info>
      <return type='int' info='the boolean value'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <function name='xmlXPathCastToNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an XPath object to its number value</info>
      <return type='double' info='the number value'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <function name='xmlXPathCastToString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlChar *' info='the allocated string value of the object, NULL in case of error. It&apos;s up to the caller to free the string memory with xmlFree().'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <function name='xmlXPathCeilingFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the ceiling() XPath function number ceiling(number) The ceiling function returns the smallest (closest to negative infinity) number that is not less than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathCmpNodes' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Compare two nodes w.r.t document order</info>
      <return type='int' info='-2 in case of error 1 if first point &lt; second point, 0 if it&apos;s the same node, -1 otherwise'/>
      <arg name='node1' type='xmlNodePtr' info='the first node'/>
      <arg name='node2' type='xmlNodePtr' info='the second node'/>
    </function>
    <function name='xmlXPathCompareValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the compare operation on XPath objects: @arg1 &lt; @arg2    (1, 1, ... @arg1 &lt;= @arg2   (1, 0, ... @arg1 &gt; @arg2    (0, 1, ... @arg1 &gt;= @arg2   (0, 0, ...  When neither object to be compared is a node-set and the operator is &lt;=, &lt;, &gt;=, &gt;, then the objects are compared by converted both objects to numbers and comparing the numbers according to IEEE 754. The &lt; comparison will be true if and only if the first number is less than the second number. The &lt;= comparison will be true if and only if the first number is less than or equal to the second number. The &gt; comparison will be true if and only if the first number is greater than the second number. The &gt;= comparison will be true if and only if the first number is greater than or equal to the second number.</info>
      <return type='int' info='1 if the comparison succeeded, 0 if it failed'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='inf' type='int' info='less than (1) or greater than (0)'/>
      <arg name='strict' type='int' info='is the comparison strict'/>
    </function>
    <function name='xmlXPathCompile' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr' info='the xmlXPathCompExprPtr resulting from the compilation or NULL. the caller has to free the object.'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
    </function>
    <function name='xmlXPathCompiledEval' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate the Precompiled XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object.'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathCompiledEvalToBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Applies the XPath boolean() function on the result of the given compiled expression.</info>
      <return type='int' info='1 if the expression evaluated to true, 0 if to false and -1 in API and internal errors.'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathConcatFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the concat() XPath function string concat(string, string, string*) The concat function returns the concatenation of its arguments.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathContainsFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the contains() XPath function boolean contains(string, string) The contains function returns true if the first argument string contains the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathContextSetCache' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Creates/frees an object cache on the XPath context. If activates XPath objects (xmlXPathObject) will be cached internally to be reused. @options: 0: This will set the XPath object caching: @value: This will set the maximum number of XPath objects to be cached per slot There are 5 slots for: node-set, string, number, boolean, and misc objects. Use &lt;0 for the default number (100). Other values for @options have currently no effect.</info>
      <return type='int' info='0 if the setting succeeded, and -1 on API or internal errors.'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='active' type='int' info='enables/disables (creates/frees) the cache'/>
      <arg name='value' type='int' info='a value with semantics dependant on @options'/>
      <arg name='options' type='int' info='options (currently only the value 0 is used)'/>
    </function>
    <function name='xmlXPathConvertBoolean' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an existing object to its boolean() equivalent</info>
      <return type='xmlXPathObjectPtr' info='the new object, the old one is freed (or the operation is done directly on @val)'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <functype name='xmlXPathConvertFunc' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>A conversion function is associated to a type and used to cast the new type to primitive values.</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an XPath object'/>
      <arg name='type' type='int' info='the number of the target type'/>
    </functype>
    <function name='xmlXPathConvertNumber' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an existing object to its number() equivalent</info>
      <return type='xmlXPathObjectPtr' info='the new object, the old one is freed (or the operation is done directly on @val)'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <function name='xmlXPathConvertString' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Converts an existing object to its string() equivalent</info>
      <return type='xmlXPathObjectPtr' info='the new object, the old one is freed (or the operation is done directly on @val)'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an XPath object'/>
    </function>
    <function name='xmlXPathCountFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the count() XPath function number count(node-set)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathCtxtCompile' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Compile an XPath expression</info>
      <return type='xmlXPathCompExprPtr' info='the xmlXPathCompExprPtr resulting from the compilation or NULL. the caller has to free the object.'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='an XPath context'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
    </function>
    <function name='xmlXPathDebugDumpCompExpr' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dumps the tree of the compiled XPath expression.</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the precompiled XPath expression'/>
      <arg name='depth' type='int' info='the indentation level.'/>
    </function>
    <function name='xmlXPathDebugDumpObject' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED) &amp;&amp; defined(LIBXML_DEBUG_ENABLED)</cond>
      <info>Dump the content of the object for debugging purposes</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * to dump the output'/>
      <arg name='cur' type='xmlXPathObjectPtr' info='the object to inspect'/>
      <arg name='depth' type='int' info='indentation level'/>
    </function>
    <function name='xmlXPathDifference' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets difference() function: node-set set:difference (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the difference between the two node sets, or nodes1 if nodes2 is empty'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathDistinct' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set) @nodes is sorted by document order, then #exslSetsDistinctSorted is called with the sorted node-set</info>
      <return type='xmlNodeSetPtr' info='a subset of the nodes contained in @nodes, or @nodes if it is empty'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathDistinctSorted' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets distinct() function: node-set set:distinct (node-set)</info>
      <return type='xmlNodeSetPtr' info='a subset of the nodes contained in @nodes, or @nodes if it is empty'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
    </function>
    <function name='xmlXPathDivValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the div operation on XPath objects @arg1 / @arg2: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathEqualValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the equal operation on XPath objects content: @arg1 == @arg2</info>
      <return type='int' info='0 or 1 depending on the results of the test.'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathErr' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Handle an XPath error</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='a XPath parser context'/>
      <arg name='error' type='int' info='the error code'/>
    </function>
    <function name='xmlXPathEval' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object.'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathEvalExpr' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Parse and evaluate an XPath expression in the given context, then push the result on the context stack</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathEvalExpression' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate the XPath expression in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object.'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <functype name='xmlXPathEvalFunc' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>An XPath evaluation function, the parameters are on the XPath context stack.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
      <arg name='nargs' type='int' info='the number of arguments passed to the function'/>
    </functype>
    <function name='xmlXPathEvalPredicate' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int' info='1 if predicate is true, 0 otherwise'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='res' type='xmlXPathObjectPtr' info='the Predicate Expression evaluation result'/>
    </function>
    <function name='xmlXPathEvaluatePredicateResult' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate a predicate result for the current node. A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the position of the context node in the context node list (as returned by the position function) and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function.</info>
      <return type='int' info='1 if predicate is true, 0 otherwise'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='res' type='xmlXPathObjectPtr' info='the Predicate Expression evaluation result'/>
    </function>
    <function name='xmlXPathFalseFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the false() XPath function boolean false()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathFloorFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the floor() XPath function number floor(number) The floor function returns the largest (closest to positive infinity) number that is not greater than the argument and that is an integer.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathFreeCompExpr' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free up the memory allocated by @comp</info>
      <return type='void'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='an XPATH comp'/>
    </function>
    <function name='xmlXPathFreeContext' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free up an xmlXPathContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the context to free'/>
    </function>
    <function name='xmlXPathFreeNodeSet' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free the NodeSet compound (not the actual nodes !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlNodeSetPtr' info='the xmlNodeSetPtr to free'/>
    </function>
    <function name='xmlXPathFreeNodeSetList' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free up the xmlXPathObjectPtr @obj but don&apos;t deallocate the objects in the list contrary to xmlXPathFreeObject().</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='an existing NodeSetList object'/>
    </function>
    <function name='xmlXPathFreeObject' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free up an xmlXPathObjectPtr object.</info>
      <return type='void'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='the object to free'/>
    </function>
    <function name='xmlXPathFreeParserContext' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Free up an xmlXPathParserContext</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the context to free'/>
    </function>
    <functype name='xmlXPathFuncLookupFunc' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Prototype for callbacks used to plug function lookup in the XPath engine.</info>
      <return type='xmlXPathFunction' info='the XPath function or NULL if not found.'/>
      <arg name='ctxt' type='void *' info='an XPath context'/>
      <arg name='name' type='const xmlChar *' info='name of the function'/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name hosting this function'/>
    </functype>
    <functype name='xmlXPathFunction' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>An XPath function. The arguments (if any) are popped out from the context stack and the result is pushed on the stack.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath interprestation context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </functype>
    <function name='xmlXPathFunctionLookup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction' info='the xmlXPathFunction or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
    </function>
    <function name='xmlXPathFunctionLookupNS' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Search in the Function array of the context for the given function.</info>
      <return type='xmlXPathFunction' info='the xmlXPathFunction or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xmlXPathHasSameNodes' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets has-same-nodes function: boolean set:has-same-node(node-set, node-set)</info>
      <return type='int' info='true (1) if @nodes1 shares any node with @nodes2, false (0) otherwise'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathIdFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the id() XPath function node-set id(object) The id function selects elements by their unique ID (see [5.2.1 Unique IDs]). When the argument to id is of type node-set, then the result is the union of the result of applying id to the string value of each of the nodes in the argument node-set. When the argument to id is of any other type, the argument is converted to a string as if by a call to the string function; the string is split into a whitespace-separated list of tokens (whitespace is any sequence of characters matching the production S); the result is a node-set containing the elements in the same document as the context node that have a unique ID equal to any of the tokens in the list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathInit' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Initialize the XPath environment</info>
      <return type='void'/>
    </function>
    <function name='xmlXPathIntersection' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets intersection() function: node-set set:intersection (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='a node set comprising the nodes that are within both the node sets passed as arguments'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathIsInf' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Provides a portable isinf() function to detect whether a double is a +Infinite or -Infinite. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int' info='1 vi the value is +Infinite, -1 if -Infinite, 0 otherwise'/>
      <arg name='val' type='double' info='a double value'/>
    </function>
    <function name='xmlXPathIsNaN' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)</cond>
      <info>Provides a portable isnan() function to detect whether a double is a NotaNumber. Based on trio code http://sourceforge.net/projects/ctrio/</info>
      <return type='int' info='1 if the value is a NaN, 0 otherwise'/>
      <arg name='val' type='double' info='a double value'/>
    </function>
    <function name='xmlXPathIsNodeType' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Is the name given a NodeType one.  [38]   NodeType ::=   &apos;comment&apos; | &apos;text&apos; | &apos;processing-instruction&apos; | &apos;node&apos;</info>
      <return type='int' info='1 if true 0 otherwise'/>
      <arg name='name' type='const xmlChar *' info='a name string'/>
    </function>
    <function name='xmlXPathLangFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the lang() XPath function boolean lang(string) The lang function returns true or false depending on whether the language of the context node as specified by xml:lang attributes is the same as or is a sublanguage of the language specified by the argument string. The language of the context node is determined by the value of the xml:lang attribute on the context node, or, if the context node has no xml:lang attribute, by the value of the xml:lang attribute on the nearest ancestor of the context node that has an xml:lang attribute. If there is no such attribute, then lang</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathLastFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the last() XPath function number last() The last function returns the number of nodes in the context node list.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathLeading' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) @nodes1 and @nodes2 are sorted by document order, then #exslSetsLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes1 that precede the first node in @nodes2 in document order, @nodes1 if @nodes2 is NULL or empty or an empty node-set if @nodes1 doesn&apos;t contain @nodes2'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathLeadingSorted' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes1 that precede the first node in @nodes2 in document order, @nodes1 if @nodes2 is NULL or empty or an empty node-set if @nodes1 doesn&apos;t contain @nodes2'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
    </function>
    <function name='xmlXPathLocalNameFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the local-name() XPath function string local-name(node-set?) The local-name function returns a string containing the local part of the name of the node in the argument node-set that is first in document order. If the node-set is empty or the first node has no name, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathModValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the mod operation on XPath objects: @arg1 / @arg2 The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathMultValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the multiply operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathNamespaceURIFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the namespace-uri() XPath function string namespace-uri(node-set?) The namespace-uri function returns a string containing the namespace URI of the expanded name of the node in the argument node-set that is first in document order. If the node-set is empty, the first node has no name, or the expanded name has no namespace URI, an empty string is returned. If the argument is omitted it defaults to the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathNewBoolean' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type boolean and of value @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='int' info='the boolean value'/>
    </function>
    <function name='xmlXPathNewCString' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type string and of value @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='const char *' info='the char * value'/>
    </function>
    <function name='xmlXPathNewContext' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathContext</info>
      <return type='xmlXPathContextPtr' info='the xmlXPathContext just allocated. The caller will need to free it.'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document'/>
    </function>
    <function name='xmlXPathNewFloat' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type double and of value @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='double' info='the double value'/>
    </function>
    <function name='xmlXPathNewNodeSet' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the single Node @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlNodePtr' info='the NodePtr value'/>
    </function>
    <function name='xmlXPathNewNodeSetList' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type NodeSet and initialize it with the Nodeset @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlNodeSetPtr' info='an existing NodeSet'/>
    </function>
    <function name='xmlXPathNewParserContext' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathParserContext</info>
      <return type='xmlXPathParserContextPtr' info='the xmlXPathParserContext just allocated.'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathNewString' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type string and of value @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='const xmlChar *' info='the xmlChar * value'/>
    </function>
    <function name='xmlXPathNewValueTree' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type Value Tree (XSLT) and initialize it with the tree root @val</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlNodePtr' info='the NodePtr value'/>
    </function>
    <function name='xmlXPathNextAncestor' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;ancestor&quot; direction the ancestor axis contains the ancestors of the context node; the ancestors of the context node consist of the parent of context node and the parent&apos;s parent and so on; the nodes are ordered in reverse document order; thus the parent is the first node on the axis, and the parent&apos;s parent is the second node on the axis</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextAncestorOrSelf' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;ancestor-or-self&quot; direction he ancestor-or-self axis contains the context node and ancestors of the context node in reverse document order; thus the context node is the first node on the axis, and the context node&apos;s parent the second; parent here is defined the same as with the parent axis.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextAttribute' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;attribute&quot; direction TODO: support DTD inherited default attributes</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current attribute in the traversal'/>
    </function>
    <function name='xmlXPathNextChild' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;child&quot; direction The child axis contains the children of the context node in document order.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextDescendant' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;descendant&quot; direction the descendant axis contains the descendants of the context node in document order; a descendant is a child or a child of a child and so on.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextDescendantOrSelf' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;descendant-or-self&quot; direction the descendant-or-self axis contains the context node and the descendants of the context node in document order; thus the context node is the first node on the axis, and the first child of the context node is the second node on the axis</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextFollowing' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;following&quot; direction The following axis contains all nodes in the same document as the context node that are after the context node in document order, excluding any descendants and excluding attribute nodes and namespace nodes; the nodes are ordered in document order</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextFollowingSibling' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;following-sibling&quot; direction The following-sibling axis contains the following siblings of the context node in document order.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextNamespace' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;namespace&quot; direction the namespace axis contains the namespace nodes of the context node; the order of nodes on this axis is implementation-defined; the axis will be empty unless the context node is an element  We keep the XML namespace node at the end of the list.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current attribute in the traversal'/>
    </function>
    <function name='xmlXPathNextParent' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;parent&quot; direction The parent axis contains the parent of the context node, if there is one.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextPreceding' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;preceding&quot; direction the preceding axis contains all nodes in the same document as the context node that are before the context node in document order, excluding any ancestors and excluding attribute nodes and namespace nodes; the nodes are ordered in reverse document order</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextPrecedingSibling' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;preceding-sibling&quot; direction The preceding-sibling axis contains the preceding siblings of the context node in reverse document order; the first preceding sibling is first on the axis; the sibling preceding that node is the second on the axis and so on.</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNextSelf' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Traversal function for the &quot;self&quot; direction The self axis contains just the context node itself</info>
      <return type='xmlNodePtr' info='the next element following that axis'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='cur' type='xmlNodePtr' info='the current node in the traversal'/>
    </function>
    <function name='xmlXPathNodeEval' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Evaluate the XPath Location Path in the given context. The node &apos;node&apos; is set as the context node. The context node is not restored.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object.'/>
      <arg name='node' type='xmlNodePtr' info='the node to to use as the context node'/>
      <arg name='str' type='const xmlChar *' info='the XPath expression'/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathNodeLeading' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set) @nodes is sorted by document order, then #exslSetsNodeLeadingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes that precede @node in document order, @nodes if @node is NULL or an empty node-set if @nodes doesn&apos;t contain @node'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathNodeLeadingSorted' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets leading() function: node-set set:leading (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes that precede @node in document order, @nodes if @node is NULL or an empty node-set if @nodes doesn&apos;t contain @node'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathNodeSetAdd' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>add a new xmlNodePtr to an existing NodeSet</info>
      <return type='int' info='0 in case of success, and -1 in case of error'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set'/>
      <arg name='val' type='xmlNodePtr' info='a new xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetAddNs' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>add a new namespace node to an existing NodeSet</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set'/>
      <arg name='node' type='xmlNodePtr' info='the hosting node'/>
      <arg name='ns' type='xmlNsPtr' info='a the namespace node'/>
    </function>
    <function name='xmlXPathNodeSetAddUnique' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>add a new xmlNodePtr to an existing NodeSet, optimized version when we are sure the node is not already in the set.</info>
      <return type='int' info='0 in case of success and -1 in case of failure'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set'/>
      <arg name='val' type='xmlNodePtr' info='a new xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetContains' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>checks whether @cur contains @val</info>
      <return type='int' info='true (1) if @cur contains @val, false (0) otherwise'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the node-set'/>
      <arg name='val' type='xmlNodePtr' info='the node'/>
    </function>
    <function name='xmlXPathNodeSetCreate' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Create a new xmlNodeSetPtr of type double and of value @val</info>
      <return type='xmlNodeSetPtr' info='the newly created object.'/>
      <arg name='val' type='xmlNodePtr' info='an initial xmlNodePtr, or NULL'/>
    </function>
    <function name='xmlXPathNodeSetDel' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Removes an xmlNodePtr from an existing NodeSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set'/>
      <arg name='val' type='xmlNodePtr' info='an xmlNodePtr'/>
    </function>
    <function name='xmlXPathNodeSetFreeNs' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Namespace nodes in libxml don&apos;t match the XPath semantic. In a node set the namespace nodes are duplicated and the next pointer is set to the parent node in the XPath semantic. Check if such a node needs to be freed</info>
      <return type='void'/>
      <arg name='ns' type='xmlNsPtr' info='the XPath namespace node found in a nodeset.'/>
    </function>
    <function name='xmlXPathNodeSetMerge' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Merges two nodesets, all nodes from @val2 are added to @val1 if @val1 is NULL, a new set is created and copied from @val2</info>
      <return type='xmlNodeSetPtr' info='@val1 once extended or NULL in case of error.'/>
      <arg name='val1' type='xmlNodeSetPtr' info='the first NodeSet or NULL'/>
      <arg name='val2' type='xmlNodeSetPtr' info='the second NodeSet'/>
    </function>
    <function name='xmlXPathNodeSetRemove' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Removes an entry from an existing NodeSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodeSetPtr' info='the initial node set'/>
      <arg name='val' type='int' info='the index to remove'/>
    </function>
    <function name='xmlXPathNodeSetSort' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Sort the node set in document order</info>
      <return type='void'/>
      <arg name='set' type='xmlNodeSetPtr' info='the node set'/>
    </function>
    <function name='xmlXPathNodeTrailing' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) @nodes is sorted by document order, then #xmlXPathNodeTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes that follow @node in document order, @nodes if @node is NULL or an empty node-set if @nodes doesn&apos;t contain @node'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathNodeTrailingSorted' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes that follow @node in document order, @nodes if @node is NULL or an empty node-set if @nodes doesn&apos;t contain @node'/>
      <arg name='nodes' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
    </function>
    <function name='xmlXPathNormalizeFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the normalize-space() XPath function string normalize-space(string?) The normalize-space function returns the argument string with white space normalized by stripping leading and trailing whitespace and replacing sequences of whitespace characters by a single space. Whitespace characters are the same allowed by the S production in XML. If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathNotEqualValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the equal operation on XPath objects content: @arg1 == @arg2</info>
      <return type='int' info='0 or 1 depending on the results of the test.'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathNotFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the not() XPath function boolean not(boolean) The not function returns true if its argument is false, and false otherwise.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathNsLookup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Search in the namespace declaration array of the context for the given namespace name associated to the given prefix</info>
      <return type='const xmlChar *' info='the value or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix value'/>
    </function>
    <function name='xmlXPathNumberFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the number() XPath function number number(object?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathObjectCopy' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>allocate a new copy of a given object</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlXPathObjectPtr' info='the original object'/>
    </function>
    <function name='xmlXPathOrderDocElems' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Call this routine to speed up XPath computation on static documents. This stamps all the element nodes with the document order Like for line information, the order is kept in the element-&gt;content field, the value stored is actually - the node number (starting at -1) to be able to differentiate from line numbers.</info>
      <return type='long' info='the number of elements found in the document or -1 in case of error.'/>
      <arg name='doc' type='xmlDocPtr' info='an input document'/>
    </function>
    <function name='xmlXPathParseNCName' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>parse an XML namespace non qualified name.  [NS 3] NCName ::= (Letter | &apos;_&apos;) (NCNameChar)*  [NS 4] NCNameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | CombiningChar | Extender</info>
      <return type='xmlChar *' info='the namespace name or NULL'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathParseName' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>parse an XML name  [4] NameChar ::= Letter | Digit | &apos;.&apos; | &apos;-&apos; | &apos;_&apos; | &apos;:&apos; | CombiningChar | Extender  [5] Name ::= (Letter | &apos;_&apos; | &apos;:&apos;) (NameChar)*</info>
      <return type='xmlChar *' info='the namespace name or NULL'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathPopBoolean' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops a boolean from the stack, handling conversion if needed. Check error with #xmlXPathCheckError.</info>
      <return type='int' info='the boolean'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
    </function>
    <function name='xmlXPathPopExternal' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops an external object from the stack, handling conversion if needed. Check error with #xmlXPathCheckError.</info>
      <return type='void *' info='the object'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
    </function>
    <function name='xmlXPathPopNodeSet' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops a node-set from the stack, handling conversion if needed. Check error with #xmlXPathCheckError.</info>
      <return type='xmlNodeSetPtr' info='the node-set'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
    </function>
    <function name='xmlXPathPopNumber' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops a number from the stack, handling conversion if needed. Check error with #xmlXPathCheckError.</info>
      <return type='double' info='the number'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
    </function>
    <function name='xmlXPathPopString' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Pops a string from the stack, handling conversion if needed. Check error with #xmlXPathCheckError.</info>
      <return type='xmlChar *' info='the string'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath parser context'/>
    </function>
    <function name='xmlXPathPositionFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the position() XPath function number position() The position function returns the position of the context node in the context node list. The first position is 1, and so the last position will be equal to last().</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathRegisterAllFunctions' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Registers all default XPath functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathRegisterFunc' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Register a new function. If @f is NULL it unregisters the function</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='f' type='xmlXPathFunction' info='the function implementation or NULL'/>
    </function>
    <function name='xmlXPathRegisterFuncLookup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Registers an external mechanism to do function lookup.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='f' type='xmlXPathFuncLookupFunc' info='the lookup function'/>
      <arg name='funcCtxt' type='void *' info='the lookup data'/>
    </function>
    <function name='xmlXPathRegisterFuncNS' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Register a new function. If @f is NULL it unregisters the function</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI'/>
      <arg name='f' type='xmlXPathFunction' info='the function implementation or NULL'/>
    </function>
    <function name='xmlXPathRegisterNs' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Register a new namespace. If @ns_uri is NULL it unregisters the namespace</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix cannot be NULL or empty string'/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name'/>
    </function>
    <function name='xmlXPathRegisterVariable' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Register a new variable value. If @value is NULL it unregisters the variable</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='value' type='xmlXPathObjectPtr' info='the variable value or NULL'/>
    </function>
    <function name='xmlXPathRegisterVariableLookup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>register an external mechanism to do variable lookup</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='f' type='xmlXPathVariableLookupFunc' info='the lookup function'/>
      <arg name='data' type='void *' info='the lookup data'/>
    </function>
    <function name='xmlXPathRegisterVariableNS' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Register a new variable value. If @value is NULL it unregisters the variable</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
      <arg name='value' type='xmlXPathObjectPtr' info='the variable value or NULL'/>
    </function>
    <function name='xmlXPathRegisteredFuncsCleanup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Cleanup the XPath context data associated to registered functions</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathRegisteredNsCleanup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathRegisteredVariablesCleanup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Cleanup the XPath context data associated to registered variables</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathRoot' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Initialize the context to the root of the document</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathRoundFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the round() XPath function number round(number) The round function returns the number that is closest to the argument and that is an integer. If there are two such numbers, then the one that is even is returned.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathSetContextNode' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Sets &apos;node&apos; as the context node. The node must be in the same document as that associated with the context.</info>
      <return type='int' info='-1 in case of error or 0 if successful'/>
      <arg name='node' type='xmlNodePtr' info='the node to to use as the context node'/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xmlXPathStartsWithFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the starts-with() XPath function boolean starts-with(string, string) The starts-with function returns true if the first argument string starts with the second argument string, and otherwise returns false.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathStringEvalNumber' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>[30a]  Float  ::= Number (&apos;e&apos; Digits?)?  [30]   Number ::=   Digits (&apos;.&apos; Digits?)? | &apos;.&apos; Digits [31]   Digits ::=   [0-9]+  Compile a Number in the string In complement of the Number expression, this function also handles negative values : &apos;-&apos; Number.</info>
      <return type='double' info='the double value.'/>
      <arg name='str' type='const xmlChar *' info='A string to scan'/>
    </function>
    <function name='xmlXPathStringFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the string() XPath function string string(object?) The string function converts an object to a string as follows: - A node-set is converted to a string by returning the value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned. - A number is converted to a string as follows + NaN is converted to the string NaN + positive zero is converted to the string 0 + negative zero is converted to the string 0 + positive infinity is converted to the string Infinity + negative infinity is converted to the string -Infinity + if the number is an integer, the number is represented in decimal form as a Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is negative + otherwise, the number is represented in decimal form as a Number including a decimal point with at least one digit before the decimal point and at least one digit after the decimal point, preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the decimal point apart possibly from the one required digit immediately before the decimal point; beyond the one required digit after the decimal point there must be as many, but only as many, more digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. - The boolean false value is converted to the string false. The boolean true value is converted to the string true.  If the argument is omitted, it defaults to a node-set with the context node as its only member.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathStringLengthFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the string-length() XPath function number string-length(string?) The string-length returns the number of characters in the string (see [3.6 Strings]). If the argument is omitted, it defaults to the context node converted to a string, in other words the value of the context node.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathSubValues' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the subtraction operation on XPath objects: The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathSubstringAfterFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the substring-after() XPath function string substring-after(string, string) The substring-after function returns the substring of the first argument string that follows the first occurrence of the second argument string in the first argument string, or the empty stringi if the first argument string does not contain the second argument string. For example, substring-after(&quot;1999/04/01&quot;,&quot;/&quot;) returns 04/01, and substring-after(&quot;1999/04/01&quot;,&quot;19&quot;) returns 99/04/01.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathSubstringBeforeFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the substring-before() XPath function string substring-before(string, string) The substring-before function returns the substring of the first argument string that precedes the first occurrence of the second argument string in the first argument string, or the empty string if the first argument string does not contain the second argument string. For example, substring-before(&quot;1999/04/01&quot;,&quot;/&quot;) returns 1999.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathSubstringFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the substring() XPath function string substring(string, number, number?) The substring function returns the substring of the first argument starting at the position specified in the second argument with length specified in the third argument. For example, substring(&quot;12345&quot;,2,3) returns &quot;234&quot;. If the third argument is not specified, it returns the substring starting at the position specified in the second argument and continuing to the end of the string. For example, substring(&quot;12345&quot;,2) returns &quot;2345&quot;.  More precisely, each character in the string (see [3.6 Strings]) is considered to have a numeric position: the position of the first character is 1, the position of the second character is 2 and so on. The returned substring contains those characters for which the position of the character is greater than or equal to the second argument and, if the third argument is specified, less than the sum of the second and third arguments; the comparisons and addition used for the above follow the standard IEEE 754 rules. Thus: - substring(&quot;12345&quot;, 1.5, 2.6) returns &quot;234&quot; - substring(&quot;12345&quot;, 0, 3) returns &quot;12&quot; - substring(&quot;12345&quot;, 0 div 0, 3) returns &quot;&quot; - substring(&quot;12345&quot;, 1, 0 div 0) returns &quot;&quot; - substring(&quot;12345&quot;, -42, 1 div 0) returns &quot;12345&quot; - substring(&quot;12345&quot;, -1 div 0, 1 div 0) returns &quot;&quot;</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathSumFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the sum() XPath function number sum(node-set) The sum function returns the sum of the values of the nodes in the argument node-set.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathTrailing' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set) @nodes1 and @nodes2 are sorted by document order, then #xmlXPathTrailingSorted is called.</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes1 that follow the first node in @nodes2 in document order, @nodes1 if @nodes2 is NULL or empty or an empty node-set if @nodes1 doesn&apos;t contain @nodes2'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set'/>
    </function>
    <function name='xmlXPathTrailingSorted' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implements the EXSLT - Sets trailing() function: node-set set:trailing (node-set, node-set)</info>
      <return type='xmlNodeSetPtr' info='the nodes in @nodes1 that follow the first node in @nodes2 in document order, @nodes1 if @nodes2 is NULL or empty or an empty node-set if @nodes1 doesn&apos;t contain @nodes2'/>
      <arg name='nodes1' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
      <arg name='nodes2' type='xmlNodeSetPtr' info='a node-set, sorted by document order'/>
    </function>
    <function name='xmlXPathTranslateFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the translate() XPath function string translate(string, string, string) The translate function returns the first argument string with occurrences of characters in the second argument string replaced by the character at the corresponding position in the third argument string. For example, translate(&quot;bar&quot;,&quot;abc&quot;,&quot;ABC&quot;) returns the string BAr. If there is a character in the second argument string with no character at a corresponding position in the third argument string (because the second argument string is longer than the third argument string), then occurrences of that character in the first argument string are removed. For example, translate(&quot;--aaa--&quot;,&quot;abc-&quot;,&quot;ABC&quot;)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathTrueFunction' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the true() XPath function boolean true()</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xmlXPathValueFlipSign' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Implement the unary - operation on an XPath object The numeric operators convert their operands to numbers as if by calling the number function.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
    </function>
    <function name='xmlXPathVariableLookup' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='a copy of the value or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
    </function>
    <functype name='xmlXPathVariableLookupFunc' file='xpath' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Prototype for callbacks used to plug variable lookup in the XPath engine.</info>
      <return type='xmlXPathObjectPtr' info='the XPath object value or NULL if not found.'/>
      <arg name='ctxt' type='void *' info='an XPath context'/>
      <arg name='name' type='const xmlChar *' info='name of the variable'/>
      <arg name='ns_uri' type='const xmlChar *' info='the namespace name hosting this variable'/>
    </functype>
    <function name='xmlXPathVariableLookupNS' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='the a copy of the value or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
    </function>
    <function name='xmlXPathWrapCString' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Wraps a string into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='char *' info='the char * value'/>
    </function>
    <function name='xmlXPathWrapExternal' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Wraps the @val data into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='void *' info='the user data'/>
    </function>
    <function name='xmlXPathWrapNodeSet' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Wrap the Nodeset @val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlNodeSetPtr' info='the NodePtr value'/>
    </function>
    <function name='xmlXPathWrapString' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Wraps the @val string into an XPath object.</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlChar *' info='the xmlChar * value'/>
    </function>
    <function name='xmlXPatherror' file='xpathInternals' module='xpath'>
      <cond>defined(LIBXML_XPATH_ENABLED)</cond>
      <info>Formats an error message.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='file' type='const char *' info='the file name'/>
      <arg name='line' type='int' info='the line number'/>
      <arg name='no' type='int' info='the error number'/>
    </function>
    <function name='xmlXPtrBuildNodeList' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Build a node list tree copy of the XPointer result. This will drop Attributes and Namespace declarations.</info>
      <return type='xmlNodePtr' info='an xmlNodePtr list or NULL. the caller has to free the node tree.'/>
      <arg name='obj' type='xmlXPathObjectPtr' info='the XPointer result from the evaluation.'/>
    </function>
    <function name='xmlXPtrEval' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Evaluate the XPath Location Path in the given context.</info>
      <return type='xmlXPathObjectPtr' info='the xmlXPathObjectPtr resulting from the evaluation or NULL. the caller has to free the object.'/>
      <arg name='str' type='const xmlChar *' info='the XPointer expression'/>
      <arg name='ctx' type='xmlXPathContextPtr' info='the XPointer context'/>
    </function>
    <function name='xmlXPtrEvalRangePredicate' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>[8]   Predicate ::=   &apos;[&apos; PredicateExpr &apos;]&apos; [9]   PredicateExpr ::=   Expr  Evaluate a predicate as in xmlXPathEvalPredicate() but for a Location Set instead of a node set</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context'/>
    </function>
    <function name='xmlXPtrFreeLocationSet' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Free the LocationSet compound (not the actual ranges !).</info>
      <return type='void'/>
      <arg name='obj' type='xmlLocationSetPtr' info='the xmlLocationSetPtr to free'/>
    </function>
    <function name='xmlXPtrLocationSetAdd' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>add a new xmlXPathObjectPtr to an existing LocationSet If the location already exist in the set @val is freed.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
      <arg name='val' type='xmlXPathObjectPtr' info='a new xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrLocationSetCreate' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlLocationSetPtr of type double and of value @val</info>
      <return type='xmlLocationSetPtr' info='the newly created object.'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an initial xmlXPathObjectPtr, or NULL'/>
    </function>
    <function name='xmlXPtrLocationSetDel' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Removes an xmlXPathObjectPtr from an existing LocationSet</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
      <arg name='val' type='xmlXPathObjectPtr' info='an xmlXPathObjectPtr'/>
    </function>
    <function name='xmlXPtrLocationSetMerge' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Merges two rangesets, all ranges from @val2 are added to @val1</info>
      <return type='xmlLocationSetPtr' info='val1 once extended or NULL in case of error.'/>
      <arg name='val1' type='xmlLocationSetPtr' info='the first LocationSet'/>
      <arg name='val2' type='xmlLocationSetPtr' info='the second LocationSet'/>
    </function>
    <function name='xmlXPtrLocationSetRemove' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Removes an entry from an existing LocationSet list.</info>
      <return type='void'/>
      <arg name='cur' type='xmlLocationSetPtr' info='the initial range set'/>
      <arg name='val' type='int' info='the index to remove'/>
    </function>
    <function name='xmlXPtrNewCollapsedRange' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range using a single nodes</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the starting and ending node'/>
    </function>
    <function name='xmlXPtrNewContext' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new XPointer context</info>
      <return type='xmlXPathContextPtr' info='the xmlXPathContext just allocated.'/>
      <arg name='doc' type='xmlDocPtr' info='the XML document'/>
      <arg name='here' type='xmlNodePtr' info='the node that directly contains the XPointer being evaluated or NULL'/>
      <arg name='origin' type='xmlNodePtr' info='the element from which a user or program initiated traversal of the link, or NULL.'/>
    </function>
    <function name='xmlXPtrNewLocationSetNodeSet' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with all the nodes from @set</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='set' type='xmlNodeSetPtr' info='a node set'/>
    </function>
    <function name='xmlXPtrNewLocationSetNodes' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type LocationSet and initialize it with the single range made of the two nodes @start and @end</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the start NodePtr value'/>
      <arg name='end' type='xmlNodePtr' info='the end NodePtr value or NULL'/>
    </function>
    <function name='xmlXPtrNewRange' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the starting node'/>
      <arg name='startindex' type='int' info='the start index'/>
      <arg name='end' type='xmlNodePtr' info='the ending point'/>
      <arg name='endindex' type='int' info='the ending index'/>
    </function>
    <function name='xmlXPtrNewRangeNodeObject' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range from a not to an object</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the starting node'/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending object'/>
    </function>
    <function name='xmlXPtrNewRangeNodePoint' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range from a node to a point</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the starting node'/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending point'/>
    </function>
    <function name='xmlXPtrNewRangeNodes' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range using 2 nodes</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlNodePtr' info='the starting node'/>
      <arg name='end' type='xmlNodePtr' info='the ending node'/>
    </function>
    <function name='xmlXPtrNewRangePointNode' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range from a point to a node</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlXPathObjectPtr' info='the starting point'/>
      <arg name='end' type='xmlNodePtr' info='the ending node'/>
    </function>
    <function name='xmlXPtrNewRangePoints' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Create a new xmlXPathObjectPtr of type range using 2 Points</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='start' type='xmlXPathObjectPtr' info='the starting point'/>
      <arg name='end' type='xmlXPathObjectPtr' info='the ending point'/>
    </function>
    <function name='xmlXPtrRangeToFunction' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Implement the range-to() XPointer function</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPointer Parser context'/>
      <arg name='nargs' type='int' info='the number of args'/>
    </function>
    <function name='xmlXPtrWrapLocationSet' file='xpointer' module='xpointer'>
      <cond>defined(LIBXML_XPTR_ENABLED)</cond>
      <info>Wrap the LocationSet @val in a new xmlXPathObjectPtr</info>
      <return type='xmlXPathObjectPtr' info='the newly created object.'/>
      <arg name='val' type='xmlLocationSetPtr' info='the LocationSet value'/>
    </function>
  </symbols>
</api>
