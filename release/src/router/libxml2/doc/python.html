<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><link rel="SHORTCUT ICON" href="/favicon.ico" /><style type="text/css">
TD {font-family: Verdana,Arial,Helvetica}
BODY {font-family: Verdana,Arial,Helvetica; margin-top: 2em; margin-left: 0em; margin-right: 0em}
H1 {font-family: Verdana,Arial,Helvetica}
H2 {font-family: Verdana,Arial,Helvetica}
H3 {font-family: Verdana,Arial,Helvetica}
A:link, A:visited, A:active { text-decoration: underline }
</style><title>Python and bindings</title></head><body bgcolor="#8b7765" text="#000000" link="#a06060" vlink="#000000"><table border="0" width="100%" cellpadding="5" cellspacing="0" align="center"><tr><td width="120"><a href="http://swpat.ffii.org/"><img src="epatents.png" alt="Action against software patents" /></a></td><td width="180"><a href="http://www.gnome.org/"><img src="gnome2.png" alt="Gnome2 Logo" /></a><a href="http://www.w3.org/Status"><img src="w3c.png" alt="W3C Logo" /></a><a href="http://www.redhat.com/"><img src="redhat.gif" alt="Red Hat Logo" /></a><div align="left"><a href="http://xmlsoft.org/"><img src="Libxml2-Logo-180x168.gif" alt="Made with Libxml2 Logo" /></a></div></td><td><table border="0" width="90%" cellpadding="2" cellspacing="0" align="center" bgcolor="#000000"><tr><td><table width="100%" border="0" cellspacing="1" cellpadding="3" bgcolor="#fffacd"><tr><td align="center"><h1>The XML C parser and toolkit of Gnome</h1><h2>Python and bindings</h2></td></tr></table></td></tr></table></td></tr></table><table border="0" cellpadding="4" cellspacing="0" width="100%" align="center"><tr><td bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="2" width="100%"><tr><td valign="top" width="200" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td><table width="100%" border="0" cellspacing="1" cellpadding="3"><tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Developer Menu</b></center></td></tr><tr><td bgcolor="#fffacd"><form action="search.php" enctype="application/x-www-form-urlencoded" method="get"><input name="query" type="text" size="20" value="" /><input name="submit" type="submit" value="Search ..." /></form><ul><li><a href="index.html" style="font-weight:bold">Main Menu</a></li><li><a href="html/index.html" style="font-weight:bold">Reference Manual</a></li><li><a href="examples/index.html" style="font-weight:bold">Code Examples</a></li><li><a href="guidelines.html">XML Guidelines</a></li><li><a href="tutorial/index.html">Tutorial</a></li><li><a href="xmlreader.html">The Reader Interface</a></li><li><a href="ChangeLog.html">ChangeLog</a></li><li><a href="XSLT.html">XSLT</a></li><li><a href="python.html">Python and bindings</a></li><li><a href="architecture.html">libxml2 architecture</a></li><li><a href="tree.html">The tree output</a></li><li><a href="interface.html">The SAX interface</a></li><li><a href="xmlmem.html">Memory Management</a></li><li><a href="xmlio.html">I/O Interfaces</a></li><li><a href="library.html">The parser interfaces</a></li><li><a href="entities.html">Entities or no entities</a></li><li><a href="namespaces.html">Namespaces</a></li><li><a href="upgrade.html">Upgrading 1.x code</a></li><li><a href="threads.html">Thread safety</a></li><li><a href="DOM.html">DOM Principles</a></li><li><a href="example.html">A real example</a></li><li><a href="xml.html">flat page</a>, <a href="site.xsl">stylesheet</a></li></ul></td></tr></table><table width="100%" border="0" cellspacing="1" cellpadding="3"><tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>API Indexes</b></center></td></tr><tr><td bgcolor="#fffacd"><ul><li><a href="APIchunk0.html">Alphabetic</a></li><li><a href="APIconstructors.html">Constructors</a></li><li><a href="APIfunctions.html">Functions/Types</a></li><li><a href="APIfiles.html">Modules</a></li><li><a href="APIsymbols.html">Symbols</a></li></ul></td></tr></table><table width="100%" border="0" cellspacing="1" cellpadding="3"><tr><td colspan="1" bgcolor="#eecfa1" align="center"><center><b>Related links</b></center></td></tr><tr><td bgcolor="#fffacd"><ul><li><a href="http://mail.gnome.org/archives/xml/">Mail archive</a></li><li><a href="http://xmlsoft.org/XSLT/">XSLT libxslt</a></li><li><a href="http://phd.cs.unibo.it/gdome2/">DOM gdome2</a></li><li><a href="http://www.aleksey.com/xmlsec/">XML-DSig xmlsec</a></li><li><a href="ftp://xmlsoft.org/">FTP</a></li><li><a href="http://www.zlatkovic.com/projects/libxml/">Windows binaries</a></li><li><a href="http://opencsw.org/packages/libxml2">Solaris binaries</a></li><li><a href="http://www.explain.com.au/oss/libxml2xslt.html">MacOsX binaries</a></li><li><a href="http://lxml.de/">lxml Python bindings</a></li><li><a href="http://cpan.uwinnipeg.ca/dist/XML-LibXML">Perl bindings</a></li><li><a href="http://libxmlplusplus.sourceforge.net/">C++ bindings</a></li><li><a href="http://www.zend.com/php5/articles/php5-xmlphp.php#Heading4">PHP bindings</a></li><li><a href="http://sourceforge.net/projects/libxml2-pas/">Pascal bindings</a></li><li><a href="http://libxml.rubyforge.org/">Ruby bindings</a></li><li><a href="http://tclxml.sourceforge.net/">Tcl bindings</a></li><li><a href="http://bugzilla.gnome.org/buglist.cgi?product=libxml2">Bug Tracker</a></li></ul></td></tr></table></td></tr></table></td><td valign="top" bgcolor="#8b7765"><table border="0" cellspacing="0" cellpadding="1" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="1" width="100%" bgcolor="#000000"><tr><td><table border="0" cellpadding="3" cellspacing="1" width="100%"><tr><td bgcolor="#fffacd"><p>There are a number of language bindings and wrappers available for
libxml2, the list below is not exhaustive. Please contact the <a href="http://mail.gnome.org/mailman/listinfo/xml-bindings">xml-bindings@gnome.org</a>
(<a href="http://mail.gnome.org/archives/xml-bindings/">archives</a>) in
order to get updates to this list or to discuss the specific topic of libxml2
or libxslt wrappers or bindings:</p><ul>
  <li><a href="http://libxmlplusplus.sourceforge.net/">Libxml++</a> seems the
    most up-to-date C++ bindings for libxml2, check the <a href="http://libxmlplusplus.sourceforge.net/reference/html/hierarchy.html">documentation</a>
    and the <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/libxmlplusplus/libxml%2b%2b/examples/">examples</a>.</li>
  <li>There is another <a href="http://libgdome-cpp.berlios.de/">C++ wrapper
    based on the gdome2 bindings</a> maintained by Tobias Peters.</li>
  <li>and a third C++ wrapper by Peter Jones &lt;pjones@pmade.org&gt;
    <p>Website: <a href="http://pmade.org/pjones/software/xmlwrapp/">http://pmade.org/pjones/software/xmlwrapp/</a></p>
  </li>
  <li>XML::LibXML <a href="http://cpan.uwinnipeg.ca/dist/XML-LibXML">Perl
      bindings</a> are available on CPAN, as well as XML::LibXSLT
      <a href="http://cpan.uwinnipeg.ca/dist/XML-LibXSLT">Perl libxslt
      bindings</a>.</li>
  <li>If you're interested into scripting XML processing, have a look at <a href="http://xsh.sourceforge.net/">XSH</a> an XML editing shell based on
    Libxml2 Perl bindings.</li>
  <li><a href="mailto:dkuhlman@cutter.rexx.com">Dave Kuhlman</a> provides an
    earlier version of the libxml/libxslt <a href="http://www.rexx.com/~dkuhlman">wrappers for Python</a>.</li>
  <li>Gopal.V and Peter Minten develop <a href="http://savannah.gnu.org/projects/libxmlsharp">libxml#</a>, a set of
    C# libxml2 bindings.</li>
  <li>Petr Kozelka provides <a href="http://sourceforge.net/projects/libxml2-pas">Pascal units to glue
    libxml2</a> with Kylix, Delphi and other Pascal compilers.</li>
  <li>Uwe Fechner also provides <a href="http://sourceforge.net/projects/idom2-pas/">idom2</a>, a DOM2
    implementation for Kylix2/D5/D6 from Borland.</li>
  <li>There is <a href="http://libxml.rubyforge.org/">bindings for Ruby</a> 
    and libxml2 bindings are also available in Ruby through the <a href="http://libgdome-ruby.berlios.de/">libgdome-ruby</a> module
    maintained by Tobias Peters.</li>
  <li>Steve Ball and contributors maintains <a href="http://tclxml.sourceforge.net/">libxml2 and libxslt bindings for
    Tcl</a>.</li>
  <li>libxml2 and libxslt are the default XML libraries for PHP5.</li>
  <li><a href="http://savannah.gnu.org/projects/classpathx/">LibxmlJ</a> is
    an effort to create a 100% JAXP-compatible Java wrapper for libxml2 and
    libxslt as part of GNU ClasspathX project.</li>
  <li>Patrick McPhee provides Rexx bindings fof libxml2 and libxslt, look for
    <a href="http://www.interlog.com/~ptjm/software.html">RexxXML</a>.</li>
  <li><a href="http://www.satimage.fr/software/en/xml_suite.html">Satimage</a>
    provides <a href="http://www.satimage.fr/software/en/downloads_osaxen.html">XMLLib
    osax</a>. This is an osax for Mac OS X with a set of commands to
    implement in AppleScript the XML DOM, XPATH and XSLT. Also includes
    commands for Property-lists (Apple's fast lookup table XML format.)</li>
  <li>Francesco Montorsi developped <a href="https://sourceforge.net/project/showfiles.php?group_id=51305&amp;package_id=45182">wxXml2</a>
    wrappers that interface libxml2, allowing wxWidgets applications to
    load/save/edit XML instances.</li>
</ul><p>The distribution includes a set of Python bindings, which are guaranteed
to be maintained as part of the library in the future, though the Python
interface have not yet reached the completeness of the C API.</p><p>Note that some of the Python purist dislike the default set of Python
bindings, rather than complaining I suggest they have a look at <a href="http://lxml.de/">lxml the more pythonic bindings for libxml2
and libxslt</a> and <a href="http://lxml.de/mailinglist/">check the mailing-list</a>.</p><p><a href="mailto:stephane.bidoul@softwareag.com">StÃ©phane Bidoul</a>
maintains <a href="http://users.skynet.be/sbi/libxml-python/">a Windows port
of the Python bindings</a>.</p><p>Note to people interested in building bindings, the API is formalized as
<a href="libxml2-api.xml">an XML API description file</a> which allows to
automate a large part of the Python bindings, this includes function
descriptions, enums, structures, typedefs, etc... The Python script used to
build the bindings is python/generator.py in the source distribution.</p><p>To install the Python bindings there are 2 options:</p><ul>
  <li>If you use an RPM based distribution, simply install the <a href="http://rpmfind.net/linux/rpm2html/search.php?query=libxml2-python">libxml2-python
    RPM</a> (and if needed the <a href="http://rpmfind.net/linux/rpm2html/search.php?query=libxslt-python">libxslt-python
    RPM</a>).</li>
  <li>Otherwise use the <a href="ftp://xmlsoft.org/libxml2/python/">libxml2-python
    module distribution</a> corresponding to your installed version of
    libxml2 and libxslt. Note that to install it you will need both libxml2
    and libxslt installed and run "python setup.py build install" in the
    module tree.</li>
</ul><p>The distribution includes a set of examples and regression tests for the
python bindings in the <code>python/tests</code> directory. Here are some
excerpts from those tests:</p><h3>tst.py:</h3><p>This is a basic test of the file interface and DOM navigation:</p><pre>import libxml2, sys

doc = libxml2.parseFile("tst.xml")
if doc.name != "tst.xml":
    print "doc.name failed"
    sys.exit(1)
root = doc.children
if root.name != "doc":
    print "root.name failed"
    sys.exit(1)
child = root.children
if child.name != "foo":
    print "child.name failed"
    sys.exit(1)
doc.freeDoc()</pre><p>The Python module is called libxml2; parseFile is the equivalent of
xmlParseFile (most of the bindings are automatically generated, and the xml
prefix is removed and the casing convention are kept). All node seen at the
binding level share the same subset of accessors:</p><ul>
  <li><code>name</code> : returns the node name</li>
  <li><code>type</code> : returns a string indicating the node type</li>
  <li><code>content</code> : returns the content of the node, it is based on
    xmlNodeGetContent() and hence is recursive.</li>
  <li><code>parent</code> , <code>children</code>, <code>last</code>,
    <code>next</code>, <code>prev</code>, <code>doc</code>,
    <code>properties</code>: pointing to the associated element in the tree,
    those may return None in case no such link exists.</li>
</ul><p>Also note the need to explicitly deallocate documents with freeDoc() .
Reference counting for libxml2 trees would need quite a lot of work to
function properly, and rather than risk memory leaks if not implemented
correctly it sounds safer to have an explicit function to free a tree. The
wrapper python objects like doc, root or child are them automatically garbage
collected.</p><h3>validate.py:</h3><p>This test check the validation interfaces and redirection of error
messages:</p><pre>import libxml2

#deactivate error messages from the validation
def noerr(ctx, str):
    pass

libxml2.registerErrorHandler(noerr, None)

ctxt = libxml2.createFileParserCtxt("invalid.xml")
ctxt.validate(1)
ctxt.parseDocument()
doc = ctxt.doc()
valid = ctxt.isValid()
doc.freeDoc()
if valid != 0:
    print "validity check failed"</pre><p>The first thing to notice is the call to registerErrorHandler(), it
defines a new error handler global to the library. It is used to avoid seeing
the error messages when trying to validate the invalid document.</p><p>The main interest of that test is the creation of a parser context with
createFileParserCtxt() and how the behaviour can be changed before calling
parseDocument() . Similarly the information resulting from the parsing phase
is also available using context methods.</p><p>Contexts like nodes are defined as class and the libxml2 wrappers maps the
C function interfaces in terms of objects method as much as possible. The
best to get a complete view of what methods are supported is to look at the
libxml2.py module containing all the wrappers.</p><h3>push.py:</h3><p>This test show how to activate the push parser interface:</p><pre>import libxml2

ctxt = libxml2.createPushParser(None, "&lt;foo", 4, "test.xml")
ctxt.parseChunk("/&gt;", 2, 1)
doc = ctxt.doc()

doc.freeDoc()</pre><p>The context is created with a special call based on the
xmlCreatePushParser() from the C library. The first argument is an optional
SAX callback object, then the initial set of data, the length and the name of
the resource in case URI-References need to be computed by the parser.</p><p>Then the data are pushed using the parseChunk() method, the last call
setting the third argument terminate to 1.</p><h3>pushSAX.py:</h3><p>this test show the use of the event based parsing interfaces. In this case
the parser does not build a document, but provides callback information as
the parser makes progresses analyzing the data being provided:</p><pre>import libxml2
log = ""

class callback:
    def startDocument(self):
        global log
        log = log + "startDocument:"

    def endDocument(self):
        global log
        log = log + "endDocument:"

    def startElement(self, tag, attrs):
        global log
        log = log + "startElement %s %s:" % (tag, attrs)

    def endElement(self, tag):
        global log
        log = log + "endElement %s:" % (tag)

    def characters(self, data):
        global log
        log = log + "characters: %s:" % (data)

    def warning(self, msg):
        global log
        log = log + "warning: %s:" % (msg)

    def error(self, msg):
        global log
        log = log + "error: %s:" % (msg)

    def fatalError(self, msg):
        global log
        log = log + "fatalError: %s:" % (msg)

handler = callback()

ctxt = libxml2.createPushParser(handler, "&lt;foo", 4, "test.xml")
chunk = " url='tst'&gt;b"
ctxt.parseChunk(chunk, len(chunk), 0)
chunk = "ar&lt;/foo&gt;"
ctxt.parseChunk(chunk, len(chunk), 1)

reference = "startDocument:startElement foo {'url': 'tst'}:" + \ 
            "characters: bar:endElement foo:endDocument:"
if log != reference:
    print "Error got: %s" % log
    print "Expected: %s" % reference</pre><p>The key object in that test is the handler, it provides a number of entry
points which can be called by the parser as it makes progresses to indicate
the information set obtained. The full set of callback is larger than what
the callback class in that specific example implements (see the SAX
definition for a complete list). The wrapper will only call those supplied by
the object when activated. The startElement receives the names of the element
and a dictionary containing the attributes carried by this element.</p><p>Also note that the reference string generated from the callback shows a
single character call even though the string "bar" is passed to the parser
from 2 different call to parseChunk()</p><h3>xpath.py:</h3><p>This is a basic test of XPath wrappers support</p><pre>import libxml2

doc = libxml2.parseFile("tst.xml")
ctxt = doc.xpathNewContext()
res = ctxt.xpathEval("//*")
if len(res) != 2:
    print "xpath query: wrong node set size"
    sys.exit(1)
if res[0].name != "doc" or res[1].name != "foo":
    print "xpath query: wrong node set value"
    sys.exit(1)
doc.freeDoc()
ctxt.xpathFreeContext()</pre><p>This test parses a file, then create an XPath context to evaluate XPath
expression on it. The xpathEval() method execute an XPath query and returns
the result mapped in a Python way. String and numbers are natively converted,
and node sets are returned as a tuple of libxml2 Python nodes wrappers. Like
the document, the XPath context need to be freed explicitly, also not that
the result of the XPath query may point back to the document tree and hence
the document must be freed after the result of the query is used.</p><h3>xpathext.py:</h3><p>This test shows how to extend the XPath engine with functions written in
python:</p><pre>import libxml2

def foo(ctx, x):
    return x + 1

doc = libxml2.parseFile("tst.xml")
ctxt = doc.xpathNewContext()
libxml2.registerXPathFunction(ctxt._o, "foo", None, foo)
res = ctxt.xpathEval("foo(1)")
if res != 2:
    print "xpath extension failure"
doc.freeDoc()
ctxt.xpathFreeContext()</pre><p>Note how the extension function is registered with the context (but that
part is not yet finalized, this may change slightly in the future).</p><h3>tstxpath.py:</h3><p>This test is similar to the previous one but shows how the extension
function can access the XPath evaluation context:</p><pre>def foo(ctx, x):
    global called

    #
    # test that access to the XPath evaluation contexts
    #
    pctxt = libxml2.xpathParserContext(_obj=ctx)
    ctxt = pctxt.context()
    called = ctxt.function()
    return x + 1</pre><p>All the interfaces around the XPath parser(or rather evaluation) context
are not finalized, but it should be sufficient to do contextual work at the
evaluation point.</p><h3>Memory debugging:</h3><p>last but not least, all tests starts with the following prologue:</p><pre>#memory debug specific
libxml2.debugMemory(1)</pre><p>and ends with the following epilogue:</p><pre>#memory debug specific
libxml2.cleanupParser()
if libxml2.debugMemory(1) == 0:
    print "OK"
else:
    print "Memory leak %d bytes" % (libxml2.debugMemory(1))
    libxml2.dumpMemory()</pre><p>Those activate the memory debugging interface of libxml2 where all
allocated block in the library are tracked. The prologue then cleans up the
library state and checks that all allocated memory has been freed. If not it
calls dumpMemory() which saves that list in a <code>.memdump</code> file.</p><p><a href="bugs.html">Daniel Veillard</a></p></td></tr></table></td></tr></table></td></tr></table></td></tr></table></td></tr></table></body></html>
