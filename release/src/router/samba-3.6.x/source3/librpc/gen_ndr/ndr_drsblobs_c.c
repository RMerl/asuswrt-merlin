/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "librpc/gen_ndr/ndr_drsblobs.h"
#include "librpc/gen_ndr/ndr_drsblobs_c.h"

/* drsblobs - client functions generated by pidl */

struct dcerpc_decode_replPropertyMetaData_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_replPropertyMetaData_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_replPropertyMetaData_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_replPropertyMetaData *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_replPropertyMetaData_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_replPropertyMetaData_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPLPROPERTYMETADATA, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_replPropertyMetaData_r_done, req);

	return req;
}

static void dcerpc_decode_replPropertyMetaData_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_replPropertyMetaData_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_replPropertyMetaData_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_replPropertyMetaData_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_replPropertyMetaData_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_replPropertyMetaData *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPLPROPERTYMETADATA, mem_ctx, r);

	return status;
}

struct dcerpc_decode_replPropertyMetaData_state {
	struct decode_replPropertyMetaData orig;
	struct decode_replPropertyMetaData tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_replPropertyMetaData_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_replPropertyMetaData_send(TALLOC_CTX *mem_ctx,
							   struct tevent_context *ev,
							   struct dcerpc_binding_handle *h,
							   struct replPropertyMetaDataBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_replPropertyMetaData_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_replPropertyMetaData_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_replPropertyMetaData_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_replPropertyMetaData_done, req);
	return req;
}

static void dcerpc_decode_replPropertyMetaData_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_replPropertyMetaData_state *state = tevent_req_data(
		req, struct dcerpc_decode_replPropertyMetaData_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_replPropertyMetaData_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_replPropertyMetaData_recv(struct tevent_req *req,
						 TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_replPropertyMetaData_state *state = tevent_req_data(
		req, struct dcerpc_decode_replPropertyMetaData_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_replPropertyMetaData(struct dcerpc_binding_handle *h,
					    TALLOC_CTX *mem_ctx,
					    struct replPropertyMetaDataBlob _blob /* [in]  */)
{
	struct decode_replPropertyMetaData r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_replPropertyMetaData_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_replUpToDateVector_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_replUpToDateVector_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_replUpToDateVector_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_replUpToDateVector *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_replUpToDateVector_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_replUpToDateVector_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPLUPTODATEVECTOR, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_replUpToDateVector_r_done, req);

	return req;
}

static void dcerpc_decode_replUpToDateVector_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_replUpToDateVector_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_replUpToDateVector_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_replUpToDateVector_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_replUpToDateVector_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_replUpToDateVector *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPLUPTODATEVECTOR, mem_ctx, r);

	return status;
}

struct dcerpc_decode_replUpToDateVector_state {
	struct decode_replUpToDateVector orig;
	struct decode_replUpToDateVector tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_replUpToDateVector_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_replUpToDateVector_send(TALLOC_CTX *mem_ctx,
							 struct tevent_context *ev,
							 struct dcerpc_binding_handle *h,
							 struct replUpToDateVectorBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_replUpToDateVector_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_replUpToDateVector_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_replUpToDateVector_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_replUpToDateVector_done, req);
	return req;
}

static void dcerpc_decode_replUpToDateVector_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_replUpToDateVector_state *state = tevent_req_data(
		req, struct dcerpc_decode_replUpToDateVector_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_replUpToDateVector_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_replUpToDateVector_recv(struct tevent_req *req,
					       TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_replUpToDateVector_state *state = tevent_req_data(
		req, struct dcerpc_decode_replUpToDateVector_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_replUpToDateVector(struct dcerpc_binding_handle *h,
					  TALLOC_CTX *mem_ctx,
					  struct replUpToDateVectorBlob _blob /* [in]  */)
{
	struct decode_replUpToDateVector r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_replUpToDateVector_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_repsFromTo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_repsFromTo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_repsFromTo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_repsFromTo *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_repsFromTo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_repsFromTo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPSFROMTO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_repsFromTo_r_done, req);

	return req;
}

static void dcerpc_decode_repsFromTo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_repsFromTo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_repsFromTo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_repsFromTo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_repsFromTo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_repsFromTo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_REPSFROMTO, mem_ctx, r);

	return status;
}

struct dcerpc_decode_repsFromTo_state {
	struct decode_repsFromTo orig;
	struct decode_repsFromTo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_repsFromTo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_repsFromTo_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct dcerpc_binding_handle *h,
						 struct repsFromToBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_repsFromTo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_repsFromTo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_repsFromTo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_repsFromTo_done, req);
	return req;
}

static void dcerpc_decode_repsFromTo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_repsFromTo_state *state = tevent_req_data(
		req, struct dcerpc_decode_repsFromTo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_repsFromTo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_repsFromTo_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_repsFromTo_state *state = tevent_req_data(
		req, struct dcerpc_decode_repsFromTo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_repsFromTo(struct dcerpc_binding_handle *h,
				  TALLOC_CTX *mem_ctx,
				  struct repsFromToBlob _blob /* [in]  */)
{
	struct decode_repsFromTo r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_repsFromTo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_partialAttributeSet_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_partialAttributeSet_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_partialAttributeSet_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_partialAttributeSet *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_partialAttributeSet_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_partialAttributeSet_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PARTIALATTRIBUTESET, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_partialAttributeSet_r_done, req);

	return req;
}

static void dcerpc_decode_partialAttributeSet_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_partialAttributeSet_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_partialAttributeSet_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_partialAttributeSet_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_partialAttributeSet_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_partialAttributeSet *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PARTIALATTRIBUTESET, mem_ctx, r);

	return status;
}

struct dcerpc_decode_partialAttributeSet_state {
	struct decode_partialAttributeSet orig;
	struct decode_partialAttributeSet tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_partialAttributeSet_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_partialAttributeSet_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h,
							  struct partialAttributeSetBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_partialAttributeSet_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_partialAttributeSet_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_partialAttributeSet_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_partialAttributeSet_done, req);
	return req;
}

static void dcerpc_decode_partialAttributeSet_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_partialAttributeSet_state *state = tevent_req_data(
		req, struct dcerpc_decode_partialAttributeSet_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_partialAttributeSet_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_partialAttributeSet_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_partialAttributeSet_state *state = tevent_req_data(
		req, struct dcerpc_decode_partialAttributeSet_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_partialAttributeSet(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   struct partialAttributeSetBlob _blob /* [in]  */)
{
	struct decode_partialAttributeSet r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_partialAttributeSet_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_prefixMap_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_prefixMap_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_prefixMap_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_prefixMap *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_prefixMap_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_prefixMap_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PREFIXMAP, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_prefixMap_r_done, req);

	return req;
}

static void dcerpc_decode_prefixMap_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_prefixMap_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_prefixMap_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_prefixMap_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_prefixMap_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_prefixMap *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PREFIXMAP, mem_ctx, r);

	return status;
}

struct dcerpc_decode_prefixMap_state {
	struct decode_prefixMap orig;
	struct decode_prefixMap tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_prefixMap_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_prefixMap_send(TALLOC_CTX *mem_ctx,
						struct tevent_context *ev,
						struct dcerpc_binding_handle *h,
						struct prefixMapBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_prefixMap_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_prefixMap_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_prefixMap_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_prefixMap_done, req);
	return req;
}

static void dcerpc_decode_prefixMap_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_prefixMap_state *state = tevent_req_data(
		req, struct dcerpc_decode_prefixMap_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_prefixMap_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_prefixMap_recv(struct tevent_req *req,
				      TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_prefixMap_state *state = tevent_req_data(
		req, struct dcerpc_decode_prefixMap_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_prefixMap(struct dcerpc_binding_handle *h,
				 TALLOC_CTX *mem_ctx,
				 struct prefixMapBlob _blob /* [in]  */)
{
	struct decode_prefixMap r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_prefixMap_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_ldapControlDirSync_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ldapControlDirSync_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ldapControlDirSync_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_ldapControlDirSync *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_ldapControlDirSync_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ldapControlDirSync_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_LDAPCONTROLDIRSYNC, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ldapControlDirSync_r_done, req);

	return req;
}

static void dcerpc_decode_ldapControlDirSync_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ldapControlDirSync_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ldapControlDirSync_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_ldapControlDirSync_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ldapControlDirSync_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_ldapControlDirSync *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_LDAPCONTROLDIRSYNC, mem_ctx, r);

	return status;
}

struct dcerpc_decode_ldapControlDirSync_state {
	struct decode_ldapControlDirSync orig;
	struct decode_ldapControlDirSync tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ldapControlDirSync_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ldapControlDirSync_send(TALLOC_CTX *mem_ctx,
							 struct tevent_context *ev,
							 struct dcerpc_binding_handle *h,
							 struct ldapControlDirSyncCookie _cookie /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_ldapControlDirSync_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ldapControlDirSync_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.cookie = _cookie;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_ldapControlDirSync_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ldapControlDirSync_done, req);
	return req;
}

static void dcerpc_decode_ldapControlDirSync_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_ldapControlDirSync_state *state = tevent_req_data(
		req, struct dcerpc_decode_ldapControlDirSync_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_ldapControlDirSync_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ldapControlDirSync_recv(struct tevent_req *req,
					       TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ldapControlDirSync_state *state = tevent_req_data(
		req, struct dcerpc_decode_ldapControlDirSync_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ldapControlDirSync(struct dcerpc_binding_handle *h,
					  TALLOC_CTX *mem_ctx,
					  struct ldapControlDirSyncCookie _cookie /* [in]  */)
{
	struct decode_ldapControlDirSync r;
	NTSTATUS status;

	/* In parameters */
	r.in.cookie = _cookie;

	status = dcerpc_decode_ldapControlDirSync_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_supplementalCredentials_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_supplementalCredentials_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_supplementalCredentials_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_supplementalCredentials *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_supplementalCredentials_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_supplementalCredentials_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_SUPPLEMENTALCREDENTIALS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_supplementalCredentials_r_done, req);

	return req;
}

static void dcerpc_decode_supplementalCredentials_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_supplementalCredentials_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_supplementalCredentials_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_supplementalCredentials_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_supplementalCredentials_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_supplementalCredentials *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_SUPPLEMENTALCREDENTIALS, mem_ctx, r);

	return status;
}

struct dcerpc_decode_supplementalCredentials_state {
	struct decode_supplementalCredentials orig;
	struct decode_supplementalCredentials tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_supplementalCredentials_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_supplementalCredentials_send(TALLOC_CTX *mem_ctx,
							      struct tevent_context *ev,
							      struct dcerpc_binding_handle *h,
							      struct supplementalCredentialsBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_supplementalCredentials_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_supplementalCredentials_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_supplementalCredentials_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_supplementalCredentials_done, req);
	return req;
}

static void dcerpc_decode_supplementalCredentials_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_supplementalCredentials_state *state = tevent_req_data(
		req, struct dcerpc_decode_supplementalCredentials_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_supplementalCredentials_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_supplementalCredentials_recv(struct tevent_req *req,
						    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_supplementalCredentials_state *state = tevent_req_data(
		req, struct dcerpc_decode_supplementalCredentials_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_supplementalCredentials(struct dcerpc_binding_handle *h,
					       TALLOC_CTX *mem_ctx,
					       struct supplementalCredentialsBlob _blob /* [in]  */)
{
	struct decode_supplementalCredentials r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_supplementalCredentials_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_Packages_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_Packages_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_Packages_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_Packages *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_Packages_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_Packages_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PACKAGES, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_Packages_r_done, req);

	return req;
}

static void dcerpc_decode_Packages_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_Packages_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_Packages_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_Packages_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_Packages_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_Packages *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PACKAGES, mem_ctx, r);

	return status;
}

struct dcerpc_decode_Packages_state {
	struct decode_Packages orig;
	struct decode_Packages tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_Packages_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_Packages_send(TALLOC_CTX *mem_ctx,
					       struct tevent_context *ev,
					       struct dcerpc_binding_handle *h,
					       struct package_PackagesBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_Packages_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_Packages_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_Packages_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_Packages_done, req);
	return req;
}

static void dcerpc_decode_Packages_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_Packages_state *state = tevent_req_data(
		req, struct dcerpc_decode_Packages_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_Packages_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_Packages_recv(struct tevent_req *req,
				     TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_Packages_state *state = tevent_req_data(
		req, struct dcerpc_decode_Packages_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_Packages(struct dcerpc_binding_handle *h,
				TALLOC_CTX *mem_ctx,
				struct package_PackagesBlob _blob /* [in]  */)
{
	struct decode_Packages r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_Packages_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_PrimaryKerberos_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryKerberos_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryKerberos_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_PrimaryKerberos *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryKerberos_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryKerberos_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYKERBEROS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryKerberos_r_done, req);

	return req;
}

static void dcerpc_decode_PrimaryKerberos_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryKerberos_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryKerberos_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_PrimaryKerberos_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryKerberos_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_PrimaryKerberos *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYKERBEROS, mem_ctx, r);

	return status;
}

struct dcerpc_decode_PrimaryKerberos_state {
	struct decode_PrimaryKerberos orig;
	struct decode_PrimaryKerberos tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryKerberos_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryKerberos_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct dcerpc_binding_handle *h,
						      struct package_PrimaryKerberosBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryKerberos_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryKerberos_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_PrimaryKerberos_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryKerberos_done, req);
	return req;
}

static void dcerpc_decode_PrimaryKerberos_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_PrimaryKerberos_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryKerberos_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_PrimaryKerberos_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryKerberos_recv(struct tevent_req *req,
					    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryKerberos_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryKerberos_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryKerberos(struct dcerpc_binding_handle *h,
				       TALLOC_CTX *mem_ctx,
				       struct package_PrimaryKerberosBlob _blob /* [in]  */)
{
	struct decode_PrimaryKerberos r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_PrimaryKerberos_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_PrimaryCLEARTEXT_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryCLEARTEXT_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryCLEARTEXT_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_PrimaryCLEARTEXT *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryCLEARTEXT_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryCLEARTEXT_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYCLEARTEXT, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryCLEARTEXT_r_done, req);

	return req;
}

static void dcerpc_decode_PrimaryCLEARTEXT_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryCLEARTEXT_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryCLEARTEXT_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_PrimaryCLEARTEXT_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryCLEARTEXT_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_PrimaryCLEARTEXT *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYCLEARTEXT, mem_ctx, r);

	return status;
}

struct dcerpc_decode_PrimaryCLEARTEXT_state {
	struct decode_PrimaryCLEARTEXT orig;
	struct decode_PrimaryCLEARTEXT tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryCLEARTEXT_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryCLEARTEXT_send(TALLOC_CTX *mem_ctx,
						       struct tevent_context *ev,
						       struct dcerpc_binding_handle *h,
						       struct package_PrimaryCLEARTEXTBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryCLEARTEXT_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryCLEARTEXT_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_PrimaryCLEARTEXT_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryCLEARTEXT_done, req);
	return req;
}

static void dcerpc_decode_PrimaryCLEARTEXT_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_PrimaryCLEARTEXT_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryCLEARTEXT_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_PrimaryCLEARTEXT_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryCLEARTEXT_recv(struct tevent_req *req,
					     TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryCLEARTEXT_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryCLEARTEXT_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryCLEARTEXT(struct dcerpc_binding_handle *h,
					TALLOC_CTX *mem_ctx,
					struct package_PrimaryCLEARTEXTBlob _blob /* [in]  */)
{
	struct decode_PrimaryCLEARTEXT r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_PrimaryCLEARTEXT_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_PrimaryWDigest_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryWDigest_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryWDigest_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_PrimaryWDigest *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryWDigest_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryWDigest_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYWDIGEST, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryWDigest_r_done, req);

	return req;
}

static void dcerpc_decode_PrimaryWDigest_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryWDigest_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryWDigest_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_PrimaryWDigest_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryWDigest_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_PrimaryWDigest *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_PRIMARYWDIGEST, mem_ctx, r);

	return status;
}

struct dcerpc_decode_PrimaryWDigest_state {
	struct decode_PrimaryWDigest orig;
	struct decode_PrimaryWDigest tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_PrimaryWDigest_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_PrimaryWDigest_send(TALLOC_CTX *mem_ctx,
						     struct tevent_context *ev,
						     struct dcerpc_binding_handle *h,
						     struct package_PrimaryWDigestBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_PrimaryWDigest_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_PrimaryWDigest_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_PrimaryWDigest_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_PrimaryWDigest_done, req);
	return req;
}

static void dcerpc_decode_PrimaryWDigest_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_PrimaryWDigest_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryWDigest_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_PrimaryWDigest_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_PrimaryWDigest_recv(struct tevent_req *req,
					   TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_PrimaryWDigest_state *state = tevent_req_data(
		req, struct dcerpc_decode_PrimaryWDigest_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_PrimaryWDigest(struct dcerpc_binding_handle *h,
				      TALLOC_CTX *mem_ctx,
				      struct package_PrimaryWDigestBlob _blob /* [in]  */)
{
	struct decode_PrimaryWDigest r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_PrimaryWDigest_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_trustAuthInOut_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_trustAuthInOut_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_trustAuthInOut_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_trustAuthInOut *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_trustAuthInOut_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_trustAuthInOut_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_TRUSTAUTHINOUT, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_trustAuthInOut_r_done, req);

	return req;
}

static void dcerpc_decode_trustAuthInOut_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_trustAuthInOut_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_trustAuthInOut_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_trustAuthInOut_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_trustAuthInOut_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_trustAuthInOut *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_TRUSTAUTHINOUT, mem_ctx, r);

	return status;
}

struct dcerpc_decode_trustAuthInOut_state {
	struct decode_trustAuthInOut orig;
	struct decode_trustAuthInOut tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_trustAuthInOut_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_trustAuthInOut_send(TALLOC_CTX *mem_ctx,
						     struct tevent_context *ev,
						     struct dcerpc_binding_handle *h,
						     struct trustAuthInOutBlob _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_trustAuthInOut_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_trustAuthInOut_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_trustAuthInOut_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_trustAuthInOut_done, req);
	return req;
}

static void dcerpc_decode_trustAuthInOut_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_trustAuthInOut_state *state = tevent_req_data(
		req, struct dcerpc_decode_trustAuthInOut_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_trustAuthInOut_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_trustAuthInOut_recv(struct tevent_req *req,
					   TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_trustAuthInOut_state *state = tevent_req_data(
		req, struct dcerpc_decode_trustAuthInOut_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_trustAuthInOut(struct dcerpc_binding_handle *h,
				      TALLOC_CTX *mem_ctx,
				      struct trustAuthInOutBlob _blob /* [in]  */)
{
	struct decode_trustAuthInOut r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_trustAuthInOut_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_trustDomainPasswords_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_trustDomainPasswords_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_trustDomainPasswords_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_trustDomainPasswords *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_trustDomainPasswords_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_trustDomainPasswords_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_TRUSTDOMAINPASSWORDS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_trustDomainPasswords_r_done, req);

	return req;
}

static void dcerpc_decode_trustDomainPasswords_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_trustDomainPasswords_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_trustDomainPasswords_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_trustDomainPasswords_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_trustDomainPasswords_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_trustDomainPasswords *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_TRUSTDOMAINPASSWORDS, mem_ctx, r);

	return status;
}

struct dcerpc_decode_trustDomainPasswords_state {
	struct decode_trustDomainPasswords orig;
	struct decode_trustDomainPasswords tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_trustDomainPasswords_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_trustDomainPasswords_send(TALLOC_CTX *mem_ctx,
							   struct tevent_context *ev,
							   struct dcerpc_binding_handle *h,
							   struct trustDomainPasswords _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_trustDomainPasswords_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_trustDomainPasswords_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_trustDomainPasswords_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_trustDomainPasswords_done, req);
	return req;
}

static void dcerpc_decode_trustDomainPasswords_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_trustDomainPasswords_state *state = tevent_req_data(
		req, struct dcerpc_decode_trustDomainPasswords_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_trustDomainPasswords_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_trustDomainPasswords_recv(struct tevent_req *req,
						 TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_trustDomainPasswords_state *state = tevent_req_data(
		req, struct dcerpc_decode_trustDomainPasswords_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_trustDomainPasswords(struct dcerpc_binding_handle *h,
					    TALLOC_CTX *mem_ctx,
					    struct trustDomainPasswords _blob /* [in]  */)
{
	struct decode_trustDomainPasswords r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_trustDomainPasswords_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_ExtendedErrorInfo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ExtendedErrorInfo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ExtendedErrorInfo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_ExtendedErrorInfo *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_ExtendedErrorInfo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ExtendedErrorInfo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_EXTENDEDERRORINFO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ExtendedErrorInfo_r_done, req);

	return req;
}

static void dcerpc_decode_ExtendedErrorInfo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ExtendedErrorInfo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ExtendedErrorInfo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_ExtendedErrorInfo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ExtendedErrorInfo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_ExtendedErrorInfo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_EXTENDEDERRORINFO, mem_ctx, r);

	return status;
}

struct dcerpc_decode_ExtendedErrorInfo_state {
	struct decode_ExtendedErrorInfo orig;
	struct decode_ExtendedErrorInfo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ExtendedErrorInfo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ExtendedErrorInfo_send(TALLOC_CTX *mem_ctx,
							struct tevent_context *ev,
							struct dcerpc_binding_handle *h,
							struct ExtendedErrorInfoPtr _ptr /* [in] [subcontext(0xFFFFFC01)] */)
{
	struct tevent_req *req;
	struct dcerpc_decode_ExtendedErrorInfo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ExtendedErrorInfo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ptr = _ptr;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_ExtendedErrorInfo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ExtendedErrorInfo_done, req);
	return req;
}

static void dcerpc_decode_ExtendedErrorInfo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_ExtendedErrorInfo_state *state = tevent_req_data(
		req, struct dcerpc_decode_ExtendedErrorInfo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_ExtendedErrorInfo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ExtendedErrorInfo_recv(struct tevent_req *req,
					      TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ExtendedErrorInfo_state *state = tevent_req_data(
		req, struct dcerpc_decode_ExtendedErrorInfo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ExtendedErrorInfo(struct dcerpc_binding_handle *h,
					 TALLOC_CTX *mem_ctx,
					 struct ExtendedErrorInfoPtr _ptr /* [in] [subcontext(0xFFFFFC01)] */)
{
	struct decode_ExtendedErrorInfo r;
	NTSTATUS status;

	/* In parameters */
	r.in.ptr = _ptr;

	status = dcerpc_decode_ExtendedErrorInfo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_decode_ForestTrustInfo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ForestTrustInfo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ForestTrustInfo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct decode_ForestTrustInfo *r)
{
	struct tevent_req *req;
	struct dcerpc_decode_ForestTrustInfo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ForestTrustInfo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_FORESTTRUSTINFO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ForestTrustInfo_r_done, req);

	return req;
}

static void dcerpc_decode_ForestTrustInfo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ForestTrustInfo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ForestTrustInfo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_ForestTrustInfo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ForestTrustInfo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct decode_ForestTrustInfo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_drsblobs,
			NDR_DECODE_FORESTTRUSTINFO, mem_ctx, r);

	return status;
}

struct dcerpc_decode_ForestTrustInfo_state {
	struct decode_ForestTrustInfo orig;
	struct decode_ForestTrustInfo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_decode_ForestTrustInfo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_decode_ForestTrustInfo_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct dcerpc_binding_handle *h,
						      struct ForestTrustInfo _blob /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_decode_ForestTrustInfo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_decode_ForestTrustInfo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.blob = _blob;

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_decode_ForestTrustInfo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_decode_ForestTrustInfo_done, req);
	return req;
}

static void dcerpc_decode_ForestTrustInfo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_decode_ForestTrustInfo_state *state = tevent_req_data(
		req, struct dcerpc_decode_ForestTrustInfo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_decode_ForestTrustInfo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_decode_ForestTrustInfo_recv(struct tevent_req *req,
					    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_ForestTrustInfo_state *state = tevent_req_data(
		req, struct dcerpc_decode_ForestTrustInfo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_decode_ForestTrustInfo(struct dcerpc_binding_handle *h,
				       TALLOC_CTX *mem_ctx,
				       struct ForestTrustInfo _blob /* [in]  */)
{
	struct decode_ForestTrustInfo r;
	NTSTATUS status;

	/* In parameters */
	r.in.blob = _blob;

	status = dcerpc_decode_ForestTrustInfo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

