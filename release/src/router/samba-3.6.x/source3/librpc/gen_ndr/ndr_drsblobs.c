/* parser auto-generated by pidl */

#include "includes.h"
#include "librpc/gen_ndr/ndr_drsblobs.h"

#include "librpc/gen_ndr/ndr_drsuapi.h"
#include "librpc/gen_ndr/ndr_misc.h"
#include "librpc/gen_ndr/ndr_samr.h"
#include "librpc/gen_ndr/ndr_lsa.h"
#include "librpc/gen_ndr/ndr_security.h"
static enum ndr_err_code ndr_push_replPropertyMetaData1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_drsuapi_DsAttributeId(ndr, NDR_SCALARS, r->attid));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->originating_change_time));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->originating_invocation_id));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->originating_usn));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->local_usn));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaData1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaData1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_drsuapi_DsAttributeId(ndr, NDR_SCALARS, &r->attid));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->originating_change_time));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->originating_invocation_id));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->originating_usn));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->local_usn));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaData1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaData1 *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaData1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_drsuapi_DsAttributeId(ndr, "attid", r->attid);
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_NTTIME_1sec(ndr, "originating_change_time", r->originating_change_time);
	ndr_print_GUID(ndr, "originating_invocation_id", &r->originating_invocation_id);
	ndr_print_hyper(ndr, "originating_usn", r->originating_usn);
	ndr_print_hyper(ndr, "local_usn", r->local_usn);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replPropertyMetaDataCtr1(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_replPropertyMetaData1(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaDataCtr1(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataCtr1 *r)
{
	uint32_t size_array_0 = 0;
	uint32_t cntr_array_0;
	TALLOC_CTX *_mem_save_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		size_array_0 = r->count;
		NDR_PULL_ALLOC_N(ndr, r->array, size_array_0);
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < size_array_0; cntr_array_0++) {
			NDR_CHECK(ndr_pull_replPropertyMetaData1(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr1(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataCtr1 *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "replPropertyMetaDataCtr1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", (int)r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		ndr_print_replPropertyMetaData1(ndr, "array", &r->array[cntr_array_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replPropertyMetaDataCtr(struct ndr_push *ndr, int ndr_flags, const union replPropertyMetaDataCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replPropertyMetaDataCtr(struct ndr_pull *ndr, int ndr_flags, union replPropertyMetaDataCtr *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replPropertyMetaDataCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataCtr(struct ndr_print *ndr, const char *name, const union replPropertyMetaDataCtr *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replPropertyMetaDataCtr");
	switch (level) {
		case 1:
			ndr_print_replPropertyMetaDataCtr1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_replPropertyMetaDataBlob(struct ndr_push *ndr, int ndr_flags, const struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_replPropertyMetaDataBlob(struct ndr_pull *ndr, int ndr_flags, struct replPropertyMetaDataBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replPropertyMetaDataCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replPropertyMetaDataBlob(struct ndr_print *ndr, const char *name, const struct replPropertyMetaDataBlob *r)
{
	ndr_print_struct(ndr, name, "replPropertyMetaDataBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replPropertyMetaDataCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr1(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCursor(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr1(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr1 *r)
{
	uint32_t size_cursors_0 = 0;
	uint32_t cntr_cursors_0;
	TALLOC_CTX *_mem_save_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		size_cursors_0 = r->count;
		NDR_PULL_ALLOC_N(ndr, r->cursors, size_cursors_0);
		_mem_save_cursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->cursors, 0);
		for (cntr_cursors_0 = 0; cntr_cursors_0 < size_cursors_0; cntr_cursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCursor(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_cursors_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr1(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr1 *r)
{
	uint32_t cntr_cursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "cursors", (int)r->count);
	ndr->depth++;
	for (cntr_cursors_0=0;cntr_cursors_0<r->count;cntr_cursors_0++) {
		ndr_print_drsuapi_DsReplicaCursor(ndr, "cursors", &r->cursors[cntr_cursors_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr2(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		for (cntr_cursors_0 = 0; cntr_cursors_0 < r->count; cntr_cursors_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsReplicaCursor2(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr2(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorCtr2 *r)
{
	uint32_t size_cursors_0 = 0;
	uint32_t cntr_cursors_0;
	TALLOC_CTX *_mem_save_cursors_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		size_cursors_0 = r->count;
		NDR_PULL_ALLOC_N(ndr, r->cursors, size_cursors_0);
		_mem_save_cursors_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->cursors, 0);
		for (cntr_cursors_0 = 0; cntr_cursors_0 < size_cursors_0; cntr_cursors_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaCursor2(ndr, NDR_SCALARS, &r->cursors[cntr_cursors_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_cursors_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr2(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorCtr2 *r)
{
	uint32_t cntr_cursors_0;
	ndr_print_struct(ndr, name, "replUpToDateVectorCtr2");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr->print(ndr, "%s: ARRAY(%d)", "cursors", (int)r->count);
	ndr->depth++;
	for (cntr_cursors_0=0;cntr_cursors_0<r->count;cntr_cursors_0++) {
		ndr_print_drsuapi_DsReplicaCursor2(ndr, "cursors", &r->cursors[cntr_cursors_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_replUpToDateVectorCtr(struct ndr_push *ndr, int ndr_flags, const union replUpToDateVectorCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_push_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_replUpToDateVectorCtr(struct ndr_pull *ndr, int ndr_flags, union replUpToDateVectorCtr *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_replUpToDateVectorCtr2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorCtr(struct ndr_print *ndr, const char *name, const union replUpToDateVectorCtr *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "replUpToDateVectorCtr");
	switch (level) {
		case 1:
			ndr_print_replUpToDateVectorCtr1(ndr, "ctr1", &r->ctr1);
		break;

		case 2:
			ndr_print_replUpToDateVectorCtr2(ndr, "ctr2", &r->ctr2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_replUpToDateVectorBlob(struct ndr_push *ndr, int ndr_flags, const struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_replUpToDateVectorBlob(struct ndr_pull *ndr, int ndr_flags, struct replUpToDateVectorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_replUpToDateVectorCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_replUpToDateVectorBlob(struct ndr_print *ndr, const char *name, const struct replUpToDateVectorBlob *r)
{
	ndr_print_struct(ndr, name, "replUpToDateVectorBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_replUpToDateVectorCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo1OtherInfo(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1OtherInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, strlen(r->dns_name) + 1));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->dns_name, strlen(r->dns_name) + 1, sizeof(uint8_t), CH_DOS));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo1OtherInfo(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1OtherInfo *r)
{
	uint32_t size_dns_name_0 = 0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__dns_name_size));
		size_dns_name_0 = r->__dns_name_size;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->dns_name, size_dns_name_0, sizeof(uint8_t), CH_DOS));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo1OtherInfo(struct ndr_print *ndr, const char *name, const struct repsFromTo1OtherInfo *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1OtherInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "__dns_name_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?strlen(r->dns_name) + 1:r->__dns_name_size);
	ndr_print_string(ndr, "dns_name", r->dns_name);
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_repsFromTo1OtherInfo(const struct repsFromTo1OtherInfo *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1OtherInfo);
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo1(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo1 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1(r, ndr->flags) + 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->consecutive_sync_failures));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_success));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_attempt));
			NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->result_last_attempt));
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->other_info));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo1OtherInfo(r->other_info, ndr->flags)));
			NDR_CHECK(ndr_push_drsuapi_DrsOptions(ndr, NDR_SCALARS, r->replica_flags));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->transport_guid));
			NDR_CHECK(ndr_push_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->other_info));
				NDR_CHECK(ndr_push_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->other_info));
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo1(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo1 *r)
{
	uint32_t _ptr_other_info;
	TALLOC_CTX *_mem_save_other_info_0;
	uint32_t size_schedule_0 = 0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 8));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->blobsize));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->consecutive_sync_failures));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_success));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_attempt));
			NDR_CHECK(ndr_pull_WERROR(ndr, NDR_SCALARS, &r->result_last_attempt));
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_other_info));
			if (_ptr_other_info) {
				NDR_PULL_ALLOC(ndr, r->other_info);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->other_info, _ptr_other_info));
			} else {
				r->other_info = NULL;
			}
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->other_info_length));
			NDR_CHECK(ndr_pull_drsuapi_DrsOptions(ndr, NDR_SCALARS, &r->replica_flags));
			size_schedule_0 = 84;
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->schedule, size_schedule_0));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->transport_guid));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->other_info));
				_mem_save_other_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->other_info, 0);
				NDR_CHECK(ndr_pull_repsFromTo1OtherInfo(ndr, NDR_SCALARS, r->other_info));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_other_info_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo1(struct ndr_print *ndr, const char *name, const struct repsFromTo1 *r)
{
	ndr_print_struct(ndr, name, "repsFromTo1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_uint32(ndr, "blobsize", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1(r, ndr->flags) + 8:r->blobsize);
		ndr_print_uint32(ndr, "consecutive_sync_failures", r->consecutive_sync_failures);
		ndr_print_NTTIME_1sec(ndr, "last_success", r->last_success);
		ndr_print_NTTIME_1sec(ndr, "last_attempt", r->last_attempt);
		ndr_print_WERROR(ndr, "result_last_attempt", r->result_last_attempt);
		ndr_print_ptr(ndr, "other_info", r->other_info);
		ndr->depth++;
		if (r->other_info) {
			ndr_print_repsFromTo1OtherInfo(ndr, "other_info", r->other_info);
		}
		ndr->depth--;
		ndr_print_uint32(ndr, "other_info_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo1OtherInfo(r->other_info, ndr->flags):r->other_info_length);
		ndr_print_drsuapi_DrsOptions(ndr, "replica_flags", r->replica_flags);
		ndr_print_array_uint8(ndr, "schedule", r->schedule, 84);
		ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
		ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
		ndr_print_GUID(ndr, "source_dsa_obj_guid", &r->source_dsa_obj_guid);
		ndr_print_GUID(ndr, "source_dsa_invocation_id", &r->source_dsa_invocation_id);
		ndr_print_GUID(ndr, "transport_guid", &r->transport_guid);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ size_t ndr_size_repsFromTo1(const struct repsFromTo1 *r, int flags)
{
	flags |= LIBNDR_PRINT_ARRAY_HEX;
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo1);
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo2OtherInfo(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo2OtherInfo *r)
{
	uint32_t _save_relative_base_offset = ndr_push_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo2OtherInfo(r, ndr->flags)));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->dns_name1));
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->unknown1));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->dns_name2));
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->unknown2));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_setup_relative_base_offset2(ndr, r));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			if (r->dns_name1) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->dns_name1));
				NDR_CHECK(ndr_push_string(ndr, NDR_SCALARS, r->dns_name1));
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->dns_name1));
			}
			ndr->flags = _flags_save_string;
		}
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			if (r->dns_name2) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->dns_name2));
				NDR_CHECK(ndr_push_string(ndr, NDR_SCALARS, r->dns_name2));
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->dns_name2));
			}
			ndr->flags = _flags_save_string;
		}
	}
	ndr_push_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo2OtherInfo(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo2OtherInfo *r)
{
	uint32_t _save_relative_base_offset = ndr_pull_get_relative_base_offset(ndr);
	uint32_t _ptr_dns_name1;
	TALLOC_CTX *_mem_save_dns_name1_0;
	uint32_t _ptr_dns_name2;
	TALLOC_CTX *_mem_save_dns_name2_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__ndr_size));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_dns_name1));
			if (_ptr_dns_name1) {
				NDR_PULL_ALLOC(ndr, r->dns_name1);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->dns_name1, _ptr_dns_name1));
			} else {
				r->dns_name1 = NULL;
			}
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_dns_name2));
			if (_ptr_dns_name2) {
				NDR_PULL_ALLOC(ndr, r->dns_name2);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->dns_name2, _ptr_dns_name2));
			} else {
				r->dns_name2 = NULL;
			}
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->unknown2));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_setup_relative_base_offset2(ndr, r));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			if (r->dns_name1) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->dns_name1));
				_mem_save_dns_name1_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->dns_name1, 0);
				NDR_CHECK(ndr_pull_string(ndr, NDR_SCALARS, &r->dns_name1));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_dns_name1_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_string;
		}
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NULLTERM|LIBNDR_FLAG_ALIGN2);
			if (r->dns_name2) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->dns_name2));
				_mem_save_dns_name2_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->dns_name2, 0);
				NDR_CHECK(ndr_pull_string(ndr, NDR_SCALARS, &r->dns_name2));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_dns_name2_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_string;
		}
	}
	ndr_pull_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo2OtherInfo(struct ndr_print *ndr, const char *name, const struct repsFromTo2OtherInfo *r)
{
	ndr_print_struct(ndr, name, "repsFromTo2OtherInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "__ndr_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo2OtherInfo(r, ndr->flags):r->__ndr_size);
	ndr_print_ptr(ndr, "dns_name1", r->dns_name1);
	ndr->depth++;
	if (r->dns_name1) {
		ndr_print_string(ndr, "dns_name1", r->dns_name1);
	}
	ndr->depth--;
	ndr_print_uint32(ndr, "unknown1", r->unknown1);
	ndr_print_ptr(ndr, "dns_name2", r->dns_name2);
	ndr->depth++;
	if (r->dns_name2) {
		ndr_print_string(ndr, "dns_name2", r->dns_name2);
	}
	ndr->depth--;
	ndr_print_hyper(ndr, "unknown2", r->unknown2);
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_repsFromTo2OtherInfo(const struct repsFromTo2OtherInfo *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo2OtherInfo);
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromTo2(struct ndr_push *ndr, int ndr_flags, const struct repsFromTo2 *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo2(r, ndr->flags) + 8));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->consecutive_sync_failures));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_success));
			NDR_CHECK(ndr_push_NTTIME_1sec(ndr, NDR_SCALARS, r->last_attempt));
			NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->result_last_attempt));
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->other_info));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_repsFromTo2OtherInfo(r->other_info, ndr->flags)));
			NDR_CHECK(ndr_push_drsuapi_DrsOptions(ndr, NDR_SCALARS, r->replica_flags));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->schedule, 84));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->transport_guid));
			NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->unknown1));
			NDR_CHECK(ndr_push_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->other_info));
				NDR_CHECK(ndr_push_repsFromTo2OtherInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->other_info));
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->other_info));
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromTo2(struct ndr_pull *ndr, int ndr_flags, struct repsFromTo2 *r)
{
	uint32_t _ptr_other_info;
	TALLOC_CTX *_mem_save_other_info_0;
	uint32_t size_schedule_0 = 0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 8));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->blobsize));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->consecutive_sync_failures));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_success));
			NDR_CHECK(ndr_pull_NTTIME_1sec(ndr, NDR_SCALARS, &r->last_attempt));
			NDR_CHECK(ndr_pull_WERROR(ndr, NDR_SCALARS, &r->result_last_attempt));
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_other_info));
			if (_ptr_other_info) {
				NDR_PULL_ALLOC(ndr, r->other_info);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->other_info, _ptr_other_info));
			} else {
				r->other_info = NULL;
			}
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->other_info_length));
			NDR_CHECK(ndr_pull_drsuapi_DrsOptions(ndr, NDR_SCALARS, &r->replica_flags));
			size_schedule_0 = 84;
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->schedule, size_schedule_0));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
			NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_obj_guid));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->source_dsa_invocation_id));
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->transport_guid));
			NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->unknown1));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
		}
		if (ndr_flags & NDR_BUFFERS) {
			if (r->other_info) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->other_info));
				_mem_save_other_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->other_info, 0);
				NDR_CHECK(ndr_pull_repsFromTo2OtherInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->other_info));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_other_info_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo2(struct ndr_print *ndr, const char *name, const struct repsFromTo2 *r)
{
	ndr_print_struct(ndr, name, "repsFromTo2");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_uint32(ndr, "blobsize", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo2(r, ndr->flags) + 8:r->blobsize);
		ndr_print_uint32(ndr, "consecutive_sync_failures", r->consecutive_sync_failures);
		ndr_print_NTTIME_1sec(ndr, "last_success", r->last_success);
		ndr_print_NTTIME_1sec(ndr, "last_attempt", r->last_attempt);
		ndr_print_WERROR(ndr, "result_last_attempt", r->result_last_attempt);
		ndr_print_ptr(ndr, "other_info", r->other_info);
		ndr->depth++;
		if (r->other_info) {
			ndr_print_repsFromTo2OtherInfo(ndr, "other_info", r->other_info);
		}
		ndr->depth--;
		ndr_print_uint32(ndr, "other_info_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_repsFromTo2OtherInfo(r->other_info, ndr->flags):r->other_info_length);
		ndr_print_drsuapi_DrsOptions(ndr, "replica_flags", r->replica_flags);
		ndr_print_array_uint8(ndr, "schedule", r->schedule, 84);
		ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
		ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
		ndr_print_GUID(ndr, "source_dsa_obj_guid", &r->source_dsa_obj_guid);
		ndr_print_GUID(ndr, "source_dsa_invocation_id", &r->source_dsa_invocation_id);
		ndr_print_GUID(ndr, "transport_guid", &r->transport_guid);
		ndr_print_hyper(ndr, "unknown1", r->unknown1);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ size_t ndr_size_repsFromTo2(const struct repsFromTo2 *r, int flags)
{
	flags |= LIBNDR_PRINT_ARRAY_HEX;
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_repsFromTo2);
}

static enum ndr_err_code ndr_push_repsFromTo(struct ndr_push *ndr, int ndr_flags, const union repsFromTo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_push_repsFromTo2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
				NDR_CHECK(ndr_push_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_push_repsFromTo2(ndr, NDR_BUFFERS, &r->ctr2));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_repsFromTo(struct ndr_pull *ndr, int ndr_flags, union repsFromTo *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_repsFromTo2(ndr, NDR_SCALARS, &r->ctr2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
				NDR_CHECK(ndr_pull_repsFromTo1(ndr, NDR_BUFFERS, &r->ctr1));
			break;

			case 2:
				NDR_CHECK(ndr_pull_repsFromTo2(ndr, NDR_BUFFERS, &r->ctr2));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromTo(struct ndr_print *ndr, const char *name, const union repsFromTo *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "repsFromTo");
	switch (level) {
		case 1:
			ndr_print_repsFromTo1(ndr, "ctr1", &r->ctr1);
		break;

		case 2:
			ndr_print_repsFromTo2(ndr, "ctr2", &r->ctr2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_repsFromToBlob(struct ndr_push *ndr, int ndr_flags, const struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_repsFromToBlob(struct ndr_pull *ndr, int ndr_flags, struct repsFromToBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_repsFromTo(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_repsFromToBlob(struct ndr_print *ndr, const char *name, const struct repsFromToBlob *r)
{
	ndr_print_struct(ndr, name, "repsFromToBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_repsFromTo(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_partialAttributeSetCtr1(struct ndr_push *ndr, int ndr_flags, const struct partialAttributeSetCtr1 *r)
{
	uint32_t cntr_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
		for (cntr_array_0 = 0; cntr_array_0 < r->count; cntr_array_0++) {
			NDR_CHECK(ndr_push_drsuapi_DsAttributeId(ndr, NDR_SCALARS, r->array[cntr_array_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_partialAttributeSetCtr1(struct ndr_pull *ndr, int ndr_flags, struct partialAttributeSetCtr1 *r)
{
	uint32_t size_array_0 = 0;
	uint32_t cntr_array_0;
	TALLOC_CTX *_mem_save_array_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		size_array_0 = r->count;
		NDR_PULL_ALLOC_N(ndr, r->array, size_array_0);
		_mem_save_array_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->array, 0);
		for (cntr_array_0 = 0; cntr_array_0 < size_array_0; cntr_array_0++) {
			NDR_CHECK(ndr_pull_drsuapi_DsAttributeId(ndr, NDR_SCALARS, &r->array[cntr_array_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_array_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetCtr1(struct ndr_print *ndr, const char *name, const struct partialAttributeSetCtr1 *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "partialAttributeSetCtr1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", (int)r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		ndr_print_drsuapi_DsAttributeId(ndr, "array", r->array[cntr_array_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_partialAttributeSetCtr(struct ndr_push *ndr, int ndr_flags, const union partialAttributeSetCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 4));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_partialAttributeSetCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_partialAttributeSetCtr(struct ndr_pull *ndr, int ndr_flags, union partialAttributeSetCtr *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 4));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_partialAttributeSetCtr1(ndr, NDR_SCALARS, &r->ctr1));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetCtr(struct ndr_print *ndr, const char *name, const union partialAttributeSetCtr *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "partialAttributeSetCtr");
	switch (level) {
		case 1:
			ndr_print_partialAttributeSetCtr1(ndr, "ctr1", &r->ctr1);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_partialAttributeSetBlob(struct ndr_push *ndr, int ndr_flags, const struct partialAttributeSetBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_partialAttributeSetCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_partialAttributeSetBlob(struct ndr_pull *ndr, int ndr_flags, struct partialAttributeSetBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_partialAttributeSetCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_partialAttributeSetBlob(struct ndr_print *ndr, const char *name, const struct partialAttributeSetBlob *r)
{
	ndr_print_struct(ndr, name, "partialAttributeSetBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_partialAttributeSetCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_schemaInfoBlob(struct ndr_push *ndr, int ndr_flags, const struct schemaInfoBlob *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, 0xFF));
			{
				uint32_t _flags_save_uint32 = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->revision));
				ndr->flags = _flags_save_uint32;
			}
			NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->invocation_id));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_schemaInfoBlob(struct ndr_pull *ndr, int ndr_flags, struct schemaInfoBlob *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->marker));
			{
				uint32_t _flags_save_uint32 = ndr->flags;
				ndr_set_flags(&ndr->flags, LIBNDR_FLAG_BIGENDIAN);
				NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->revision));
				ndr->flags = _flags_save_uint32;
			}
			NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->invocation_id));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_schemaInfoBlob(struct ndr_print *ndr, const char *name, const struct schemaInfoBlob *r)
{
	ndr_print_struct(ndr, name, "schemaInfoBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint8(ndr, "marker", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0xFF:r->marker);
		ndr_print_uint32(ndr, "revision", r->revision);
		ndr_print_GUID(ndr, "invocation_id", &r->invocation_id);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_drsuapi_MSPrefixMap_Entry(struct ndr_push *ndr, int ndr_flags, const struct drsuapi_MSPrefixMap_Entry *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 2));
			NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->entryID));
			NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->length));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->binary_oid, r->length));
			NDR_CHECK(ndr_push_trailer_align(ndr, 2));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_drsuapi_MSPrefixMap_Entry(struct ndr_pull *ndr, int ndr_flags, struct drsuapi_MSPrefixMap_Entry *r)
{
	uint32_t size_binary_oid_0 = 0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 2));
			NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->entryID));
			NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->length));
			size_binary_oid_0 = r->length;
			NDR_PULL_ALLOC_N(ndr, r->binary_oid, size_binary_oid_0);
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->binary_oid, size_binary_oid_0));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 2));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_push_drsuapi_MSPrefixMap_Ctr(struct ndr_push *ndr, int ndr_flags, const struct drsuapi_MSPrefixMap_Ctr *r)
{
	uint32_t cntr_entries_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->num_entries));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_drsuapi_MSPrefixMap_Ctr(r, ndr->flags)));
		for (cntr_entries_0 = 0; cntr_entries_0 < r->num_entries; cntr_entries_0++) {
			NDR_CHECK(ndr_push_drsuapi_MSPrefixMap_Entry(ndr, NDR_SCALARS, &r->entries[cntr_entries_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_drsuapi_MSPrefixMap_Ctr(struct ndr_pull *ndr, int ndr_flags, struct drsuapi_MSPrefixMap_Ctr *r)
{
	uint32_t size_entries_0 = 0;
	uint32_t cntr_entries_0;
	TALLOC_CTX *_mem_save_entries_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->num_entries));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__ndr_size));
		size_entries_0 = r->num_entries;
		NDR_PULL_ALLOC_N(ndr, r->entries, size_entries_0);
		_mem_save_entries_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->entries, 0);
		for (cntr_entries_0 = 0; cntr_entries_0 < size_entries_0; cntr_entries_0++) {
			NDR_CHECK(ndr_pull_drsuapi_MSPrefixMap_Entry(ndr, NDR_SCALARS, &r->entries[cntr_entries_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_entries_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_drsuapi_MSPrefixMap_Ctr(struct ndr_print *ndr, const char *name, const struct drsuapi_MSPrefixMap_Ctr *r)
{
	uint32_t cntr_entries_0;
	ndr_print_struct(ndr, name, "drsuapi_MSPrefixMap_Ctr");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "num_entries", r->num_entries);
	ndr_print_uint32(ndr, "__ndr_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_drsuapi_MSPrefixMap_Ctr(r, ndr->flags):r->__ndr_size);
	ndr->print(ndr, "%s: ARRAY(%d)", "entries", (int)r->num_entries);
	ndr->depth++;
	for (cntr_entries_0=0;cntr_entries_0<r->num_entries;cntr_entries_0++) {
		ndr_print_drsuapi_MSPrefixMap_Entry(ndr, "entries", &r->entries[cntr_entries_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_drsuapi_MSPrefixMap_Ctr(const struct drsuapi_MSPrefixMap_Ctr *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_drsuapi_MSPrefixMap_Ctr);
}

static enum ndr_err_code ndr_push_prefixMapVersion(struct ndr_push *ndr, int ndr_flags, enum prefixMapVersion r)
{
	NDR_CHECK(ndr_push_enum_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_prefixMapVersion(struct ndr_pull *ndr, int ndr_flags, enum prefixMapVersion *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_enum_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapVersion(struct ndr_print *ndr, const char *name, enum prefixMapVersion r)
{
	const char *val = NULL;

	switch (r) {
		case PREFIX_MAP_VERSION_DSDB: val = "PREFIX_MAP_VERSION_DSDB"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_prefixMapCtr(struct ndr_push *ndr, int ndr_flags, const union prefixMapCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 5));
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB: {
				NDR_CHECK(ndr_push_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_SCALARS, &r->dsdb));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB:
				NDR_CHECK(ndr_push_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_BUFFERS, &r->dsdb));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_prefixMapCtr(struct ndr_pull *ndr, int ndr_flags, union prefixMapCtr *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 5));
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB: {
				NDR_CHECK(ndr_pull_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_SCALARS, &r->dsdb));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case PREFIX_MAP_VERSION_DSDB:
				NDR_CHECK(ndr_pull_drsuapi_DsReplicaOIDMapping_Ctr(ndr, NDR_BUFFERS, &r->dsdb));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapCtr(struct ndr_print *ndr, const char *name, const union prefixMapCtr *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "prefixMapCtr");
	switch (level) {
		case PREFIX_MAP_VERSION_DSDB:
			ndr_print_drsuapi_DsReplicaOIDMapping_Ctr(ndr, "dsdb", &r->dsdb);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_prefixMapBlob(struct ndr_push *ndr, int ndr_flags, const struct prefixMapBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_prefixMapVersion(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_prefixMapCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_prefixMapCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_prefixMapBlob(struct ndr_pull *ndr, int ndr_flags, struct prefixMapBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_prefixMapVersion(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_prefixMapCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_prefixMapCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_prefixMapBlob(struct ndr_print *ndr, const char *name, const struct prefixMapBlob *r)
{
	ndr_print_struct(ndr, name, "prefixMapBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_prefixMapVersion(ndr, "version", r->version);
	ndr_print_uint32(ndr, "reserved", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_prefixMapCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ldapControlDirSyncExtra(struct ndr_push *ndr, int ndr_flags, const union ldapControlDirSyncExtra *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_push_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->uptodateness_vector));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 0:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ldapControlDirSyncExtra(struct ndr_pull *ndr, int ndr_flags, union ldapControlDirSyncExtra *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case 0: {
			break; }

			default: {
				NDR_CHECK(ndr_pull_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->uptodateness_vector));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 0:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncExtra(struct ndr_print *ndr, const char *name, const union ldapControlDirSyncExtra *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ldapControlDirSyncExtra");
	switch (level) {
		case 0:
		break;

		default:
			ndr_print_replUpToDateVectorBlob(ndr, "uptodateness_vector", &r->uptodateness_vector);
		break;

	}
}

static size_t ndr_size_ldapControlDirSyncExtra(const union ldapControlDirSyncExtra *r, uint32_t level, int flags)
{
	return ndr_size_union(r, flags, level, (ndr_push_flags_fn_t)ndr_push_ldapControlDirSyncExtra);
}

static enum ndr_err_code ndr_push_ldapControlDirSyncBlob(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 3));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u2));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->u3));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0)));
		NDR_CHECK(ndr_push_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_push_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->extra, ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0)));
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ldapControlDirSyncBlob(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u1));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->u3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->extra_length));
		NDR_CHECK(ndr_pull_drsuapi_DsReplicaHighWaterMark(ndr, NDR_SCALARS, &r->highwatermark));
		NDR_CHECK(ndr_pull_GUID(ndr, NDR_SCALARS, &r->guid1));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->extra, r->extra_length));
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_SCALARS, &r->extra));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_ldapControlDirSyncExtra(ndr, NDR_BUFFERS, &r->extra));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncBlob(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncBlob *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "u1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?3:r->u1);
	ndr_print_NTTIME(ndr, "time", r->time);
	ndr_print_uint32(ndr, "u2", r->u2);
	ndr_print_uint32(ndr, "u3", r->u3);
	ndr_print_uint32(ndr, "extra_length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_ldapControlDirSyncExtra(&r->extra, r->extra.uptodateness_vector.version, 0):r->extra_length);
	ndr_print_drsuapi_DsReplicaHighWaterMark(ndr, "highwatermark", &r->highwatermark);
	ndr_print_GUID(ndr, "guid1", &r->guid1);
	ndr_print_set_switch_value(ndr, &r->extra, r->extra_length);
	ndr_print_ldapControlDirSyncExtra(ndr, "extra", &r->extra);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_ldapControlDirSyncCookie(struct ndr_push *ndr, int ndr_flags, const struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_push_get_relative_base_offset(ndr);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_setup_relative_base_offset1(ndr, r, ndr->offset));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, "MSDS", 4, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_push *_ndr_blob;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_push_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_setup_relative_base_offset2(ndr, r));
	}
	ndr_push_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_ldapControlDirSyncCookie(struct ndr_pull *ndr, int ndr_flags, struct ldapControlDirSyncCookie *r)
{
	uint32_t _save_relative_base_offset = ndr_pull_get_relative_base_offset(ndr);
	uint32_t size_msds_0 = 0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_setup_relative_base_offset1(ndr, r, ndr->offset));
		size_msds_0 = 4;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->msds, size_msds_0, sizeof(uint8_t), CH_DOS));
		{
			struct ndr_pull *_ndr_blob;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_blob, 0, -1));
			NDR_CHECK(ndr_pull_ldapControlDirSyncBlob(_ndr_blob, NDR_SCALARS|NDR_BUFFERS, &r->blob));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_blob, 0, -1));
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_setup_relative_base_offset2(ndr, r));
	}
	ndr_pull_restore_relative_base_offset(ndr, _save_relative_base_offset);
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ldapControlDirSyncCookie(struct ndr_print *ndr, const char *name, const struct ldapControlDirSyncCookie *r)
{
	ndr_print_struct(ndr, name, "ldapControlDirSyncCookie");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_string(ndr, "msds", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?"MSDS":r->msds);
	ndr_print_ldapControlDirSyncBlob(ndr, "blob", &r->blob);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_supplementalCredentialsPackage(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsPackage *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 2));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->name)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, strlen(r->data)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->reserved));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->name, 2 * strlen_m(r->name), sizeof(uint8_t), CH_UTF16));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->data, strlen(r->data), sizeof(uint8_t), CH_DOS));
		NDR_CHECK(ndr_push_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsPackage(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsPackage *r)
{
	uint32_t size_name_0 = 0;
	uint32_t size_data_0 = 0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 2));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->name_len));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->data_len));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved));
		size_name_0 = r->name_len;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->name, size_name_0, sizeof(uint8_t), CH_UTF16));
		size_data_0 = r->data_len;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->data, size_data_0, sizeof(uint8_t), CH_DOS));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsPackage(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsPackage *r)
{
	ndr_print_struct(ndr, name, "supplementalCredentialsPackage");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "name_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->name):r->name_len);
	ndr_print_uint16(ndr, "data_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?strlen(r->data):r->data_len);
	ndr_print_uint16(ndr, "reserved", r->reserved);
	ndr_print_string(ndr, "name", r->name);
	ndr_print_string(ndr, "data", r->data);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_supplementalCredentialsSignature(struct ndr_push *ndr, int ndr_flags, enum supplementalCredentialsSignature r)
{
	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		NDR_CHECK(ndr_push_enum_uint1632(ndr, NDR_SCALARS, r));
		ndr->flags = _flags_save_ENUM;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsSignature(struct ndr_pull *ndr, int ndr_flags, enum supplementalCredentialsSignature *r)
{
	uint16_t v;
	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		NDR_CHECK(ndr_pull_enum_uint1632(ndr, NDR_SCALARS, &v));
		*r = v;
		ndr->flags = _flags_save_ENUM;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsSignature(struct ndr_print *ndr, const char *name, enum supplementalCredentialsSignature r)
{
	const char *val = NULL;

	{
		uint32_t _flags_save_ENUM = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		switch (r) {
			case SUPPLEMENTAL_CREDENTIALS_SIGNATURE: val = "SUPPLEMENTAL_CREDENTIALS_SIGNATURE"; break;
		}
		ndr_print_enum(ndr, name, "ENUM", val, r);
		ndr->flags = _flags_save_ENUM;
	}
}

static enum ndr_err_code ndr_push_supplementalCredentialsSubBlob(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsSubBlob *r)
{
	uint32_t cntr_packages_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 3));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, SUPPLEMENTAL_CREDENTIALS_PREFIX, 0x30, sizeof(uint16_t), CH_UTF16));
		NDR_CHECK(ndr_push_supplementalCredentialsSignature(ndr, NDR_SCALARS, SUPPLEMENTAL_CREDENTIALS_SIGNATURE));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_packages));
		for (cntr_packages_0 = 0; cntr_packages_0 < r->num_packages; cntr_packages_0++) {
			NDR_CHECK(ndr_push_supplementalCredentialsPackage(ndr, NDR_SCALARS, &r->packages[cntr_packages_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 3));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_supplementalCredentialsSubBlob(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsSubBlob *r)
{
	uint32_t size_prefix_0 = 0;
	uint32_t size_packages_0 = 0;
	uint32_t cntr_packages_0;
	TALLOC_CTX *_mem_save_packages_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 3));
		size_prefix_0 = 0x30;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->prefix, size_prefix_0, sizeof(uint16_t), CH_UTF16));
		NDR_CHECK(ndr_pull_supplementalCredentialsSignature(ndr, NDR_SCALARS, &r->signature));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_packages));
		size_packages_0 = r->num_packages;
		NDR_PULL_ALLOC_N(ndr, r->packages, size_packages_0);
		_mem_save_packages_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->packages, 0);
		for (cntr_packages_0 = 0; cntr_packages_0 < size_packages_0; cntr_packages_0++) {
			NDR_CHECK(ndr_pull_supplementalCredentialsPackage(ndr, NDR_SCALARS, &r->packages[cntr_packages_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_packages_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 3));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsSubBlob(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsSubBlob *r)
{
	uint32_t cntr_packages_0;
	ndr_print_struct(ndr, name, "supplementalCredentialsSubBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_string(ndr, "prefix", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?SUPPLEMENTAL_CREDENTIALS_PREFIX:r->prefix);
	ndr_print_supplementalCredentialsSignature(ndr, "signature", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?SUPPLEMENTAL_CREDENTIALS_SIGNATURE:r->signature);
	ndr_print_uint16(ndr, "num_packages", r->num_packages);
	ndr->print(ndr, "%s: ARRAY(%d)", "packages", (int)r->num_packages);
	ndr->depth++;
	for (cntr_packages_0=0;cntr_packages_0<r->num_packages;cntr_packages_0++) {
		ndr_print_supplementalCredentialsPackage(ndr, "packages", &r->packages[cntr_packages_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static size_t ndr_size_supplementalCredentialsSubBlob(const struct supplementalCredentialsSubBlob *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_supplementalCredentialsSubBlob);
}

_PUBLIC_ enum ndr_err_code ndr_push_supplementalCredentialsBlob(struct ndr_push *ndr, int ndr_flags, const struct supplementalCredentialsBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		{
			struct ndr_push *_ndr_sub;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_sub, 0, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
			NDR_CHECK(ndr_push_supplementalCredentialsSubBlob(_ndr_sub, NDR_SCALARS, &r->sub));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_sub, 0, ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags)));
		}
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_supplementalCredentialsBlob(struct ndr_pull *ndr, int ndr_flags, struct supplementalCredentialsBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->__ndr_size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown2));
		{
			struct ndr_pull *_ndr_sub;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_sub, 0, r->__ndr_size));
			NDR_CHECK(ndr_pull_supplementalCredentialsSubBlob(_ndr_sub, NDR_SCALARS, &r->sub));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_sub, 0, r->__ndr_size));
		}
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->unknown3));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_supplementalCredentialsBlob(struct ndr_print *ndr, const char *name, const struct supplementalCredentialsBlob *r)
{
	ndr_print_struct(ndr, name, "supplementalCredentialsBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "unknown1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown1);
	ndr_print_uint32(ndr, "__ndr_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_supplementalCredentialsSubBlob(&r->sub, ndr->flags):r->__ndr_size);
	ndr_print_uint32(ndr, "unknown2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown2);
	ndr_print_supplementalCredentialsSubBlob(ndr, "sub", &r->sub);
	ndr_print_uint8(ndr, "unknown3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown3);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PackagesBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PackagesBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_string_array = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_string_array(ndr, NDR_SCALARS, r->names));
			ndr->flags = _flags_save_string_array;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PackagesBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PackagesBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_string_array = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_string_array(ndr, NDR_SCALARS, &r->names));
			ndr->flags = _flags_save_string_array;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PackagesBlob(struct ndr_print *ndr, const char *name, const struct package_PackagesBlob *r)
{
	ndr_print_struct(ndr, name, "package_PackagesBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_string_array(ndr, "names", r->names);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosString(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosString *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->string)));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 2 * strlen_m(r->string)));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->string));
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			if (r->string) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->string));
				{
					struct ndr_push *_ndr_string;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_string, 0, 2 * strlen_m(r->string)));
					NDR_CHECK(ndr_push_string(_ndr_string, NDR_SCALARS, r->string));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_string, 0, 2 * strlen_m(r->string)));
				}
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->string));
			}
			ndr->flags = _flags_save_string;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosString(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosString *r)
{
	uint32_t _ptr_string;
	TALLOC_CTX *_mem_save_string_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->length));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->size));
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_string));
			if (_ptr_string) {
				NDR_PULL_ALLOC(ndr, r->string);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->string, _ptr_string));
			} else {
				r->string = NULL;
			}
			ndr->flags = _flags_save_string;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_string = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_STR_NOTERM|LIBNDR_FLAG_REMAINING);
			if (r->string) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->string));
				_mem_save_string_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->string, 0);
				{
					struct ndr_pull *_ndr_string;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_string, 0, r->size));
					NDR_CHECK(ndr_pull_string(_ndr_string, NDR_SCALARS, &r->string));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_string, 0, r->size));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_string_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_string;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosString(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosString *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosString");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "length", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->string):r->length);
	ndr_print_uint16(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?2 * strlen_m(r->string):r->size);
	ndr_print_ptr(ndr, "string", r->string);
	ndr->depth++;
	if (r->string) {
		ndr_print_string(ndr, "string", r->string);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosKey3(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosKey3 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->keytype));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, (r->value?r->value->length:0)));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->value));
				{
					struct ndr_push *_ndr_value;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_value, 0, (r->value?r->value->length:0)));
					NDR_CHECK(ndr_push_DATA_BLOB(_ndr_value, NDR_SCALARS, *r->value));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_value, 0, (r->value?r->value->length:0)));
				}
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->value));
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosKey3(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosKey3 *r)
{
	uint32_t _ptr_value;
	TALLOC_CTX *_mem_save_value_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved1));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->keytype));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->value_len));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value));
			if (_ptr_value) {
				NDR_PULL_ALLOC(ndr, r->value);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value, _ptr_value));
			} else {
				r->value = NULL;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value));
				_mem_save_value_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->value, 0);
				{
					struct ndr_pull *_ndr_value;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_value, 0, r->value_len));
					NDR_CHECK(ndr_pull_DATA_BLOB(_ndr_value, NDR_SCALARS, r->value));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_value, 0, r->value_len));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosKey3(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosKey3 *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosKey3");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "reserved1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved1);
	ndr_print_uint16(ndr, "reserved2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved2);
	ndr_print_uint32(ndr, "reserved3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved3);
	ndr_print_uint32(ndr, "keytype", r->keytype);
	ndr_print_uint32(ndr, "value_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->value?r->value->length:0):r->value_len);
	ndr_print_ptr(ndr, "value", r->value);
	ndr->depth++;
	if (r->value) {
		ndr_print_DATA_BLOB(ndr, "value", *r->value);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr3(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_old_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_old_keys));
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr3(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t size_keys_0 = 0;
	uint32_t cntr_keys_0;
	TALLOC_CTX *_mem_save_keys_0;
	uint32_t size_old_keys_0 = 0;
	uint32_t cntr_old_keys_0;
	TALLOC_CTX *_mem_save_old_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_old_keys));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		size_keys_0 = r->num_keys;
		NDR_PULL_ALLOC_N(ndr, r->keys, size_keys_0);
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < size_keys_0; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		size_old_keys_0 = r->num_old_keys;
		NDR_PULL_ALLOC_N(ndr, r->old_keys, size_old_keys_0);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < size_old_keys_0; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding1));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->padding5));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		size_keys_0 = r->num_keys;
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < size_keys_0; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		size_old_keys_0 = r->num_old_keys;
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < size_old_keys_0; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey3(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr3(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosCtr3 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_old_keys_0;
	ndr_print_struct(ndr, name, "package_PrimaryKerberosCtr3");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "num_keys", r->num_keys);
	ndr_print_uint16(ndr, "num_old_keys", r->num_old_keys);
	ndr_print_package_PrimaryKerberosString(ndr, "salt", &r->salt);
	ndr->print(ndr, "%s: ARRAY(%d)", "keys", (int)r->num_keys);
	ndr->depth++;
	for (cntr_keys_0=0;cntr_keys_0<r->num_keys;cntr_keys_0++) {
		ndr_print_package_PrimaryKerberosKey3(ndr, "keys", &r->keys[cntr_keys_0]);
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "old_keys", (int)r->num_old_keys);
	ndr->depth++;
	for (cntr_old_keys_0=0;cntr_old_keys_0<r->num_old_keys;cntr_old_keys_0++) {
		ndr_print_package_PrimaryKerberosKey3(ndr, "old_keys", &r->old_keys[cntr_old_keys_0]);
	}
	ndr->depth--;
	ndr_print_uint32(ndr, "padding1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding1);
	ndr_print_uint32(ndr, "padding2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding2);
	ndr_print_uint32(ndr, "padding3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding3);
	ndr_print_uint32(ndr, "padding4", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding4);
	ndr_print_uint32(ndr, "padding5", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->padding5);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosKey4(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosKey4 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->iteration_count));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->keytype));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, (r->value?r->value->length:0)));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_relative_ptr1(ndr, r->value));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				NDR_CHECK(ndr_push_relative_ptr2_start(ndr, r->value));
				{
					struct ndr_push *_ndr_value;
					NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_value, 0, (r->value?r->value->length:0)));
					NDR_CHECK(ndr_push_DATA_BLOB(_ndr_value, NDR_SCALARS, *r->value));
					NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_value, 0, (r->value?r->value->length:0)));
				}
				NDR_CHECK(ndr_push_relative_ptr2_end(ndr, r->value));
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosKey4(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosKey4 *r)
{
	uint32_t _ptr_value;
	TALLOC_CTX *_mem_save_value_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved1));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->reserved2));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->reserved3));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->iteration_count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->keytype));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->value_len));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_value));
			if (_ptr_value) {
				NDR_PULL_ALLOC(ndr, r->value);
				NDR_CHECK(ndr_pull_relative_ptr1(ndr, r->value, _ptr_value));
			} else {
				r->value = NULL;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			if (r->value) {
				uint32_t _relative_save_offset;
				_relative_save_offset = ndr->offset;
				NDR_CHECK(ndr_pull_relative_ptr2(ndr, r->value));
				_mem_save_value_0 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, r->value, 0);
				{
					struct ndr_pull *_ndr_value;
					NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_value, 0, r->value_len));
					NDR_CHECK(ndr_pull_DATA_BLOB(_ndr_value, NDR_SCALARS, r->value));
					NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_value, 0, r->value_len));
				}
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_value_0, 0);
				if (ndr->offset > ndr->relative_highest_offset) {
					ndr->relative_highest_offset = ndr->offset;
				}
				ndr->offset = _relative_save_offset;
			}
			ndr->flags = _flags_save_DATA_BLOB;
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosKey4(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosKey4 *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosKey4");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "reserved1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved1);
	ndr_print_uint16(ndr, "reserved2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved2);
	ndr_print_uint32(ndr, "reserved3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->reserved3);
	ndr_print_uint32(ndr, "iteration_count", r->iteration_count);
	ndr_print_uint32(ndr, "keytype", r->keytype);
	ndr_print_uint32(ndr, "value_len", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->value?r->value->length:0):r->value_len);
	ndr_print_ptr(ndr, "value", r->value);
	ndr->depth++;
	if (r->value) {
		ndr_print_DATA_BLOB(ndr, "value", *r->value);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr4(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_old_keys_0;
	uint32_t cntr_older_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_old_keys));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_older_keys));
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->default_iteration_count));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->older_keys[cntr_older_keys_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		for (cntr_keys_0 = 0; cntr_keys_0 < r->num_keys; cntr_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < r->num_old_keys; cntr_old_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < r->num_older_keys; cntr_older_keys_0++) {
			NDR_CHECK(ndr_push_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->older_keys[cntr_older_keys_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr4(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t size_keys_0 = 0;
	uint32_t cntr_keys_0;
	TALLOC_CTX *_mem_save_keys_0;
	uint32_t size_service_keys_0 = 0;
	uint32_t cntr_service_keys_0;
	TALLOC_CTX *_mem_save_service_keys_0;
	uint32_t size_old_keys_0 = 0;
	uint32_t cntr_old_keys_0;
	TALLOC_CTX *_mem_save_old_keys_0;
	uint32_t size_older_keys_0 = 0;
	uint32_t cntr_older_keys_0;
	TALLOC_CTX *_mem_save_older_keys_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_service_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_old_keys));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_older_keys));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_SCALARS, &r->salt));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->default_iteration_count));
		size_keys_0 = r->num_keys;
		NDR_PULL_ALLOC_N(ndr, r->keys, size_keys_0);
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < size_keys_0; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		size_service_keys_0 = r->num_service_keys;
		NDR_PULL_ALLOC_N(ndr, r->service_keys, size_service_keys_0);
		_mem_save_service_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->service_keys, 0);
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < size_service_keys_0; cntr_service_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->service_keys[cntr_service_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_service_keys_0, 0);
		size_old_keys_0 = r->num_old_keys;
		NDR_PULL_ALLOC_N(ndr, r->old_keys, size_old_keys_0);
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < size_old_keys_0; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		size_older_keys_0 = r->num_older_keys;
		NDR_PULL_ALLOC_N(ndr, r->older_keys, size_older_keys_0);
		_mem_save_older_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->older_keys, 0);
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < size_older_keys_0; cntr_older_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_SCALARS, &r->older_keys[cntr_older_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_older_keys_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosString(ndr, NDR_BUFFERS, &r->salt));
		size_keys_0 = r->num_keys;
		_mem_save_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->keys, 0);
		for (cntr_keys_0 = 0; cntr_keys_0 < size_keys_0; cntr_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->keys[cntr_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_keys_0, 0);
		size_service_keys_0 = r->num_service_keys;
		_mem_save_service_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->service_keys, 0);
		for (cntr_service_keys_0 = 0; cntr_service_keys_0 < size_service_keys_0; cntr_service_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->service_keys[cntr_service_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_service_keys_0, 0);
		size_old_keys_0 = r->num_old_keys;
		_mem_save_old_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->old_keys, 0);
		for (cntr_old_keys_0 = 0; cntr_old_keys_0 < size_old_keys_0; cntr_old_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->old_keys[cntr_old_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_old_keys_0, 0);
		size_older_keys_0 = r->num_older_keys;
		_mem_save_older_keys_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->older_keys, 0);
		for (cntr_older_keys_0 = 0; cntr_older_keys_0 < size_older_keys_0; cntr_older_keys_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryKerberosKey4(ndr, NDR_BUFFERS, &r->older_keys[cntr_older_keys_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_older_keys_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr4(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosCtr4 *r)
{
	uint32_t cntr_keys_0;
	uint32_t cntr_service_keys_0;
	uint32_t cntr_old_keys_0;
	uint32_t cntr_older_keys_0;
	ndr_print_struct(ndr, name, "package_PrimaryKerberosCtr4");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "num_keys", r->num_keys);
	ndr_print_uint16(ndr, "num_service_keys", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->num_service_keys);
	ndr_print_uint16(ndr, "num_old_keys", r->num_old_keys);
	ndr_print_uint16(ndr, "num_older_keys", r->num_older_keys);
	ndr_print_package_PrimaryKerberosString(ndr, "salt", &r->salt);
	ndr_print_uint32(ndr, "default_iteration_count", r->default_iteration_count);
	ndr->print(ndr, "%s: ARRAY(%d)", "keys", (int)r->num_keys);
	ndr->depth++;
	for (cntr_keys_0=0;cntr_keys_0<r->num_keys;cntr_keys_0++) {
		ndr_print_package_PrimaryKerberosKey4(ndr, "keys", &r->keys[cntr_keys_0]);
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "service_keys", (int)r->num_service_keys);
	ndr->depth++;
	for (cntr_service_keys_0=0;cntr_service_keys_0<r->num_service_keys;cntr_service_keys_0++) {
		ndr_print_package_PrimaryKerberosKey4(ndr, "service_keys", &r->service_keys[cntr_service_keys_0]);
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "old_keys", (int)r->num_old_keys);
	ndr->depth++;
	for (cntr_old_keys_0=0;cntr_old_keys_0<r->num_old_keys;cntr_old_keys_0++) {
		ndr_print_package_PrimaryKerberosKey4(ndr, "old_keys", &r->old_keys[cntr_old_keys_0]);
	}
	ndr->depth--;
	ndr->print(ndr, "%s: ARRAY(%d)", "older_keys", (int)r->num_older_keys);
	ndr->depth++;
	for (cntr_older_keys_0=0;cntr_older_keys_0<r->num_older_keys;cntr_older_keys_0++) {
		ndr_print_package_PrimaryKerberosKey4(ndr, "older_keys", &r->older_keys[cntr_older_keys_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryKerberosCtr(struct ndr_push *ndr, int ndr_flags, const union package_PrimaryKerberosCtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 5));
		switch (level) {
			case 3: {
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr3(ndr, NDR_SCALARS, &r->ctr3));
			break; }

			case 4: {
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr4(ndr, NDR_SCALARS, &r->ctr4));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 3:
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr3(ndr, NDR_BUFFERS, &r->ctr3));
			break;

			case 4:
				NDR_CHECK(ndr_push_package_PrimaryKerberosCtr4(ndr, NDR_BUFFERS, &r->ctr4));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryKerberosCtr(struct ndr_pull *ndr, int ndr_flags, union package_PrimaryKerberosCtr *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 5));
		switch (level) {
			case 3: {
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr3(ndr, NDR_SCALARS, &r->ctr3));
			break; }

			case 4: {
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr4(ndr, NDR_SCALARS, &r->ctr4));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 3:
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr3(ndr, NDR_BUFFERS, &r->ctr3));
			break;

			case 4:
				NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr4(ndr, NDR_BUFFERS, &r->ctr4));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosCtr(struct ndr_print *ndr, const char *name, const union package_PrimaryKerberosCtr *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "package_PrimaryKerberosCtr");
	switch (level) {
		case 3:
			ndr_print_package_PrimaryKerberosCtr3(ndr, "ctr3", &r->ctr3);
		break;

		case 4:
			ndr_print_package_PrimaryKerberosCtr4(ndr, "ctr4", &r->ctr4);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryKerberosBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryKerberosBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_push_package_PrimaryKerberosCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryKerberosBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryKerberosBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->ctr, r->version));
		NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr(ndr, NDR_SCALARS, &r->ctr));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosCtr(ndr, NDR_BUFFERS, &r->ctr));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryKerberosBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryKerberosBlob *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryKerberosBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "version", r->version);
	ndr_print_uint16(ndr, "flags", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->flags);
	ndr_print_set_switch_value(ndr, &r->ctr, r->version);
	ndr_print_package_PrimaryKerberosCtr(ndr, "ctr", &r->ctr);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryCLEARTEXTBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryCLEARTEXTBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->cleartext));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryCLEARTEXTBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryCLEARTEXTBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->cleartext));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryCLEARTEXTBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryCLEARTEXTBlob *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryCLEARTEXTBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_DATA_BLOB(ndr, "cleartext", r->cleartext);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_package_PrimaryWDigestHash(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryWDigestHash *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 1));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->hash, 16));
			NDR_CHECK(ndr_push_trailer_align(ndr, 1));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_package_PrimaryWDigestHash(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryWDigestHash *r)
{
	uint32_t size_hash_0 = 0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 1));
			size_hash_0 = 16;
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->hash, size_hash_0));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 1));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryWDigestHash(struct ndr_print *ndr, const char *name, const struct package_PrimaryWDigestHash *r)
{
	ndr_print_struct(ndr, name, "package_PrimaryWDigestHash");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_PRINT_ARRAY_HEX);
		ndr->depth++;
		ndr_print_array_uint8(ndr, "hash", r->hash, 16);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_package_PrimaryWDigestBlob(struct ndr_push *ndr, int ndr_flags, const struct package_PrimaryWDigestBlob *r)
{
	uint32_t cntr_hashes_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, 0x31));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, 0x01));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->num_hashes));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_udlong(ndr, NDR_SCALARS, 0));
		for (cntr_hashes_0 = 0; cntr_hashes_0 < r->num_hashes; cntr_hashes_0++) {
			NDR_CHECK(ndr_push_package_PrimaryWDigestHash(ndr, NDR_SCALARS, &r->hashes[cntr_hashes_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_package_PrimaryWDigestBlob(struct ndr_pull *ndr, int ndr_flags, struct package_PrimaryWDigestBlob *r)
{
	uint32_t size_hashes_0 = 0;
	uint32_t cntr_hashes_0;
	TALLOC_CTX *_mem_save_hashes_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->unknown1));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->unknown2));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->num_hashes));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->unknown3));
		NDR_CHECK(ndr_pull_udlong(ndr, NDR_SCALARS, &r->uuknown4));
		size_hashes_0 = r->num_hashes;
		NDR_PULL_ALLOC_N(ndr, r->hashes, size_hashes_0);
		_mem_save_hashes_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->hashes, 0);
		for (cntr_hashes_0 = 0; cntr_hashes_0 < size_hashes_0; cntr_hashes_0++) {
			NDR_CHECK(ndr_pull_package_PrimaryWDigestHash(ndr, NDR_SCALARS, &r->hashes[cntr_hashes_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_hashes_0, 0);
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_package_PrimaryWDigestBlob(struct ndr_print *ndr, const char *name, const struct package_PrimaryWDigestBlob *r)
{
	uint32_t cntr_hashes_0;
	ndr_print_struct(ndr, name, "package_PrimaryWDigestBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "unknown1", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0x31:r->unknown1);
	ndr_print_uint8(ndr, "unknown2", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0x01:r->unknown2);
	ndr_print_uint8(ndr, "num_hashes", r->num_hashes);
	ndr_print_uint32(ndr, "unknown3", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->unknown3);
	ndr_print_udlong(ndr, "uuknown4", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->uuknown4);
	ndr->print(ndr, "%s: ARRAY(%d)", "hashes", (int)r->num_hashes);
	ndr->depth++;
	for (cntr_hashes_0=0;cntr_hashes_0<r->num_hashes;cntr_hashes_0++) {
		ndr_print_package_PrimaryWDigestHash(ndr, "hashes", &r->hashes[cntr_hashes_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_AuthInfoNone(struct ndr_push *ndr, int ndr_flags, const struct AuthInfoNone *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_AuthInfoNone(struct ndr_pull *ndr, int ndr_flags, struct AuthInfoNone *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthInfoNone(struct ndr_print *ndr, const char *name, const struct AuthInfoNone *r)
{
	ndr_print_struct(ndr, name, "AuthInfoNone");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?0:r->size);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_AuthInfoNT4Owf(struct ndr_push *ndr, int ndr_flags, const struct AuthInfoNT4Owf *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 16));
		NDR_CHECK(ndr_push_samr_Password(ndr, NDR_SCALARS, &r->password));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_AuthInfoNT4Owf(struct ndr_pull *ndr, int ndr_flags, struct AuthInfoNT4Owf *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_samr_Password(ndr, NDR_SCALARS, &r->password));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthInfoNT4Owf(struct ndr_print *ndr, const char *name, const struct AuthInfoNT4Owf *r)
{
	ndr_print_struct(ndr, name, "AuthInfoNT4Owf");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?16:r->size);
	ndr_print_samr_Password(ndr, "password", &r->password);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_AuthInfoClear(struct ndr_push *ndr, int ndr_flags, const struct AuthInfoClear *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->password, r->size));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_AuthInfoClear(struct ndr_pull *ndr, int ndr_flags, struct AuthInfoClear *r)
{
	uint32_t size_password_0 = 0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		size_password_0 = r->size;
		NDR_PULL_ALLOC_N(ndr, r->password, size_password_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->password, size_password_0));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthInfoClear(struct ndr_print *ndr, const char *name, const struct AuthInfoClear *r)
{
	ndr_print_struct(ndr, name, "AuthInfoClear");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", r->size);
	ndr_print_array_uint8(ndr, "password", r->password, r->size);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_AuthInfoVersion(struct ndr_push *ndr, int ndr_flags, const struct AuthInfoVersion *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_AuthInfoVersion(struct ndr_pull *ndr, int ndr_flags, struct AuthInfoVersion *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthInfoVersion(struct ndr_print *ndr, const char *name, const struct AuthInfoVersion *r)
{
	ndr_print_struct(ndr, name, "AuthInfoVersion");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?4:r->size);
	ndr_print_uint32(ndr, "version", r->version);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_AuthInfo(struct ndr_push *ndr, int ndr_flags, const union AuthInfo *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 4));
		switch (level) {
			case TRUST_AUTH_TYPE_NONE: {
				NDR_CHECK(ndr_push_AuthInfoNone(ndr, NDR_SCALARS, &r->none));
			break; }

			case TRUST_AUTH_TYPE_NT4OWF: {
				NDR_CHECK(ndr_push_AuthInfoNT4Owf(ndr, NDR_SCALARS, &r->nt4owf));
			break; }

			case TRUST_AUTH_TYPE_CLEAR: {
				NDR_CHECK(ndr_push_AuthInfoClear(ndr, NDR_SCALARS, &r->clear));
			break; }

			case TRUST_AUTH_TYPE_VERSION: {
				NDR_CHECK(ndr_push_AuthInfoVersion(ndr, NDR_SCALARS, &r->version));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case TRUST_AUTH_TYPE_NONE:
			break;

			case TRUST_AUTH_TYPE_NT4OWF:
			break;

			case TRUST_AUTH_TYPE_CLEAR:
			break;

			case TRUST_AUTH_TYPE_VERSION:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_AuthInfo(struct ndr_pull *ndr, int ndr_flags, union AuthInfo *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 4));
		switch (level) {
			case TRUST_AUTH_TYPE_NONE: {
				NDR_CHECK(ndr_pull_AuthInfoNone(ndr, NDR_SCALARS, &r->none));
			break; }

			case TRUST_AUTH_TYPE_NT4OWF: {
				NDR_CHECK(ndr_pull_AuthInfoNT4Owf(ndr, NDR_SCALARS, &r->nt4owf));
			break; }

			case TRUST_AUTH_TYPE_CLEAR: {
				NDR_CHECK(ndr_pull_AuthInfoClear(ndr, NDR_SCALARS, &r->clear));
			break; }

			case TRUST_AUTH_TYPE_VERSION: {
				NDR_CHECK(ndr_pull_AuthInfoVersion(ndr, NDR_SCALARS, &r->version));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case TRUST_AUTH_TYPE_NONE:
			break;

			case TRUST_AUTH_TYPE_NT4OWF:
			break;

			case TRUST_AUTH_TYPE_CLEAR:
			break;

			case TRUST_AUTH_TYPE_VERSION:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthInfo(struct ndr_print *ndr, const char *name, const union AuthInfo *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "AuthInfo");
	switch (level) {
		case TRUST_AUTH_TYPE_NONE:
			ndr_print_AuthInfoNone(ndr, "none", &r->none);
		break;

		case TRUST_AUTH_TYPE_NT4OWF:
			ndr_print_AuthInfoNT4Owf(ndr, "nt4owf", &r->nt4owf);
		break;

		case TRUST_AUTH_TYPE_CLEAR:
			ndr_print_AuthInfoClear(ndr, "clear", &r->clear);
		break;

		case TRUST_AUTH_TYPE_VERSION:
			ndr_print_AuthInfoVersion(ndr, "version", &r->version);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_AuthenticationInformation(struct ndr_push *ndr, int ndr_flags, const struct AuthenticationInformation *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->LastUpdateTime));
		NDR_CHECK(ndr_push_lsa_TrustAuthType(ndr, NDR_SCALARS, r->AuthType));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->AuthInfo, r->AuthType));
		NDR_CHECK(ndr_push_AuthInfo(ndr, NDR_SCALARS, &r->AuthInfo));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_AuthenticationInformation(struct ndr_pull *ndr, int ndr_flags, struct AuthenticationInformation *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->LastUpdateTime));
		NDR_CHECK(ndr_pull_lsa_TrustAuthType(ndr, NDR_SCALARS, &r->AuthType));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->AuthInfo, r->AuthType));
		NDR_CHECK(ndr_pull_AuthInfo(ndr, NDR_SCALARS, &r->AuthInfo));
		{
			uint32_t _flags_save_DATA_BLOB = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_ALIGN4);
			NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->_pad));
			ndr->flags = _flags_save_DATA_BLOB;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_AuthenticationInformation(struct ndr_print *ndr, const char *name, const struct AuthenticationInformation *r)
{
	ndr_print_struct(ndr, name, "AuthenticationInformation");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_NTTIME(ndr, "LastUpdateTime", r->LastUpdateTime);
	ndr_print_lsa_TrustAuthType(ndr, "AuthType", r->AuthType);
	ndr_print_set_switch_value(ndr, &r->AuthInfo, r->AuthType);
	ndr_print_AuthInfo(ndr, "AuthInfo", &r->AuthInfo);
	ndr_print_DATA_BLOB(ndr, "_pad", r->_pad);
	ndr->depth--;
}

_PUBLIC_ void ndr_print_AuthenticationInformationArray(struct ndr_print *ndr, const char *name, const struct AuthenticationInformationArray *r)
{
	uint32_t cntr_array_0;
	ndr_print_struct(ndr, name, "AuthenticationInformationArray");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr->print(ndr, "%s: ARRAY(%d)", "array", (int)r->count);
	ndr->depth++;
	for (cntr_array_0=0;cntr_array_0<r->count;cntr_array_0++) {
		ndr_print_AuthenticationInformation(ndr, "array", &r->array[cntr_array_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_AuthenticationInformationArray(const struct AuthenticationInformationArray *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_AuthenticationInformationArray);
}

_PUBLIC_ enum ndr_err_code ndr_pull_trustAuthInOutBlob(struct ndr_pull *ndr, int ndr_flags, struct trustAuthInOutBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->current_offset));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->previous_offset));
		{
			struct ndr_pull *_ndr_current;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_current, 0, (r->previous_offset) - (r->current_offset)));
			NDR_CHECK(ndr_pull_AuthenticationInformationArray(_ndr_current, NDR_SCALARS, &r->current));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_current, 0, (r->previous_offset) - (r->current_offset)));
		}
		{
			uint32_t _flags_save_AuthenticationInformationArray = ndr->flags;
			ndr_set_flags(&ndr->flags, LIBNDR_FLAG_REMAINING);
			{
				struct ndr_pull *_ndr_previous;
				NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_previous, 0, -1));
				NDR_CHECK(ndr_pull_AuthenticationInformationArray(_ndr_previous, NDR_SCALARS, &r->previous));
				NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_previous, 0, -1));
			}
			ndr->flags = _flags_save_AuthenticationInformationArray;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustAuthInOutBlob(struct ndr_print *ndr, const char *name, const struct trustAuthInOutBlob *r)
{
	ndr_print_struct(ndr, name, "trustAuthInOutBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "count", r->count);
	ndr_print_uint32(ndr, "current_offset", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->count > 0)?12:0:r->current_offset);
	ndr_print_uint32(ndr, "previous_offset", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?(r->count > 0)?12 + ndr_size_AuthenticationInformationArray(&r->current, ndr->flags):0:r->previous_offset);
	ndr_print_AuthenticationInformationArray(ndr, "current", &r->current);
	ndr_print_AuthenticationInformationArray(ndr, "previous", &r->previous);
	ndr->depth--;
}

_PUBLIC_ size_t ndr_size_trustAuthInOutBlob(const struct trustAuthInOutBlob *r, int flags)
{
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_trustAuthInOutBlob);
}

_PUBLIC_ enum ndr_err_code ndr_push_trustDomainPasswords(struct ndr_push *ndr, int ndr_flags, const struct trustDomainPasswords *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->confounder, 512));
		{
			struct ndr_push *_ndr_outgoing;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_outgoing, 0, ndr_size_trustAuthInOutBlob(&r->outgoing, ndr->flags)));
			NDR_CHECK(ndr_push_trustAuthInOutBlob(_ndr_outgoing, NDR_SCALARS, &r->outgoing));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_outgoing, 0, ndr_size_trustAuthInOutBlob(&r->outgoing, ndr->flags)));
		}
		{
			struct ndr_push *_ndr_incoming;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_incoming, 0, ndr_size_trustAuthInOutBlob(&r->incoming, ndr->flags)));
			NDR_CHECK(ndr_push_trustAuthInOutBlob(_ndr_incoming, NDR_SCALARS, &r->incoming));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_incoming, 0, ndr_size_trustAuthInOutBlob(&r->incoming, ndr->flags)));
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_trustAuthInOutBlob(&r->outgoing, ndr->flags)));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_trustAuthInOutBlob(&r->incoming, ndr->flags)));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_trustDomainPasswords(struct ndr_print *ndr, const char *name, const struct trustDomainPasswords *r)
{
	ndr_print_struct(ndr, name, "trustDomainPasswords");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_array_uint8(ndr, "confounder", r->confounder, 512);
	ndr_print_trustAuthInOutBlob(ndr, "outgoing", &r->outgoing);
	ndr_print_trustAuthInOutBlob(ndr, "incoming", &r->incoming);
	ndr_print_uint32(ndr, "outgoing_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_trustAuthInOutBlob(&r->outgoing, ndr->flags):r->outgoing_size);
	ndr_print_uint32(ndr, "incoming_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_trustAuthInOutBlob(&r->incoming, ndr->flags):r->incoming_size);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_DsCompressedChunk(struct ndr_push *ndr, int ndr_flags, const struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->marker));
		NDR_CHECK(ndr_push_DATA_BLOB(ndr, NDR_SCALARS, r->data));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_DsCompressedChunk(struct ndr_pull *ndr, int ndr_flags, struct DsCompressedChunk *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->marker));
		NDR_CHECK(ndr_pull_DATA_BLOB(ndr, NDR_SCALARS, &r->data));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_DsCompressedChunk(struct ndr_print *ndr, const char *name, const struct DsCompressedChunk *r)
{
	ndr_print_struct(ndr, name, "DsCompressedChunk");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "marker", r->marker);
	ndr_print_DATA_BLOB(ndr, "data", r->data);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorAString(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorAString *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->__size));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->string));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->string) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->__size));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->string, r->__size, sizeof(uint8_t), CH_DOS));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorAString(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorAString *r)
{
	uint32_t _ptr_string;
	uint32_t size_string_1 = 0;
	TALLOC_CTX *_mem_save_string_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->__size));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_string));
		if (_ptr_string) {
			NDR_PULL_ALLOC(ndr, r->string);
		} else {
			r->string = NULL;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->string) {
			_mem_save_string_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->string, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->string));
			size_string_1 = ndr_get_array_size(ndr, &r->string);
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->string, size_string_1, sizeof(uint8_t), CH_DOS));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_string_0, 0);
		}
		if (r->string) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->string, r->__size));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorAString(struct ndr_print *ndr, const char *name, const struct ExtendedErrorAString *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorAString");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "__size", r->__size);
	ndr_print_ptr(ndr, "string", r->string);
	ndr->depth++;
	if (r->string) {
		ndr_print_string(ndr, "string", r->string);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorUString(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorUString *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->__size));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->string));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->string) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->__size));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->string, r->__size, sizeof(uint16_t), CH_UTF16));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorUString(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorUString *r)
{
	uint32_t _ptr_string;
	uint32_t size_string_1 = 0;
	TALLOC_CTX *_mem_save_string_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->__size));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_string));
		if (_ptr_string) {
			NDR_PULL_ALLOC(ndr, r->string);
		} else {
			r->string = NULL;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->string) {
			_mem_save_string_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->string, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->string));
			size_string_1 = ndr_get_array_size(ndr, &r->string);
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->string, size_string_1, sizeof(uint16_t), CH_UTF16));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_string_0, 0);
		}
		if (r->string) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->string, r->__size));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorUString(struct ndr_print *ndr, const char *name, const struct ExtendedErrorUString *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorUString");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "__size", r->__size);
	ndr_print_ptr(ndr, "string", r->string);
	ndr->depth++;
	if (r->string) {
		ndr_print_string(ndr, "string", r->string);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorBlob(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorBlob *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->length));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->data));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->data) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->length));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->data, r->length));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorBlob(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorBlob *r)
{
	uint32_t _ptr_data;
	uint32_t size_data_1 = 0;
	TALLOC_CTX *_mem_save_data_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->length));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_data));
		if (_ptr_data) {
			NDR_PULL_ALLOC(ndr, r->data);
		} else {
			r->data = NULL;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->data) {
			_mem_save_data_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->data, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, &r->data));
			size_data_1 = ndr_get_array_size(ndr, &r->data);
			NDR_PULL_ALLOC_N(ndr, r->data, size_data_1);
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->data, size_data_1));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_0, 0);
		}
		if (r->data) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->data, r->length));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorBlob(struct ndr_print *ndr, const char *name, const struct ExtendedErrorBlob *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorBlob");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "length", r->length);
	ndr_print_ptr(ndr, "data", r->data);
	ndr->depth++;
	if (r->data) {
		ndr_print_array_uint8(ndr, "data", r->data, r->length);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorComputerNamePresent(struct ndr_push *ndr, int ndr_flags, enum ExtendedErrorComputerNamePresent r)
{
	NDR_CHECK(ndr_push_enum_uint1632(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorComputerNamePresent(struct ndr_pull *ndr, int ndr_flags, enum ExtendedErrorComputerNamePresent *r)
{
	uint16_t v;
	NDR_CHECK(ndr_pull_enum_uint1632(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorComputerNamePresent(struct ndr_print *ndr, const char *name, enum ExtendedErrorComputerNamePresent r)
{
	const char *val = NULL;

	switch (r) {
		case EXTENDED_ERROR_COMPUTER_NAME_PRESENT: val = "EXTENDED_ERROR_COMPUTER_NAME_PRESENT"; break;
		case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT: val = "EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_ExtendedErrorComputerNameU(struct ndr_push *ndr, int ndr_flags, const union ExtendedErrorComputerNameU *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 5));
		NDR_CHECK(ndr_push_ExtendedErrorComputerNamePresent(ndr, NDR_SCALARS, level));
		NDR_CHECK(ndr_push_union_align(ndr, 5));
		switch (level) {
			case EXTENDED_ERROR_COMPUTER_NAME_PRESENT: {
				NDR_CHECK(ndr_push_ExtendedErrorUString(ndr, NDR_SCALARS, &r->name));
			break; }

			case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT: {
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case EXTENDED_ERROR_COMPUTER_NAME_PRESENT:
				NDR_CHECK(ndr_push_ExtendedErrorUString(ndr, NDR_BUFFERS, &r->name));
			break;

			case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorComputerNameU(struct ndr_pull *ndr, int ndr_flags, union ExtendedErrorComputerNameU *r)
{
	uint32_t level;
	uint16_t _level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 5));
		NDR_CHECK(ndr_pull_uint1632(ndr, NDR_SCALARS, &_level));
		if (_level != level) {
			return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u for r at %s", _level, __location__);
		}
		NDR_CHECK(ndr_pull_union_align(ndr, 5));
		switch (level) {
			case EXTENDED_ERROR_COMPUTER_NAME_PRESENT: {
				NDR_CHECK(ndr_pull_ExtendedErrorUString(ndr, NDR_SCALARS, &r->name));
			break; }

			case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT: {
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case EXTENDED_ERROR_COMPUTER_NAME_PRESENT:
				NDR_CHECK(ndr_pull_ExtendedErrorUString(ndr, NDR_BUFFERS, &r->name));
			break;

			case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorComputerNameU(struct ndr_print *ndr, const char *name, const union ExtendedErrorComputerNameU *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ExtendedErrorComputerNameU");
	switch (level) {
		case EXTENDED_ERROR_COMPUTER_NAME_PRESENT:
			ndr_print_ExtendedErrorUString(ndr, "name", &r->name);
		break;

		case EXTENDED_ERROR_COMPUTER_NAME_NOT_PRESENT:
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

static enum ndr_err_code ndr_push_ExtendedErrorComputerName(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorComputerName *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_ExtendedErrorComputerNamePresent(ndr, NDR_SCALARS, r->present));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->n, r->present));
		NDR_CHECK(ndr_push_ExtendedErrorComputerNameU(ndr, NDR_SCALARS, &r->n));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_ExtendedErrorComputerNameU(ndr, NDR_BUFFERS, &r->n));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorComputerName(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorComputerName *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_ExtendedErrorComputerNamePresent(ndr, NDR_SCALARS, &r->present));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->n, r->present));
		NDR_CHECK(ndr_pull_ExtendedErrorComputerNameU(ndr, NDR_SCALARS, &r->n));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_ExtendedErrorComputerNameU(ndr, NDR_BUFFERS, &r->n));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorComputerName(struct ndr_print *ndr, const char *name, const struct ExtendedErrorComputerName *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorComputerName");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_ExtendedErrorComputerNamePresent(ndr, "present", r->present);
	ndr_print_set_switch_value(ndr, &r->n, r->present);
	ndr_print_ExtendedErrorComputerNameU(ndr, "n", &r->n);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorParamType(struct ndr_push *ndr, int ndr_flags, enum ExtendedErrorParamType r)
{
	NDR_CHECK(ndr_push_enum_uint1632(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorParamType(struct ndr_pull *ndr, int ndr_flags, enum ExtendedErrorParamType *r)
{
	uint16_t v;
	NDR_CHECK(ndr_pull_enum_uint1632(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorParamType(struct ndr_print *ndr, const char *name, enum ExtendedErrorParamType r)
{
	const char *val = NULL;

	switch (r) {
		case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING: val = "EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING"; break;
		case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING: val = "EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING"; break;
		case EXTENDED_ERROR_PARAM_TYPE_UINT32: val = "EXTENDED_ERROR_PARAM_TYPE_UINT32"; break;
		case EXTENDED_ERROR_PARAM_TYPE_UINT16: val = "EXTENDED_ERROR_PARAM_TYPE_UINT16"; break;
		case EXTENDED_ERROR_PARAM_TYPE_UINT64: val = "EXTENDED_ERROR_PARAM_TYPE_UINT64"; break;
		case EXTENDED_ERROR_PARAM_TYPE_NONE: val = "EXTENDED_ERROR_PARAM_TYPE_NONE"; break;
		case EXTENDED_ERROR_PARAM_TYPE_BLOB: val = "EXTENDED_ERROR_PARAM_TYPE_BLOB"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_ExtendedErrorParamU(struct ndr_push *ndr, int ndr_flags, const union ExtendedErrorParamU *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		NDR_CHECK(ndr_push_ExtendedErrorParamType(ndr, NDR_SCALARS, level));
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING: {
				NDR_CHECK(ndr_push_ExtendedErrorAString(ndr, NDR_SCALARS, &r->a_string));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING: {
				NDR_CHECK(ndr_push_ExtendedErrorUString(ndr, NDR_SCALARS, &r->u_string));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT32: {
				NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->uint32));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT16: {
				NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->uint16));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT64: {
				NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->uint64));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_NONE: {
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_BLOB: {
				NDR_CHECK(ndr_push_ExtendedErrorBlob(ndr, NDR_SCALARS, &r->blob));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING:
				NDR_CHECK(ndr_push_ExtendedErrorAString(ndr, NDR_BUFFERS, &r->a_string));
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING:
				NDR_CHECK(ndr_push_ExtendedErrorUString(ndr, NDR_BUFFERS, &r->u_string));
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT32:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT16:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT64:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_NONE:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_BLOB:
				NDR_CHECK(ndr_push_ExtendedErrorBlob(ndr, NDR_BUFFERS, &r->blob));
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorParamU(struct ndr_pull *ndr, int ndr_flags, union ExtendedErrorParamU *r)
{
	uint32_t level;
	uint16_t _level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint1632(ndr, NDR_SCALARS, &_level));
		if (_level != level) {
			return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u for r at %s", _level, __location__);
		}
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING: {
				NDR_CHECK(ndr_pull_ExtendedErrorAString(ndr, NDR_SCALARS, &r->a_string));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING: {
				NDR_CHECK(ndr_pull_ExtendedErrorUString(ndr, NDR_SCALARS, &r->u_string));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT32: {
				NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->uint32));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT16: {
				NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->uint16));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_UINT64: {
				NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->uint64));
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_NONE: {
			break; }

			case EXTENDED_ERROR_PARAM_TYPE_BLOB: {
				NDR_CHECK(ndr_pull_ExtendedErrorBlob(ndr, NDR_SCALARS, &r->blob));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING:
				NDR_CHECK(ndr_pull_ExtendedErrorAString(ndr, NDR_BUFFERS, &r->a_string));
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING:
				NDR_CHECK(ndr_pull_ExtendedErrorUString(ndr, NDR_BUFFERS, &r->u_string));
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT32:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT16:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_UINT64:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_NONE:
			break;

			case EXTENDED_ERROR_PARAM_TYPE_BLOB:
				NDR_CHECK(ndr_pull_ExtendedErrorBlob(ndr, NDR_BUFFERS, &r->blob));
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorParamU(struct ndr_print *ndr, const char *name, const union ExtendedErrorParamU *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ExtendedErrorParamU");
	switch (level) {
		case EXTENDED_ERROR_PARAM_TYPE_ASCII_STRING:
			ndr_print_ExtendedErrorAString(ndr, "a_string", &r->a_string);
		break;

		case EXTENDED_ERROR_PARAM_TYPE_UNICODE_STRING:
			ndr_print_ExtendedErrorUString(ndr, "u_string", &r->u_string);
		break;

		case EXTENDED_ERROR_PARAM_TYPE_UINT32:
			ndr_print_uint32(ndr, "uint32", r->uint32);
		break;

		case EXTENDED_ERROR_PARAM_TYPE_UINT16:
			ndr_print_uint16(ndr, "uint16", r->uint16);
		break;

		case EXTENDED_ERROR_PARAM_TYPE_UINT64:
			ndr_print_hyper(ndr, "uint64", r->uint64);
		break;

		case EXTENDED_ERROR_PARAM_TYPE_NONE:
		break;

		case EXTENDED_ERROR_PARAM_TYPE_BLOB:
			ndr_print_ExtendedErrorBlob(ndr, "blob", &r->blob);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

static enum ndr_err_code ndr_push_ExtendedErrorParam(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorParam *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_ExtendedErrorParamType(ndr, NDR_SCALARS, r->type));
		NDR_CHECK(ndr_push_set_switch_value(ndr, &r->p, r->type));
		NDR_CHECK(ndr_push_ExtendedErrorParamU(ndr, NDR_SCALARS, &r->p));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_push_ExtendedErrorParamU(ndr, NDR_BUFFERS, &r->p));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorParam(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorParam *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_ExtendedErrorParamType(ndr, NDR_SCALARS, &r->type));
		NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->p, r->type));
		NDR_CHECK(ndr_pull_ExtendedErrorParamU(ndr, NDR_SCALARS, &r->p));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		NDR_CHECK(ndr_pull_ExtendedErrorParamU(ndr, NDR_BUFFERS, &r->p));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorParam(struct ndr_print *ndr, const char *name, const struct ExtendedErrorParam *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorParam");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_ExtendedErrorParamType(ndr, "type", r->type);
	ndr_print_set_switch_value(ndr, &r->p, r->type);
	ndr_print_ExtendedErrorParamU(ndr, "p", &r->p);
	ndr->depth--;
}

_PUBLIC_ enum ndr_err_code ndr_push_ExtendedErrorInfo(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorInfo *r)
{
	uint32_t cntr_params_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->num_params));
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->next));
		NDR_CHECK(ndr_push_ExtendedErrorComputerName(ndr, NDR_SCALARS, &r->computer_name));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->pid));
		NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->time));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->generating_component));
		NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->status));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->detection_location));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->flags));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->num_params));
		for (cntr_params_0 = 0; cntr_params_0 < r->num_params; cntr_params_0++) {
			NDR_CHECK(ndr_push_ExtendedErrorParam(ndr, NDR_SCALARS, &r->params[cntr_params_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->next) {
			NDR_CHECK(ndr_push_ExtendedErrorInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->next));
		}
		NDR_CHECK(ndr_push_ExtendedErrorComputerName(ndr, NDR_BUFFERS, &r->computer_name));
		for (cntr_params_0 = 0; cntr_params_0 < r->num_params; cntr_params_0++) {
			NDR_CHECK(ndr_push_ExtendedErrorParam(ndr, NDR_BUFFERS, &r->params[cntr_params_0]));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_ExtendedErrorInfo(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorInfo *r)
{
	uint32_t _ptr_next;
	TALLOC_CTX *_mem_save_next_0;
	uint32_t size_params_0 = 0;
	uint32_t cntr_params_0;
	TALLOC_CTX *_mem_save_params_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->params));
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_next));
		if (_ptr_next) {
			NDR_PULL_ALLOC(ndr, r->next);
		} else {
			r->next = NULL;
		}
		NDR_CHECK(ndr_pull_ExtendedErrorComputerName(ndr, NDR_SCALARS, &r->computer_name));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->pid));
		NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->time));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->generating_component));
		NDR_CHECK(ndr_pull_WERROR(ndr, NDR_SCALARS, &r->status));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->detection_location));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->flags));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->num_params));
		size_params_0 = ndr_get_array_size(ndr, &r->params);
		NDR_PULL_ALLOC_N(ndr, r->params, size_params_0);
		_mem_save_params_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->params, 0);
		for (cntr_params_0 = 0; cntr_params_0 < size_params_0; cntr_params_0++) {
			NDR_CHECK(ndr_pull_ExtendedErrorParam(ndr, NDR_SCALARS, &r->params[cntr_params_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_params_0, 0);
		if (r->params) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->params, r->num_params));
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->next) {
			_mem_save_next_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->next, 0);
			NDR_CHECK(ndr_pull_ExtendedErrorInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->next));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_next_0, 0);
		}
		NDR_CHECK(ndr_pull_ExtendedErrorComputerName(ndr, NDR_BUFFERS, &r->computer_name));
		size_params_0 = ndr_get_array_size(ndr, &r->params);
		_mem_save_params_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->params, 0);
		for (cntr_params_0 = 0; cntr_params_0 < size_params_0; cntr_params_0++) {
			NDR_CHECK(ndr_pull_ExtendedErrorParam(ndr, NDR_BUFFERS, &r->params[cntr_params_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_params_0, 0);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorInfo(struct ndr_print *ndr, const char *name, const struct ExtendedErrorInfo *r)
{
	uint32_t cntr_params_0;
	ndr_print_struct(ndr, name, "ExtendedErrorInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_ptr(ndr, "next", r->next);
	ndr->depth++;
	if (r->next) {
		ndr_print_ExtendedErrorInfo(ndr, "next", r->next);
	}
	ndr->depth--;
	ndr_print_ExtendedErrorComputerName(ndr, "computer_name", &r->computer_name);
	ndr_print_hyper(ndr, "pid", r->pid);
	ndr_print_NTTIME(ndr, "time", r->time);
	ndr_print_uint32(ndr, "generating_component", r->generating_component);
	ndr_print_WERROR(ndr, "status", r->status);
	ndr_print_uint16(ndr, "detection_location", r->detection_location);
	ndr_print_uint16(ndr, "flags", r->flags);
	ndr_print_uint16(ndr, "num_params", r->num_params);
	ndr->print(ndr, "%s: ARRAY(%d)", "params", (int)r->num_params);
	ndr->depth++;
	for (cntr_params_0=0;cntr_params_0<r->num_params;cntr_params_0++) {
		ndr_print_ExtendedErrorParam(ndr, "params", &r->params[cntr_params_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ExtendedErrorInfoPtr(struct ndr_push *ndr, int ndr_flags, const struct ExtendedErrorInfoPtr *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 5));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->info));
		NDR_CHECK(ndr_push_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->info) {
			NDR_CHECK(ndr_push_ExtendedErrorInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->info));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ExtendedErrorInfoPtr(struct ndr_pull *ndr, int ndr_flags, struct ExtendedErrorInfoPtr *r)
{
	uint32_t _ptr_info;
	TALLOC_CTX *_mem_save_info_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 5));
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_info));
		if (_ptr_info) {
			NDR_PULL_ALLOC(ndr, r->info);
		} else {
			r->info = NULL;
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 5));
	}
	if (ndr_flags & NDR_BUFFERS) {
		if (r->info) {
			_mem_save_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->info, 0);
			NDR_CHECK(ndr_pull_ExtendedErrorInfo(ndr, NDR_SCALARS|NDR_BUFFERS, r->info));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_info_0, 0);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ExtendedErrorInfoPtr(struct ndr_print *ndr, const char *name, const struct ExtendedErrorInfoPtr *r)
{
	ndr_print_struct(ndr, name, "ExtendedErrorInfoPtr");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_ptr(ndr, "info", r->info);
	ndr->depth++;
	if (r->info) {
		ndr_print_ExtendedErrorInfo(ndr, "info", r->info);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ForestTrustString(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustString *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, strlen_m(r->string)));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->string, strlen_m(r->string), sizeof(uint8_t), CH_UTF8));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustString(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustString *r)
{
	uint32_t size_string_0 = 0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
		size_string_0 = r->size;
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->string, size_string_0, sizeof(uint8_t), CH_UTF8));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustString(struct ndr_print *ndr, const char *name, const struct ForestTrustString *r)
{
	ndr_print_struct(ndr, name, "ForestTrustString");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?strlen_m(r->string):r->size);
	ndr_print_string(ndr, "string", r->string);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_ForestTrustDataDomainInfo(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustDataDomainInfo *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_dom_sid0(&r->sid, ndr->flags)));
			{
				struct ndr_push *_ndr_sid;
				NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_sid, 0, ndr_size_dom_sid0(&r->sid, ndr->flags)));
				NDR_CHECK(ndr_push_dom_sid(_ndr_sid, NDR_SCALARS, &r->sid));
				NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_sid, 0, ndr_size_dom_sid0(&r->sid, ndr->flags)));
			}
			NDR_CHECK(ndr_push_ForestTrustString(ndr, NDR_SCALARS, &r->dns_name));
			NDR_CHECK(ndr_push_ForestTrustString(ndr, NDR_SCALARS, &r->netbios_name));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustDataDomainInfo(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustDataDomainInfo *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->sid_size));
			{
				struct ndr_pull *_ndr_sid;
				NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_sid, 0, r->sid_size));
				NDR_CHECK(ndr_pull_dom_sid(_ndr_sid, NDR_SCALARS, &r->sid));
				NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_sid, 0, r->sid_size));
			}
			NDR_CHECK(ndr_pull_ForestTrustString(ndr, NDR_SCALARS, &r->dns_name));
			NDR_CHECK(ndr_pull_ForestTrustString(ndr, NDR_SCALARS, &r->netbios_name));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustDataDomainInfo(struct ndr_print *ndr, const char *name, const struct ForestTrustDataDomainInfo *r)
{
	ndr_print_struct(ndr, name, "ForestTrustDataDomainInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "sid_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_dom_sid0(&r->sid, ndr->flags):r->sid_size);
		ndr_print_dom_sid(ndr, "sid", &r->sid);
		ndr_print_ForestTrustString(ndr, "dns_name", &r->dns_name);
		ndr_print_ForestTrustString(ndr, "netbios_name", &r->netbios_name);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_ForestTrustDataBinaryData(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustDataBinaryData *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->size));
			NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->data, r->size));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustDataBinaryData(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustDataBinaryData *r)
{
	uint32_t size_data_0 = 0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->size));
			size_data_0 = r->size;
			NDR_PULL_ALLOC_N(ndr, r->data, size_data_0);
			NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->data, size_data_0));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustDataBinaryData(struct ndr_print *ndr, const char *name, const struct ForestTrustDataBinaryData *r)
{
	ndr_print_struct(ndr, name, "ForestTrustDataBinaryData");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "size", r->size);
		ndr_print_array_uint8(ndr, "data", r->data, r->size);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_ForestTrustData(struct ndr_push *ndr, int ndr_flags, const union ForestTrustData *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 4));
		switch (level) {
			case FOREST_TRUST_TOP_LEVEL_NAME: {
				NDR_CHECK(ndr_push_ForestTrustString(ndr, NDR_SCALARS, &r->name));
			break; }

			case FOREST_TRUST_TOP_LEVEL_NAME_EX: {
				NDR_CHECK(ndr_push_ForestTrustString(ndr, NDR_SCALARS, &r->name));
			break; }

			case FOREST_TRUST_DOMAIN_INFO: {
				NDR_CHECK(ndr_push_ForestTrustDataDomainInfo(ndr, NDR_SCALARS, &r->info));
			break; }

			default: {
				NDR_CHECK(ndr_push_ForestTrustDataBinaryData(ndr, NDR_SCALARS, &r->data));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case FOREST_TRUST_TOP_LEVEL_NAME:
			break;

			case FOREST_TRUST_TOP_LEVEL_NAME_EX:
			break;

			case FOREST_TRUST_DOMAIN_INFO:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustData(struct ndr_pull *ndr, int ndr_flags, union ForestTrustData *r)
{
	uint32_t level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 4));
		switch (level) {
			case FOREST_TRUST_TOP_LEVEL_NAME: {
				NDR_CHECK(ndr_pull_ForestTrustString(ndr, NDR_SCALARS, &r->name));
			break; }

			case FOREST_TRUST_TOP_LEVEL_NAME_EX: {
				NDR_CHECK(ndr_pull_ForestTrustString(ndr, NDR_SCALARS, &r->name));
			break; }

			case FOREST_TRUST_DOMAIN_INFO: {
				NDR_CHECK(ndr_pull_ForestTrustDataDomainInfo(ndr, NDR_SCALARS, &r->info));
			break; }

			default: {
				NDR_CHECK(ndr_pull_ForestTrustDataBinaryData(ndr, NDR_SCALARS, &r->data));
			break; }

		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case FOREST_TRUST_TOP_LEVEL_NAME:
			break;

			case FOREST_TRUST_TOP_LEVEL_NAME_EX:
			break;

			case FOREST_TRUST_DOMAIN_INFO:
			break;

			default:
			break;

		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustData(struct ndr_print *ndr, const char *name, const union ForestTrustData *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "ForestTrustData");
	switch (level) {
		case FOREST_TRUST_TOP_LEVEL_NAME:
			ndr_print_ForestTrustString(ndr, "name", &r->name);
		break;

		case FOREST_TRUST_TOP_LEVEL_NAME_EX:
			ndr_print_ForestTrustString(ndr, "name", &r->name);
		break;

		case FOREST_TRUST_DOMAIN_INFO:
			ndr_print_ForestTrustDataDomainInfo(ndr, "info", &r->info);
		break;

		default:
			ndr_print_ForestTrustDataBinaryData(ndr, "data", &r->data);
		break;

	}
}

static enum ndr_err_code ndr_push_ForestTrustInfoRecordType(struct ndr_push *ndr, int ndr_flags, enum ForestTrustInfoRecordType r)
{
	NDR_CHECK(ndr_push_enum_uint8(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustInfoRecordType(struct ndr_pull *ndr, int ndr_flags, enum ForestTrustInfoRecordType *r)
{
	uint8_t v;
	NDR_CHECK(ndr_pull_enum_uint8(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustInfoRecordType(struct ndr_print *ndr, const char *name, enum ForestTrustInfoRecordType r)
{
	const char *val = NULL;

	switch (r) {
		case FOREST_TRUST_TOP_LEVEL_NAME: val = "FOREST_TRUST_TOP_LEVEL_NAME"; break;
		case FOREST_TRUST_TOP_LEVEL_NAME_EX: val = "FOREST_TRUST_TOP_LEVEL_NAME_EX"; break;
		case FOREST_TRUST_DOMAIN_INFO: val = "FOREST_TRUST_DOMAIN_INFO"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

_PUBLIC_ enum ndr_err_code ndr_push_ForestTrustInfoRecord(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustInfoRecord *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->flags));
			NDR_CHECK(ndr_push_NTTIME(ndr, NDR_SCALARS, r->timestamp));
			NDR_CHECK(ndr_push_ForestTrustInfoRecordType(ndr, NDR_SCALARS, r->type));
			NDR_CHECK(ndr_push_set_switch_value(ndr, &r->data, r->type));
			NDR_CHECK(ndr_push_ForestTrustData(ndr, NDR_SCALARS, &r->data));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_ForestTrustInfoRecord(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustInfoRecord *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->flags));
			NDR_CHECK(ndr_pull_NTTIME(ndr, NDR_SCALARS, &r->timestamp));
			NDR_CHECK(ndr_pull_ForestTrustInfoRecordType(ndr, NDR_SCALARS, &r->type));
			NDR_CHECK(ndr_pull_set_switch_value(ndr, &r->data, r->type));
			NDR_CHECK(ndr_pull_ForestTrustData(ndr, NDR_SCALARS, &r->data));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustInfoRecord(struct ndr_print *ndr, const char *name, const struct ForestTrustInfoRecord *r)
{
	ndr_print_struct(ndr, name, "ForestTrustInfoRecord");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "flags", r->flags);
		ndr_print_NTTIME(ndr, "timestamp", r->timestamp);
		ndr_print_ForestTrustInfoRecordType(ndr, "type", r->type);
		ndr_print_set_switch_value(ndr, &r->data, r->type);
		ndr_print_ForestTrustData(ndr, "data", &r->data);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ size_t ndr_size_ForestTrustInfoRecord(const struct ForestTrustInfoRecord *r, int flags)
{
	flags |= LIBNDR_FLAG_NOALIGN;
	return ndr_size_struct(r, flags, (ndr_push_flags_fn_t)ndr_push_ForestTrustInfoRecord);
}

static enum ndr_err_code ndr_push_ForestTrustInfoRecordArmor(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustInfoRecordArmor *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, ndr_size_ForestTrustInfoRecord(&r->record, ndr->flags)));
			NDR_CHECK(ndr_push_ForestTrustInfoRecord(ndr, NDR_SCALARS, &r->record));
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_ForestTrustInfoRecordArmor(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustInfoRecordArmor *r)
{
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->record_size));
			NDR_CHECK(ndr_pull_ForestTrustInfoRecord(ndr, NDR_SCALARS, &r->record));
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustInfoRecordArmor(struct ndr_print *ndr, const char *name, const struct ForestTrustInfoRecordArmor *r)
{
	ndr_print_struct(ndr, name, "ForestTrustInfoRecordArmor");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "record_size", (ndr->flags & LIBNDR_PRINT_SET_VALUES)?ndr_size_ForestTrustInfoRecord(&r->record, ndr->flags):r->record_size);
		ndr_print_ForestTrustInfoRecord(ndr, "record", &r->record);
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

_PUBLIC_ enum ndr_err_code ndr_push_ForestTrustInfo(struct ndr_push *ndr, int ndr_flags, const struct ForestTrustInfo *r)
{
	uint32_t cntr_records_0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_push_align(ndr, 4));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->version));
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->count));
			for (cntr_records_0 = 0; cntr_records_0 < r->count; cntr_records_0++) {
				NDR_CHECK(ndr_push_ForestTrustInfoRecordArmor(ndr, NDR_SCALARS, &r->records[cntr_records_0]));
			}
			NDR_CHECK(ndr_push_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_ForestTrustInfo(struct ndr_pull *ndr, int ndr_flags, struct ForestTrustInfo *r)
{
	uint32_t size_records_0 = 0;
	uint32_t cntr_records_0;
	TALLOC_CTX *_mem_save_records_0;
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		if (ndr_flags & NDR_SCALARS) {
			NDR_CHECK(ndr_pull_align(ndr, 4));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->version));
			NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->count));
			size_records_0 = r->count;
			NDR_PULL_ALLOC_N(ndr, r->records, size_records_0);
			_mem_save_records_0 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, r->records, 0);
			for (cntr_records_0 = 0; cntr_records_0 < size_records_0; cntr_records_0++) {
				NDR_CHECK(ndr_pull_ForestTrustInfoRecordArmor(ndr, NDR_SCALARS, &r->records[cntr_records_0]));
			}
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_records_0, 0);
			NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
		}
		if (ndr_flags & NDR_BUFFERS) {
		}
		ndr->flags = _flags_save_STRUCT;
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_ForestTrustInfo(struct ndr_print *ndr, const char *name, const struct ForestTrustInfo *r)
{
	uint32_t cntr_records_0;
	ndr_print_struct(ndr, name, "ForestTrustInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	{
		uint32_t _flags_save_STRUCT = ndr->flags;
		ndr_set_flags(&ndr->flags, LIBNDR_FLAG_NOALIGN);
		ndr->depth++;
		ndr_print_uint32(ndr, "version", r->version);
		ndr_print_uint32(ndr, "count", r->count);
		ndr->print(ndr, "%s: ARRAY(%d)", "records", (int)r->count);
		ndr->depth++;
		for (cntr_records_0=0;cntr_records_0<r->count;cntr_records_0++) {
			ndr_print_ForestTrustInfoRecordArmor(ndr, "records", &r->records[cntr_records_0]);
		}
		ndr->depth--;
		ndr->depth--;
		ndr->flags = _flags_save_STRUCT;
	}
}

static enum ndr_err_code ndr_push_decode_replPropertyMetaData(struct ndr_push *ndr, int flags, const struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replPropertyMetaDataBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_replPropertyMetaData(struct ndr_pull *ndr, int flags, struct decode_replPropertyMetaData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replPropertyMetaDataBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_replPropertyMetaData(struct ndr_print *ndr, const char *name, int flags, const struct decode_replPropertyMetaData *r)
{
	ndr_print_struct(ndr, name, "decode_replPropertyMetaData");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr_print_replPropertyMetaDataBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replPropertyMetaData");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_replUpToDateVector(struct ndr_push *ndr, int flags, const struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_replUpToDateVector(struct ndr_pull *ndr, int flags, struct decode_replUpToDateVector *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_replUpToDateVectorBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_replUpToDateVector(struct ndr_print *ndr, const char *name, int flags, const struct decode_replUpToDateVector *r)
{
	ndr_print_struct(ndr, name, "decode_replUpToDateVector");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_replUpToDateVector");
		ndr->depth++;
		ndr_print_replUpToDateVectorBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_replUpToDateVector");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_repsFromTo(struct ndr_push *ndr, int flags, const struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_repsFromTo(struct ndr_pull *ndr, int flags, struct decode_repsFromTo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_repsFromToBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_repsFromTo(struct ndr_print *ndr, const char *name, int flags, const struct decode_repsFromTo *r)
{
	ndr_print_struct(ndr, name, "decode_repsFromTo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_repsFromTo");
		ndr->depth++;
		ndr_print_repsFromToBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_repsFromTo");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_partialAttributeSet(struct ndr_push *ndr, int flags, const struct decode_partialAttributeSet *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_partialAttributeSetBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_partialAttributeSet(struct ndr_pull *ndr, int flags, struct decode_partialAttributeSet *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_partialAttributeSetBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_partialAttributeSet(struct ndr_print *ndr, const char *name, int flags, const struct decode_partialAttributeSet *r)
{
	ndr_print_struct(ndr, name, "decode_partialAttributeSet");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_partialAttributeSet");
		ndr->depth++;
		ndr_print_partialAttributeSetBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_partialAttributeSet");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_prefixMap(struct ndr_push *ndr, int flags, const struct decode_prefixMap *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_prefixMapBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_prefixMap(struct ndr_pull *ndr, int flags, struct decode_prefixMap *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_prefixMapBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_prefixMap(struct ndr_print *ndr, const char *name, int flags, const struct decode_prefixMap *r)
{
	ndr_print_struct(ndr, name, "decode_prefixMap");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_prefixMap");
		ndr->depth++;
		ndr_print_prefixMapBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_prefixMap");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_ldapControlDirSync(struct ndr_push *ndr, int flags, const struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_ldapControlDirSync(struct ndr_pull *ndr, int flags, struct decode_ldapControlDirSync *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_ldapControlDirSyncCookie(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.cookie));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_ldapControlDirSync(struct ndr_print *ndr, const char *name, int flags, const struct decode_ldapControlDirSync *r)
{
	ndr_print_struct(ndr, name, "decode_ldapControlDirSync");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr_print_ldapControlDirSyncCookie(ndr, "cookie", &r->in.cookie);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_ldapControlDirSync");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_supplementalCredentials(struct ndr_push *ndr, int flags, const struct decode_supplementalCredentials *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_supplementalCredentialsBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_supplementalCredentials(struct ndr_pull *ndr, int flags, struct decode_supplementalCredentials *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_supplementalCredentialsBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_supplementalCredentials(struct ndr_print *ndr, const char *name, int flags, const struct decode_supplementalCredentials *r)
{
	ndr_print_struct(ndr, name, "decode_supplementalCredentials");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_supplementalCredentials");
		ndr->depth++;
		ndr_print_supplementalCredentialsBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_supplementalCredentials");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_Packages(struct ndr_push *ndr, int flags, const struct decode_Packages *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PackagesBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_Packages(struct ndr_pull *ndr, int flags, struct decode_Packages *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PackagesBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_Packages(struct ndr_print *ndr, const char *name, int flags, const struct decode_Packages *r)
{
	ndr_print_struct(ndr, name, "decode_Packages");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_Packages");
		ndr->depth++;
		ndr_print_package_PackagesBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_Packages");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryKerberos(struct ndr_push *ndr, int flags, const struct decode_PrimaryKerberos *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryKerberosBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryKerberos(struct ndr_pull *ndr, int flags, struct decode_PrimaryKerberos *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryKerberosBlob(ndr, NDR_SCALARS|NDR_BUFFERS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryKerberos(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryKerberos *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryKerberos");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryKerberos");
		ndr->depth++;
		ndr_print_package_PrimaryKerberosBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryKerberos");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryCLEARTEXT(struct ndr_push *ndr, int flags, const struct decode_PrimaryCLEARTEXT *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryCLEARTEXTBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryCLEARTEXT(struct ndr_pull *ndr, int flags, struct decode_PrimaryCLEARTEXT *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryCLEARTEXTBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryCLEARTEXT(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryCLEARTEXT *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryCLEARTEXT");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryCLEARTEXT");
		ndr->depth++;
		ndr_print_package_PrimaryCLEARTEXTBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryCLEARTEXT");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_PrimaryWDigest(struct ndr_push *ndr, int flags, const struct decode_PrimaryWDigest *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_package_PrimaryWDigestBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_PrimaryWDigest(struct ndr_pull *ndr, int flags, struct decode_PrimaryWDigest *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_package_PrimaryWDigestBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_PrimaryWDigest(struct ndr_print *ndr, const char *name, int flags, const struct decode_PrimaryWDigest *r)
{
	ndr_print_struct(ndr, name, "decode_PrimaryWDigest");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_PrimaryWDigest");
		ndr->depth++;
		ndr_print_package_PrimaryWDigestBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_PrimaryWDigest");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_trustAuthInOut(struct ndr_push *ndr, int flags, const struct decode_trustAuthInOut *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_trustAuthInOutBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_trustAuthInOut(struct ndr_pull *ndr, int flags, struct decode_trustAuthInOut *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_trustAuthInOutBlob(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_trustAuthInOut(struct ndr_print *ndr, const char *name, int flags, const struct decode_trustAuthInOut *r)
{
	ndr_print_struct(ndr, name, "decode_trustAuthInOut");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_trustAuthInOut");
		ndr->depth++;
		ndr_print_trustAuthInOutBlob(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_trustAuthInOut");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_trustDomainPasswords(struct ndr_push *ndr, int flags, const struct decode_trustDomainPasswords *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_trustDomainPasswords(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_trustDomainPasswords(struct ndr_pull *ndr, int flags, struct decode_trustDomainPasswords *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_trustDomainPasswords(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_trustDomainPasswords(struct ndr_print *ndr, const char *name, int flags, const struct decode_trustDomainPasswords *r)
{
	ndr_print_struct(ndr, name, "decode_trustDomainPasswords");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_trustDomainPasswords");
		ndr->depth++;
		ndr_print_trustDomainPasswords(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_trustDomainPasswords");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_ExtendedErrorInfo(struct ndr_push *ndr, int flags, const struct decode_ExtendedErrorInfo *r)
{
	if (flags & NDR_IN) {
		{
			struct ndr_push *_ndr_ptr;
			NDR_CHECK(ndr_push_subcontext_start(ndr, &_ndr_ptr, 0xFFFFFC01, -1));
			NDR_CHECK(ndr_push_ExtendedErrorInfoPtr(_ndr_ptr, NDR_SCALARS|NDR_BUFFERS, &r->in.ptr));
			NDR_CHECK(ndr_push_subcontext_end(ndr, _ndr_ptr, 0xFFFFFC01, -1));
		}
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_ExtendedErrorInfo(struct ndr_pull *ndr, int flags, struct decode_ExtendedErrorInfo *r)
{
	if (flags & NDR_IN) {
		{
			struct ndr_pull *_ndr_ptr;
			NDR_CHECK(ndr_pull_subcontext_start(ndr, &_ndr_ptr, 0xFFFFFC01, -1));
			NDR_CHECK(ndr_pull_ExtendedErrorInfoPtr(_ndr_ptr, NDR_SCALARS|NDR_BUFFERS, &r->in.ptr));
			NDR_CHECK(ndr_pull_subcontext_end(ndr, _ndr_ptr, 0xFFFFFC01, -1));
		}
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_ExtendedErrorInfo(struct ndr_print *ndr, const char *name, int flags, const struct decode_ExtendedErrorInfo *r)
{
	ndr_print_struct(ndr, name, "decode_ExtendedErrorInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_ExtendedErrorInfo");
		ndr->depth++;
		ndr_print_ExtendedErrorInfoPtr(ndr, "ptr", &r->in.ptr);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_ExtendedErrorInfo");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_decode_ForestTrustInfo(struct ndr_push *ndr, int flags, const struct decode_ForestTrustInfo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_ForestTrustInfo(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_decode_ForestTrustInfo(struct ndr_pull *ndr, int flags, struct decode_ForestTrustInfo *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_ForestTrustInfo(ndr, NDR_SCALARS, &r->in.blob));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_decode_ForestTrustInfo(struct ndr_print *ndr, const char *name, int flags, const struct decode_ForestTrustInfo *r)
{
	ndr_print_struct(ndr, name, "decode_ForestTrustInfo");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "decode_ForestTrustInfo");
		ndr->depth++;
		ndr_print_ForestTrustInfo(ndr, "blob", &r->in.blob);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "decode_ForestTrustInfo");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static const struct ndr_interface_call drsblobs_calls[] = {
	{
		"decode_replPropertyMetaData",
		sizeof(struct decode_replPropertyMetaData),
		(ndr_push_flags_fn_t) ndr_push_decode_replPropertyMetaData,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replPropertyMetaData,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_replUpToDateVector",
		sizeof(struct decode_replUpToDateVector),
		(ndr_push_flags_fn_t) ndr_push_decode_replUpToDateVector,
		(ndr_pull_flags_fn_t) ndr_pull_decode_replUpToDateVector,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_repsFromTo",
		sizeof(struct decode_repsFromTo),
		(ndr_push_flags_fn_t) ndr_push_decode_repsFromTo,
		(ndr_pull_flags_fn_t) ndr_pull_decode_repsFromTo,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_partialAttributeSet",
		sizeof(struct decode_partialAttributeSet),
		(ndr_push_flags_fn_t) ndr_push_decode_partialAttributeSet,
		(ndr_pull_flags_fn_t) ndr_pull_decode_partialAttributeSet,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_prefixMap",
		sizeof(struct decode_prefixMap),
		(ndr_push_flags_fn_t) ndr_push_decode_prefixMap,
		(ndr_pull_flags_fn_t) ndr_pull_decode_prefixMap,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_ldapControlDirSync",
		sizeof(struct decode_ldapControlDirSync),
		(ndr_push_flags_fn_t) ndr_push_decode_ldapControlDirSync,
		(ndr_pull_flags_fn_t) ndr_pull_decode_ldapControlDirSync,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_supplementalCredentials",
		sizeof(struct decode_supplementalCredentials),
		(ndr_push_flags_fn_t) ndr_push_decode_supplementalCredentials,
		(ndr_pull_flags_fn_t) ndr_pull_decode_supplementalCredentials,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_Packages",
		sizeof(struct decode_Packages),
		(ndr_push_flags_fn_t) ndr_push_decode_Packages,
		(ndr_pull_flags_fn_t) ndr_pull_decode_Packages,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_PrimaryKerberos",
		sizeof(struct decode_PrimaryKerberos),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryKerberos,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryKerberos,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_PrimaryCLEARTEXT",
		sizeof(struct decode_PrimaryCLEARTEXT),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryCLEARTEXT,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryCLEARTEXT,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_PrimaryWDigest",
		sizeof(struct decode_PrimaryWDigest),
		(ndr_push_flags_fn_t) ndr_push_decode_PrimaryWDigest,
		(ndr_pull_flags_fn_t) ndr_pull_decode_PrimaryWDigest,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_trustAuthInOut",
		sizeof(struct decode_trustAuthInOut),
		(ndr_push_flags_fn_t) ndr_push_decode_trustAuthInOut,
		(ndr_pull_flags_fn_t) ndr_pull_decode_trustAuthInOut,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_trustDomainPasswords",
		sizeof(struct decode_trustDomainPasswords),
		(ndr_push_flags_fn_t) ndr_push_decode_trustDomainPasswords,
		(ndr_pull_flags_fn_t) ndr_pull_decode_trustDomainPasswords,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_ExtendedErrorInfo",
		sizeof(struct decode_ExtendedErrorInfo),
		(ndr_push_flags_fn_t) ndr_push_decode_ExtendedErrorInfo,
		(ndr_pull_flags_fn_t) ndr_pull_decode_ExtendedErrorInfo,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"decode_ForestTrustInfo",
		sizeof(struct decode_ForestTrustInfo),
		(ndr_push_flags_fn_t) ndr_push_decode_ForestTrustInfo,
		(ndr_pull_flags_fn_t) ndr_pull_decode_ForestTrustInfo,
		(ndr_print_function_t) ndr_print_disabled,
		{ 0, NULL },
		{ 0, NULL },
	},
	{ NULL, 0, NULL, NULL, NULL }
};

static const char * const drsblobs_endpoint_strings[] = {
	"ncacn_np:[\\pipe\\drsblobs]", 
};

static const struct ndr_interface_string_array drsblobs_endpoints = {
	.count	= 1,
	.names	= drsblobs_endpoint_strings
};

static const char * const drsblobs_authservice_strings[] = {
	"host", 
};

static const struct ndr_interface_string_array drsblobs_authservices = {
	.count	= 1,
	.names	= drsblobs_authservice_strings
};


const struct ndr_interface_table ndr_table_drsblobs = {
	.name		= "drsblobs",
	.syntax_id	= {
		{0x12345778,0x1234,0xabcd,{0x00,0x01},{0x00,0x00,0x00,0x01}},
		NDR_DRSBLOBS_VERSION
	},
	.helpstring	= NDR_DRSBLOBS_HELPSTRING,
	.num_calls	= 15,
	.calls		= drsblobs_calls,
	.endpoints	= &drsblobs_endpoints,
	.authservices	= &drsblobs_authservices
};

