
/* Python wrapper functions auto-generated by pidl */
#include <Python.h>
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "librpc/gen_ndr/ndr_epmapper.h"
#include "librpc/gen_ndr/ndr_epmapper_c.h"

#include "librpc/gen_ndr/misc.h"
staticforward PyTypeObject epm_rhs_dnet_nsp_Type;
staticforward PyTypeObject epm_rhs_osi_tp4_Type;
staticforward PyTypeObject epm_rhs_osi_clns_Type;
staticforward PyTypeObject epm_rhs_udp_Type;
staticforward PyTypeObject epm_rhs_tcp_Type;
staticforward PyTypeObject epm_rhs_ip_Type;
staticforward PyTypeObject epm_rhs_ncadg_Type;
staticforward PyTypeObject epm_rhs_ncacn_Type;
staticforward PyTypeObject epm_rhs_uuid_Type;
staticforward PyTypeObject epm_rhs_ipx_Type;
staticforward PyTypeObject epm_rhs_smb_Type;
staticforward PyTypeObject epm_rhs_named_pipe_Type;
staticforward PyTypeObject epm_rhs_netbios_Type;
staticforward PyTypeObject epm_rhs_netbeui_Type;
staticforward PyTypeObject epm_rhs_spx_Type;
staticforward PyTypeObject epm_rhs_nb_ipx_Type;
staticforward PyTypeObject epm_rhs_http_Type;
staticforward PyTypeObject epm_rhs_unix_ds_Type;
staticforward PyTypeObject epm_rhs_null_Type;
staticforward PyTypeObject epm_rhs_ncalrpc_Type;
staticforward PyTypeObject epm_rhs_appletalk_Type;
staticforward PyTypeObject epm_rhs_atalk_stream_Type;
staticforward PyTypeObject epm_rhs_atalk_datagram_Type;
staticforward PyTypeObject epm_rhs_vines_spp_Type;
staticforward PyTypeObject epm_rhs_vines_ipc_Type;
staticforward PyTypeObject epm_rhs_streettalk_Type;
staticforward PyTypeObject epm_lhs_Type;
staticforward PyTypeObject epm_floor_Type;
staticforward PyTypeObject epm_tower_Type;
staticforward PyTypeObject epm_twr_t_Type;
staticforward PyTypeObject epm_entry_t_Type;
staticforward PyTypeObject rpc_if_id_t_Type;
staticforward PyTypeObject epm_twr_p_t_Type;
staticforward PyTypeObject epmapper_InterfaceType;

void initepmapper(void);static PyTypeObject *ClientConnection_Type;
static PyTypeObject *GUID_Type;
static PyTypeObject *policy_handle_Type;
static PyTypeObject *Object_Type;

static PyObject *py_epm_rhs_dnet_nsp_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_dnet_nsp, type);
}


static PyTypeObject epm_rhs_dnet_nsp_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_dnet_nsp",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_dnet_nsp_new,
};


static PyObject *py_epm_rhs_osi_tp4_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_osi_tp4, type);
}


static PyTypeObject epm_rhs_osi_tp4_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_osi_tp4",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_osi_tp4_new,
};


static PyObject *py_epm_rhs_osi_clns_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_osi_clns, type);
}


static PyTypeObject epm_rhs_osi_clns_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_osi_clns",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_osi_clns_new,
};


static PyObject *py_epm_rhs_udp_get_port(PyObject *obj, void *closure)
{
	struct epm_rhs_udp *object = (struct epm_rhs_udp *)py_talloc_get_ptr(obj);
	PyObject *py_port;
	py_port = PyInt_FromLong(object->port);
	return py_port;
}

static int py_epm_rhs_udp_set_port(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_udp *object = (struct epm_rhs_udp *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->port = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_udp_getsetters[] = {
	{ discard_const_p(char, "port"), py_epm_rhs_udp_get_port, py_epm_rhs_udp_set_port },
	{ NULL }
};

static PyObject *py_epm_rhs_udp_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_udp, type);
}


static PyTypeObject epm_rhs_udp_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_udp",
	.tp_getset = py_epm_rhs_udp_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_udp_new,
};


static PyObject *py_epm_rhs_tcp_get_port(PyObject *obj, void *closure)
{
	struct epm_rhs_tcp *object = (struct epm_rhs_tcp *)py_talloc_get_ptr(obj);
	PyObject *py_port;
	py_port = PyInt_FromLong(object->port);
	return py_port;
}

static int py_epm_rhs_tcp_set_port(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_tcp *object = (struct epm_rhs_tcp *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->port = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_tcp_getsetters[] = {
	{ discard_const_p(char, "port"), py_epm_rhs_tcp_get_port, py_epm_rhs_tcp_set_port },
	{ NULL }
};

static PyObject *py_epm_rhs_tcp_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_tcp, type);
}


static PyTypeObject epm_rhs_tcp_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_tcp",
	.tp_getset = py_epm_rhs_tcp_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_tcp_new,
};


static PyObject *py_epm_rhs_ip_get_ipaddr(PyObject *obj, void *closure)
{
	struct epm_rhs_ip *object = (struct epm_rhs_ip *)py_talloc_get_ptr(obj);
	PyObject *py_ipaddr;
	py_ipaddr = PyString_FromStringOrNULL(object->ipaddr);
	return py_ipaddr;
}

static int py_epm_rhs_ip_set_ipaddr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_ip *object = (struct epm_rhs_ip *)py_talloc_get_ptr(py_obj);
	object->ipaddr = PyString_AS_STRING(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_ip_getsetters[] = {
	{ discard_const_p(char, "ipaddr"), py_epm_rhs_ip_get_ipaddr, py_epm_rhs_ip_set_ipaddr },
	{ NULL }
};

static PyObject *py_epm_rhs_ip_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_ip, type);
}


static PyTypeObject epm_rhs_ip_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_ip",
	.tp_getset = py_epm_rhs_ip_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_ip_new,
};


static PyObject *py_epm_rhs_ncadg_get_minor_version(PyObject *obj, void *closure)
{
	struct epm_rhs_ncadg *object = (struct epm_rhs_ncadg *)py_talloc_get_ptr(obj);
	PyObject *py_minor_version;
	py_minor_version = PyInt_FromLong(object->minor_version);
	return py_minor_version;
}

static int py_epm_rhs_ncadg_set_minor_version(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_ncadg *object = (struct epm_rhs_ncadg *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->minor_version = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_ncadg_getsetters[] = {
	{ discard_const_p(char, "minor_version"), py_epm_rhs_ncadg_get_minor_version, py_epm_rhs_ncadg_set_minor_version },
	{ NULL }
};

static PyObject *py_epm_rhs_ncadg_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_ncadg, type);
}


static PyTypeObject epm_rhs_ncadg_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_ncadg",
	.tp_getset = py_epm_rhs_ncadg_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_ncadg_new,
};


static PyObject *py_epm_rhs_ncacn_get_minor_version(PyObject *obj, void *closure)
{
	struct epm_rhs_ncacn *object = (struct epm_rhs_ncacn *)py_talloc_get_ptr(obj);
	PyObject *py_minor_version;
	py_minor_version = PyInt_FromLong(object->minor_version);
	return py_minor_version;
}

static int py_epm_rhs_ncacn_set_minor_version(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_ncacn *object = (struct epm_rhs_ncacn *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->minor_version = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_ncacn_getsetters[] = {
	{ discard_const_p(char, "minor_version"), py_epm_rhs_ncacn_get_minor_version, py_epm_rhs_ncacn_set_minor_version },
	{ NULL }
};

static PyObject *py_epm_rhs_ncacn_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_ncacn, type);
}


static PyTypeObject epm_rhs_ncacn_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_ncacn",
	.tp_getset = py_epm_rhs_ncacn_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_ncacn_new,
};


static PyObject *py_epm_rhs_uuid_get_unknown(PyObject *obj, void *closure)
{
	struct epm_rhs_uuid *object = (struct epm_rhs_uuid *)py_talloc_get_ptr(obj);
	PyObject *py_unknown;
	py_unknown = PyString_FromStringAndSize((char *)(object->unknown).data, (object->unknown).length);
	return py_unknown;
}

static int py_epm_rhs_uuid_set_unknown(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_uuid *object = (struct epm_rhs_uuid *)py_talloc_get_ptr(py_obj);
	object->unknown = data_blob_talloc(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value), PyString_GET_SIZE(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_uuid_getsetters[] = {
	{ discard_const_p(char, "unknown"), py_epm_rhs_uuid_get_unknown, py_epm_rhs_uuid_set_unknown },
	{ NULL }
};

static PyObject *py_epm_rhs_uuid_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_uuid, type);
}


static PyTypeObject epm_rhs_uuid_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_uuid",
	.tp_getset = py_epm_rhs_uuid_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_uuid_new,
};


static PyObject *py_epm_rhs_ipx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_ipx, type);
}


static PyTypeObject epm_rhs_ipx_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_ipx",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_ipx_new,
};


static PyObject *py_epm_rhs_smb_get_unc(PyObject *obj, void *closure)
{
	struct epm_rhs_smb *object = (struct epm_rhs_smb *)py_talloc_get_ptr(obj);
	PyObject *py_unc;
	py_unc = PyString_FromStringOrNULL(object->unc);
	return py_unc;
}

static int py_epm_rhs_smb_set_unc(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_smb *object = (struct epm_rhs_smb *)py_talloc_get_ptr(py_obj);
	object->unc = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_smb_getsetters[] = {
	{ discard_const_p(char, "unc"), py_epm_rhs_smb_get_unc, py_epm_rhs_smb_set_unc },
	{ NULL }
};

static PyObject *py_epm_rhs_smb_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_smb, type);
}


static PyTypeObject epm_rhs_smb_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_smb",
	.tp_getset = py_epm_rhs_smb_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_smb_new,
};


static PyObject *py_epm_rhs_named_pipe_get_path(PyObject *obj, void *closure)
{
	struct epm_rhs_named_pipe *object = (struct epm_rhs_named_pipe *)py_talloc_get_ptr(obj);
	PyObject *py_path;
	py_path = PyString_FromStringOrNULL(object->path);
	return py_path;
}

static int py_epm_rhs_named_pipe_set_path(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_named_pipe *object = (struct epm_rhs_named_pipe *)py_talloc_get_ptr(py_obj);
	object->path = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_named_pipe_getsetters[] = {
	{ discard_const_p(char, "path"), py_epm_rhs_named_pipe_get_path, py_epm_rhs_named_pipe_set_path },
	{ NULL }
};

static PyObject *py_epm_rhs_named_pipe_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_named_pipe, type);
}


static PyTypeObject epm_rhs_named_pipe_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_named_pipe",
	.tp_getset = py_epm_rhs_named_pipe_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_named_pipe_new,
};


static PyObject *py_epm_rhs_netbios_get_name(PyObject *obj, void *closure)
{
	struct epm_rhs_netbios *object = (struct epm_rhs_netbios *)py_talloc_get_ptr(obj);
	PyObject *py_name;
	py_name = PyString_FromStringOrNULL(object->name);
	return py_name;
}

static int py_epm_rhs_netbios_set_name(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_netbios *object = (struct epm_rhs_netbios *)py_talloc_get_ptr(py_obj);
	object->name = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_netbios_getsetters[] = {
	{ discard_const_p(char, "name"), py_epm_rhs_netbios_get_name, py_epm_rhs_netbios_set_name },
	{ NULL }
};

static PyObject *py_epm_rhs_netbios_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_netbios, type);
}


static PyTypeObject epm_rhs_netbios_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_netbios",
	.tp_getset = py_epm_rhs_netbios_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_netbios_new,
};


static PyObject *py_epm_rhs_netbeui_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_netbeui, type);
}


static PyTypeObject epm_rhs_netbeui_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_netbeui",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_netbeui_new,
};


static PyObject *py_epm_rhs_spx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_spx, type);
}


static PyTypeObject epm_rhs_spx_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_spx",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_spx_new,
};


static PyObject *py_epm_rhs_nb_ipx_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_nb_ipx, type);
}


static PyTypeObject epm_rhs_nb_ipx_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_nb_ipx",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_nb_ipx_new,
};


static PyObject *py_epm_rhs_http_get_port(PyObject *obj, void *closure)
{
	struct epm_rhs_http *object = (struct epm_rhs_http *)py_talloc_get_ptr(obj);
	PyObject *py_port;
	py_port = PyInt_FromLong(object->port);
	return py_port;
}

static int py_epm_rhs_http_set_port(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_http *object = (struct epm_rhs_http *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->port = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_http_getsetters[] = {
	{ discard_const_p(char, "port"), py_epm_rhs_http_get_port, py_epm_rhs_http_set_port },
	{ NULL }
};

static PyObject *py_epm_rhs_http_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_http, type);
}


static PyTypeObject epm_rhs_http_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_http",
	.tp_getset = py_epm_rhs_http_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_http_new,
};


static PyObject *py_epm_rhs_unix_ds_get_path(PyObject *obj, void *closure)
{
	struct epm_rhs_unix_ds *object = (struct epm_rhs_unix_ds *)py_talloc_get_ptr(obj);
	PyObject *py_path;
	py_path = PyString_FromStringOrNULL(object->path);
	return py_path;
}

static int py_epm_rhs_unix_ds_set_path(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_unix_ds *object = (struct epm_rhs_unix_ds *)py_talloc_get_ptr(py_obj);
	object->path = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_unix_ds_getsetters[] = {
	{ discard_const_p(char, "path"), py_epm_rhs_unix_ds_get_path, py_epm_rhs_unix_ds_set_path },
	{ NULL }
};

static PyObject *py_epm_rhs_unix_ds_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_unix_ds, type);
}


static PyTypeObject epm_rhs_unix_ds_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_unix_ds",
	.tp_getset = py_epm_rhs_unix_ds_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_unix_ds_new,
};


static PyObject *py_epm_rhs_null_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_null, type);
}


static PyTypeObject epm_rhs_null_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_null",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_null_new,
};


static PyObject *py_epm_rhs_ncalrpc_get_minor_version(PyObject *obj, void *closure)
{
	struct epm_rhs_ncalrpc *object = (struct epm_rhs_ncalrpc *)py_talloc_get_ptr(obj);
	PyObject *py_minor_version;
	py_minor_version = PyInt_FromLong(object->minor_version);
	return py_minor_version;
}

static int py_epm_rhs_ncalrpc_set_minor_version(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_ncalrpc *object = (struct epm_rhs_ncalrpc *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->minor_version = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_ncalrpc_getsetters[] = {
	{ discard_const_p(char, "minor_version"), py_epm_rhs_ncalrpc_get_minor_version, py_epm_rhs_ncalrpc_set_minor_version },
	{ NULL }
};

static PyObject *py_epm_rhs_ncalrpc_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_ncalrpc, type);
}


static PyTypeObject epm_rhs_ncalrpc_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_ncalrpc",
	.tp_getset = py_epm_rhs_ncalrpc_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_ncalrpc_new,
};


static PyObject *py_epm_rhs_appletalk_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_appletalk, type);
}


static PyTypeObject epm_rhs_appletalk_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_appletalk",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_appletalk_new,
};


static PyObject *py_epm_rhs_atalk_stream_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_atalk_stream, type);
}


static PyTypeObject epm_rhs_atalk_stream_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_atalk_stream",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_atalk_stream_new,
};


static PyObject *py_epm_rhs_atalk_datagram_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_atalk_datagram, type);
}


static PyTypeObject epm_rhs_atalk_datagram_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_atalk_datagram",
	.tp_getset = NULL,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_atalk_datagram_new,
};


static PyObject *py_epm_rhs_vines_spp_get_port(PyObject *obj, void *closure)
{
	struct epm_rhs_vines_spp *object = (struct epm_rhs_vines_spp *)py_talloc_get_ptr(obj);
	PyObject *py_port;
	py_port = PyInt_FromLong(object->port);
	return py_port;
}

static int py_epm_rhs_vines_spp_set_port(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_vines_spp *object = (struct epm_rhs_vines_spp *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->port = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_vines_spp_getsetters[] = {
	{ discard_const_p(char, "port"), py_epm_rhs_vines_spp_get_port, py_epm_rhs_vines_spp_set_port },
	{ NULL }
};

static PyObject *py_epm_rhs_vines_spp_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_vines_spp, type);
}


static PyTypeObject epm_rhs_vines_spp_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_vines_spp",
	.tp_getset = py_epm_rhs_vines_spp_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_vines_spp_new,
};


static PyObject *py_epm_rhs_vines_ipc_get_port(PyObject *obj, void *closure)
{
	struct epm_rhs_vines_ipc *object = (struct epm_rhs_vines_ipc *)py_talloc_get_ptr(obj);
	PyObject *py_port;
	py_port = PyInt_FromLong(object->port);
	return py_port;
}

static int py_epm_rhs_vines_ipc_set_port(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_vines_ipc *object = (struct epm_rhs_vines_ipc *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->port = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_epm_rhs_vines_ipc_getsetters[] = {
	{ discard_const_p(char, "port"), py_epm_rhs_vines_ipc_get_port, py_epm_rhs_vines_ipc_set_port },
	{ NULL }
};

static PyObject *py_epm_rhs_vines_ipc_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_vines_ipc, type);
}


static PyTypeObject epm_rhs_vines_ipc_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_vines_ipc",
	.tp_getset = py_epm_rhs_vines_ipc_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_vines_ipc_new,
};


static PyObject *py_epm_rhs_streettalk_get_streettalk(PyObject *obj, void *closure)
{
	struct epm_rhs_streettalk *object = (struct epm_rhs_streettalk *)py_talloc_get_ptr(obj);
	PyObject *py_streettalk;
	py_streettalk = PyString_FromStringOrNULL(object->streettalk);
	return py_streettalk;
}

static int py_epm_rhs_streettalk_set_streettalk(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_rhs_streettalk *object = (struct epm_rhs_streettalk *)py_talloc_get_ptr(py_obj);
	object->streettalk = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyGetSetDef py_epm_rhs_streettalk_getsetters[] = {
	{ discard_const_p(char, "streettalk"), py_epm_rhs_streettalk_get_streettalk, py_epm_rhs_streettalk_set_streettalk },
	{ NULL }
};

static PyObject *py_epm_rhs_streettalk_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_rhs_streettalk, type);
}


static PyTypeObject epm_rhs_streettalk_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_rhs_streettalk",
	.tp_getset = py_epm_rhs_streettalk_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_rhs_streettalk_new,
};

PyObject *py_import_epm_rhs(TALLOC_CTX *mem_ctx, int level, union epm_rhs *in)
{
	PyObject *ret;

	switch (level) {
		case EPM_PROTOCOL_DNET_NSP:
			ret = py_talloc_reference_ex(&epm_rhs_dnet_nsp_Type, mem_ctx, &in->dnet_nsp);
			return ret;

		case EPM_PROTOCOL_OSI_TP4:
			ret = py_talloc_reference_ex(&epm_rhs_osi_tp4_Type, mem_ctx, &in->osi_tp4);
			return ret;

		case EPM_PROTOCOL_OSI_CLNS:
			ret = py_talloc_reference_ex(&epm_rhs_osi_clns_Type, mem_ctx, &in->osi_clns);
			return ret;

		case EPM_PROTOCOL_TCP:
			ret = py_talloc_reference_ex(&epm_rhs_tcp_Type, mem_ctx, &in->tcp);
			return ret;

		case EPM_PROTOCOL_UDP:
			ret = py_talloc_reference_ex(&epm_rhs_udp_Type, mem_ctx, &in->udp);
			return ret;

		case EPM_PROTOCOL_IP:
			ret = py_talloc_reference_ex(&epm_rhs_ip_Type, mem_ctx, &in->ip);
			return ret;

		case EPM_PROTOCOL_NCADG:
			ret = py_talloc_reference_ex(&epm_rhs_ncadg_Type, mem_ctx, &in->ncadg);
			return ret;

		case EPM_PROTOCOL_NCACN:
			ret = py_talloc_reference_ex(&epm_rhs_ncacn_Type, mem_ctx, &in->ncacn);
			return ret;

		case EPM_PROTOCOL_NCALRPC:
			ret = py_talloc_reference_ex(&epm_rhs_ncalrpc_Type, mem_ctx, &in->ncalrpc);
			return ret;

		case EPM_PROTOCOL_UUID:
			ret = py_talloc_reference_ex(&epm_rhs_uuid_Type, mem_ctx, &in->uuid);
			return ret;

		case EPM_PROTOCOL_IPX:
			ret = py_talloc_reference_ex(&epm_rhs_ipx_Type, mem_ctx, &in->ipx);
			return ret;

		case EPM_PROTOCOL_SMB:
			ret = py_talloc_reference_ex(&epm_rhs_smb_Type, mem_ctx, &in->smb);
			return ret;

		case EPM_PROTOCOL_NAMED_PIPE:
			ret = py_talloc_reference_ex(&epm_rhs_named_pipe_Type, mem_ctx, &in->named_pipe);
			return ret;

		case EPM_PROTOCOL_NETBIOS:
			ret = py_talloc_reference_ex(&epm_rhs_netbios_Type, mem_ctx, &in->netbios);
			return ret;

		case EPM_PROTOCOL_NETBEUI:
			ret = py_talloc_reference_ex(&epm_rhs_netbeui_Type, mem_ctx, &in->netbeui);
			return ret;

		case EPM_PROTOCOL_SPX:
			ret = py_talloc_reference_ex(&epm_rhs_spx_Type, mem_ctx, &in->spx);
			return ret;

		case EPM_PROTOCOL_NB_IPX:
			ret = py_talloc_reference_ex(&epm_rhs_nb_ipx_Type, mem_ctx, &in->nb_ipx);
			return ret;

		case EPM_PROTOCOL_DSP:
			ret = py_talloc_reference_ex(&epm_rhs_atalk_stream_Type, mem_ctx, &in->atalk_stream);
			return ret;

		case EPM_PROTOCOL_DDP:
			ret = py_talloc_reference_ex(&epm_rhs_atalk_datagram_Type, mem_ctx, &in->atalk_datagram);
			return ret;

		case EPM_PROTOCOL_APPLETALK:
			ret = py_talloc_reference_ex(&epm_rhs_appletalk_Type, mem_ctx, &in->appletalk);
			return ret;

		case EPM_PROTOCOL_VINES_SPP:
			ret = py_talloc_reference_ex(&epm_rhs_vines_spp_Type, mem_ctx, &in->vines_spp);
			return ret;

		case EPM_PROTOCOL_VINES_IPC:
			ret = py_talloc_reference_ex(&epm_rhs_vines_ipc_Type, mem_ctx, &in->vines_ipc);
			return ret;

		case EPM_PROTOCOL_STREETTALK:
			ret = py_talloc_reference_ex(&epm_rhs_streettalk_Type, mem_ctx, &in->streettalk);
			return ret;

		case EPM_PROTOCOL_HTTP:
			ret = py_talloc_reference_ex(&epm_rhs_http_Type, mem_ctx, &in->http);
			return ret;

		case EPM_PROTOCOL_UNIX_DS:
			ret = py_talloc_reference_ex(&epm_rhs_unix_ds_Type, mem_ctx, &in->unix_ds);
			return ret;

		case EPM_PROTOCOL_NULL:
			ret = py_talloc_reference_ex(&epm_rhs_null_Type, mem_ctx, &in->null);
			return ret;

		default:
			ret = PyString_FromStringAndSize((char *)(in->unknown).data, (in->unknown).length);
			return ret;

	}
	PyErr_SetString(PyExc_TypeError, "unknown union level");
	return NULL;
}

union epm_rhs *py_export_epm_rhs(TALLOC_CTX *mem_ctx, int level, PyObject *in)
{
	union epm_rhs *ret = talloc_zero(mem_ctx, union epm_rhs);
	switch (level) {
		case EPM_PROTOCOL_DNET_NSP:
			PY_CHECK_TYPE(&epm_rhs_dnet_nsp_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->dnet_nsp = *(struct epm_rhs_dnet_nsp *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_OSI_TP4:
			PY_CHECK_TYPE(&epm_rhs_osi_tp4_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->osi_tp4 = *(struct epm_rhs_osi_tp4 *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_OSI_CLNS:
			PY_CHECK_TYPE(&epm_rhs_osi_clns_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->osi_clns = *(struct epm_rhs_osi_clns *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_TCP:
			PY_CHECK_TYPE(&epm_rhs_tcp_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->tcp = *(struct epm_rhs_tcp *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_UDP:
			PY_CHECK_TYPE(&epm_rhs_udp_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->udp = *(struct epm_rhs_udp *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_IP:
			PY_CHECK_TYPE(&epm_rhs_ip_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->ip = *(struct epm_rhs_ip *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NCADG:
			PY_CHECK_TYPE(&epm_rhs_ncadg_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->ncadg = *(struct epm_rhs_ncadg *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NCACN:
			PY_CHECK_TYPE(&epm_rhs_ncacn_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->ncacn = *(struct epm_rhs_ncacn *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NCALRPC:
			PY_CHECK_TYPE(&epm_rhs_ncalrpc_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->ncalrpc = *(struct epm_rhs_ncalrpc *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_UUID:
			PY_CHECK_TYPE(&epm_rhs_uuid_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->uuid = *(struct epm_rhs_uuid *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_IPX:
			PY_CHECK_TYPE(&epm_rhs_ipx_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->ipx = *(struct epm_rhs_ipx *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_SMB:
			PY_CHECK_TYPE(&epm_rhs_smb_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->smb = *(struct epm_rhs_smb *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NAMED_PIPE:
			PY_CHECK_TYPE(&epm_rhs_named_pipe_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->named_pipe = *(struct epm_rhs_named_pipe *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NETBIOS:
			PY_CHECK_TYPE(&epm_rhs_netbios_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->netbios = *(struct epm_rhs_netbios *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NETBEUI:
			PY_CHECK_TYPE(&epm_rhs_netbeui_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->netbeui = *(struct epm_rhs_netbeui *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_SPX:
			PY_CHECK_TYPE(&epm_rhs_spx_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->spx = *(struct epm_rhs_spx *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NB_IPX:
			PY_CHECK_TYPE(&epm_rhs_nb_ipx_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->nb_ipx = *(struct epm_rhs_nb_ipx *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_DSP:
			PY_CHECK_TYPE(&epm_rhs_atalk_stream_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->atalk_stream = *(struct epm_rhs_atalk_stream *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_DDP:
			PY_CHECK_TYPE(&epm_rhs_atalk_datagram_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->atalk_datagram = *(struct epm_rhs_atalk_datagram *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_APPLETALK:
			PY_CHECK_TYPE(&epm_rhs_appletalk_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->appletalk = *(struct epm_rhs_appletalk *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_VINES_SPP:
			PY_CHECK_TYPE(&epm_rhs_vines_spp_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->vines_spp = *(struct epm_rhs_vines_spp *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_VINES_IPC:
			PY_CHECK_TYPE(&epm_rhs_vines_ipc_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->vines_ipc = *(struct epm_rhs_vines_ipc *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_STREETTALK:
			PY_CHECK_TYPE(&epm_rhs_streettalk_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->streettalk = *(struct epm_rhs_streettalk *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_HTTP:
			PY_CHECK_TYPE(&epm_rhs_http_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->http = *(struct epm_rhs_http *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_UNIX_DS:
			PY_CHECK_TYPE(&epm_rhs_unix_ds_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->unix_ds = *(struct epm_rhs_unix_ds *)py_talloc_get_ptr(in);
			break;

		case EPM_PROTOCOL_NULL:
			PY_CHECK_TYPE(&epm_rhs_null_Type, in, talloc_free(ret); return NULL;);
			if (talloc_reference(mem_ctx, py_talloc_get_mem_ctx(in)) == NULL) {
				PyErr_NoMemory();
				talloc_free(ret); return NULL;
			}
			ret->null = *(struct epm_rhs_null *)py_talloc_get_ptr(in);
			break;

		default:
			ret->unknown = data_blob_talloc(mem_ctx, PyString_AS_STRING(in), PyString_GET_SIZE(in));
			break;

	}

	return ret;
}


static PyObject *py_epm_lhs_get_protocol(PyObject *obj, void *closure)
{
	struct epm_lhs *object = (struct epm_lhs *)py_talloc_get_ptr(obj);
	PyObject *py_protocol;
	py_protocol = PyInt_FromLong(object->protocol);
	return py_protocol;
}

static int py_epm_lhs_set_protocol(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_lhs *object = (struct epm_lhs *)py_talloc_get_ptr(py_obj);
	if (PyLong_Check(value)) {
		object->protocol = PyLong_AsLongLong(value);
	} else if (PyInt_Check(value)) {
		object->protocol = PyInt_AsLong(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
		  PyInt_Type.tp_name, PyLong_Type.tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_epm_lhs_get_lhs_data(PyObject *obj, void *closure)
{
	struct epm_lhs *object = (struct epm_lhs *)py_talloc_get_ptr(obj);
	PyObject *py_lhs_data;
	py_lhs_data = PyString_FromStringAndSize((char *)(object->lhs_data).data, (object->lhs_data).length);
	return py_lhs_data;
}

static int py_epm_lhs_set_lhs_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_lhs *object = (struct epm_lhs *)py_talloc_get_ptr(py_obj);
	object->lhs_data = data_blob_talloc(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value), PyString_GET_SIZE(value));
	return 0;
}

static PyGetSetDef py_epm_lhs_getsetters[] = {
	{ discard_const_p(char, "protocol"), py_epm_lhs_get_protocol, py_epm_lhs_set_protocol },
	{ discard_const_p(char, "lhs_data"), py_epm_lhs_get_lhs_data, py_epm_lhs_set_lhs_data },
	{ NULL }
};

static PyObject *py_epm_lhs_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_lhs, type);
}


static PyTypeObject epm_lhs_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_lhs",
	.tp_getset = py_epm_lhs_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_lhs_new,
};


static PyObject *py_epm_floor_get_lhs(PyObject *obj, void *closure)
{
	struct epm_floor *object = (struct epm_floor *)py_talloc_get_ptr(obj);
	PyObject *py_lhs;
	py_lhs = py_talloc_reference_ex(&epm_lhs_Type, py_talloc_get_mem_ctx(obj), &object->lhs);
	return py_lhs;
}

static int py_epm_floor_set_lhs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_floor *object = (struct epm_floor *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&epm_lhs_Type, value, return -1;);
	if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->lhs = *(struct epm_lhs *)py_talloc_get_ptr(value);
	return 0;
}

static PyObject *py_epm_floor_get_rhs(PyObject *obj, void *closure)
{
	struct epm_floor *object = (struct epm_floor *)py_talloc_get_ptr(obj);
	PyObject *py_rhs;
	py_rhs = py_import_epm_rhs(py_talloc_get_mem_ctx(obj), object->lhs.protocol, &object->rhs);
	if (py_rhs == NULL) {
		return NULL;
	}
	return py_rhs;
}

static int py_epm_floor_set_rhs(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_floor *object = (struct epm_floor *)py_talloc_get_ptr(py_obj);
	{
		union epm_rhs *rhs_switch_1;
		rhs_switch_1 = py_export_epm_rhs(py_talloc_get_mem_ctx(py_obj), object->lhs.protocol, value);
		if (rhs_switch_1 == NULL) {
			return -1;
		}
		object->rhs = *rhs_switch_1;
	}
	return 0;
}

static PyGetSetDef py_epm_floor_getsetters[] = {
	{ discard_const_p(char, "lhs"), py_epm_floor_get_lhs, py_epm_floor_set_lhs },
	{ discard_const_p(char, "rhs"), py_epm_floor_get_rhs, py_epm_floor_set_rhs },
	{ NULL }
};

static PyObject *py_epm_floor_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_floor, type);
}


static PyTypeObject epm_floor_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_floor",
	.tp_getset = py_epm_floor_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_floor_new,
};


static PyObject *py_epm_tower_get_num_floors(PyObject *obj, void *closure)
{
	struct epm_tower *object = (struct epm_tower *)py_talloc_get_ptr(obj);
	PyObject *py_num_floors;
	py_num_floors = PyInt_FromLong(object->num_floors);
	return py_num_floors;
}

static int py_epm_tower_set_num_floors(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_tower *object = (struct epm_tower *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->num_floors = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_epm_tower_get_floors(PyObject *obj, void *closure)
{
	struct epm_tower *object = (struct epm_tower *)py_talloc_get_ptr(obj);
	PyObject *py_floors;
	py_floors = PyList_New(object->num_floors);
	if (py_floors == NULL) {
		return NULL;
	}
	{
		int floors_cntr_0;
		for (floors_cntr_0 = 0; floors_cntr_0 < object->num_floors; floors_cntr_0++) {
			PyObject *py_floors_0;
			py_floors_0 = py_talloc_reference_ex(&epm_floor_Type, object->floors, &object->floors[floors_cntr_0]);
			PyList_SetItem(py_floors, floors_cntr_0, py_floors_0);
		}
	}
	return py_floors;
}

static int py_epm_tower_set_floors(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_tower *object = (struct epm_tower *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int floors_cntr_0;
		object->floors = talloc_array_ptrtype(py_talloc_get_mem_ctx(py_obj), object->floors, PyList_GET_SIZE(value));
		if (!object->floors) { return -1;; }
		talloc_set_name_const(object->floors, "ARRAY: object->floors");
		for (floors_cntr_0 = 0; floors_cntr_0 < PyList_GET_SIZE(value); floors_cntr_0++) {
			PY_CHECK_TYPE(&epm_floor_Type, PyList_GET_ITEM(value, floors_cntr_0), return -1;);
			if (talloc_reference(object->floors, py_talloc_get_mem_ctx(PyList_GET_ITEM(value, floors_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->floors[floors_cntr_0] = *(struct epm_floor *)py_talloc_get_ptr(PyList_GET_ITEM(value, floors_cntr_0));
		}
	}
	return 0;
}

static PyGetSetDef py_epm_tower_getsetters[] = {
	{ discard_const_p(char, "num_floors"), py_epm_tower_get_num_floors, py_epm_tower_set_num_floors },
	{ discard_const_p(char, "floors"), py_epm_tower_get_floors, py_epm_tower_set_floors },
	{ NULL }
};

static PyObject *py_epm_tower_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_tower, type);
}


static PyTypeObject epm_tower_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_tower",
	.tp_getset = py_epm_tower_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_tower_new,
};


static PyObject *py_epm_twr_t_get_tower_length(PyObject *obj, void *closure)
{
	struct epm_twr_t *object = (struct epm_twr_t *)py_talloc_get_ptr(obj);
	PyObject *py_tower_length;
	py_tower_length = PyInt_FromLong(object->tower_length);
	return py_tower_length;
}

static int py_epm_twr_t_set_tower_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_twr_t *object = (struct epm_twr_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->tower_length = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_epm_twr_t_get_tower(PyObject *obj, void *closure)
{
	struct epm_twr_t *object = (struct epm_twr_t *)py_talloc_get_ptr(obj);
	PyObject *py_tower;
	py_tower = py_talloc_reference_ex(&epm_tower_Type, py_talloc_get_mem_ctx(obj), &object->tower);
	return py_tower;
}

static int py_epm_twr_t_set_tower(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_twr_t *object = (struct epm_twr_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&epm_tower_Type, value, return -1;);
	if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->tower = *(struct epm_tower *)py_talloc_get_ptr(value);
	return 0;
}

static PyGetSetDef py_epm_twr_t_getsetters[] = {
	{ discard_const_p(char, "tower_length"), py_epm_twr_t_get_tower_length, py_epm_twr_t_set_tower_length },
	{ discard_const_p(char, "tower"), py_epm_twr_t_get_tower, py_epm_twr_t_set_tower },
	{ NULL }
};

static PyObject *py_epm_twr_t_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_twr_t, type);
}


static PyTypeObject epm_twr_t_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_twr_t",
	.tp_getset = py_epm_twr_t_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_twr_t_new,
};


static PyObject *py_epm_entry_t_get_object(PyObject *obj, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(obj);
	PyObject *py_object;
	py_object = py_talloc_reference_ex(GUID_Type, py_talloc_get_mem_ctx(obj), &object->object);
	return py_object;
}

static int py_epm_entry_t_set_object(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->object = *(struct GUID *)py_talloc_get_ptr(value);
	return 0;
}

static PyObject *py_epm_entry_t_get_tower(PyObject *obj, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(obj);
	PyObject *py_tower;
	if (object->tower == NULL) {
		py_tower = Py_None;
		Py_INCREF(py_tower);
	} else {
		py_tower = py_talloc_reference_ex(&epm_twr_t_Type, object->tower, object->tower);
	}
	return py_tower;
}

static int py_epm_entry_t_set_tower(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(py_obj);
	talloc_unlink(py_talloc_get_mem_ctx(py_obj), object->tower);
	if (value == Py_None) {
		object->tower = NULL;
	} else {
		object->tower = NULL;
		PY_CHECK_TYPE(&epm_twr_t_Type, value, return -1;);
		if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->tower = (struct epm_twr_t *)py_talloc_get_ptr(value);
	}
	return 0;
}

static PyObject *py_epm_entry_t_get___annotation_offset(PyObject *obj, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(obj);
	PyObject *py___annotation_offset;
	py___annotation_offset = PyInt_FromLong(object->__annotation_offset);
	return py___annotation_offset;
}

static int py_epm_entry_t_set___annotation_offset(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->__annotation_offset = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_epm_entry_t_get___annotation_length(PyObject *obj, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(obj);
	PyObject *py___annotation_length;
	py___annotation_length = PyInt_FromLong(object->__annotation_length);
	return py___annotation_length;
}

static int py_epm_entry_t_set___annotation_length(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->__annotation_length = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_epm_entry_t_get_annotation(PyObject *obj, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(obj);
	PyObject *py_annotation;
	if (object->annotation == NULL) {
		py_annotation = Py_None;
		Py_INCREF(py_annotation);
	} else {
		py_annotation = PyUnicode_Decode(object->annotation, strlen(object->annotation), "utf-8", "ignore");
	}
	return py_annotation;
}

static int py_epm_entry_t_set_annotation(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_entry_t *object = (struct epm_entry_t *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->annotation = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->annotation = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyGetSetDef py_epm_entry_t_getsetters[] = {
	{ discard_const_p(char, "object"), py_epm_entry_t_get_object, py_epm_entry_t_set_object },
	{ discard_const_p(char, "tower"), py_epm_entry_t_get_tower, py_epm_entry_t_set_tower },
	{ discard_const_p(char, "__annotation_offset"), py_epm_entry_t_get___annotation_offset, py_epm_entry_t_set___annotation_offset },
	{ discard_const_p(char, "__annotation_length"), py_epm_entry_t_get___annotation_length, py_epm_entry_t_set___annotation_length },
	{ discard_const_p(char, "annotation"), py_epm_entry_t_get_annotation, py_epm_entry_t_set_annotation },
	{ NULL }
};

static PyObject *py_epm_entry_t_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_entry_t, type);
}


static PyTypeObject epm_entry_t_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_entry_t",
	.tp_getset = py_epm_entry_t_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_entry_t_new,
};


static PyObject *py_rpc_if_id_t_get_uuid(PyObject *obj, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(obj);
	PyObject *py_uuid;
	py_uuid = py_talloc_reference_ex(GUID_Type, py_talloc_get_mem_ctx(obj), &object->uuid);
	return py_uuid;
}

static int py_rpc_if_id_t_set_uuid(PyObject *py_obj, PyObject *value, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(GUID_Type, value, return -1;);
	if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->uuid = *(struct GUID *)py_talloc_get_ptr(value);
	return 0;
}

static PyObject *py_rpc_if_id_t_get_vers_major(PyObject *obj, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(obj);
	PyObject *py_vers_major;
	py_vers_major = PyInt_FromLong(object->vers_major);
	return py_vers_major;
}

static int py_rpc_if_id_t_set_vers_major(PyObject *py_obj, PyObject *value, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->vers_major = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_rpc_if_id_t_get_vers_minor(PyObject *obj, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(obj);
	PyObject *py_vers_minor;
	py_vers_minor = PyInt_FromLong(object->vers_minor);
	return py_vers_minor;
}

static int py_rpc_if_id_t_set_vers_minor(PyObject *py_obj, PyObject *value, void *closure)
{
	struct rpc_if_id_t *object = (struct rpc_if_id_t *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->vers_minor = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_rpc_if_id_t_getsetters[] = {
	{ discard_const_p(char, "uuid"), py_rpc_if_id_t_get_uuid, py_rpc_if_id_t_set_uuid },
	{ discard_const_p(char, "vers_major"), py_rpc_if_id_t_get_vers_major, py_rpc_if_id_t_set_vers_major },
	{ discard_const_p(char, "vers_minor"), py_rpc_if_id_t_get_vers_minor, py_rpc_if_id_t_set_vers_minor },
	{ NULL }
};

static PyObject *py_rpc_if_id_t_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct rpc_if_id_t, type);
}


static PyTypeObject rpc_if_id_t_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.rpc_if_id_t",
	.tp_getset = py_rpc_if_id_t_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_rpc_if_id_t_new,
};


static PyObject *py_epm_twr_p_t_get_twr(PyObject *obj, void *closure)
{
	struct epm_twr_p_t *object = (struct epm_twr_p_t *)py_talloc_get_ptr(obj);
	PyObject *py_twr;
	if (object->twr == NULL) {
		py_twr = Py_None;
		Py_INCREF(py_twr);
	} else {
		py_twr = py_talloc_reference_ex(&epm_twr_t_Type, object->twr, object->twr);
	}
	return py_twr;
}

static int py_epm_twr_p_t_set_twr(PyObject *py_obj, PyObject *value, void *closure)
{
	struct epm_twr_p_t *object = (struct epm_twr_p_t *)py_talloc_get_ptr(py_obj);
	talloc_unlink(py_talloc_get_mem_ctx(py_obj), object->twr);
	if (value == Py_None) {
		object->twr = NULL;
	} else {
		object->twr = NULL;
		PY_CHECK_TYPE(&epm_twr_t_Type, value, return -1;);
		if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
			PyErr_NoMemory();
			return -1;
		}
		object->twr = (struct epm_twr_t *)py_talloc_get_ptr(value);
	}
	return 0;
}

static PyGetSetDef py_epm_twr_p_t_getsetters[] = {
	{ discard_const_p(char, "twr"), py_epm_twr_p_t_get_twr, py_epm_twr_p_t_set_twr },
	{ NULL }
};

static PyObject *py_epm_twr_p_t_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct epm_twr_p_t, type);
}


static PyTypeObject epm_twr_p_t_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epm_twr_p_t",
	.tp_getset = py_epm_twr_p_t_getsetters,
	.tp_methods = NULL,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_epm_twr_p_t_new,
};


static bool pack_py_epm_Insert_args_in(PyObject *args, PyObject *kwargs, struct epm_Insert *r)
{
	PyObject *py_entries;
	PyObject *py_replace;
	const char *kwnames[] = {
		"entries", "replace", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:epm_Insert", discard_const_p(char *, kwnames), &py_entries, &py_replace)) {
		return false;
	}

	PY_CHECK_TYPE(&PyList_Type, py_entries, return false;);
	r->in.num_ents = PyList_GET_SIZE(py_entries);
	PY_CHECK_TYPE(&PyList_Type, py_entries, return false;);
	{
		int entries_cntr_0;
		r->in.entries = talloc_array_ptrtype(r, r->in.entries, PyList_GET_SIZE(py_entries));
		if (!r->in.entries) { return false;; }
		talloc_set_name_const(r->in.entries, "ARRAY: r->in.entries");
		for (entries_cntr_0 = 0; entries_cntr_0 < PyList_GET_SIZE(py_entries); entries_cntr_0++) {
			PY_CHECK_TYPE(&epm_entry_t_Type, PyList_GET_ITEM(py_entries, entries_cntr_0), return false;);
			if (talloc_reference(r->in.entries, py_talloc_get_mem_ctx(PyList_GET_ITEM(py_entries, entries_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.entries[entries_cntr_0] = *(struct epm_entry_t *)py_talloc_get_ptr(PyList_GET_ITEM(py_entries, entries_cntr_0));
		}
	}
	PY_CHECK_TYPE(&PyInt_Type, py_replace, return false;);
	r->in.replace = PyInt_AsLong(py_replace);
	return true;
}

static PyObject *unpack_py_epm_Insert_args_out(struct epm_Insert *r)
{
	PyObject *result;
	result = PyInt_FromLong(r->out.result);
	return result;
}

static bool pack_py_epm_Delete_args_in(PyObject *args, PyObject *kwargs, struct epm_Delete *r)
{
	PyObject *py_entries;
	const char *kwnames[] = {
		"entries", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:epm_Delete", discard_const_p(char *, kwnames), &py_entries)) {
		return false;
	}

	PY_CHECK_TYPE(&PyList_Type, py_entries, return false;);
	r->in.num_ents = PyList_GET_SIZE(py_entries);
	PY_CHECK_TYPE(&PyList_Type, py_entries, return false;);
	{
		int entries_cntr_0;
		r->in.entries = talloc_array_ptrtype(r, r->in.entries, PyList_GET_SIZE(py_entries));
		if (!r->in.entries) { return false;; }
		talloc_set_name_const(r->in.entries, "ARRAY: r->in.entries");
		for (entries_cntr_0 = 0; entries_cntr_0 < PyList_GET_SIZE(py_entries); entries_cntr_0++) {
			PY_CHECK_TYPE(&epm_entry_t_Type, PyList_GET_ITEM(py_entries, entries_cntr_0), return false;);
			if (talloc_reference(r->in.entries, py_talloc_get_mem_ctx(PyList_GET_ITEM(py_entries, entries_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return false;
			}
			r->in.entries[entries_cntr_0] = *(struct epm_entry_t *)py_talloc_get_ptr(PyList_GET_ITEM(py_entries, entries_cntr_0));
		}
	}
	return true;
}

static PyObject *unpack_py_epm_Delete_args_out(struct epm_Delete *r)
{
	PyObject *result;
	result = PyInt_FromLong(r->out.result);
	return result;
}

static bool pack_py_epm_Lookup_args_in(PyObject *args, PyObject *kwargs, struct epm_Lookup *r)
{
	PyObject *py_inquiry_type;
	PyObject *py_object;
	PyObject *py_interface_id;
	PyObject *py_vers_option;
	PyObject *py_entry_handle;
	PyObject *py_max_ents;
	const char *kwnames[] = {
		"inquiry_type", "object", "interface_id", "vers_option", "entry_handle", "max_ents", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOOOO:epm_Lookup", discard_const_p(char *, kwnames), &py_inquiry_type, &py_object, &py_interface_id, &py_vers_option, &py_entry_handle, &py_max_ents)) {
		return false;
	}

	if (PyLong_Check(py_inquiry_type)) {
		r->in.inquiry_type = PyLong_AsLongLong(py_inquiry_type);
	} else if (PyInt_Check(py_inquiry_type)) {
		r->in.inquiry_type = PyInt_AsLong(py_inquiry_type);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
		  PyInt_Type.tp_name, PyLong_Type.tp_name);
		return false;
	}
	if (py_object == Py_None) {
		r->in.object = NULL;
	} else {
		r->in.object = NULL;
		PY_CHECK_TYPE(GUID_Type, py_object, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_object)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.object = (struct GUID *)py_talloc_get_ptr(py_object);
	}
	if (py_interface_id == Py_None) {
		r->in.interface_id = NULL;
	} else {
		r->in.interface_id = NULL;
		PY_CHECK_TYPE(&rpc_if_id_t_Type, py_interface_id, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_interface_id)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.interface_id = (struct rpc_if_id_t *)py_talloc_get_ptr(py_interface_id);
	}
	if (PyLong_Check(py_vers_option)) {
		r->in.vers_option = PyLong_AsLongLong(py_vers_option);
	} else if (PyInt_Check(py_vers_option)) {
		r->in.vers_option = PyInt_AsLong(py_vers_option);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
		  PyInt_Type.tp_name, PyLong_Type.tp_name);
		return false;
	}
	r->in.entry_handle = talloc_ptrtype(r, r->in.entry_handle);
	PY_CHECK_TYPE(policy_handle_Type, py_entry_handle, return false;);
	if (talloc_reference(r, py_talloc_get_mem_ctx(py_entry_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.entry_handle = (struct policy_handle *)py_talloc_get_ptr(py_entry_handle);
	PY_CHECK_TYPE(&PyInt_Type, py_max_ents, return false;);
	r->in.max_ents = PyInt_AsLong(py_max_ents);
	return true;
}

static PyObject *unpack_py_epm_Lookup_args_out(struct epm_Lookup *r)
{
	PyObject *result;
	PyObject *py_entry_handle;
	PyObject *py_entries;
	result = PyTuple_New(3);
	py_entry_handle = py_talloc_reference_ex(policy_handle_Type, r->out.entry_handle, r->out.entry_handle);
	PyTuple_SetItem(result, 0, py_entry_handle);
	py_entries = PyList_New(*r->out.num_ents);
	if (py_entries == NULL) {
		return NULL;
	}
	{
		int entries_cntr_0;
		for (entries_cntr_0 = 0; entries_cntr_0 < *r->out.num_ents; entries_cntr_0++) {
			PyObject *py_entries_0;
			py_entries_0 = py_talloc_reference_ex(&epm_entry_t_Type, r->out.entries, &r->out.entries[entries_cntr_0]);
			PyList_SetItem(py_entries, entries_cntr_0, py_entries_0);
		}
	}
	PyTuple_SetItem(result, 1, py_entries);
	PyTuple_SetItem(result, 2, PyInt_FromLong(r->out.result));
	return result;
}

static bool pack_py_epm_Map_args_in(PyObject *args, PyObject *kwargs, struct epm_Map *r)
{
	PyObject *py_object;
	PyObject *py_map_tower;
	PyObject *py_entry_handle;
	PyObject *py_max_towers;
	const char *kwnames[] = {
		"object", "map_tower", "entry_handle", "max_towers", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOOO:epm_Map", discard_const_p(char *, kwnames), &py_object, &py_map_tower, &py_entry_handle, &py_max_towers)) {
		return false;
	}

	if (py_object == Py_None) {
		r->in.object = NULL;
	} else {
		r->in.object = NULL;
		PY_CHECK_TYPE(GUID_Type, py_object, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_object)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.object = (struct GUID *)py_talloc_get_ptr(py_object);
	}
	if (py_map_tower == Py_None) {
		r->in.map_tower = NULL;
	} else {
		r->in.map_tower = NULL;
		PY_CHECK_TYPE(&epm_twr_t_Type, py_map_tower, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_map_tower)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.map_tower = (struct epm_twr_t *)py_talloc_get_ptr(py_map_tower);
	}
	r->in.entry_handle = talloc_ptrtype(r, r->in.entry_handle);
	PY_CHECK_TYPE(policy_handle_Type, py_entry_handle, return false;);
	if (talloc_reference(r, py_talloc_get_mem_ctx(py_entry_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.entry_handle = (struct policy_handle *)py_talloc_get_ptr(py_entry_handle);
	PY_CHECK_TYPE(&PyInt_Type, py_max_towers, return false;);
	r->in.max_towers = PyInt_AsLong(py_max_towers);
	return true;
}

static PyObject *unpack_py_epm_Map_args_out(struct epm_Map *r)
{
	PyObject *result;
	PyObject *py_entry_handle;
	PyObject *py_towers;
	result = PyTuple_New(3);
	py_entry_handle = py_talloc_reference_ex(policy_handle_Type, r->out.entry_handle, r->out.entry_handle);
	PyTuple_SetItem(result, 0, py_entry_handle);
	py_towers = PyList_New(*r->out.num_towers);
	if (py_towers == NULL) {
		return NULL;
	}
	{
		int towers_cntr_0;
		for (towers_cntr_0 = 0; towers_cntr_0 < *r->out.num_towers; towers_cntr_0++) {
			PyObject *py_towers_0;
			py_towers_0 = py_talloc_reference_ex(&epm_twr_p_t_Type, r->out.towers, &r->out.towers[towers_cntr_0]);
			PyList_SetItem(py_towers, towers_cntr_0, py_towers_0);
		}
	}
	PyTuple_SetItem(result, 1, py_towers);
	PyTuple_SetItem(result, 2, PyInt_FromLong(r->out.result));
	return result;
}

static bool pack_py_epm_LookupHandleFree_args_in(PyObject *args, PyObject *kwargs, struct epm_LookupHandleFree *r)
{
	PyObject *py_entry_handle;
	const char *kwnames[] = {
		"entry_handle", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:epm_LookupHandleFree", discard_const_p(char *, kwnames), &py_entry_handle)) {
		return false;
	}

	r->in.entry_handle = talloc_ptrtype(r, r->in.entry_handle);
	PY_CHECK_TYPE(policy_handle_Type, py_entry_handle, return false;);
	if (talloc_reference(r, py_talloc_get_mem_ctx(py_entry_handle)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.entry_handle = (struct policy_handle *)py_talloc_get_ptr(py_entry_handle);
	return true;
}

static PyObject *unpack_py_epm_LookupHandleFree_args_out(struct epm_LookupHandleFree *r)
{
	PyObject *result;
	PyObject *py_entry_handle;
	result = PyTuple_New(2);
	py_entry_handle = py_talloc_reference_ex(policy_handle_Type, r->out.entry_handle, r->out.entry_handle);
	PyTuple_SetItem(result, 0, py_entry_handle);
	PyTuple_SetItem(result, 1, PyInt_FromLong(r->out.result));
	return result;
}

static bool pack_py_epm_InqObject_args_in(PyObject *args, PyObject *kwargs, struct epm_InqObject *r)
{
	PyObject *py_epm_object;
	const char *kwnames[] = {
		"epm_object", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:epm_InqObject", discard_const_p(char *, kwnames), &py_epm_object)) {
		return false;
	}

	r->in.epm_object = talloc_ptrtype(r, r->in.epm_object);
	PY_CHECK_TYPE(GUID_Type, py_epm_object, return false;);
	if (talloc_reference(r, py_talloc_get_mem_ctx(py_epm_object)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.epm_object = (struct GUID *)py_talloc_get_ptr(py_epm_object);
	return true;
}

static PyObject *unpack_py_epm_InqObject_args_out(struct epm_InqObject *r)
{
	PyObject *result;
	result = PyInt_FromLong(r->out.result);
	return result;
}

static bool pack_py_epm_MgmtDelete_args_in(PyObject *args, PyObject *kwargs, struct epm_MgmtDelete *r)
{
	PyObject *py_object_speced;
	PyObject *py_object;
	PyObject *py_tower;
	const char *kwnames[] = {
		"object_speced", "object", "tower", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOO:epm_MgmtDelete", discard_const_p(char *, kwnames), &py_object_speced, &py_object, &py_tower)) {
		return false;
	}

	PY_CHECK_TYPE(&PyInt_Type, py_object_speced, return false;);
	r->in.object_speced = PyInt_AsLong(py_object_speced);
	if (py_object == Py_None) {
		r->in.object = NULL;
	} else {
		r->in.object = NULL;
		PY_CHECK_TYPE(GUID_Type, py_object, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_object)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.object = (struct GUID *)py_talloc_get_ptr(py_object);
	}
	if (py_tower == Py_None) {
		r->in.tower = NULL;
	} else {
		r->in.tower = NULL;
		PY_CHECK_TYPE(&epm_twr_t_Type, py_tower, return false;);
		if (talloc_reference(r, py_talloc_get_mem_ctx(py_tower)) == NULL) {
			PyErr_NoMemory();
			return false;
		}
		r->in.tower = (struct epm_twr_t *)py_talloc_get_ptr(py_tower);
	}
	return true;
}

static PyObject *unpack_py_epm_MgmtDelete_args_out(struct epm_MgmtDelete *r)
{
	PyObject *result;
	result = PyInt_FromLong(r->out.result);
	return result;
}

const struct PyNdrRpcMethodDef py_ndr_epmapper_methods[] = {
	{ "epm_Insert", "S.epm_Insert(entries, replace) -> result", (py_dcerpc_call_fn)dcerpc_epm_Insert_r, (py_data_pack_fn)pack_py_epm_Insert_args_in, (py_data_unpack_fn)unpack_py_epm_Insert_args_out, 0, &ndr_table_epmapper },
	{ "epm_Delete", "S.epm_Delete(entries) -> result", (py_dcerpc_call_fn)dcerpc_epm_Delete_r, (py_data_pack_fn)pack_py_epm_Delete_args_in, (py_data_unpack_fn)unpack_py_epm_Delete_args_out, 1, &ndr_table_epmapper },
	{ "epm_Lookup", "S.epm_Lookup(inquiry_type, object, interface_id, vers_option, entry_handle, max_ents) -> (entry_handle, entries, result)", (py_dcerpc_call_fn)dcerpc_epm_Lookup_r, (py_data_pack_fn)pack_py_epm_Lookup_args_in, (py_data_unpack_fn)unpack_py_epm_Lookup_args_out, 2, &ndr_table_epmapper },
	{ "epm_Map", "S.epm_Map(object, map_tower, entry_handle, max_towers) -> (entry_handle, towers, result)", (py_dcerpc_call_fn)dcerpc_epm_Map_r, (py_data_pack_fn)pack_py_epm_Map_args_in, (py_data_unpack_fn)unpack_py_epm_Map_args_out, 3, &ndr_table_epmapper },
	{ "epm_LookupHandleFree", "S.epm_LookupHandleFree(entry_handle) -> (entry_handle, result)", (py_dcerpc_call_fn)dcerpc_epm_LookupHandleFree_r, (py_data_pack_fn)pack_py_epm_LookupHandleFree_args_in, (py_data_unpack_fn)unpack_py_epm_LookupHandleFree_args_out, 4, &ndr_table_epmapper },
	{ "epm_InqObject", "S.epm_InqObject(epm_object) -> result", (py_dcerpc_call_fn)dcerpc_epm_InqObject_r, (py_data_pack_fn)pack_py_epm_InqObject_args_in, (py_data_unpack_fn)unpack_py_epm_InqObject_args_out, 5, &ndr_table_epmapper },
	{ "epm_MgmtDelete", "S.epm_MgmtDelete(object_speced, object, tower) -> result", (py_dcerpc_call_fn)dcerpc_epm_MgmtDelete_r, (py_data_pack_fn)pack_py_epm_MgmtDelete_args_in, (py_data_unpack_fn)unpack_py_epm_MgmtDelete_args_out, 6, &ndr_table_epmapper },
	{ NULL }
};

static PyObject *interface_epmapper_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_interface_init_helper(type, args, kwargs, &ndr_table_epmapper);
}

#define PY_DOC_EPMAPPER "EndPoint Mapper"
static PyTypeObject epmapper_InterfaceType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "epmapper.epmapper",
	.tp_basicsize = sizeof(dcerpc_InterfaceObject),
	.tp_doc = "epmapper(binding, lp_ctx=None, credentials=None) -> connection\n"
"\n"
"binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)\n"
"lp_ctx should be a path to a smb.conf file or a param.LoadParm object\n"
"credentials should be a credentials.Credentials object.\n\n"PY_DOC_EPMAPPER,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = interface_epmapper_new,
};

static PyMethodDef epmapper_methods[] = {
	{ NULL, NULL, 0, NULL }
};

void initepmapper(void)
{
	PyObject *m;
	PyObject *dep_talloc;
	PyObject *dep_samba_dcerpc_base;
	PyObject *dep_samba_dcerpc_misc;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return;

	GUID_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "GUID");
	if (GUID_Type == NULL)
		return;

	policy_handle_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_misc, "policy_handle");
	if (policy_handle_Type == NULL)
		return;

	Object_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "Object");
	if (Object_Type == NULL)
		return;

	epm_rhs_dnet_nsp_Type.tp_base = Object_Type;

	epm_rhs_osi_tp4_Type.tp_base = Object_Type;

	epm_rhs_osi_clns_Type.tp_base = Object_Type;

	epm_rhs_udp_Type.tp_base = Object_Type;

	epm_rhs_tcp_Type.tp_base = Object_Type;

	epm_rhs_ip_Type.tp_base = Object_Type;

	epm_rhs_ncadg_Type.tp_base = Object_Type;

	epm_rhs_ncacn_Type.tp_base = Object_Type;

	epm_rhs_uuid_Type.tp_base = Object_Type;

	epm_rhs_ipx_Type.tp_base = Object_Type;

	epm_rhs_smb_Type.tp_base = Object_Type;

	epm_rhs_named_pipe_Type.tp_base = Object_Type;

	epm_rhs_netbios_Type.tp_base = Object_Type;

	epm_rhs_netbeui_Type.tp_base = Object_Type;

	epm_rhs_spx_Type.tp_base = Object_Type;

	epm_rhs_nb_ipx_Type.tp_base = Object_Type;

	epm_rhs_http_Type.tp_base = Object_Type;

	epm_rhs_unix_ds_Type.tp_base = Object_Type;

	epm_rhs_null_Type.tp_base = Object_Type;

	epm_rhs_ncalrpc_Type.tp_base = Object_Type;

	epm_rhs_appletalk_Type.tp_base = Object_Type;

	epm_rhs_atalk_stream_Type.tp_base = Object_Type;

	epm_rhs_atalk_datagram_Type.tp_base = Object_Type;

	epm_rhs_vines_spp_Type.tp_base = Object_Type;

	epm_rhs_vines_ipc_Type.tp_base = Object_Type;

	epm_rhs_streettalk_Type.tp_base = Object_Type;

	epm_lhs_Type.tp_base = Object_Type;

	epm_floor_Type.tp_base = Object_Type;

	epm_tower_Type.tp_base = Object_Type;

	epm_twr_t_Type.tp_base = Object_Type;

	epm_entry_t_Type.tp_base = Object_Type;

	rpc_if_id_t_Type.tp_base = Object_Type;

	epm_twr_p_t_Type.tp_base = Object_Type;

	epmapper_InterfaceType.tp_base = ClientConnection_Type;

	if (PyType_Ready(&epm_rhs_dnet_nsp_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_osi_tp4_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_osi_clns_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_udp_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_tcp_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_ip_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_ncadg_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_ncacn_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_uuid_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_ipx_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_smb_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_named_pipe_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_netbios_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_netbeui_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_spx_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_nb_ipx_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_http_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_unix_ds_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_null_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_ncalrpc_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_appletalk_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_atalk_stream_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_atalk_datagram_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_vines_spp_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_vines_ipc_Type) < 0)
		return;
	if (PyType_Ready(&epm_rhs_streettalk_Type) < 0)
		return;
	if (PyType_Ready(&epm_lhs_Type) < 0)
		return;
	if (PyType_Ready(&epm_floor_Type) < 0)
		return;
	if (PyType_Ready(&epm_tower_Type) < 0)
		return;
	if (PyType_Ready(&epm_twr_t_Type) < 0)
		return;
	if (PyType_Ready(&epm_entry_t_Type) < 0)
		return;
	if (PyType_Ready(&rpc_if_id_t_Type) < 0)
		return;
	if (PyType_Ready(&epm_twr_p_t_Type) < 0)
		return;
	if (PyType_Ready(&epmapper_InterfaceType) < 0)
		return;
	if (!PyInterface_AddNdrRpcMethods(&epmapper_InterfaceType, py_ndr_epmapper_methods))
		return;

#ifdef PY_EPM_RHS_DNET_NSP_PATCH
	PY_EPM_RHS_DNET_NSP_PATCH(&epm_rhs_dnet_nsp_Type);
#endif
#ifdef PY_EPM_RHS_OSI_TP4_PATCH
	PY_EPM_RHS_OSI_TP4_PATCH(&epm_rhs_osi_tp4_Type);
#endif
#ifdef PY_EPM_RHS_OSI_CLNS_PATCH
	PY_EPM_RHS_OSI_CLNS_PATCH(&epm_rhs_osi_clns_Type);
#endif
#ifdef PY_EPM_RHS_UDP_PATCH
	PY_EPM_RHS_UDP_PATCH(&epm_rhs_udp_Type);
#endif
#ifdef PY_EPM_RHS_TCP_PATCH
	PY_EPM_RHS_TCP_PATCH(&epm_rhs_tcp_Type);
#endif
#ifdef PY_EPM_RHS_IP_PATCH
	PY_EPM_RHS_IP_PATCH(&epm_rhs_ip_Type);
#endif
#ifdef PY_EPM_RHS_NCADG_PATCH
	PY_EPM_RHS_NCADG_PATCH(&epm_rhs_ncadg_Type);
#endif
#ifdef PY_EPM_RHS_NCACN_PATCH
	PY_EPM_RHS_NCACN_PATCH(&epm_rhs_ncacn_Type);
#endif
#ifdef PY_EPM_RHS_UUID_PATCH
	PY_EPM_RHS_UUID_PATCH(&epm_rhs_uuid_Type);
#endif
#ifdef PY_EPM_RHS_IPX_PATCH
	PY_EPM_RHS_IPX_PATCH(&epm_rhs_ipx_Type);
#endif
#ifdef PY_EPM_RHS_SMB_PATCH
	PY_EPM_RHS_SMB_PATCH(&epm_rhs_smb_Type);
#endif
#ifdef PY_EPM_RHS_NAMED_PIPE_PATCH
	PY_EPM_RHS_NAMED_PIPE_PATCH(&epm_rhs_named_pipe_Type);
#endif
#ifdef PY_EPM_RHS_NETBIOS_PATCH
	PY_EPM_RHS_NETBIOS_PATCH(&epm_rhs_netbios_Type);
#endif
#ifdef PY_EPM_RHS_NETBEUI_PATCH
	PY_EPM_RHS_NETBEUI_PATCH(&epm_rhs_netbeui_Type);
#endif
#ifdef PY_EPM_RHS_SPX_PATCH
	PY_EPM_RHS_SPX_PATCH(&epm_rhs_spx_Type);
#endif
#ifdef PY_EPM_RHS_NB_IPX_PATCH
	PY_EPM_RHS_NB_IPX_PATCH(&epm_rhs_nb_ipx_Type);
#endif
#ifdef PY_EPM_RHS_HTTP_PATCH
	PY_EPM_RHS_HTTP_PATCH(&epm_rhs_http_Type);
#endif
#ifdef PY_EPM_RHS_UNIX_DS_PATCH
	PY_EPM_RHS_UNIX_DS_PATCH(&epm_rhs_unix_ds_Type);
#endif
#ifdef PY_EPM_RHS_NULL_PATCH
	PY_EPM_RHS_NULL_PATCH(&epm_rhs_null_Type);
#endif
#ifdef PY_EPM_RHS_NCALRPC_PATCH
	PY_EPM_RHS_NCALRPC_PATCH(&epm_rhs_ncalrpc_Type);
#endif
#ifdef PY_EPM_RHS_APPLETALK_PATCH
	PY_EPM_RHS_APPLETALK_PATCH(&epm_rhs_appletalk_Type);
#endif
#ifdef PY_EPM_RHS_ATALK_STREAM_PATCH
	PY_EPM_RHS_ATALK_STREAM_PATCH(&epm_rhs_atalk_stream_Type);
#endif
#ifdef PY_EPM_RHS_ATALK_DATAGRAM_PATCH
	PY_EPM_RHS_ATALK_DATAGRAM_PATCH(&epm_rhs_atalk_datagram_Type);
#endif
#ifdef PY_EPM_RHS_VINES_SPP_PATCH
	PY_EPM_RHS_VINES_SPP_PATCH(&epm_rhs_vines_spp_Type);
#endif
#ifdef PY_EPM_RHS_VINES_IPC_PATCH
	PY_EPM_RHS_VINES_IPC_PATCH(&epm_rhs_vines_ipc_Type);
#endif
#ifdef PY_EPM_RHS_STREETTALK_PATCH
	PY_EPM_RHS_STREETTALK_PATCH(&epm_rhs_streettalk_Type);
#endif
#ifdef PY_EPM_LHS_PATCH
	PY_EPM_LHS_PATCH(&epm_lhs_Type);
#endif
#ifdef PY_EPM_FLOOR_PATCH
	PY_EPM_FLOOR_PATCH(&epm_floor_Type);
#endif
#ifdef PY_EPM_TOWER_PATCH
	PY_EPM_TOWER_PATCH(&epm_tower_Type);
#endif
#ifdef PY_EPM_TWR_T_PATCH
	PY_EPM_TWR_T_PATCH(&epm_twr_t_Type);
#endif
#ifdef PY_EPM_ENTRY_T_PATCH
	PY_EPM_ENTRY_T_PATCH(&epm_entry_t_Type);
#endif
#ifdef PY_RPC_IF_ID_T_PATCH
	PY_RPC_IF_ID_T_PATCH(&rpc_if_id_t_Type);
#endif
#ifdef PY_EPM_TWR_P_T_PATCH
	PY_EPM_TWR_P_T_PATCH(&epm_twr_p_t_Type);
#endif
#ifdef PY_EPMAPPER_PATCH
	PY_EPMAPPER_PATCH(&epmapper_InterfaceType);
#endif

	m = Py_InitModule3("epmapper", epmapper_methods, "epmapper DCE/RPC");
	if (m == NULL)
		return;

	PyModule_AddObject(m, "EPM_PROTOCOL_VINES_SPP", PyInt_FromLong(EPM_PROTOCOL_VINES_SPP));
	PyModule_AddObject(m, "EPM_PROTOCOL_NCACN", PyInt_FromLong(EPM_PROTOCOL_NCACN));
	PyModule_AddObject(m, "EPM_PROTOCOL_HTTP", PyInt_FromLong(EPM_PROTOCOL_HTTP));
	PyModule_AddObject(m, "RPC_C_EP_ALL_ELTS", PyInt_FromLong(RPC_C_EP_ALL_ELTS));
	PyModule_AddObject(m, "EPM_PROTOCOL_DSP", PyInt_FromLong(EPM_PROTOCOL_DSP));
	PyModule_AddObject(m, "EPM_PROTOCOL_STREETTALK", PyInt_FromLong(EPM_PROTOCOL_STREETTALK));
	PyModule_AddObject(m, "EPM_PROTOCOL_UDP", PyInt_FromLong(EPM_PROTOCOL_UDP));
	PyModule_AddObject(m, "EPM_PROTOCOL_NB_IPX", PyInt_FromLong(EPM_PROTOCOL_NB_IPX));
	PyModule_AddObject(m, "EPM_PROTOCOL_IP", PyInt_FromLong(EPM_PROTOCOL_IP));
	PyModule_AddObject(m, "EPM_PROTOCOL_SMB", PyInt_FromLong(EPM_PROTOCOL_SMB));
	PyModule_AddObject(m, "EPM_PROTOCOL_IPX", PyInt_FromLong(EPM_PROTOCOL_IPX));
	PyModule_AddObject(m, "EPM_PROTOCOL_NAMED_PIPE", PyInt_FromLong(EPM_PROTOCOL_NAMED_PIPE));
	PyModule_AddObject(m, "EPM_PROTOCOL_DDP", PyInt_FromLong(EPM_PROTOCOL_DDP));
	PyModule_AddObject(m, "RPC_C_VERS_ALL", PyInt_FromLong(RPC_C_VERS_ALL));
	PyModule_AddObject(m, "RPC_C_VERS_COMPATIBLE", PyInt_FromLong(RPC_C_VERS_COMPATIBLE));
	PyModule_AddObject(m, "RPC_C_EP_MATCH_BY_OBJ", PyInt_FromLong(RPC_C_EP_MATCH_BY_OBJ));
	PyModule_AddObject(m, "EPM_PROTOCOL_NULL", PyInt_FromLong(EPM_PROTOCOL_NULL));
	PyModule_AddObject(m, "EPM_PROTOCOL_NETBEUI", PyInt_FromLong(EPM_PROTOCOL_NETBEUI));
	PyModule_AddObject(m, "EPM_PROTOCOL_VINES_IPC", PyInt_FromLong(EPM_PROTOCOL_VINES_IPC));
	PyModule_AddObject(m, "RPC_C_EP_MATCH_BY_IF", PyInt_FromLong(RPC_C_EP_MATCH_BY_IF));
	PyModule_AddObject(m, "EPMAPPER_STATUS_NO_MEMORY", PyInt_FromLong(0x16C9A012));
	PyModule_AddObject(m, "EPM_PROTOCOL_TCP", PyInt_FromLong(EPM_PROTOCOL_TCP));
	PyModule_AddObject(m, "EPM_PROTOCOL_UUID", PyInt_FromLong(EPM_PROTOCOL_UUID));
	PyModule_AddObject(m, "EPMAPPER_STATUS_OK", PyInt_FromLong(0));
	PyModule_AddObject(m, "RPC_C_VERS_EXACT", PyInt_FromLong(RPC_C_VERS_EXACT));
	PyModule_AddObject(m, "EPM_PROTOCOL_OSI_CLNS", PyInt_FromLong(EPM_PROTOCOL_OSI_CLNS));
	PyModule_AddObject(m, "EPM_PROTOCOL_DNET_NSP", PyInt_FromLong(EPM_PROTOCOL_DNET_NSP));
	PyModule_AddObject(m, "EPM_PROTOCOL_UNIX_DS", PyInt_FromLong(EPM_PROTOCOL_UNIX_DS));
	PyModule_AddObject(m, "RPC_C_EP_MATCH_BY_BOTH", PyInt_FromLong(RPC_C_EP_MATCH_BY_BOTH));
	PyModule_AddObject(m, "EPMAPPER_STATUS_CANT_PERFORM_OP", PyInt_FromLong(0x6d8));
	PyModule_AddObject(m, "RPC_C_VERS_UPTO", PyInt_FromLong(RPC_C_VERS_UPTO));
	PyModule_AddObject(m, "EPM_PROTOCOL_NCADG", PyInt_FromLong(EPM_PROTOCOL_NCADG));
	PyModule_AddObject(m, "EPM_PROTOCOL_APPLETALK", PyInt_FromLong(EPM_PROTOCOL_APPLETALK));
	PyModule_AddObject(m, "EPM_PROTOCOL_OSI_TP4", PyInt_FromLong(EPM_PROTOCOL_OSI_TP4));
	PyModule_AddObject(m, "EPMAPPER_STATUS_NO_MORE_ENTRIES", PyInt_FromLong(0x16c9a0d6));
	PyModule_AddObject(m, "EPM_PROTOCOL_NETBIOS", PyInt_FromLong(EPM_PROTOCOL_NETBIOS));
	PyModule_AddObject(m, "EPM_PROTOCOL_NCALRPC", PyInt_FromLong(EPM_PROTOCOL_NCALRPC));
	PyModule_AddObject(m, "EPM_PROTOCOL_SPX", PyInt_FromLong(EPM_PROTOCOL_SPX));
	PyModule_AddObject(m, "RPC_C_VERS_MAJOR_ONLY", PyInt_FromLong(RPC_C_VERS_MAJOR_ONLY));
	Py_INCREF((PyObject *)(void *)&epm_rhs_dnet_nsp_Type);
	PyModule_AddObject(m, "epm_rhs_dnet_nsp", (PyObject *)(void *)&epm_rhs_dnet_nsp_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_osi_tp4_Type);
	PyModule_AddObject(m, "epm_rhs_osi_tp4", (PyObject *)(void *)&epm_rhs_osi_tp4_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_osi_clns_Type);
	PyModule_AddObject(m, "epm_rhs_osi_clns", (PyObject *)(void *)&epm_rhs_osi_clns_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_udp_Type);
	PyModule_AddObject(m, "epm_rhs_udp", (PyObject *)(void *)&epm_rhs_udp_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_tcp_Type);
	PyModule_AddObject(m, "epm_rhs_tcp", (PyObject *)(void *)&epm_rhs_tcp_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_ip_Type);
	PyModule_AddObject(m, "epm_rhs_ip", (PyObject *)(void *)&epm_rhs_ip_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_ncadg_Type);
	PyModule_AddObject(m, "epm_rhs_ncadg", (PyObject *)(void *)&epm_rhs_ncadg_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_ncacn_Type);
	PyModule_AddObject(m, "epm_rhs_ncacn", (PyObject *)(void *)&epm_rhs_ncacn_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_uuid_Type);
	PyModule_AddObject(m, "epm_rhs_uuid", (PyObject *)(void *)&epm_rhs_uuid_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_ipx_Type);
	PyModule_AddObject(m, "epm_rhs_ipx", (PyObject *)(void *)&epm_rhs_ipx_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_smb_Type);
	PyModule_AddObject(m, "epm_rhs_smb", (PyObject *)(void *)&epm_rhs_smb_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_named_pipe_Type);
	PyModule_AddObject(m, "epm_rhs_named_pipe", (PyObject *)(void *)&epm_rhs_named_pipe_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_netbios_Type);
	PyModule_AddObject(m, "epm_rhs_netbios", (PyObject *)(void *)&epm_rhs_netbios_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_netbeui_Type);
	PyModule_AddObject(m, "epm_rhs_netbeui", (PyObject *)(void *)&epm_rhs_netbeui_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_spx_Type);
	PyModule_AddObject(m, "epm_rhs_spx", (PyObject *)(void *)&epm_rhs_spx_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_nb_ipx_Type);
	PyModule_AddObject(m, "epm_rhs_nb_ipx", (PyObject *)(void *)&epm_rhs_nb_ipx_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_http_Type);
	PyModule_AddObject(m, "epm_rhs_http", (PyObject *)(void *)&epm_rhs_http_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_unix_ds_Type);
	PyModule_AddObject(m, "epm_rhs_unix_ds", (PyObject *)(void *)&epm_rhs_unix_ds_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_null_Type);
	PyModule_AddObject(m, "epm_rhs_null", (PyObject *)(void *)&epm_rhs_null_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_ncalrpc_Type);
	PyModule_AddObject(m, "epm_rhs_ncalrpc", (PyObject *)(void *)&epm_rhs_ncalrpc_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_appletalk_Type);
	PyModule_AddObject(m, "epm_rhs_appletalk", (PyObject *)(void *)&epm_rhs_appletalk_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_atalk_stream_Type);
	PyModule_AddObject(m, "epm_rhs_atalk_stream", (PyObject *)(void *)&epm_rhs_atalk_stream_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_atalk_datagram_Type);
	PyModule_AddObject(m, "epm_rhs_atalk_datagram", (PyObject *)(void *)&epm_rhs_atalk_datagram_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_vines_spp_Type);
	PyModule_AddObject(m, "epm_rhs_vines_spp", (PyObject *)(void *)&epm_rhs_vines_spp_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_vines_ipc_Type);
	PyModule_AddObject(m, "epm_rhs_vines_ipc", (PyObject *)(void *)&epm_rhs_vines_ipc_Type);
	Py_INCREF((PyObject *)(void *)&epm_rhs_streettalk_Type);
	PyModule_AddObject(m, "epm_rhs_streettalk", (PyObject *)(void *)&epm_rhs_streettalk_Type);
	Py_INCREF((PyObject *)(void *)&epm_lhs_Type);
	PyModule_AddObject(m, "epm_lhs", (PyObject *)(void *)&epm_lhs_Type);
	Py_INCREF((PyObject *)(void *)&epm_floor_Type);
	PyModule_AddObject(m, "epm_floor", (PyObject *)(void *)&epm_floor_Type);
	Py_INCREF((PyObject *)(void *)&epm_tower_Type);
	PyModule_AddObject(m, "epm_tower", (PyObject *)(void *)&epm_tower_Type);
	Py_INCREF((PyObject *)(void *)&epm_twr_t_Type);
	PyModule_AddObject(m, "epm_twr_t", (PyObject *)(void *)&epm_twr_t_Type);
	Py_INCREF((PyObject *)(void *)&epm_entry_t_Type);
	PyModule_AddObject(m, "epm_entry_t", (PyObject *)(void *)&epm_entry_t_Type);
	Py_INCREF((PyObject *)(void *)&rpc_if_id_t_Type);
	PyModule_AddObject(m, "rpc_if_id_t", (PyObject *)(void *)&rpc_if_id_t_Type);
	Py_INCREF((PyObject *)(void *)&epm_twr_p_t_Type);
	PyModule_AddObject(m, "epm_twr_p_t", (PyObject *)(void *)&epm_twr_p_t_Type);
	Py_INCREF((PyObject *)(void *)&epmapper_InterfaceType);
	PyModule_AddObject(m, "epmapper", (PyObject *)(void *)&epmapper_InterfaceType);
#ifdef PY_MOD_EPMAPPER_PATCH
	PY_MOD_EPMAPPER_PATCH(m);
#endif

}
