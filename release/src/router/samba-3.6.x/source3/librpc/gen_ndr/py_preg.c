
/* Python wrapper functions auto-generated by pidl */
#include <Python.h>
#include "includes.h"
#include <pytalloc.h>
#include "librpc/rpc/pyrpc.h"
#include "librpc/rpc/pyrpc_util.h"
#include "librpc/gen_ndr/ndr_preg.h"
#include "librpc/gen_ndr/ndr_preg_c.h"

#include "librpc/gen_ndr/misc.h"
staticforward PyTypeObject preg_entry_Type;
staticforward PyTypeObject preg_header_Type;
staticforward PyTypeObject preg_file_Type;
staticforward PyTypeObject preg_InterfaceType;

void initpreg(void);static PyTypeObject *ClientConnection_Type;
static PyTypeObject *Object_Type;

static PyObject *py_preg_entry_get__opening_bracket(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__opening_bracket;
	if (object->_opening_bracket == NULL) {
		py__opening_bracket = Py_None;
		Py_INCREF(py__opening_bracket);
	} else {
		py__opening_bracket = PyUnicode_Decode(object->_opening_bracket, strlen(object->_opening_bracket), "utf-8", "ignore");
	}
	return py__opening_bracket;
}

static int py_preg_entry_set__opening_bracket(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_opening_bracket = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_opening_bracket = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get_keyname(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py_keyname;
	py_keyname = PyString_FromStringOrNULL(object->keyname);
	return py_keyname;
}

static int py_preg_entry_set_keyname(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	object->keyname = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyObject *py_preg_entry_get__sep1(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__sep1;
	if (object->_sep1 == NULL) {
		py__sep1 = Py_None;
		Py_INCREF(py__sep1);
	} else {
		py__sep1 = PyUnicode_Decode(object->_sep1, strlen(object->_sep1), "utf-8", "ignore");
	}
	return py__sep1;
}

static int py_preg_entry_set__sep1(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_sep1 = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_sep1 = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get_valuename(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py_valuename;
	py_valuename = PyString_FromStringOrNULL(object->valuename);
	return py_valuename;
}

static int py_preg_entry_set_valuename(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	object->valuename = talloc_strdup(py_talloc_get_mem_ctx(py_obj), PyString_AS_STRING(value));
	return 0;
}

static PyObject *py_preg_entry_get__sep2(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__sep2;
	if (object->_sep2 == NULL) {
		py__sep2 = Py_None;
		Py_INCREF(py__sep2);
	} else {
		py__sep2 = PyUnicode_Decode(object->_sep2, strlen(object->_sep2), "utf-8", "ignore");
	}
	return py__sep2;
}

static int py_preg_entry_set__sep2(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_sep2 = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_sep2 = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get_type(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py_type;
	py_type = PyInt_FromLong(object->type);
	return py_type;
}

static int py_preg_entry_set_type(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyLong_Check(value)) {
		object->type = PyLong_AsLongLong(value);
	} else if (PyInt_Check(value)) {
		object->type = PyInt_AsLong(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected type %s or %s",\
		  PyInt_Type.tp_name, PyLong_Type.tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get__sep3(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__sep3;
	if (object->_sep3 == NULL) {
		py__sep3 = Py_None;
		Py_INCREF(py__sep3);
	} else {
		py__sep3 = PyUnicode_Decode(object->_sep3, strlen(object->_sep3), "utf-8", "ignore");
	}
	return py__sep3;
}

static int py_preg_entry_set__sep3(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_sep3 = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_sep3 = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get_size(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py_size;
	py_size = PyInt_FromLong(object->size);
	return py_size;
}

static int py_preg_entry_set_size(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->size = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_preg_entry_get__sep4(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__sep4;
	if (object->_sep4 == NULL) {
		py__sep4 = Py_None;
		Py_INCREF(py__sep4);
	} else {
		py__sep4 = PyUnicode_Decode(object->_sep4, strlen(object->_sep4), "utf-8", "ignore");
	}
	return py__sep4;
}

static int py_preg_entry_set__sep4(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_sep4 = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_sep4 = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_entry_get_data(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py_data;
	py_data = PyList_New(object->size);
	if (py_data == NULL) {
		return NULL;
	}
	{
		int data_cntr_0;
		for (data_cntr_0 = 0; data_cntr_0 < object->size; data_cntr_0++) {
			PyObject *py_data_0;
			py_data_0 = PyInt_FromLong(object->data[data_cntr_0]);
			PyList_SetItem(py_data, data_cntr_0, py_data_0);
		}
	}
	return py_data;
}

static int py_preg_entry_set_data(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int data_cntr_0;
		object->data = talloc_array_ptrtype(py_talloc_get_mem_ctx(py_obj), object->data, PyList_GET_SIZE(value));
		if (!object->data) { return -1;; }
		talloc_set_name_const(object->data, "ARRAY: object->data");
		for (data_cntr_0 = 0; data_cntr_0 < PyList_GET_SIZE(value); data_cntr_0++) {
			PY_CHECK_TYPE(&PyInt_Type, PyList_GET_ITEM(value, data_cntr_0), return -1;);
			object->data[data_cntr_0] = PyInt_AsLong(PyList_GET_ITEM(value, data_cntr_0));
		}
	}
	return 0;
}

static PyObject *py_preg_entry_get__closing_bracket(PyObject *obj, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(obj);
	PyObject *py__closing_bracket;
	if (object->_closing_bracket == NULL) {
		py__closing_bracket = Py_None;
		Py_INCREF(py__closing_bracket);
	} else {
		py__closing_bracket = PyUnicode_Decode(object->_closing_bracket, strlen(object->_closing_bracket), "utf-8", "ignore");
	}
	return py__closing_bracket;
}

static int py_preg_entry_set__closing_bracket(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->_closing_bracket = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->_closing_bracket = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyGetSetDef py_preg_entry_getsetters[] = {
	{ discard_const_p(char, "_opening_bracket"), py_preg_entry_get__opening_bracket, py_preg_entry_set__opening_bracket },
	{ discard_const_p(char, "keyname"), py_preg_entry_get_keyname, py_preg_entry_set_keyname },
	{ discard_const_p(char, "_sep1"), py_preg_entry_get__sep1, py_preg_entry_set__sep1 },
	{ discard_const_p(char, "valuename"), py_preg_entry_get_valuename, py_preg_entry_set_valuename },
	{ discard_const_p(char, "_sep2"), py_preg_entry_get__sep2, py_preg_entry_set__sep2 },
	{ discard_const_p(char, "type"), py_preg_entry_get_type, py_preg_entry_set_type },
	{ discard_const_p(char, "_sep3"), py_preg_entry_get__sep3, py_preg_entry_set__sep3 },
	{ discard_const_p(char, "size"), py_preg_entry_get_size, py_preg_entry_set_size },
	{ discard_const_p(char, "_sep4"), py_preg_entry_get__sep4, py_preg_entry_set__sep4 },
	{ discard_const_p(char, "data"), py_preg_entry_get_data, py_preg_entry_set_data },
	{ discard_const_p(char, "_closing_bracket"), py_preg_entry_get__closing_bracket, py_preg_entry_set__closing_bracket },
	{ NULL }
};

static PyObject *py_preg_entry_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct preg_entry, type);
}

static PyObject *py_preg_entry_ndr_pack(PyObject *py_obj)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	err = ndr_push_struct_blob(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_push_flags_fn_t)ndr_push_preg_entry);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	return PyString_FromStringAndSize((char *)blob.data, blob.length);
}

static PyObject *py_preg_entry_ndr_unpack(PyObject *py_obj, PyObject *args)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	if (!PyArg_ParseTuple(args, "s#:__ndr_unpack__", &blob.data, &blob.length))
		return NULL;

	err = ndr_pull_struct_blob_all(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_preg_entry);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_preg_entry_ndr_print(PyObject *py_obj)
{
	struct preg_entry *object = (struct preg_entry *)py_talloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(py_talloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_preg_entry, "preg_entry", object);
	ret = PyString_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_preg_entry_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_preg_entry_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_preg_entry_ndr_unpack, METH_VARARGS, "S.ndr_unpack(class, blob) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_preg_entry_ndr_print, METH_VARARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject preg_entry_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "preg.entry",
	.tp_getset = py_preg_entry_getsetters,
	.tp_methods = py_preg_entry_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_preg_entry_new,
};


static PyObject *py_preg_header_get_signature(PyObject *obj, void *closure)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(obj);
	PyObject *py_signature;
	if (object->signature == NULL) {
		py_signature = Py_None;
		Py_INCREF(py_signature);
	} else {
		py_signature = PyUnicode_Decode(object->signature, strlen(object->signature), "utf-8", "ignore");
	}
	return py_signature;
}

static int py_preg_header_set_signature(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(py_obj);
	if (PyUnicode_Check(value)) {
		object->signature = PyString_AS_STRING(PyUnicode_AsEncodedString(value, "utf-8", "ignore"));
	} else if (PyString_Check(value)) {
		object->signature = PyString_AS_STRING(value);
	} else {
		PyErr_Format(PyExc_TypeError, "Expected string or unicode object, got %s", Py_TYPE(value)->tp_name);
		return -1;
	}
	return 0;
}

static PyObject *py_preg_header_get_version(PyObject *obj, void *closure)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(obj);
	PyObject *py_version;
	py_version = PyInt_FromLong(object->version);
	return py_version;
}

static int py_preg_header_set_version(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->version = PyInt_AsLong(value);
	return 0;
}

static PyGetSetDef py_preg_header_getsetters[] = {
	{ discard_const_p(char, "signature"), py_preg_header_get_signature, py_preg_header_set_signature },
	{ discard_const_p(char, "version"), py_preg_header_get_version, py_preg_header_set_version },
	{ NULL }
};

static PyObject *py_preg_header_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct preg_header, type);
}

static PyObject *py_preg_header_ndr_pack(PyObject *py_obj)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	err = ndr_push_struct_blob(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_push_flags_fn_t)ndr_push_preg_header);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	return PyString_FromStringAndSize((char *)blob.data, blob.length);
}

static PyObject *py_preg_header_ndr_unpack(PyObject *py_obj, PyObject *args)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	if (!PyArg_ParseTuple(args, "s#:__ndr_unpack__", &blob.data, &blob.length))
		return NULL;

	err = ndr_pull_struct_blob_all(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_preg_header);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_preg_header_ndr_print(PyObject *py_obj)
{
	struct preg_header *object = (struct preg_header *)py_talloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(py_talloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_preg_header, "preg_header", object);
	ret = PyString_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_preg_header_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_preg_header_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_preg_header_ndr_unpack, METH_VARARGS, "S.ndr_unpack(class, blob) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_preg_header_ndr_print, METH_VARARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject preg_header_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "preg.header",
	.tp_getset = py_preg_header_getsetters,
	.tp_methods = py_preg_header_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_preg_header_new,
};


static PyObject *py_preg_file_get_header(PyObject *obj, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(obj);
	PyObject *py_header;
	py_header = py_talloc_reference_ex(&preg_header_Type, py_talloc_get_mem_ctx(obj), &object->header);
	return py_header;
}

static int py_preg_file_set_header(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&preg_header_Type, value, return -1;);
	if (talloc_reference(py_talloc_get_mem_ctx(py_obj), py_talloc_get_mem_ctx(value)) == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	object->header = *(struct preg_header *)py_talloc_get_ptr(value);
	return 0;
}

static PyObject *py_preg_file_get_num_entries(PyObject *obj, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(obj);
	PyObject *py_num_entries;
	py_num_entries = PyInt_FromLong(object->num_entries);
	return py_num_entries;
}

static int py_preg_file_set_num_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyInt_Type, value, return -1;);
	object->num_entries = PyInt_AsLong(value);
	return 0;
}

static PyObject *py_preg_file_get_entries(PyObject *obj, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(obj);
	PyObject *py_entries;
	py_entries = PyList_New(object->num_entries);
	if (py_entries == NULL) {
		return NULL;
	}
	{
		int entries_cntr_0;
		for (entries_cntr_0 = 0; entries_cntr_0 < object->num_entries; entries_cntr_0++) {
			PyObject *py_entries_0;
			py_entries_0 = py_talloc_reference_ex(&preg_entry_Type, object->entries, &object->entries[entries_cntr_0]);
			PyList_SetItem(py_entries, entries_cntr_0, py_entries_0);
		}
	}
	return py_entries;
}

static int py_preg_file_set_entries(PyObject *py_obj, PyObject *value, void *closure)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	PY_CHECK_TYPE(&PyList_Type, value, return -1;);
	{
		int entries_cntr_0;
		object->entries = talloc_array_ptrtype(py_talloc_get_mem_ctx(py_obj), object->entries, PyList_GET_SIZE(value));
		if (!object->entries) { return -1;; }
		talloc_set_name_const(object->entries, "ARRAY: object->entries");
		for (entries_cntr_0 = 0; entries_cntr_0 < PyList_GET_SIZE(value); entries_cntr_0++) {
			PY_CHECK_TYPE(&preg_entry_Type, PyList_GET_ITEM(value, entries_cntr_0), return -1;);
			if (talloc_reference(object->entries, py_talloc_get_mem_ctx(PyList_GET_ITEM(value, entries_cntr_0))) == NULL) {
				PyErr_NoMemory();
				return -1;
			}
			object->entries[entries_cntr_0] = *(struct preg_entry *)py_talloc_get_ptr(PyList_GET_ITEM(value, entries_cntr_0));
		}
	}
	return 0;
}

static PyGetSetDef py_preg_file_getsetters[] = {
	{ discard_const_p(char, "header"), py_preg_file_get_header, py_preg_file_set_header },
	{ discard_const_p(char, "num_entries"), py_preg_file_get_num_entries, py_preg_file_set_num_entries },
	{ discard_const_p(char, "entries"), py_preg_file_get_entries, py_preg_file_set_entries },
	{ NULL }
};

static PyObject *py_preg_file_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_talloc_new(struct preg_file, type);
}

static PyObject *py_preg_file_ndr_pack(PyObject *py_obj)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	err = ndr_push_struct_blob(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_push_flags_fn_t)ndr_push_preg_file);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	return PyString_FromStringAndSize((char *)blob.data, blob.length);
}

static PyObject *py_preg_file_ndr_unpack(PyObject *py_obj, PyObject *args)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	DATA_BLOB blob;
	enum ndr_err_code err;
	if (!PyArg_ParseTuple(args, "s#:__ndr_unpack__", &blob.data, &blob.length))
		return NULL;

	err = ndr_pull_struct_blob_all(&blob, py_talloc_get_mem_ctx(py_obj), object, (ndr_pull_flags_fn_t)ndr_pull_preg_file);
	if (err != NDR_ERR_SUCCESS) {
		PyErr_SetNdrError(err);
		return NULL;
	}

	Py_RETURN_NONE;
}

static PyObject *py_preg_file_ndr_print(PyObject *py_obj)
{
	struct preg_file *object = (struct preg_file *)py_talloc_get_ptr(py_obj);
	PyObject *ret;
	char *retstr;

	retstr = ndr_print_struct_string(py_talloc_get_mem_ctx(py_obj), (ndr_print_fn_t)ndr_print_preg_file, "preg_file", object);
	ret = PyString_FromString(retstr);
	talloc_free(retstr);

	return ret;
}

static PyMethodDef py_preg_file_methods[] = {
	{ "__ndr_pack__", (PyCFunction)py_preg_file_ndr_pack, METH_NOARGS, "S.ndr_pack(object) -> blob\nNDR pack" },
	{ "__ndr_unpack__", (PyCFunction)py_preg_file_ndr_unpack, METH_VARARGS, "S.ndr_unpack(class, blob) -> None\nNDR unpack" },
	{ "__ndr_print__", (PyCFunction)py_preg_file_ndr_print, METH_VARARGS, "S.ndr_print(object) -> None\nNDR print" },
	{ NULL, NULL, 0, NULL }
};


static PyTypeObject preg_file_Type = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "preg.file",
	.tp_getset = py_preg_file_getsetters,
	.tp_methods = py_preg_file_methods,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_basicsize = sizeof(py_talloc_Object),
	.tp_new = py_preg_file_new,
};


static bool pack_py_decode_preg_file_args_in(PyObject *args, PyObject *kwargs, struct decode_preg_file *r)
{
	PyObject *py_file;
	const char *kwnames[] = {
		"file", NULL
	};

	if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:decode_preg_file", discard_const_p(char *, kwnames), &py_file)) {
		return false;
	}

	PY_CHECK_TYPE(&preg_file_Type, py_file, return false;);
	if (talloc_reference(r, py_talloc_get_mem_ctx(py_file)) == NULL) {
		PyErr_NoMemory();
		return false;
	}
	r->in.file = *(struct preg_file *)py_talloc_get_ptr(py_file);
	return true;
}

static PyObject *unpack_py_decode_preg_file_args_out(struct decode_preg_file *r)
{
	PyObject *result;
	result = Py_None;
	Py_INCREF(result);
	return result;
}

const struct PyNdrRpcMethodDef py_ndr_preg_methods[] = {
	{ "decode_preg_file", "S.decode_preg_file(file) -> None", (py_dcerpc_call_fn)dcerpc_decode_preg_file_r, (py_data_pack_fn)pack_py_decode_preg_file_args_in, (py_data_unpack_fn)unpack_py_decode_preg_file_args_out, 0, &ndr_table_preg },
	{ NULL }
};

static PyObject *interface_preg_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
	return py_dcerpc_interface_init_helper(type, args, kwargs, &ndr_table_preg);
}

#define PY_DOC_PREG "PReg structure"
static PyTypeObject preg_InterfaceType = {
	PyObject_HEAD_INIT(NULL) 0,
	.tp_name = "preg.preg",
	.tp_basicsize = sizeof(dcerpc_InterfaceObject),
	.tp_doc = "preg(binding, lp_ctx=None, credentials=None) -> connection\n"
"\n"
"binding should be a DCE/RPC binding string (for example: ncacn_ip_tcp:127.0.0.1)\n"
"lp_ctx should be a path to a smb.conf file or a param.LoadParm object\n"
"credentials should be a credentials.Credentials object.\n\n"PY_DOC_PREG,
	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
	.tp_new = interface_preg_new,
};

static PyMethodDef preg_methods[] = {
	{ NULL, NULL, 0, NULL }
};

void initpreg(void)
{
	PyObject *m;
	PyObject *dep_talloc;
	PyObject *dep_samba_dcerpc_base;
	PyObject *dep_samba_dcerpc_misc;

	dep_talloc = PyImport_ImportModule("talloc");
	if (dep_talloc == NULL)
		return;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return;

	dep_samba_dcerpc_misc = PyImport_ImportModule("samba.dcerpc.misc");
	if (dep_samba_dcerpc_misc == NULL)
		return;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return;

	Object_Type = (PyTypeObject *)PyObject_GetAttrString(dep_talloc, "Object");
	if (Object_Type == NULL)
		return;

	preg_entry_Type.tp_base = Object_Type;

	preg_header_Type.tp_base = Object_Type;

	preg_file_Type.tp_base = Object_Type;

	preg_InterfaceType.tp_base = ClientConnection_Type;

	if (PyType_Ready(&preg_entry_Type) < 0)
		return;
	if (PyType_Ready(&preg_header_Type) < 0)
		return;
	if (PyType_Ready(&preg_file_Type) < 0)
		return;
	if (PyType_Ready(&preg_InterfaceType) < 0)
		return;
	if (!PyInterface_AddNdrRpcMethods(&preg_InterfaceType, py_ndr_preg_methods))
		return;

#ifdef PY_ENTRY_PATCH
	PY_ENTRY_PATCH(&preg_entry_Type);
#endif
#ifdef PY_HEADER_PATCH
	PY_HEADER_PATCH(&preg_header_Type);
#endif
#ifdef PY_FILE_PATCH
	PY_FILE_PATCH(&preg_file_Type);
#endif
#ifdef PY_PREG_PATCH
	PY_PREG_PATCH(&preg_InterfaceType);
#endif

	m = Py_InitModule3("preg", preg_methods, "preg DCE/RPC");
	if (m == NULL)
		return;

	Py_INCREF((PyObject *)(void *)&preg_entry_Type);
	PyModule_AddObject(m, "entry", (PyObject *)(void *)&preg_entry_Type);
	Py_INCREF((PyObject *)(void *)&preg_header_Type);
	PyModule_AddObject(m, "header", (PyObject *)(void *)&preg_header_Type);
	Py_INCREF((PyObject *)(void *)&preg_file_Type);
	PyModule_AddObject(m, "file", (PyObject *)(void *)&preg_file_Type);
	Py_INCREF((PyObject *)(void *)&preg_InterfaceType);
	PyModule_AddObject(m, "preg", (PyObject *)(void *)&preg_InterfaceType);
#ifdef PY_MOD_PREG_PATCH
	PY_MOD_PREG_PATCH(m);
#endif

}
