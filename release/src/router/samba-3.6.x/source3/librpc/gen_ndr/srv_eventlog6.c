/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "ntdomain.h"
#include "librpc/gen_ndr/srv_eventlog6.h"

static bool api_eventlog6_EvtRpcRegisterRemoteSubscription(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRegisterRemoteSubscription *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREGISTERREMOTESUBSCRIPTION];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRegisterRemoteSubscription);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterRemoteSubscription, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.control = talloc_zero(r, struct policy_handle);
	if (r->out.control == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.queryChannelInfoSize = talloc_zero(r, uint32_t);
	if (r->out.queryChannelInfoSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.queryChannelInfo = talloc_zero(r, struct eventlog6_EvtRpcQueryChannelInfo *);
	if (r->out.queryChannelInfo == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcRegisterRemoteSubscription(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterRemoteSubscription, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRemoteSubscriptionNextAsync(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRemoteSubscriptionNextAsync *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXTASYNC];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRemoteSubscriptionNextAsync);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionNextAsync, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numActualRecords = talloc_zero(r, uint32_t);
	if (r->out.numActualRecords == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataIndices = talloc_zero(r, uint32_t *);
	if (r->out.eventDataIndices == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataSizes = talloc_zero(r, uint32_t *);
	if (r->out.eventDataSizes == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBufferSize = talloc_zero(r, uint32_t);
	if (r->out.resultBufferSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBuffer = talloc_zero(r, uint8_t *);
	if (r->out.resultBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcRemoteSubscriptionNextAsync(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionNextAsync, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRemoteSubscriptionNext(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRemoteSubscriptionNext *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXT];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRemoteSubscriptionNext);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionNext, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numActualRecords = talloc_zero(r, uint32_t);
	if (r->out.numActualRecords == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataIndices = talloc_zero(r, uint32_t *);
	if (r->out.eventDataIndices == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataSizes = talloc_zero(r, uint32_t *);
	if (r->out.eventDataSizes == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBufferSize = talloc_zero(r, uint32_t);
	if (r->out.resultBufferSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBuffer = talloc_zero(r, uint8_t *);
	if (r->out.resultBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcRemoteSubscriptionNext(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionNext, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRemoteSubscriptionWaitAsync(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRemoteSubscriptionWaitAsync *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONWAITASYNC];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRemoteSubscriptionWaitAsync);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionWaitAsync, NDR_IN, r);
	}

	r->out.result = _eventlog6_EvtRpcRemoteSubscriptionWaitAsync(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRemoteSubscriptionWaitAsync, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRegisterControllableOperation(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRegisterControllableOperation *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREGISTERCONTROLLABLEOPERATION];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRegisterControllableOperation);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterControllableOperation, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcRegisterControllableOperation(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterControllableOperation, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRegisterLogQuery(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRegisterLogQuery *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCREGISTERLOGQUERY];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRegisterLogQuery);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterLogQuery, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.opControl = talloc_zero(r, struct policy_handle);
	if (r->out.opControl == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.queryChannelInfoSize = talloc_zero(r, uint32_t);
	if (r->out.queryChannelInfoSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.queryChannelInfo = talloc_zero(r, struct eventlog6_EvtRpcQueryChannelInfo *);
	if (r->out.queryChannelInfo == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcRegisterLogQuery(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRegisterLogQuery, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcClearLog(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcClearLog *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCCLEARLOG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcClearLog);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcClearLog, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcClearLog(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcClearLog, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcExportLog(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcExportLog *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCEXPORTLOG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcExportLog);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcExportLog, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcExportLog(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcExportLog, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcLocalizeExportLog(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcLocalizeExportLog *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCLOCALIZEEXPORTLOG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcLocalizeExportLog);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcLocalizeExportLog, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcLocalizeExportLog(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcLocalizeExportLog, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcMessageRender(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcMessageRender *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCMESSAGERENDER];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcMessageRender);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcMessageRender, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.actualSizeString = talloc_zero(r, uint32_t);
	if (r->out.actualSizeString == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.neededSizeString = talloc_zero(r, uint32_t);
	if (r->out.neededSizeString == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.string = talloc_zero(r, uint8_t *);
	if (r->out.string == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcMessageRender(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcMessageRender, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcMessageRenderDefault(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcMessageRenderDefault *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCMESSAGERENDERDEFAULT];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcMessageRenderDefault);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcMessageRenderDefault, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.actualSizeString = talloc_zero(r, uint32_t);
	if (r->out.actualSizeString == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.neededSizeString = talloc_zero(r, uint32_t);
	if (r->out.neededSizeString == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.string = talloc_zero(r, uint8_t *);
	if (r->out.string == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcMessageRenderDefault(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcMessageRenderDefault, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcQueryNext(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcQueryNext *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCQUERYNEXT];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcQueryNext);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcQueryNext, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numActualRecords = talloc_zero(r, uint32_t);
	if (r->out.numActualRecords == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataIndices = talloc_zero(r, uint32_t *);
	if (r->out.eventDataIndices == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventDataSizes = talloc_zero(r, uint32_t *);
	if (r->out.eventDataSizes == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBufferSize = talloc_zero(r, uint32_t);
	if (r->out.resultBufferSize == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resultBuffer = talloc_zero(r, uint8_t *);
	if (r->out.resultBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcQueryNext(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcQueryNext, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcQuerySeek(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcQuerySeek *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCQUERYSEEK];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcQuerySeek);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcQuerySeek, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcQuerySeek(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcQuerySeek, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcClose(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcClose *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCCLOSE];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcClose);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcClose, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = r->in.handle;
	r->out.result = _eventlog6_EvtRpcClose(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcClose, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcCancel(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcCancel *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCCANCEL];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcCancel);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcCancel, NDR_IN, r);
	}

	r->out.result = _eventlog6_EvtRpcCancel(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcCancel, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcAssertConfig(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcAssertConfig *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCASSERTCONFIG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcAssertConfig);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcAssertConfig, NDR_IN, r);
	}

	r->out.result = _eventlog6_EvtRpcAssertConfig(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcAssertConfig, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcRetractConfig(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcRetractConfig *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCRETRACTCONFIG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcRetractConfig);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRetractConfig, NDR_IN, r);
	}

	r->out.result = _eventlog6_EvtRpcRetractConfig(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcRetractConfig, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcOpenLogHandle(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcOpenLogHandle *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCOPENLOGHANDLE];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcOpenLogHandle);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcOpenLogHandle, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.handle = talloc_zero(r, struct policy_handle);
	if (r->out.handle == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcOpenLogHandle(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcOpenLogHandle, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetLogFileInfo(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetLogFileInfo *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETLOGFILEINFO];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetLogFileInfo);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetLogFileInfo, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.propertyValueBuffer = talloc_zero_array(r, uint8_t, r->in.propertyValueBufferSize);
	if (r->out.propertyValueBuffer == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.propertyValueBufferLength = talloc_zero(r, uint32_t);
	if (r->out.propertyValueBufferLength == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetLogFileInfo(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetLogFileInfo, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetChannelList(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetChannelList *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETCHANNELLIST];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetChannelList);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetChannelList, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numChannelPaths = talloc_zero(r, uint32_t);
	if (r->out.numChannelPaths == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.channelPaths = talloc_zero(r, const char **);
	if (r->out.channelPaths == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetChannelList(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetChannelList, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetChannelConfig(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetChannelConfig *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETCHANNELCONFIG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetChannelConfig);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetChannelConfig, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.props = talloc_zero(r, struct eventlog6_EvtRpcVariantList);
	if (r->out.props == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetChannelConfig(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetChannelConfig, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcPutChannelConfig(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcPutChannelConfig *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCPUTCHANNELCONFIG];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcPutChannelConfig);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcPutChannelConfig, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.error = talloc_zero(r, struct eventlog6_RpcInfo);
	if (r->out.error == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcPutChannelConfig(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcPutChannelConfig, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetPublisherList(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetPublisherList *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETPUBLISHERLIST];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetPublisherList);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherList, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numPublisherIds = talloc_zero(r, uint32_t);
	if (r->out.numPublisherIds == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.publisherIds = talloc_zero(r, const char **);
	if (r->out.publisherIds == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetPublisherList(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherList, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetPublisherListForChannel(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetPublisherListForChannel *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETPUBLISHERLISTFORCHANNEL];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetPublisherListForChannel);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherListForChannel, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numPublisherIds = talloc_zero(r, uint32_t);
	if (r->out.numPublisherIds == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.publisherIds = talloc_zero(r, const char **);
	if (r->out.publisherIds == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetPublisherListForChannel(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherListForChannel, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetPublisherMetadata(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetPublisherMetadata *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETPUBLISHERMETADATA];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetPublisherMetadata);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherMetadata, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pubMetadataProps = talloc_zero(r, struct eventlog6_EvtRpcVariantList);
	if (r->out.pubMetadataProps == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.pubMetadata = talloc_zero(r, struct policy_handle);
	if (r->out.pubMetadata == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetPublisherMetadata(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherMetadata, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetPublisherResourceMetadata(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetPublisherResourceMetadata *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETPUBLISHERRESOURCEMETADATA];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetPublisherResourceMetadata);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherResourceMetadata, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pubMetadataProps = talloc_zero(r, struct eventlog6_EvtRpcVariantList);
	if (r->out.pubMetadataProps == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetPublisherResourceMetadata(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetPublisherResourceMetadata, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetEventMetadataEnum(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetEventMetadataEnum *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETEVENTMETADATAENUM];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetEventMetadataEnum);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetEventMetadataEnum, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.eventMetaDataEnum = talloc_zero(r, struct policy_handle);
	if (r->out.eventMetaDataEnum == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetEventMetadataEnum(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetEventMetadataEnum, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetNextEventMetadata(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetNextEventMetadata *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETNEXTEVENTMETADATA];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetNextEventMetadata);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetNextEventMetadata, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.numReturned = talloc_zero(r, uint32_t);
	if (r->out.numReturned == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.eventMetadataInstances = talloc_zero(r, struct eventlog6_EvtRpcVariantList *);
	if (r->out.eventMetadataInstances == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetNextEventMetadata(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetNextEventMetadata, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}

static bool api_eventlog6_EvtRpcGetClassicLogDisplayName(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct eventlog6_EvtRpcGetClassicLogDisplayName *r;

	call = &ndr_table_eventlog6.calls[NDR_EVENTLOG6_EVTRPCGETCLASSICLOGDISPLAYNAME];

	r = talloc(talloc_tos(), struct eventlog6_EvtRpcGetClassicLogDisplayName);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetClassicLogDisplayName, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.displayName = talloc_zero(r, uint16_t *);
	if (r->out.displayName == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _eventlog6_EvtRpcGetClassicLogDisplayName(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(eventlog6_EvtRpcGetClassicLogDisplayName, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}


/* Tables */
static struct api_struct api_eventlog6_cmds[] = 
{
	{"EVENTLOG6_EVTRPCREGISTERREMOTESUBSCRIPTION", NDR_EVENTLOG6_EVTRPCREGISTERREMOTESUBSCRIPTION, api_eventlog6_EvtRpcRegisterRemoteSubscription},
	{"EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXTASYNC", NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXTASYNC, api_eventlog6_EvtRpcRemoteSubscriptionNextAsync},
	{"EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXT", NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONNEXT, api_eventlog6_EvtRpcRemoteSubscriptionNext},
	{"EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONWAITASYNC", NDR_EVENTLOG6_EVTRPCREMOTESUBSCRIPTIONWAITASYNC, api_eventlog6_EvtRpcRemoteSubscriptionWaitAsync},
	{"EVENTLOG6_EVTRPCREGISTERCONTROLLABLEOPERATION", NDR_EVENTLOG6_EVTRPCREGISTERCONTROLLABLEOPERATION, api_eventlog6_EvtRpcRegisterControllableOperation},
	{"EVENTLOG6_EVTRPCREGISTERLOGQUERY", NDR_EVENTLOG6_EVTRPCREGISTERLOGQUERY, api_eventlog6_EvtRpcRegisterLogQuery},
	{"EVENTLOG6_EVTRPCCLEARLOG", NDR_EVENTLOG6_EVTRPCCLEARLOG, api_eventlog6_EvtRpcClearLog},
	{"EVENTLOG6_EVTRPCEXPORTLOG", NDR_EVENTLOG6_EVTRPCEXPORTLOG, api_eventlog6_EvtRpcExportLog},
	{"EVENTLOG6_EVTRPCLOCALIZEEXPORTLOG", NDR_EVENTLOG6_EVTRPCLOCALIZEEXPORTLOG, api_eventlog6_EvtRpcLocalizeExportLog},
	{"EVENTLOG6_EVTRPCMESSAGERENDER", NDR_EVENTLOG6_EVTRPCMESSAGERENDER, api_eventlog6_EvtRpcMessageRender},
	{"EVENTLOG6_EVTRPCMESSAGERENDERDEFAULT", NDR_EVENTLOG6_EVTRPCMESSAGERENDERDEFAULT, api_eventlog6_EvtRpcMessageRenderDefault},
	{"EVENTLOG6_EVTRPCQUERYNEXT", NDR_EVENTLOG6_EVTRPCQUERYNEXT, api_eventlog6_EvtRpcQueryNext},
	{"EVENTLOG6_EVTRPCQUERYSEEK", NDR_EVENTLOG6_EVTRPCQUERYSEEK, api_eventlog6_EvtRpcQuerySeek},
	{"EVENTLOG6_EVTRPCCLOSE", NDR_EVENTLOG6_EVTRPCCLOSE, api_eventlog6_EvtRpcClose},
	{"EVENTLOG6_EVTRPCCANCEL", NDR_EVENTLOG6_EVTRPCCANCEL, api_eventlog6_EvtRpcCancel},
	{"EVENTLOG6_EVTRPCASSERTCONFIG", NDR_EVENTLOG6_EVTRPCASSERTCONFIG, api_eventlog6_EvtRpcAssertConfig},
	{"EVENTLOG6_EVTRPCRETRACTCONFIG", NDR_EVENTLOG6_EVTRPCRETRACTCONFIG, api_eventlog6_EvtRpcRetractConfig},
	{"EVENTLOG6_EVTRPCOPENLOGHANDLE", NDR_EVENTLOG6_EVTRPCOPENLOGHANDLE, api_eventlog6_EvtRpcOpenLogHandle},
	{"EVENTLOG6_EVTRPCGETLOGFILEINFO", NDR_EVENTLOG6_EVTRPCGETLOGFILEINFO, api_eventlog6_EvtRpcGetLogFileInfo},
	{"EVENTLOG6_EVTRPCGETCHANNELLIST", NDR_EVENTLOG6_EVTRPCGETCHANNELLIST, api_eventlog6_EvtRpcGetChannelList},
	{"EVENTLOG6_EVTRPCGETCHANNELCONFIG", NDR_EVENTLOG6_EVTRPCGETCHANNELCONFIG, api_eventlog6_EvtRpcGetChannelConfig},
	{"EVENTLOG6_EVTRPCPUTCHANNELCONFIG", NDR_EVENTLOG6_EVTRPCPUTCHANNELCONFIG, api_eventlog6_EvtRpcPutChannelConfig},
	{"EVENTLOG6_EVTRPCGETPUBLISHERLIST", NDR_EVENTLOG6_EVTRPCGETPUBLISHERLIST, api_eventlog6_EvtRpcGetPublisherList},
	{"EVENTLOG6_EVTRPCGETPUBLISHERLISTFORCHANNEL", NDR_EVENTLOG6_EVTRPCGETPUBLISHERLISTFORCHANNEL, api_eventlog6_EvtRpcGetPublisherListForChannel},
	{"EVENTLOG6_EVTRPCGETPUBLISHERMETADATA", NDR_EVENTLOG6_EVTRPCGETPUBLISHERMETADATA, api_eventlog6_EvtRpcGetPublisherMetadata},
	{"EVENTLOG6_EVTRPCGETPUBLISHERRESOURCEMETADATA", NDR_EVENTLOG6_EVTRPCGETPUBLISHERRESOURCEMETADATA, api_eventlog6_EvtRpcGetPublisherResourceMetadata},
	{"EVENTLOG6_EVTRPCGETEVENTMETADATAENUM", NDR_EVENTLOG6_EVTRPCGETEVENTMETADATAENUM, api_eventlog6_EvtRpcGetEventMetadataEnum},
	{"EVENTLOG6_EVTRPCGETNEXTEVENTMETADATA", NDR_EVENTLOG6_EVTRPCGETNEXTEVENTMETADATA, api_eventlog6_EvtRpcGetNextEventMetadata},
	{"EVENTLOG6_EVTRPCGETCLASSICLOGDISPLAYNAME", NDR_EVENTLOG6_EVTRPCGETCLASSICLOGDISPLAYNAME, api_eventlog6_EvtRpcGetClassicLogDisplayName},
};

void eventlog6_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_eventlog6_cmds;
	*n_fns = sizeof(api_eventlog6_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_eventlog6_init(const struct rpc_srv_callbacks *rpc_srv_cb)
{
	return rpc_srv_register(SMB_RPC_INTERFACE_VERSION, "eventlog6", "eventlog6", &ndr_table_eventlog6, api_eventlog6_cmds, sizeof(api_eventlog6_cmds) / sizeof(struct api_struct), rpc_srv_cb);
}

NTSTATUS rpc_eventlog6_shutdown(void)
{
	return rpc_srv_unregister(&ndr_table_eventlog6);
}
