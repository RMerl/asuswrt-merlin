dnl Process this file with autoconf to produce a configure script.

dnl We must use autotools 2.54 or above
AC_PREREQ(2.54)

AC_INIT([Samba],[3],[samba-technical@samba.org])

AC_CONFIG_SRCDIR([include/includes.h])
AC_CONFIG_HEADER(include/config.h)
AC_DEFINE(CONFIG_H_IS_FROM_SAMBA,1,[Marker for samba's config.h])

case "$PATH" in
    */usr/ucb*)
	AC_MSG_WARN([\$PATH contains /usr/ucb - build errors may follow])
	;;
esac 

builddir=`pwd`
AC_SUBST(builddir)

m4_include(m4/samba_version.m4)
m4_include(m4/check_path.m4)
m4_include(pkg.m4)

AC_LIBREPLACE_CC_CHECKS
AC_LIBREPLACE_RUNTIME_LIB_PATH_VAR

SAMBA_CPPFLAGS="-Iinclude -I${srcdir-.}/include  -I. -I${srcdir-.}"
SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} -I${srcdir-.}/../lib/replace"
SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} -I${srcdir-.}/librpc"
SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} -I${srcdir-.}/.."

SAMBA_CONFIGURE_CPPFLAGS="${SAMBA_CPPFLAGS} -I${srcdir-.}/../lib/popt"

## cleanup the $(srcdir) in the Makefile if we are outside of the tree
if test "x${srcdir-.}" != "x."; then
	SAMBA_CPPFLAGS=`echo ${SAMBA_CPPFLAGS} | sed -e "s;${srcdir};\$\(srcdir\);g"`
fi

dnl Unique-to-Samba variables we'll be playing with.
AC_SUBST(SAMBA_CPPFLAGS)
AC_SUBST(SHELL)
AC_SUBST(LDSHFLAGS)
AC_SUBST(SONAMEFLAG)
AC_SUBST(SHLD)
AC_SUBST(MODULE_EXPORTS)
AC_SUBST(DSO_EXPORTS)
AC_SUBST(HOST_OS)
AC_SUBST(PICFLAG)
AC_SUBST(PIE_CFLAGS)
AC_SUBST(PIE_LDFLAGS)
AC_SUBST(RELRO_LDFLAGS)
AC_SUBST(SHLIBEXT)
AC_SUBST(INSTALLLIBCMD_SH)
AC_SUBST(INSTALLLIBCMD_A)
AC_SUBST(UNINSTALLLIBCMD_SH)
AC_SUBST(UNINSTALLLIBCMD_A)

AC_SUBST(INSTALL_LIBWBCLIENT)
AC_SUBST(UNINSTALL_LIBWBCLIENT)
AC_SUBST(LIBWBCLIENT_SHARED_TARGET)
AC_SUBST(LIBWBCLIENT_SHARED_TARGET_SOVER)
AC_SUBST(LIBWBCLIENT_SHARED_TARGET_FULLVER)
AC_SUBST(LIBWBCLIENT_SHARED)
AC_SUBST(LIBWBCLIENT_STATIC_TARGET)
AC_SUBST(LIBWBCLIENT_STATIC)
AC_SUBST(LIBWBCLIENT_SOVER)
AC_SUBST(LIBWBCLIENT_FULLVER)
AC_SUBST(LIBWBCLIENT)
AC_SUBST(LIBWBCLIENT_LIBS)

AC_SUBST(LIBSAMBAUTIL_SHARED)

AC_SUBST(PRINT_LIBS)
AC_SUBST(AUTH_LIBS)
AC_SUBST(ACL_LIBS)
AC_SUBST(PASSDB_LIBS)
AC_SUBST(IDMAP_LIBS)
AC_SUBST(KRB5_LIBS)
AC_SUBST(UUID_LIBS)
AC_SUBST(LDAP_LIBS)
AC_SUBST(GPEXT_LIBS)
AC_SUBST(PAM_MODULES)
AC_SUBST(INSTALL_PAM_MODULES)
AC_SUBST(UNINSTALL_PAM_MODULES)
AC_SUBST(NSS_MODULES)
AC_SUBST(EXTRA_BIN_PROGS)
AC_SUBST(CIFSMOUNT_PROGS)
AC_SUBST(INSTALL_CIFSMOUNT)
AC_SUBST(UNINSTALL_CIFSMOUNT)
AC_SUBST(CIFSUMOUNT_PROGS)
AC_SUBST(INSTALL_CIFSUMOUNT)
AC_SUBST(UNINSTALL_CIFSUMOUNT)
AC_SUBST(CIFSUPCALL_PROGS)
AC_SUBST(INSTALL_CIFSUPCALL)
AC_SUBST(UNINSTALL_CIFSUPCALL)
AC_SUBST(EXTRA_SBIN_PROGS)
AC_SUBST(EXTRA_ALL_TARGETS)
AC_SUBST(CONFIG_LIBS)
AC_SUBST(NSCD_LIBS)

# compile with optimization and without debugging by default, but
# allow people to set their own preference.
# do this here since AC_CACHE_CHECK apparently sets the CFLAGS to "-g -O2"
# if it has no value.  This prevent *very* large debug binaries from occurring
# by default.
if test "x$debug" = "xyes" ; then
	CFLAGS="${CFLAGS} -g"
fi
if test "x$CFLAGS" = x; then
  CFLAGS="-O"
fi

m4_include(../lib/socket_wrapper/config.m4)
m4_include(../lib/nss_wrapper/config.m4)

m4_include(m4/swat.m4)

DEVELOPER_CFLAGS="-DDEBUG_PASSWORD -DDEVELOPER"

# Probe the gcc version for extra CFLAGS. We always stash these in
# DEVELOPER_CFLAGS, so that you can turn them on and off with a simple
# Makefile edit, avoiding the need to re-run configure.
if test x"$ac_cv_prog_gcc" = x"yes" ; then
	DEVELOPER_CFLAGS="${DEVELOPER_CFLAGS} -g -Wall -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings"
	# Add -Wdeclaration-after-statement if compiler supports it
	AC_CACHE_CHECK(
          [that the C compiler understands -Wdeclaration-after-statement],
          samba_cv_HAVE_Wdeclaration_after_statement, [
	  AC_TRY_RUN_STRICT([
	    int main(void)
	    {
	    	return 0;
	    }],[$CFLAGS -Wdeclaration-after-statement],[$CPPFLAGS],[$LDFLAGS],
	    samba_cv_HAVE_Wdeclaration_after_statement=yes,
	    samba_cv_HAVE_Wdeclaration_after_statement=no,
	    samba_cv_HAVE_Wdeclaration_after_statement=cross)
       ])

	if test x"$samba_cv_HAVE_Wdeclaration_after_statement" = x"yes"; then
	    DEVELOPER_CFLAGS="${DEVELOPER_CFLAGS} -Wdeclaration-after-statement"
	fi

	#-Werror-implicit-function-declaration
	AC_CACHE_CHECK(
          [that the C compiler understands -Werror-implicit-function-declaration],
          samba_cv_HAVE_Werror_implicit_function_declaration, [
	  AC_TRY_RUN_STRICT([
	    int main(void)
	    {
	    	return 0;
	    }],[$CFLAGS -Werror-implicit-function-declaration],[$CPPFLAGS],[$LDFLAGS],
	    samba_cv_HAVE_Werror_implicit_function_declaration=yes,
	    samba_cv_HAVE_Werror_implicit_function_declaration=no,
	    samba_cv_HAVE_Werror_implicit_function_declaration=cross)
       ])
       if test x"$samba_cv_HAVE_Werror_implicit_function_declaration" = x"yes"; then
	    DEVELOPER_CFLAGS="${DEVELOPER_CFLAGS} -Werror-implicit-function-declaration"
       fi

	# krb5developer is like developer, except we don't get
	# -Wstrict-prototypes.
       if test x"$krb5_developer" != x"$yes" ; then
	    DEVELOPER_CFLAGS="$DEVELOPER_CFLAGS -Wstrict-prototypes"
       fi

       if test x"$picky_developer" = x"yes"; then
	    DEVELOPER_CFLAGS="$DEVELOPER_CFLAGS -Werror"
       fi
fi

#################################################
# check for a shared memory profiling support
AC_MSG_CHECKING(whether to use profiling)
AC_ARG_WITH(profiling-data,
[AS_HELP_STRING([--with-profiling-data], [Include gathering source code profile information (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    AC_DEFINE(WITH_PROFILE,1,[Whether to use profiling])
    samba_cv_WITH_PROFILE=yes
    ;;
  *)
    AC_MSG_RESULT(no)
    samba_cv_WITH_PROFILE=no
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

dnl Checks for programs.
AC_ARG_ENABLE(smbtorture4,
	[AS_HELP_STRING([--enable-smbtorture4], [Enable building smbtorture4 (default=auto)])])

if test x$enable_smbtorture4 != xno; then
	smbtorture4_possible=yes
else
	smbtorture4_possible=no
fi

AC_PROG_INSTALL
AC_PROG_AWK
# Check for GNU make
m4_include(../m4/check_make.m4)
AC_SAMBA_GNU_MAKE([true], [true])

# Check for perl
m4_include(../m4/check_perl.m4)
AC_SAMBA_PERL([true], [smbtorture4_possible=no])

# Check for python
m4_include(../m4/check_python.m4)
AC_SAMBA_PYTHON_DEVEL([true], [smbtorture4_possible=no])

AC_CHECK_TOOL(AR, ar)

dnl Check if we (actually our C compiler!) use GNU ld
AC_PROG_LD_GNU

dnl Certain versions of GNU ld the default is not to have the
dnl --allow-shlib-undefined flag defined.  This causes a stackload of
dnl warnings when building modules.
if test "$ac_cv_prog_gnu_ld" = "yes"; then
	ac_cv_gnu_ld_version=`$CC -Wl,-v /dev/null 2> /dev/null < /dev/null | grep "GNU ld"`
	# we need to make a 2nd (separate!) check on the output of stderr, see bug #7825:
	if test -z "$ac_cv_gnu_ld_version" ; then
	  ac_cv_gnu_ld_version=`$CC -Wl,-v /dev/null 2>&1 > /dev/null < /dev/null | grep "GNU ld"`
	fi
	AC_MSG_CHECKING(GNU ld release date)
	changequote(,)dnl
	ac_cv_gnu_ld_date=`echo $ac_cv_gnu_ld_version | sed -n 's,^.*\([2-9][0-9][0-9][0-9]\)[-]*\([01][0-9]\)[-]*\([0-3][0-9]\).*$,\1\2\3,p'`
	changequote([,])dnl
	AC_MSG_RESULT(${ac_cv_gnu_ld_date})
        if test -n "$ac_cv_gnu_ld_date"; then
 	if test "$ac_cv_gnu_ld_date" -lt 20030217; then
 		ac_cv_gnu_ld_no_default_allow_shlib_undefined=yes
 	fi
	if test "$ac_cv_gnu_ld_date" -gt 20030101; then
		ac_cv_gnu_ld_version_script=yes
	fi
        else
           AC_MSG_CHECKING(GNU ld release version)
           changequote(,)dnl
           ac_cv_gnu_ld_vernr=`echo $ac_cv_gnu_ld_version | awk '{print $NF}' | sed -n 's,\([1-9][0-9]*\.[0-9][0-9]*\).*$,\1,p'`
           ac_cv_gnu_ld_vernr_major=`echo $ac_cv_gnu_ld_vernr | cut -d '.' -f 1`
           ac_cv_gnu_ld_vernr_minor=`echo $ac_cv_gnu_ld_vernr | cut -d '.' -f 2`
           changequote([,])dnl
           AC_MSG_RESULT(${ac_cv_gnu_ld_vernr})
           AC_MSG_CHECKING(GNU ld release version major)
           AC_MSG_RESULT(${ac_cv_gnu_ld_vernr_major})
           AC_MSG_CHECKING(GNU ld release version minor)
           AC_MSG_RESULT(${ac_cv_gnu_ld_vernr_minor})
           if test "$ac_cv_gnu_ld_vernr_major" -lt 2 || test "$ac_cv_gnu_ld_vernr_minor" -lt 14; then
             ac_cv_gnu_ld_no_default_allow_shlib_undefined=yes
           fi
           if test "$ac_cv_gnu_ld_vernr_major" -gt 2 || test "$ac_cv_gnu_ld_vernr_major" = 2 && test "$ac_cv_gnu_ld_vernr_minor" -ge 12; then
             ac_cv_gnu_ld_version_script=yes
           fi
        fi
fi

dnl look for executable suffix
AC_EXEEXT

dnl Check if C compiler understands -c and -o at the same time
AC_PROG_CC_C_O
if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = no"; then
      BROKEN_CC=
else
      BROKEN_CC=#
fi
AC_SUBST(BROKEN_CC)

dnl Check if the C compiler understands -Werror (GNU)
AC_CACHE_CHECK([that the C compiler understands -Werror],samba_cv_HAVE_Werror, [
 AC_TRY_RUN_STRICT([
  int main(void)
  {
  	return 0;
  }],[$CFLAGS -Werror],[$CPPFLAGS],[$LDFLAGS],
  samba_cv_HAVE_Werror=yes,samba_cv_HAVE_Werror=no,samba_cv_HAVE_Werror=cross)])
if test x"$samba_cv_HAVE_Werror" = x"yes"; then
   Werror_FLAGS="-Werror"
else
dnl Check if the C compiler understands -w2
AC_CACHE_CHECK([that the C compiler understands -w2],samba_cv_HAVE_w2, [
 AC_TRY_RUN_STRICT([
  int main(void)
  {
  	return 0;
  }],[$CFLAGS -w2],[$CPPFLAGS],[$LDFLAGS],
  samba_cv_HAVE_w2=yes,samba_cv_HAVE_w2=no,samba_cv_HAVE_w2=cross)])
if test x"$samba_cv_HAVE_w2" = x"yes"; then
   Werror_FLAGS="-w2"
else
dnl Check if the C compiler understands -errwarn (Sun)
AC_CACHE_CHECK([that the C compiler understands -errwarn],samba_cv_HAVE_errwarn, [
  AC_TRY_RUN_STRICT([
   int main(void)
   {
	return 0;
   }],[$CFLAGS -errwarn=%all],[$CPPFLAGS],[$LDFLAGS],
   samba_cv_HAVE_errwarn=yes,samba_cv_HAVE_errwarn=no,samba_cv_HAVE_errwarn=cross)])
if test x"$samba_cv_HAVE_errwarn" = x"yes"; then
   Werror_FLAGS="-errwarn=%all"
else
dnl Check if the C compiler understands -qhalt (IBM)
AC_CACHE_CHECK([that the C compiler understands -qhalt],samba_cv_HAVE_qhalt, [
  AC_TRY_RUN_STRICT([
   int main(void)
   {
	return 0;
   }],[$CFLAGS -qhalt=w],[$CPPFLAGS],[$LDFLAGS],
   samba_cv_HAVE_qhalt=yes,samba_cv_HAVE_qhalt=no,samba_cv_HAVE_qhalt=cross)])
if test x"$samba_cv_HAVE_qhalt" = x"yes"; then
   Werror_FLAGS="-qhalt=w"
fi
fi
fi
fi

############################################
# check if the compiler can handle negative enum values
# and don't truncate the values to INT_MAX
# a runtime test is needed here
AC_SUBST(PIDL_ARGS)
AC_CACHE_CHECK([that the C compiler understands negative enum values],samba_cv_CC_NEGATIVE_ENUM_VALUES, [
    AC_TRY_RUN(
[
	#include <stdio.h>
	enum negative_values { NEGATIVE_VALUE = 0xFFFFFFFF };
	int main(void) {
		enum negative_values v1 = NEGATIVE_VALUE;
		unsigned v2 = NEGATIVE_VALUE;

		if (v1 != 0xFFFFFFFF) {
			printf("%u != 0xFFFFFFFF\n", v1);
			return 1;
		}
		if (v2 != 0xFFFFFFFF) {
			printf("%u != 0xFFFFFFFF\n", v2);
			return 1;
		}

		return 0;
	}
],
	samba_cv_CC_NEGATIVE_ENUM_VALUES=yes,samba_cv_CC_NEGATIVE_ENUM_VALUES=no)])
if test x"$samba_cv_CC_NEGATIVE_ENUM_VALUES" != x"yes"; then
	AC_MSG_WARN([using --uint-enums for pidl])
	PIDL_ARGS="$PIDL_ARGS --uint-enums"
fi

dnl Figure out the flags to support named structure initializers

LIBREPLACE_C99_STRUCT_INIT([],[AC_MSG_ERROR([c99 structure initializer are not supported])])

UNAME_S=`(uname -s) 2>/dev/null` || UNAME_S="unknown"
AC_MSG_CHECKING(uname -s)
AC_MSG_RESULT(${UNAME_S})

UNAME_R=`(uname -r) 2>/dev/null` || UNAME_R="unknown"
AC_MSG_CHECKING(uname -r)
AC_MSG_RESULT(${UNAME_R})

UNAME_M=`(uname -m) 2>/dev/null` || UNAME_M="unknown"
AC_MSG_CHECKING(uname -m)
AC_MSG_RESULT(${UNAME_M})

UNAME_P=`(uname -p) 2>/dev/null` || UNAME_P="unknown"
AC_MSG_CHECKING(uname -p)
AC_MSG_RESULT(${UNAME_P})

UNAME_I=`(uname -i) 2>/dev/null` || UNAME_I="unknown"
AC_MSG_CHECKING(uname -i)
AC_MSG_RESULT(${UNAME_I})

dnl Add #include for broken IRIX header files
  case "$host_os" in
	*irix6*)
		#TODO add to libreplace
		if test x"$ac_cv_prog_gcc" != x"yes" ; then
			dnl Fix sensible defaults for MIPSPro compilers. The
			dnl error numbers are valid for the 7.3 compilers,
			dnl hopefully also valid for the 7.4 series.
			dnl
			dnl Bugzilla 3801. Force an error on warning 1035
			dnl so we don't incorrectly detect stdint.h. This
			dnl warning is emitted for #error directives.
			CFLAGS="$CFLAGS -diag_error 1035"
			dnl 1209: Controlling expression is constant
			dnl 1174: Function foo declared but never referenced
			dnl 3201: Parameter foo was never referenced
			CFLAGS="$CFLAGS -woff 1209,1174,3201"
		fi
	;;
esac

DYNEXP=
AC_SUBST(DYNEXP)
LDSHFLAGS_Z_DEFS=
AC_SUBST(LDSHFLAGS_Z_DEFS)
LDSHFLAGS_Z_NODEFS=
AC_SUBST(LDSHFLAGS_Z_NODEFS)

dnl Add modules that have to be built by default here
dnl These have to be built static:
default_static_modules=""
default_static_modules="$default_static_modules pdb_smbpasswd"
default_static_modules="$default_static_modules pdb_tdbsam"
default_static_modules="$default_static_modules pdb_wbc_sam"
default_static_modules="$default_static_modules rpc_lsarpc"
default_static_modules="$default_static_modules rpc_samr"
default_static_modules="$default_static_modules rpc_winreg"
default_static_modules="$default_static_modules rpc_initshutdown"
default_static_modules="$default_static_modules rpc_dssetup"
default_static_modules="$default_static_modules rpc_wkssvc"
default_static_modules="$default_static_modules rpc_svcctl"
default_static_modules="$default_static_modules rpc_ntsvcs"
default_static_modules="$default_static_modules rpc_netlogon"
default_static_modules="$default_static_modules rpc_netdfs"
default_static_modules="$default_static_modules rpc_srvsvc"
default_static_modules="$default_static_modules rpc_spoolss"
default_static_modules="$default_static_modules rpc_eventlog"
default_static_modules="$default_static_modules auth_sam"
default_static_modules="$default_static_modules auth_unix"
default_static_modules="$default_static_modules auth_winbind"
default_static_modules="$default_static_modules auth_wbc"
default_static_modules="$default_static_modules auth_server"
default_static_modules="$default_static_modules auth_domain"
default_static_modules="$default_static_modules auth_builtin"
default_static_modules="$default_static_modules vfs_default"
default_static_modules="$default_static_modules nss_info_template"

dnl These are preferably build shared, and static if dlopen() is not available
default_shared_modules=""
default_shared_modules="$default_shared_modules vfs_recycle"
default_shared_modules="$default_shared_modules vfs_audit"
default_shared_modules="$default_shared_modules vfs_extd_audit"
default_shared_modules="$default_shared_modules vfs_full_audit"
default_shared_modules="$default_shared_modules vfs_netatalk"
default_shared_modules="$default_shared_modules vfs_fake_perms"
default_shared_modules="$default_shared_modules vfs_default_quota"
default_shared_modules="$default_shared_modules vfs_readonly"
default_shared_modules="$default_shared_modules vfs_cap"
default_shared_modules="$default_shared_modules vfs_expand_msdfs"
default_shared_modules="$default_shared_modules vfs_shadow_copy"
default_shared_modules="$default_shared_modules vfs_shadow_copy2"
default_shared_modules="$default_shared_modules charset_CP850"
default_shared_modules="$default_shared_modules charset_CP437"
default_shared_modules="$default_shared_modules auth_script"
default_shared_modules="$default_shared_modules vfs_readahead"
default_shared_modules="$default_shared_modules vfs_xattr_tdb"
default_shared_modules="$default_shared_modules vfs_streams_xattr"
default_shared_modules="$default_shared_modules vfs_streams_depot"
default_shared_modules="$default_shared_modules vfs_acl_xattr"
default_shared_modules="$default_shared_modules vfs_acl_tdb"
default_shared_modules="$default_shared_modules vfs_smb_traffic_analyzer"
default_shared_modules="$default_shared_modules vfs_preopen"
default_shared_modules="$default_shared_modules vfs_catia"
default_shared_modules="$default_shared_modules vfs_scannedonly"
default_shared_modules="$default_shared_modules vfs_crossrename"
default_shared_modules="$default_shared_modules vfs_linux_xfs_sgid"
default_shared_modules="$default_shared_modules vfs_time_audit"
default_shared_modules="$default_shared_modules idmap_autorid"

if test "x$developer" = xyes; then
   default_static_modules="$default_static_modules rpc_rpcecho pdb_ads"
   default_static_modules="$default_static_modules auth_netlogond"
   default_shared_modules="$default_shared_modules charset_weird perfcount_test"
fi

#
# Config CPPFLAG settings for strange OS's that must be set
# before other tests. Do NOT invoke AC_CHECK_HEADERS within this
# case statement; its first reference must be unconditional.
#
case "$host_os" in
    *hpux*)
#
# Defines needed for HPUX support.
# HPUX has bigcrypt but (sometimes?) doesn't use it for
# password hashing - hence the USE_BOTH_CRYPT_CALLS define.
#
      case `uname -r` in
		*9*|*10*|*11)
			AC_DEFINE(USE_BOTH_CRYPT_CALLS, 1, [Whether to use both of HPUX' crypt calls])
		;;
      esac
      ;;

#
# CRAY Unicos has broken const handling
       *unicos*)
	  AC_MSG_RESULT([disabling const])
	  CPPFLAGS="$CPPFLAGS -Dconst="
	  ;;
	
#
# AIX4.x doesn't even admit to having large
# files *at all* unless the -D_LARGE_FILE or -D_LARGE_FILE_API flags are set.
#
    *aix4*)
	  AC_MSG_RESULT([enabling large file support])
      CPPFLAGS="$CPPFLAGS -D_LARGE_FILES"
	  AC_DEFINE(_LARGE_FILES, 1, [Whether to enable large file support])
      ;;
#
# Defines needed for Solaris 2.6/2.7 aka 7.0 to make it admit
# to the existance of large files..
# Note that -D_LARGEFILE64_SOURCE is different from the Sun
# recommendations on large file support, however it makes the
# compile work using gcc 2.7 and 2.8, whereas using the Sun
# recommendation makes the compile fail on gcc2.7. JRA.
#
# Solaris uses SYSV printing.  Make sure to set that here.  --jerry
#
	*solaris*)
		AC_DEFINE(SYSV, 1, [Whether to enable System V compatibility])
		case `uname -r` in
			5.0|5.0.*|5.1|5.1.*|5.2|5.2.*|5.3|5.3.*|5.5|5.5.*)
	  			AC_MSG_RESULT([no large file support])
				;;
			5.*)
			LDFLAGS="$LDFLAGS -lthread"
			CPPFLAGS="$CPPFLAGS -D_REENTRANT"
			AC_MSG_RESULT([enabling large file support])
			if test "$ac_cv_prog_gcc" = yes; then
				${CC-cc} -v >conftest.c 2>&1
				ac_cv_gcc_compiler_version_number=`grep 'gcc version' conftest.c`
				rm -fr conftest.c
				case "$ac_cv_gcc_compiler_version_number" in
					*"gcc version 2.6"*|*"gcc version 2.7"*)
						CPPFLAGS="$CPPFLAGS -D_LARGEFILE64_SOURCE"
						AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
						;;
					*)
						CPPFLAGS="$CPPFLAGS -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
						AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
						AC_DEFINE(_FILE_OFFSET_BITS, 64, [File offset bits])
						;;
				esac
			else
				CPPFLAGS="$CPPFLAGS -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
				AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
				AC_DEFINE(_FILE_OFFSET_BITS, 64, [File offset bits])
			fi
			;;
		esac
		;;
#
# IRIX uses SYSV printing.  Make sure to set that here
#
	*irix*)
		AC_DEFINE(SYSV, 1, [Whether to enable System V compatibility])
		;;
	*freebsd*|*dragonfly*)
		AC_DEFINE(FREEBSD, 1, [Whether the host os is FreeBSD])
		;;
#
# VOS may need to have POSIX support and System V compatibility enabled.
#
    *vos*)
    case "$CPPFLAGS" in
	  *-D_POSIX_C_SOURCE*)
		;;
	  *)
		CPPFLAGS="$CPPFLAGS -D_POSIX_C_SOURCE=200112L"
		AC_DEFINE(_POSIX_C_SOURCE, 200112L, [Whether to enable POSIX support])
		;;
    esac
    case "$CPPFLAGS" in
	  *-D_SYSV*|*-D_SVID_SOURCE*)
		;;
	  *)
		CPPFLAGS="$CPPFLAGS -D_SYSV"
		AC_DEFINE(_SYSV, 1, [Whether to enable System V compatibility])
    esac
    ;;
#
# Tests needed for SINIX large file support.
#
    *sysv4*)
      if test $host = mips-sni-sysv4 ; then
        AC_MSG_CHECKING([for LFS support])
        old_CPPFLAGS="$CPPFLAGS"
        CPPFLAGS="-D_LARGEFILE64_SOURCE $CPPFLAGS"
        AC_TRY_RUN([
#include <unistd.h>
main () {
#if _LFS64_LARGEFILE == 1
exit(0);
#else
exit(1);
#endif
}], [SINIX_LFS_SUPPORT=yes], [SINIX_LFS_SUPPORT=no], [SINIX_LFS_SUPPORT=cross])
        CPPFLAGS="$old_CPPFLAGS"
        if test x$SINIX_LFS_SUPPORT = xyes ; then
          CPPFLAGS="-D_LARGEFILE64_SOURCE $CPPFLAGS"
		  AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
          CFLAGS="`getconf LFS64_CFLAGS` $CFLAGS"
          LDFLAGS="`getconf LFS64_LDFLAGS` $LDFLAGS"
          LIBS="`getconf LFS64_LIBS` $LIBS"
        fi
      AC_MSG_RESULT([$SINIX_LFS_SUPPORT])
      fi
    ;;

# Systems with LFS support.
#
    gnu* | k*bsd*-gnu | kopensolaris*-gnu)
	CPPFLAGS="-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE $CPPFLAGS"
	AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
	AC_DEFINE(_FILE_OFFSET_BITS, 64, [File offset bits])
	AC_DEFINE(_GNU_SOURCE, 1, [Whether to use GNU libc extensions])
	;;

# Tests for linux LFS support. Need kernel 2.4 and glibc2.2 or greater support.
#
    *linux*)
        AC_MSG_CHECKING([for LFS support])
        old_CPPFLAGS="$CPPFLAGS"
        CPPFLAGS="-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE $CPPFLAGS"
       AC_TRY_RUN([
#include <unistd.h>
#include <sys/utsname.h>
#include <string.h>
#include <stdlib.h>
main() {
#if _LFS64_LARGEFILE == 1
       struct utsname uts;
       char *release;
       int major, minor;

       /* Ensure this is glibc 2.2 or higher */
#if defined(__GLIBC__) && defined(__GLIBC_MINOR__)
       int libc_major = __GLIBC__;
       int libc_minor = __GLIBC_MINOR__;

       if (libc_major < 2)
              exit(1);
       if (libc_minor < 2)
              exit(1);
#endif

       /* Ensure this is kernel 2.4 or higher */

       uname(&uts);
       release = strdup(uts.release);
       major = atoi(strsep(&release, "."));
       minor = atoi(strsep(&release, "."));

       if (major > 2 || (major == 2 && minor > 3))
               exit(0);
       exit(1);
#else
       exit(1);
#endif
}
], [LINUX_LFS_SUPPORT=yes], [LINUX_LFS_SUPPORT=no], [LINUX_LFS_SUPPORT=cross])
	CPPFLAGS="$old_CPPFLAGS"
	if test x$LINUX_LFS_SUPPORT = xyes ; then
		CPPFLAGS="-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE $CPPFLAGS"
		AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
		AC_DEFINE(_FILE_OFFSET_BITS, 64, [File offset bits])
		AC_DEFINE(_GNU_SOURCE, 1, [Whether to use GNU libc extensions])
	fi
	AC_MSG_RESULT([$LINUX_LFS_SUPPORT])
	;;

#
# MacOS X is the *only* system that uses compose character in utf8. This
# is so horribly broken....
#
    *darwin*)
	AC_DEFINE(BROKEN_UNICODE_COMPOSE_CHARACTERS, 1, [Does this system use unicode compose characters])

# Add a system specific charset module.
	default_shared_modules="$default_shared_modules charset_macosxfs"

	;;
    *hurd*)
        AC_MSG_CHECKING([for LFS support])
        old_CPPFLAGS="$CPPFLAGS"
        CPPFLAGS="-D_LARGEFILE64_SOURCE -D_GNU_SOURCE $CPPFLAGS"
        AC_TRY_RUN([
#include <unistd.h>
main () {
#if _LFS64_LARGEFILE == 1
exit(0);
#else
exit(1);
#endif
}], [GLIBC_LFS_SUPPORT=yes], [GLIBC_LFS_SUPPORT=no], [GLIBC_LFS_SUPPORT=cross])
        CPPFLAGS="$old_CPPFLAGS"
        if test x$GLIBC_LFS_SUPPORT = xyes ; then
          CPPFLAGS="-D_LARGEFILE64_SOURCE -D_GNU_SOURCE $CPPFLAGS"
		  AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
          AC_DEFINE(_GNU_SOURCE, 1, [Whether to use GNU libc extensions])
        fi
      AC_MSG_RESULT([$GLIBC_LFS_SUPPORT])
    ;;
    *qnx*)
        CPPFLAGS="-D_LARGEFILE64_SOURCE $CPPFLAGS"
        AC_DEFINE(_LARGEFILE64_SOURCE, 1, [Whether to enable large file support])
        ;;

esac

SAVE_CPPFLAGS="${CPPFLAGS}"
CPPFLAGS="${CPPFLAGS} ${SAMBA_CONFIGURE_CPPFLAGS}"

AC_LIBREPLACE_BROKEN_CHECKS
AC_CHECK_FUNCS([syslog],[],[AC_MSG_ERROR([Required function not found])])
AC_LIBREPLACE_NETWORK_CHECKS

CPPFLAGS="${SAVE_CPPFLAGS}"

LIBREPLACE_DIR=`echo ${libreplacedir} | sed -e "s;${srcdir};;" -e "s;^/;;"`

LIBREPLACE_OBJS="${LIBREPLACEOBJ}"
AC_SUBST(LIBREPLACE_OBJS)

LIBREPLACE_LIBS="${LIBREPLACE_NETWORK_LIBS}"
AC_SUBST(LIBREPLACE_LIBS)


# add -ldl to the global LIBS
LIBS="${LIBS} ${LIBDL} ${LIBREPLACE_NETWORK_LIBS}"
AUTH_LIBS="${AUTH_LIBS} ${CRYPT_LIBS}"


AC_CHECK_HEADERS(aio.h sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h rpc/nettype.h)
AC_CHECK_HEADERS(unistd.h grp.h sys/id.h memory.h alloca.h)
AC_CHECK_HEADERS(limits.h float.h libintl.h)
AC_CHECK_HEADERS(rpc/rpc.h rpcsvc/nis.h rpcsvc/ypclnt.h)
AC_CHECK_HEADERS(sys/param.h ctype.h sys/wait.h sys/resource.h sys/ioctl.h sys/ipc.h sys/prctl.h sys/sysctl.h)
AC_CHECK_HEADERS(sys/mman.h sys/filio.h sys/priv.h sys/shm.h string.h strings.h stdlib.h)
AC_CHECK_HEADERS(sys/mount.h sys/vfs.h sys/fs/s5param.h sys/filsys.h termios.h termio.h)
AC_CHECK_HEADERS(sys/termio.h sys/statfs.h sys/dustat.h sys/statvfs.h stdarg.h)
AC_CHECK_HEADERS(sys/sysmacros.h)
AC_CHECK_HEADERS(sys/syslog.h syslog.h)
AC_CHECK_HEADERS(langinfo.h locale.h)
AC_CHECK_HEADERS(xfs/libxfs.h)
AC_CHECK_HEADERS(netgroup.h)
AC_CHECK_HEADERS(linux/falloc.h)

dnl check for OS implementation of md5 conformant to rfc1321
samba_cv_md5lib=none

AC_CHECK_LIB(c, MD5Update, [samba_cv_md5lib=""])

if test x"$samba_cv_md5lib" = x"none" ; then
	AC_CHECK_LIB(md, MD5Update, [samba_cv_md5lib=md])
fi

if test x"$samba_cv_md5lib" = x"none" ; then
	AC_CHECK_LIB(md5, MD5Update, [samba_cv_md5lib=md5])
fi

if test x"$samba_cv_md5lib" != x"none" ; then
	AC_CHECK_HEADERS(md5.h)
fi

CRYPTO_MD5_OBJ="../lib/crypto/md5.o"
if test x"$ac_cv_header_md5_h" = x"yes" -a \
        x"$samba_cv_md5lib" != x"none" ; then
	if test x"$samba_cv_md5lib" != x ; then
		LIBS="${LIBS} -l${samba_cv_md5lib}"
		AC_DEFINE(HAVE_LIBMD5, 1,
				  [Whether libmd5 conformant to rfc1321 is available.])
	fi
	CRYPTO_MD5_OBJ=
fi

AC_SUBST(CRYPTO_MD5_OBJ)


AC_CHECK_HEADERS(rpcsvc/yp_prot.h,,,[[
#if HAVE_RPC_RPC_H
#include <rpc/rpc.h>
#endif
]])

## These fail to compile on IRIX so just check for their presence
AC_CHECK_HEADERS(sys/mode.h,,,)

# Look for Darwin headers
old_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="-Iinclude $CPPFLAGS"
AC_CHECK_HEADERS([CoreFoundation/CFStringEncodingConverter.h], [], [AC_CHECK_HEADERS([CFStringEncodingConverter.h])])
CPPFLAGS="$old_CPPFLAGS"

# In valgrind 1.0.x, it's just valgrind.h.  In 1.9.x+ there's a
# subdirectory of headers.
AC_CHECK_HEADERS(valgrind.h valgrind/valgrind.h valgrind/memcheck.h)

if test x"$enable_developer" = x"yes" ; then
   if test x"$ac_cv_header_valgrind_h" = xyes -o \
           x"$ac_cv_header_valgrind_valgrind_h" = xyes ; then
      AC_DEFINE(VALGRIND,1,[Whether we have valgrind headers])
   fi
fi

#
# HPUX has a bug in that including shadow.h causes a re-definition of MAXINT.
# This causes configure to fail to detect it. Check for shadow separately on HPUX.
#
case "$host_os" in
    *hpux*)
		AC_TRY_COMPILE([#include <shadow.h>],[struct spwd testme],
			ac_cv_header_shadow_h=yes,ac_cv_header_shadow_h=no)
		if test x"$ac_cv_header_shadow_h" = x"yes"; then
		   AC_DEFINE(HAVE_SHADOW_H,1,[Whether we have shadow.h])
		fi
	;;
esac
AC_CHECK_HEADERS(shadow.h)
AC_CHECK_HEADERS(nss.h nss_common.h nsswitch.h ns_api.h sys/security.h)
AC_CHECK_HEADERS(syscall.h sys/syscall.h)

AC_CHECK_HEADERS(sys/attributes.h attr/xattr.h sys/xattr.h sys/extattr.h sys/uio.h)
AC_CHECK_HEADERS(sys/ea.h sys/proplist.h)

AC_CHECK_HEADERS(sys/cdefs.h glob.h)

# For experimental utmp support (lastlog on some BSD-like systems)
AC_CHECK_HEADERS(utmp.h utmpx.h lastlog.h)

AC_CHECK_SIZEOF(int,cross)
AC_CHECK_SIZEOF(long,cross)
AC_CHECK_SIZEOF(long long,cross)
AC_CHECK_SIZEOF(short,cross)

AC_C_CONST
AC_C_INLINE
AC_C_BIGENDIAN
AC_C_CHAR_UNSIGNED

AC_TYPE_SIGNAL
AC_TYPE_UID_T
AC_TYPE_MODE_T
AC_TYPE_OFF_T
AC_TYPE_SIZE_T
AC_TYPE_PID_T
AC_STRUCT_ST_RDEV
AC_DIRENT_D_OFF
AC_CHECK_TYPE(ssize_t, int)
AC_CHECK_TYPE(wchar_t, unsigned short)

############################################
# for cups support we need libcups, and a handful of header files

AC_ARG_ENABLE(cups,
[AS_HELP_STRING([--enable-cups], [Turn on CUPS support (default=auto)])])

if test x$enable_cups != xno; then
	AC_PATH_PROG(CUPS_CONFIG, cups-config)

        if test "x$CUPS_CONFIG" != x; then

		ac_save_LDFLAGS=$LDFLAGS
		ac_save_PRINT_LIBS=$PRINT_LIBS
		AC_CHECK_HEADERS(cups/cups.h cups/language.h)

		if test x"$ac_cv_header_cups_cups_h" = xyes -a \
		        x"$ac_cv_header_cups_language_h" = xyes; then
			# try linking with -lcups alone first. That should work unless libcups is
			# underlinked. With cups-config --libs we pull in unwanted and unneeded
			# dendencies including thread libraries - use cups-config only if really
			# required. 
			AC_CHECK_LIB_EXT(cups, ac_save_PRINT_LIBS , httpConnect,
				[PRINT_LIBS="$ac_save_PRINT_LIBS -lcups"],
				[AC_MSG_WARN([your cups library doesn't link with -lcups alone, it might be underlinked.]) ;
				 PRINT_LIBS="$ac_save_PRINT_LIBS `$CUPS_CONFIG --libs`"])

			AC_DEFINE(HAVE_CUPS,1,[Whether we have CUPS])
			samba_cv_HAVE_CUPS=yes
			AC_CHECK_LIB_EXT(cups, PRINT_LIBS, httpConnectEncrypt)
		else
			AC_MSG_WARN([cups-config around but cups-devel not installed])
			CFLAGS=$ac_save_CFLAGS
			LDFLAGS=$ac_save_LDFLAGS
			PRINT_LIBS=$ac_save_PRINT_LIBS
		fi

	elif test x"$enable_cups" = x"yes"; then
		AC_MSG_ERROR(Cups support required but cups-config not located.  Make sure cups-devel related files are installed.)
        fi
fi

AC_ARG_ENABLE(iprint,
[AS_HELP_STRING([--enable-iprint], [Turn on iPrint support (default=yes if cups is yes)])])

if test x$enable_iprint != xno; then
	if test x"$samba_cv_HAVE_CUPS" = xyes; then
                AC_DEFINE(HAVE_IPRINT,1,[Whether we have iPrint])
	elif test x"$enable_iprint" = x"yes"; then
		AC_MSG_ERROR(iPrint support required but cups not enabled.  Make sure cups-devel related files are installed and that cups is enabled.)
        fi
fi

############################################
# check if the compiler will optimize out function calls
AC_CACHE_CHECK([if the compiler will optimize out function calls],samba_cv_optimize_out_funcation_calls, [
    AC_TRY_LINK([
#include <stdio.h>],
[
		if (0) {
		   this_function_does_not_exist();
		} else {
		  return 1;
		}

],
	samba_cv_optimize_out_funcation_calls=yes,samba_cv_optimize_out_funcation_calls=no)])
if test x"$samba_cv_optimize_out_funcation_calls" = x"yes"; then
   AC_DEFINE(HAVE_COMPILER_WILL_OPTIMIZE_OUT_FNS,1,[Whether the compiler will optimize out function calls])
fi

#############################################
# check for fd passing struct via msg_control
AC_CACHE_CHECK([for fd passing via msg_control],samba_cv_msghdr_msg_control, [
    AC_TRY_COMPILE([
#include <sys/types.h>
#include <stdlib.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/un.h>],
[
	struct msghdr msg;
	union {
	      struct cmsghdr cm;
	      char control[CMSG_SPACE(sizeof(int))];
	} control_un;
	msg.msg_control = control_un.control;
	msg.msg_controllen = sizeof(control_un.control);
],
	samba_cv_msghdr_msg_control=yes,samba_cv_msghdr_msg_control=no)])
if test x"$samba_cv_msghdr_msg_control" = x"yes"; then
   AC_DEFINE(HAVE_MSGHDR_MSG_CONTROL,1,
	     [If we can use msg_control for passing file descriptors])
fi

#############################################
# check for fd passing struct via msg_acctrights
AC_CACHE_CHECK([for fd passing via msg_acctrights],
		samba_cv_msghdr_msg_acctrights, [
    AC_TRY_COMPILE([
#include <sys/types.h>
#include <stdlib.h>
#include <stddef.h>
#include <sys/socket.h>
#include <sys/un.h>],
[
	struct msghdr msg;
	int fd;
	msg.msg_acctrights = (caddr_t) &fd;
	msg.msg_acctrightslen = sizeof(fd);
],
	samba_cv_msghdr_msg_acctrights=yes,samba_cv_msghdr_msg_acctrights=no)])
if test x"$samba_cv_msghdr_msg_acctrights" = x"yes"; then
   AC_DEFINE(HAVE_MSGHDR_MSG_ACCTRIGHTS,1,
	     [If we can use msg_acctrights for passing file descriptors])
fi

AC_CHECK_FUNCS(dirfd)
if test x"$ac_cv_func_dirfd" = x"yes"; then
	default_shared_modules="$default_shared_modules vfs_syncops vfs_dirsort"
fi

AC_CACHE_CHECK([for struct sigevent type],samba_cv_struct_sigevent, [
    AC_TRY_COMPILE([
#include <sys/types.h>
#if STDC_HEADERS
#include <stdlib.h>
#include <stddef.h>
#endif
#include <signal.h>],[struct sigevent s;],
	samba_cv_struct_sigevent=yes,samba_cv_struct_sigevent=no)])
if test x"$samba_cv_struct_sigevent" = x"yes"; then
   AC_DEFINE(HAVE_STRUCT_SIGEVENT,1,[Whether we have the struct sigevent])
   AC_CHECK_MEMBERS([struct sigevent.sigev_value.sival_ptr,struct sigevent.sigev_value.sigval_ptr], , ,
	[#include <signal.h>])
fi

# and glibc has setresuid under linux but the function does
# nothing until kernel 2.1.44! very dumb.
AC_CACHE_CHECK([for real setresuid],samba_cv_have_setresuid,[
    AC_TRY_RUN([#include <errno.h>
main() { setresuid(1,1,1); setresuid(2,2,2); exit(errno==EPERM?0:1);}],
	samba_cv_have_setresuid=yes,samba_cv_have_setresuid=no,samba_cv_have_setresuid=cross)])
if test x"$samba_cv_have_setresuid" = x"yes"; then
    AC_DEFINE(HAVE_SETRESUID,1,[Whether the system has setresuid])
fi

# Do the same check for setresguid...
#
AC_CACHE_CHECK([for real setresgid],samba_cv_have_setresgid,[
    AC_TRY_RUN([#include <unistd.h>
#include <errno.h>
main() { errno = 0; setresgid(1,1,1); exit(errno != 0 ? (errno==EPERM ? 0 : 1) : 0);}],
	samba_cv_have_setresgid=yes,samba_cv_have_setresgid=no,samba_cv_have_setresgid=cross)])
if test x"$samba_cv_have_setresgid" = x"yes"; then
    AC_DEFINE(HAVE_SETRESGID,1,[Whether the system has setresgid])
fi

AC_FUNC_MEMCMP

###############################################
# Readline included by default unless explicitly asked not to
test "${with_readline+set}" != "set" && with_readline=yes

# test for where we get readline() from
AC_MSG_CHECKING(whether to use readline)
AC_ARG_WITH(readline,
[AS_HELP_STRING([--with-readline[=DIR]], [Look for readline include/libs in DIR (default=auto)])],
[  case "$with_readline" in
  yes)
    AC_MSG_RESULT(yes)

    AC_CHECK_HEADERS(readline.h history.h readline/readline.h)
    AC_CHECK_HEADERS(readline/history.h)

    AC_CHECK_HEADERS(readline.h readline/readline.h,[
      for termlib in ncurses curses termcap terminfo termlib tinfo; do
       AC_CHECK_LIB(${termlib}, tgetent, [TERMLIBS="-l${termlib}"; break])
      done
      AC_CHECK_LIB(readline, rl_callback_handler_install,
       [TERMLIBS="-lreadline $TERMLIBS"
       AC_DEFINE(HAVE_LIBREADLINE,1,[Whether the system has readline])
       break], [TERMLIBS=], $TERMLIBS)])
    ;;
  no)
    AC_MSG_RESULT(no)
    ;;
  *)
    AC_MSG_RESULT(yes)

    # Needed for AC_CHECK_HEADERS and AC_CHECK_LIB to look at
    # alternate readline path
    _ldflags=${LDFLAGS}
    _cppflags=${CPPFLAGS}

    # Add additional search path
    LDFLAGS="-L$with_readline/lib $LDFLAGS"
    CPPFLAGS="-I$with_readline/include $CPPFLAGS"

    AC_CHECK_HEADERS(readline.h history.h readline/readline.h)
    AC_CHECK_HEADERS(readline/history.h)

    AC_CHECK_HEADERS(readline.h readline/readline.h,[
      for termlib in ncurses curses termcap terminfo termlib; do
       AC_CHECK_LIB(${termlib}, tgetent, [TERMLIBS="-l${termlib}"; break])
      done
      AC_CHECK_LIB(readline, rl_callback_handler_install,
       [TERMLDFLAGS="-L$with_readline/lib"
       TERMCPPFLAGS="-I$with_readline/include"
       CPPFLAGS="-I$with_readline/include $CPPFLAGS"
       TERMLIBS="-lreadline $TERMLIBS"
       AC_DEFINE(HAVE_LIBREADLINE,1,[Whether the system has readline])
       break], [TERMLIBS= CPPFLAGS=$_cppflags], $TERMLIBS)])

    LDFLAGS=$_ldflags
    ;;
  esac],
  AC_MSG_RESULT(no)
)
AC_SUBST(TERMLIBS)
AC_SUBST(TERMLDFLAGS)

# The readline API changed slightly from readline3 to readline4, so
# code will generate warnings on one of them unless we have a few
# special cases.
AC_CHECK_LIB(readline, rl_completion_matches,
	     [AC_DEFINE(HAVE_NEW_LIBREADLINE, 1,
			[Do we have rl_completion_matches?])],
	     [],
	     [$TERMLIBS])

# not all readline libs have rl_event_hook or history_list
AC_CHECK_DECLS(rl_event_hook, [], [], [#include <readline/readline.h>])
AC_CHECK_LIB(readline, history_list,
	     [AC_DEFINE(HAVE_HISTORY_LIST, 1, [Do we have history_list?])],
	     [],
	     [$TERMLIBS])

###############################################
# test for where we get yp_get_default_domain() from
AC_SEARCH_LIBS(yp_get_default_domain, [nsl])
AC_CHECK_FUNCS(yp_get_default_domain)

# Check if we have execl, if not we need to compile smbrun.
AC_CHECK_FUNCS(execl)
if test x"$ac_cv_func_execl" = x"no"; then
    EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/smbrun\$(EXEEXT)"
fi

AC_CHECK_FUNCS(getcwd fchown chmod fchmod mknod mknod64)
AC_CHECK_FUNCS(strtol)
AC_CHECK_FUNCS(strchr chflags)
AC_CHECK_FUNCS(getrlimit fsync setpgid)
AC_CHECK_FUNCS(fdatasync,,[AC_CHECK_LIB_EXT(rt, LIBS, fdatasync)])
AC_CHECK_FUNCS(setsid glob strpbrk crypt16 getauthuid)
AC_CHECK_FUNCS(sigprocmask sigblock sigaction sigset innetgr setnetgrent getnetgrent endnetgrent)
AC_CHECK_FUNCS(initgroups select rdchk getgrnam getgrent pathconf)
AC_CHECK_FUNCS(getgrset)
AC_CHECK_FUNCS(setpriv setgidx setuidx setgroups sysconf stat64 fstat64)
AC_CHECK_FUNCS(lstat64 fopen64 atexit grantpt posix_openpt lseek64 ftruncate64 posix_fallocate posix_fallocate64)
AC_CHECK_FUNCS(fallocate fallocate64)
AC_CHECK_FUNCS(fseeko fseek64 fseeko64 ftell64 ftello64 setluid getpwanam)
AC_CHECK_FUNCS(opendir64 readdir64 seekdir64 telldir64 rewinddir64 closedir64)
AC_CHECK_FUNCS(fdopendir fdopendir64)
AC_CHECK_FUNCS(getpwent_r)
AC_CHECK_FUNCS(getdents64)
AC_CHECK_FUNCS(setenv strcasecmp fcvt fcvtl)
AC_CHECK_FUNCS(syslog vsyslog timegm)
AC_CHECK_FUNCS(setlocale nl_langinfo)
AC_CHECK_FUNCS(nanosleep,,[AC_CHECK_LIB_EXT(rt, LIBS, nanosleep)])
AC_CHECK_FUNCS(lutimes futimes utimensat futimens)
AC_CHECK_FUNCS(mlock munlock mlockall munlockall)
AC_CHECK_FUNCS(memalign posix_memalign hstrerror)
AC_CHECK_HEADERS(sys/mman.h)
# setbuffer, shmget, shm_open are needed for smbtorture
AC_CHECK_FUNCS(shmget shm_open)
AC_CHECK_FUNCS(gettext dgettext)
AC_CHECK_FUNCS(bindtextdomain textdomain)
AC_CHECK_FUNCS(strupr)

# Find a method of generating a stack trace
AC_CHECK_HEADERS(execinfo.h libexc.h libunwind.h)
# libexecinfo provides backtrace_symbols on FreeBSD
AC_SEARCH_LIBS(backtrace_symbols, [execinfo])
AC_CHECK_FUNCS(backtrace_symbols)
AC_CHECK_LIB(exc, trace_back_stack)

# check for sysctlbyname for BSD systems
AC_CHECK_FUNCS(sysctlbyname)

#################################################
# Check to see if core dump directory is defined in linux
# with /proc/sys/kernel/core_pattern

AC_CHECK_FILE([/proc/sys/kernel/core_pattern],
	AC_DEFINE(HAVE_SYS_KERNEL_PROC_CORE_PATTERN, 1,
	[Whether Linux kernel uses core_pattern for core files]),
	 [])

#############################
# check if building with gpfs
AC_CHECK_HEADERS(gpfs_gpl.h)
if test x"$ac_cv_header_gpfs_gpl_h" = x"yes"; then
    AC_DEFINE(HAVE_GPFS,1,[Whether GPFS GPL headers are available])
    default_shared_modules="$default_shared_modules vfs_gpfs"
    default_shared_modules="$default_shared_modules vfs_gpfs_hsm_notify"
fi

#############################################
# check if building on Isilon OneFS
printf "%s" "checking for Isilon OneFS... "
save_LIBS="$LIBS"
LIBS="$LIBS -lisi_version"
AC_TRY_LINK([#include <isi_version/isi_version.h>],
          [get_isilon_copyright()],
          samba_cv_HAVE_ONEFS=yes,
          samba_cv_HAVE_ONEFS=no)
echo $samba_cv_HAVE_ONEFS
if test x"$samba_cv_HAVE_ONEFS" = x"yes"; then
    AC_DEFINE(HAVE_ONEFS,1,[Whether building on Isilon OneFS])
    default_shared_modules="$default_shared_modules vfs_onefs vfs_onefs_shadow_copy perfcount_onefs"
    default_static_modules="$default_static_modules"
    ONEFS_LIBS="-lisi_acl -lisi_ecs -lisi_event -lisi_util"
    # Need to also add general libs for oplocks support
    save_LIBS="$save_LIBS -lisi_ecs -lisi_event -lisi_util -ldevstat"
fi
AC_SUBST(ONEFS_LIBS)
LIBS="$save_LIBS"

# Note that all the libunwind symbols in the API are defined to internal
# platform-specific version, so we must include libunwind.h before checking
# any of them.
AC_MSG_CHECKING([for libunwind])
save_LIBS=$LIBS

UNWIND_ARCH="unknown"
if test x"$UNAME_I" != x"unknown"; then
	UNWIND_ARCH="$UNAME_I"
elif test x"$UNAME_M" != x"unknown"; then
	UNWIND_ARCH="$UNAME_M"
elif test x"$UNAME_P" != x"unknown"; then
	UNWIND_ARCH="$UNAME_P"
fi

case "$UNWIND_ARCH" in
	unknown)
		# This probably won't link without
		# the platform-specific libunwind.
		LIBS="$LIBS -lunwind"
		;;
	i386|i586|i686)
		# Add the platform-specific libunwind module.
		LIBS="$LIBS -lunwind -lunwind-x86"
		;;
	*)
		# Add the platform-specific libunwind module.
		# based on uname -i, uname -m or uname -p
		LIBS="$LIBS -lunwind -lunwind-$UNWIND_ARCH"
		;;
esac

AC_TRY_LINK(
    [
#ifdef HAVE_LIBUNWIND_H
#include <libunwind.h>
#endif
    ],
    [
	unw_context_t ctx; unw_cursor_t cur;
	char buf[256]; unw_word_t off;
	unw_getcontext(&ctx); unw_init_local(&cur, &ctx);
	unw_get_proc_name(&cur, buf, sizeof(buf), &off);
    ],
    [
	AC_MSG_RESULT(yes)
	AC_DEFINE(HAVE_LIBUNWIND, 1, [Whether libunwind is available])

	# If we have libunwind, test whether we also have libunwind-ptrace
	# which would let us unwind arbitrary processes.
	save_LIBS=$LIBS
	AC_CHECK_HEADERS(libunwind-ptrace.h)
	AC_CHECK_LIB(unwind-ptrace, _UPT_create,
	    [
		LIBUNWIND_PTRACE="-lunwind-ptrace";
		AC_DEFINE(HAVE_LIBUNWIND_PTRACE, 1,
		    [Whether libunwind-ptrace.a is available.])
	    ],
	    [ LIBUNWIND_PTRACE="" ])

	LIBS=$save_LIBS
    ],
    [
	AC_MSG_RESULT(no)
	LIBS=$save_LIBS
    ])

# To use libunwind-ptrace, we also need to make some ptrace system calls.
if test x"$LIBUNWIND_PTRACE" != x"" ; then
    AC_CHECK_HEADERS(sys/ptrace.h)
    AC_MSG_CHECKING([for the Linux ptrace(2) interface])
    AC_TRY_LINK(
	    [
#if HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#if HAVE_SYS_PTRACE_H
#include <sys/ptrace.h>
#endif
	    ],
	    [
		pid_t me = (pid_t)-1;
		ptrace(PTRACE_ATTACH, me, 0, 0);
		ptrace(PTRACE_DETACH, me, 0, 0);
		return 0;
	    ],
	    [
		AC_MSG_RESULT(yes)
		AC_DEFINE(HAVE_LINUX_PTRACE, 1,
		    [Whether the Linux ptrace(2) interface is available.])
	    ],
	    [
		AC_MSG_RESULT(no)
		LIBUNWIND_PTRACE=""
	    ])
fi

AC_SUBST(LIBUNWIND_PTRACE)

AC_CHECK_FUNCS(_dup _dup2 _opendir _readdir _seekdir _telldir _closedir)
AC_CHECK_FUNCS(__dup __dup2 __opendir __readdir __seekdir __telldir __closedir)
AC_CHECK_FUNCS(__getcwd _getcwd)
AC_CHECK_FUNCS(__xstat __fxstat __lxstat)
AC_CHECK_FUNCS(_stat _lstat _fstat __stat __lstat __fstat)
AC_CHECK_FUNCS(_acl __acl _facl __facl _open __open _chdir __chdir)
AC_CHECK_FUNCS(_close __close _fchdir __fchdir _fcntl __fcntl)
AC_CHECK_FUNCS(getdents __getdents _lseek __lseek _read __read)
AC_CHECK_FUNCS(getdirentries _write __write _fork __fork)
AC_CHECK_FUNCS(_stat64 __stat64 _fstat64 __fstat64 _lstat64 __lstat64)
AC_CHECK_FUNCS(__sys_llseek llseek _llseek __llseek readdir64 _readdir64 __readdir64)
AC_CHECK_FUNCS(pread _pread __pread pread64 _pread64 __pread64)
AC_CHECK_FUNCS(pwrite _pwrite __pwrite pwrite64 _pwrite64 __pwrite64)
AC_CHECK_FUNCS(open64 _open64 __open64 creat64)
AC_CHECK_FUNCS(prctl)

AC_TRY_COMPILE([
#ifdef HAVE_SYS_PRCTL_H
#include <sys/prctl.h>
#endif
],
[int i; i = prtcl(0); ],
AC_DEFINE(HAVE_PRCTL, 1, [Whether prctl is available]),[])

#
#
#
case "$host_os" in
    *linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu)
       # glibc <= 2.3.2 has a broken getgrouplist
       AC_CACHE_CHECK([for good getgrouplist],samba_cv_linux_getgrouplist_ok,[AC_TRY_RUN([
#include <unistd.h>
#include <sys/utsname.h>
main() {
       /* glibc up to 2.3 has a broken getgrouplist */
#if defined(__GLIBC__) && defined(__GLIBC_MINOR__)
       int libc_major = __GLIBC__;
       int libc_minor = __GLIBC_MINOR__;

       if (libc_major < 2)
              exit(1);
       if ((libc_major == 2) && (libc_minor <= 3))
              exit(1);
#endif
       exit(0);
}
], [samba_cv_linux_getgrouplist_ok=yes],
   [samba_cv_linux_getgrouplist_ok=no],
   [samba_cv_linux_getgrouplist_ok=cross])])
       if test x"$samba_cv_linux_getgrouplist_ok" = x"yes"; then
          AC_DEFINE(HAVE_GETGROUPLIST, 1, [Have good getgrouplist])
       fi
       ;;
    *)
       AC_CHECK_FUNCS(getgrouplist)
       ;;
esac

#
# stat64 family may need <sys/stat.h> on some systems, notably ReliantUNIX
#

if test x$ac_cv_func_stat64 = xno ; then
  AC_MSG_CHECKING([for stat64 in <sys/stat.h>])
  AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/stat.h>
], [struct stat64 st64; exit(stat64(".",&st64));], [ac_cv_func_stat64=yes])
  AC_MSG_RESULT([$ac_cv_func_stat64])
  if test x$ac_cv_func_stat64 = xyes ; then
    AC_DEFINE(HAVE_STAT64,1,[Whether stat64() is available])
  fi
fi

if test x$ac_cv_func_lstat64 = xno ; then
  AC_MSG_CHECKING([for lstat64 in <sys/stat.h>])
  AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/stat.h>
], [struct stat64 st64; exit(lstat64(".",&st64));], [ac_cv_func_lstat64=yes])
  AC_MSG_RESULT([$ac_cv_func_lstat64])
  if test x$ac_cv_func_lstat64 = xyes ; then
    AC_DEFINE(HAVE_LSTAT64,[Whether lstat64() is available])
  fi
fi

if test x$ac_cv_func_fstat64 = xno ; then
  AC_MSG_CHECKING([for fstat64 in <sys/stat.h>])
  AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/stat.h>
], [struct stat64 st64; exit(fstat64(0,&st64));], [ac_cv_func_fstat64=yes])
  AC_MSG_RESULT([$ac_cv_func_fstat64])
  if test x$ac_cv_func_fstat64 = xyes ; then
    AC_DEFINE(HAVE_FSTAT64,1,[Whether fstat64() is available])
  fi
fi

#################################################
# Check whether struct stat has timestamps with sub-second resolution.
#

samba_cv_stat_hires=no
AC_CHECK_MEMBERS([struct stat.st_mtim.tv_nsec], # Linux, Solaris
	[samba_cv_stat_hires=yes])
AC_CHECK_MEMBERS([struct stat.st_mtimensec], # BSD, if defined _POSIX_SOURCE
	[samba_cv_stat_hires=yes])
AC_CHECK_MEMBERS([struct stat.st_mtimespec.tv_nsec], # BSD, if not defined _POSIX_SOURCE
	[samba_cv_stat_hires=yes])
AC_CHECK_MEMBERS([struct stat.st_mtime_n], # AIX
	[samba_cv_stat_hires=yes])
AC_CHECK_MEMBERS([struct stat.st_umtime], # Tru64
	[samba_cv_stat_hires=yes])

if test x"$samba_cv_stat_hires" = x"yes" ; then
    AC_DEFINE(HAVE_STAT_HIRES_TIMESTAMPS, 1,
	    [whether struct stat has sub-second timestamps])
fi

# recent FreeBSD, NetBSD have creation timestamps called birthtime:
AC_CHECK_MEMBERS([struct stat.st_birthtimespec.tv_nsec])
AC_CHECK_MEMBERS([struct stat.st_birthtime], AC_CHECK_MEMBERS([struct stat.st_birthtimensec]))


AC_CACHE_CHECK([whether there is DOS flags support in the stat struct], samba_cv_stat_dos_flags,
    [
	AC_TRY_COMPILE(
	    [#include <sys/stat.h>],
	    [
		int a = UF_DOS_ARCHIVE;
		int h = UF_DOS_HIDDEN;
		int r = UF_DOS_RO;
		int s = UF_DOS_SYSTEM;
		int i = UF_DOS_NOINDEX;
		int f = UF_DOS_FLAGS;
	    ],
	    samba_cv_stat_dos_flags=yes, samba_cv_stat_dos_flags=no)
    ])

if test x"$samba_cv_stat_dos_flags" = x"yes" ; then
    AC_DEFINE(HAVE_STAT_DOS_FLAGS, 1, [whether there is DOS flags support in the stat struct])
fi

AC_CACHE_CHECK([whether we can compile with __attribute__((destructor))],
	       samba_cv_function_attribute_destructor,
	       [
	         AC_COMPILE_IFELSE(
			[
				__attribute__((destructor))
				static void cleanup(void) { }
			],
			samba_cv_function_attribute_destructor=yes)
		])

if test x"$samba_cv_function_attribute_destructor" = xyes ; then
   AC_DEFINE(HAVE_FUNCTION_ATTRIBUTE_DESTRUCTOR, 1,
	     [whether we can compile with __attribute__((destructor))])
fi

#####################################
# needed for SRV lookups
AC_CHECK_LIB(resolv, dn_expand)
AC_CHECK_LIB(resolv, _dn_expand)
AC_CHECK_LIB(resolv, __dn_expand)

#
# Check for the functions putprpwnam, set_auth_parameters,
# getspnam, bigcrypt and getprpwnam in -lsec and -lsecurity
# Needed for OSF1 and HPUX.
#

AC_LIBTESTFUNC(security, putprpwnam)
AC_LIBTESTFUNC(sec, putprpwnam)

AC_LIBTESTFUNC(security, set_auth_parameters)
AC_LIBTESTFUNC(sec, set_auth_parameters)

# UnixWare 7.x has its getspnam in -lgen
AC_LIBTESTFUNC(gen, getspnam)

AC_LIBTESTFUNC(security, getspnam)
AC_LIBTESTFUNC(sec, getspnam)

AC_LIBTESTFUNC(security, bigcrypt)
AC_LIBTESTFUNC(sec, bigcrypt)

AC_LIBTESTFUNC(security, getprpwnam)
AC_LIBTESTFUNC(sec, getprpwnam)

AC_CHECK_FUNCS(strsignal)

############################################
# Check for EA implementations
case "$host_os" in
  *osf*)
	AC_SEARCH_LIBS(getproplist, [proplist])
	AC_CHECK_FUNCS(getproplist fgetproplist setproplist fsetproplist)
	AC_CHECK_FUNCS(delproplist fdelproplist add_proplist_entry get_proplist_entry)
	AC_CHECK_FUNCS(sizeof_proplist_entry)
  ;;
  *freebsd4* | *dragonfly* )
	AC_DEFINE(BROKEN_EXTATTR, 1, [Does extattr API work])
  ;;
  *solaris*)
	AC_CHECK_FUNCS(attropen)
  ;;
  *)
	AC_SEARCH_LIBS(getxattr, [attr])
	AC_CHECK_FUNCS(getxattr,[
		AC_CHECK_FUNCS(lgetxattr fgetxattr listxattr llistxattr flistxattr removexattr lremovexattr fremovexattr setxattr lsetxattr fsetxattr)
		])
	AC_CHECK_FUNCS(getea,[
		AC_CHECK_FUNCS(fgetea lgetea listea flistea llistea removeea fremoveea lremoveea setea fsetea lsetea)
		])
	AC_CHECK_FUNCS(attr_get,[
		AC_CHECK_FUNCS(attr_list attr_set attr_remove attr_getf attr_listf attr_setf attr_removef)
		])
	AC_CHECK_FUNCS(extattr_delete_file,[
		AC_CHECK_FUNCS(extattr_delete_fd extattr_delete_link extattr_get_fd extattr_get_file extattr_get_link extattr_list_fd extattr_list_file extattr_list_link extattr_set_fd extattr_set_file extattr_set_link)
		])
  ;;
esac

########################################################
# Do xattr functions take additional options like on Darwin?
if test x"$ac_cv_func_getxattr" = x"yes" ; then
	AC_CACHE_CHECK([whether xattr interface takes additional options], smb_attr_cv_xattr_add_opt, [
		old_LIBS=$LIBS
		LIBS="$LIBS $ACL_LIBS"
		AC_TRY_COMPILE([
			#include <sys/types.h>
			#if HAVE_ATTR_XATTR_H
			#include <attr/xattr.h>
			#elif HAVE_SYS_XATTR_H
			#include <sys/xattr.h>
			#endif
		],[
			getxattr(0, 0, 0, 0, 0, 0);
		],
	        [smb_attr_cv_xattr_add_opt=yes],
		[smb_attr_cv_xattr_add_opt=no;LIBS=$old_LIBS])
	])
	if test x"$smb_attr_cv_xattr_add_opt" = x"yes"; then
		AC_DEFINE(XATTR_ADD_OPT, 1, [xattr functions have additional options])
	fi
fi

AC_DISABLE_STATIC
AC_ENABLE_SHARED

# Set defaults
PIE_CFLAGS=""
PIE_LDFLAGS=""
AC_ARG_ENABLE(pie, [AS_HELP_STRING([--enable-pie], [Turn on pie support if available (default=yes)])])

if test "x$enable_pie" != xno
then
	AC_CACHE_CHECK(for -pie and -fPIE, samba_cv_fpie,
	[
		cat > conftest.c <<EOF
int foo;
int main () { return 0;}
EOF
		if AC_TRY_COMMAND_NO_STDERR([${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS -pie -fPIE -o conftest conftest.c])
		then
			samba_cv_fpie=yes
		else
			samba_cv_fpie=no
		fi
		rm -f conftest*
	])
	if test x"${samba_cv_fpie}" = x"yes"
	then
		PIE_CFLAGS="-fPIE"
		PIE_LDFLAGS="-pie"
	fi
fi

# Set defaults
RELRO_LDFLAGS=""
AC_ARG_ENABLE(relro, [AS_HELP_STRING([--enable-relro], [Turn on Relocations Read-Only (relro) support if available (default=yes)])])

if test "x$enable_relro" != xno
then
	AC_CACHE_CHECK([for -Wl,-z,relro], samba_cv_relro,
	[
		cat > conftest.c <<EOF
int foo;
main () { return 0;}
EOF
		if AC_TRY_COMMAND([${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS -Wl,-z,relro -o conftest conftest.c 1>&AS_MESSAGE_LOG_FD])
		then
			samba_cv_relro=yes
		else
			samba_cv_relro=no
		fi
		rm -f conftest*
	])
	if test x"${samba_cv_relro}" = x"yes"
	then
		RELRO_LDFLAGS="-Wl,-z,relro"
	fi
fi

# Set defaults
SYMSEXT="syms"
AC_SUBST(SYMSEXT)

# Assume non-shared by default and override below
BLDSHARED="false"

# these are the defaults, good for lots of systems
HOST_OS="$host_os"
LDSHFLAGS="-shared"
MODULE_EXPORTS=""
SONAMEFLAG="#"
SHLD="\${CC} \${CFLAGS}"
PICFLAG="${PIE_CFLAGS}"
SHLIBEXT="so"
DSO_EXPORTS=""

# this bit needs to be modified for each OS that supports share libs
# You need to specify how to create a shared library and
  # how to compile C code to produce PIC object files

  AC_MSG_CHECKING([ability to build shared libraries])

  # and these are for particular systems
  case "$host_os" in
		*linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu | *qnx*)
			case "$host_os" in
				*linux*) AC_DEFINE(LINUX,1,[Whether the host os is linux]) ;;
				*qnx*) AC_DEFINE(QNX,1,[Whether the host os is qnx]) ;;
			esac
			BLDSHARED="true"
			LDSHFLAGS="-shared -Wl,-Bsymbolic"
			if test "${ac_cv_gnu_ld_no_default_allow_shlib_undefined}" = "yes"; then
				LDSHFLAGS_Z_NODEFS="-Wl,--allow-shlib-undefined"
			fi
			DYNEXP="-Wl,--export-dynamic"
			PICFLAG="-fPIC"
			SONAMEFLAG="-Wl,-soname="
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*solaris*) AC_DEFINE(SUNOS5,1,[Whether the host os is solaris])
			BLDSHARED="true"
			if test "${GCC}" = "yes"; then
				PICFLAG="-fPIC"
				SONAMEFLAG="-Wl,-soname="
				if test "${ac_cv_prog_gnu_ld}" = "yes"; then
					DYNEXP="-Wl,-E"
				fi
				LDSHFLAGS="-shared"
			else
				PICFLAG="-KPIC"
				LDSHFLAGS="-G"
			fi
			if test "$ac_cv_prog_gnu_ld" = "yes"; then
				SONAMEFLAG="-Wl,-soname="
			else
				SONAMEFLAG="-Wl,-h,"
			fi
			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
			AC_DEFINE(BROKEN_GETGRNAM,1,[Does getgrnam work correctly])
			;;
		*sunos*) AC_DEFINE(SUNOS4,1,[Whether the host os is sunos4])
			BLDSHARED="true"
			LDSHFLAGS="-G"
			SONAMEFLAG="-Wl,-h,"
			PICFLAG="-KPIC"   # Is this correct for SunOS
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			AC_DEFINE(BROKEN_GETGRNAM,1,[Does getgrnam work correctly])
			;;
		*netbsd* | *freebsd* | *dragonfly* )
			BLDSHARED="true"
			LDSHFLAGS="-shared"
			DYNEXP="-Wl,--export-dynamic"
			SONAMEFLAG="-Wl,-soname,"
			PICFLAG="-fPIC -DPIC"
			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
			AC_DEFINE(BROKEN_GETGRNAM,1,[Does getgrnam work correctly])
			;;
		*openbsd*)  BLDSHARED="true"
			LDSHFLAGS="-shared"
			DYNEXP="-Wl,-Bdynamic"
			SONAMEFLAG="-Wl,-soname,"
			PICFLAG="-fPIC"
			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
			AC_DEFINE(BROKEN_GETGRNAM,1,[Does getgrnam work correctly])
			;;
		*irix*) AC_DEFINE(IRIX,1,[Whether the host os is irix])
			case "$host_os" in
			*irix6*) AC_DEFINE(IRIX6,1,[Whether the host os is irix6])
			;;
			esac
			BLDSHARED="true"
			LDSHFLAGS="-Wl,-set_version,sgi1.0 -shared"
			SONAMEFLAG="-Wl,-soname,"
			if test "${GCC}" = "yes"; then
				PICFLAG="-fPIC"
			else
				PICFLAG="-KPIC"
			fi
			AC_DEFINE(STAT_ST_BLOCKSIZE,512,[The size of a block])
			;;
		*aix*) AC_DEFINE(AIX,1,[Whether the host os is aix])
			BLDSHARED="true"
			# use expfull to export underscored symbols
			# add rtl to remove /lib/crt0.o warning
			LDSHFLAGS="-Wl,-G,-bexpfull,-bbigtoc,-brtl"
			DYNEXP="-Wl,-brtl,-bexpfull,-bbigtoc"
			PICFLAG="-O2"
			# as AIX code is always position independent...
			# .po will just create compile warnings, use po.o:
			if test "${GCC}" != "yes"; then
				## for funky AIX compiler using strncpy()
				CFLAGS="$CFLAGS -D_LINUX_SOURCE_COMPAT -qmaxmem=32000 -qhalt=e"
			fi

			AC_DEFINE(STAT_ST_BLOCKSIZE,DEV_BSIZE,[The size of a block])
			AC_DEFINE(BROKEN_STRNLEN,1,[Does strnlen work correctly])
			AC_DEFINE(BROKEN_STRNDUP,1,[Does strndup work correctly])
			;;
		*hpux*) AC_DEFINE(HPUX,1,[Whether the host os is HPUX])
			# ia64: 64bit build using gcc with CFLAGS="-mpl64"
			#       64bit build using HP's cc with CFLAGS="+DD64"
			# hppa: 64bit build unsupported by gcc
			#       64bit build using HP's cc with CFLAGS="+DA2.0w"
			# HP-UX 11.00 ld needs PHSS_33034
			BLDSHARED="true"
			if test "${GCC}" = "yes"; then
				PICFLAG="-fPIC"
				LDSHFLAGS="-shared"
			else
				PICFLAG="+z"
				LDSHFLAGS="-b"
				# "Uses depth-first symbol resolution"
				LDSHFLAGS="$LDSHFLAGS -Wl,-B,symbolic,-b"
				if test "$host_cpu" != "ia64"; then
					# "don't store literals in read-only memory" (?):
					PICFLAG="$PICFLAG +ESnolit"
				fi
			fi
			if test "$host_cpu" = "ia64"; then
				SHLIBEXT="so"
				# TODO: does the linker find the right 32/64 bit version of the libs? :
				DYNEXP="-Wl,-E,+b/usr/local/lib/hpux32:/usr/lib/hpux32:/usr/local/lib/hpux64:/usr/lib/hpux64"
			else
				SHLIBEXT="sl"
				DYNEXP="-Wl,-E,+b/usr/local/lib:/usr/lib"
			fi
			if test "$ac_cv_prog_gnu_ld" = "yes"; then
				SONAMEFLAG="-Wl,-soname="
			else
				SONAMEFLAG="-Wl,+h,"
			fi
			# PIE/PIC flags at link time are required on HP-UX because
			# linking requires a temporary source file, which is being
			# compiled with the indicated flags - which need to contain
			# PIC flags when we don't support PIE flags:
			if test "$PIE_LDFLAGS" = "" ; then
				PIE_LDFLAGS=\${PICFLAG}
			fi
			AC_DEFINE(STAT_ST_BLOCKSIZE,8192,[The size of a block])
			AC_DEFINE(POSIX_ACL_NEEDS_MASK,1,[Does a POSIX ACL need a mask element])
			;;
		*osf*) AC_DEFINE(OSF1,1,[Whether the host os is osf1])
			BLDSHARED="true"
			LDSHFLAGS="-shared"
			SONAMEFLAG="-Wl,-soname,"
			if test "${GCC}" = "yes"; then
				PICFLAG="-fPIC"
			fi
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			AC_DEFINE(BROKEN_GETGRNAM,1,[Does getgrnam work correctly])
			for flags in "-expect_unresolved '*'" "-Wl,-expect_unresolved,'*'" ; do
				saved_ldflags="$LDFLAGS"
				AC_MSG_CHECKING([if $flags works])
				LDFLAGS="$flags $saved_ldflags"
				AC_TRY_LINK([],[],
					[AC_MSG_RESULT([yes])
					LDSHFLAGS_Z_NODEFS=$flags],
					AC_MSG_RESULT([no]))
				LDFLAGS="$saved_ldflags"
				test x"$LDSHFLAGS_Z_NODEFS" != x && break
			done
			;;
		*sco*) AC_DEFINE(SCO,1,[Whether the host os is sco unix])
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*unixware*) AC_DEFINE(UNIXWARE,1,[Whether the host os is unixware])
			BLDSHARED="true"
			LDSHFLAGS="-shared"
			SONAMEFLAG="-Wl,-soname,"
			PICFLAG="-KPIC"
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*next2*) AC_DEFINE(NEXT2,1,[Whether the host os is NeXT v2])
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*dgux*) AC_CHECK_PROG( ROFF, groff, [groff -etpsR -Tascii -man])
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*sysv4*) AC_DEFINE(SYSV,1,[Whether this is a system V system])
			case "$host" in
				*-univel-*)     if [ test "$GCC" != yes ]; then
						AC_DEFINE(HAVE_MEMSET,1,[Whether memset() is available])
					fi
					LDSHFLAGS="-G"
                             		DYNEXP="-Bexport"
				;;
				*mips-sni-sysv4*) AC_DEFINE(RELIANTUNIX,1,[Whether the host os is reliantunix]);;
			esac
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;

		*sysv5*) AC_DEFINE(SYSV,1,[Whether this is a system V system])
			if [ test "$GCC" != yes ]; then
				AC_DEFINE(HAVE_MEMSET,1,[Whether memset() is available])
			fi
			LDSHFLAGS="-G"
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
		*vos*) AC_DEFINE(STAT_ST_BLOCKSIZE,4096)
			BLDSHARED="false"
			LDSHFLAGS=""
			;;

		*darwin*)   AC_DEFINE(DARWINOS,1,[Whether the host os is Darwin/MacOSX])
			BLDSHARED="true"
			LDSHFLAGS="-dynamiclib -flat_namespace -undefined suppress"
			CFLAGS="$CFLAGS -fno-common"
			SHLD="\${CC}"
			SHLIBEXT="dylib"
                        MODULE_EXPORTS="-exported_symbols_list \$(srcdir)/exports/modules-darwin.syms"
                        SHLIBEXT="dylib"
                        # Since gcc doesn't fail on unrecognised options, the
                        # PIE test incorrectly succeeds. Darwin gcc does not
                        # actually support the PIE stuff.
                        PIE_LDFLAGS=
                        PIE_CFLAGS=
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;

		*)
			AC_DEFINE(STAT_ST_BLOCKSIZE,512)
			;;
  esac

if test "$enable_shared" != "yes"; then
	BLDSHARED=false
fi

if test "$enable_shared" = yes -a "${ac_cv_gnu_ld_version_script}" = yes; then
	DSO_EXPORTS=\$\(DSO_EXPORTS_CMD\)
fi

if test x"$BLDSHARED" = x"true" ; then
	LDFLAGS="$LDFLAGS -L./bin"
fi

AC_MSG_RESULT($BLDSHARED)

if test x"$enable_developer" = x"yes" ; then
	default_as_needed=auto
else
	default_as_needed=no
fi
AC_ARG_ENABLE(as-needed,
	AS_HELP_STRING([--enable-as-needed],
	[Turn on as-needed support if available (default=no)]),
	[enable_as_needed=$enableval],
	[enable_as_needed=$default_as_needed])
if test "x$enable_as_needed" != xno; then
    saved_before_as_needed_ldflags="$LDFLAGS"
    for flags in "-Wl,--as-needed" "-Wl,-z,ignore" "-z ignore" ; do
	saved_ldflags="$LDFLAGS"
	AC_MSG_CHECKING([if $flags works])
	LDFLAGS="$flags $saved_ldflags"
	AC_TRY_LINK([],[],
		[AC_MSG_RESULT([yes])
		LD_AS_NEEDED_FLAG=$flags
		ld_as_needed_flag_found=yes],
		AC_MSG_RESULT([no]))
	LDFLAGS="$LD_AS_NEEDED_FLAG $saved_ldflags"
	test x"$ld_as_needed_flag_found" = xyes && break
    done
fi

if test x$ld_as_needed_flag_found = xyes -a x$enable_as_needed = xauto ; then
# check if ld has bug described in https://bugzilla.samba.org/show_bug.cgi?id=7209#c17
	AC_MSG_CHECKING([if $LD_AS_NEEDED_FLAG has explicit external libs bug])
cat > conftest_shb.c <<END
void b() {}
END
cat > conftest_sha.c <<END
extern void b();
void a() {
	b();
}
END
cat > conftest.c <<END
extern void a();
int main() {
	a();
	return 0;
}
END

	rm -fr conftest
	AC_TRY_COMMAND([$CC $CPPFLAGS $CFLAGS $PICFLAG -c -o conftest_sha.o conftest_sha.c 1>&AS_MESSAGE_LOG_FD 2>&1])
	AC_TRY_COMMAND([$CC $CPPFLAGS $CFLAGS $PICFLAG -c -o conftest_shb.o conftest_shb.c 1>&AS_MESSAGE_LOG_FD 2>&1])
	TESTCMD="`eval echo \"$SHLD $LDSHFLAGS $PICFLAG\"`"
	AC_TRY_COMMAND([$TESTCMD -o libconftest_shb.$SHLIBEXT conftest_shb.o 1>&AS_MESSAGE_LOG_FD 2>&1])
	AC_TRY_COMMAND([$TESTCMD -o libconftest_sha.$SHLIBEXT conftest_sha.o 1>&AS_MESSAGE_LOG_FD 2>&1])
	AC_TRY_COMMAND([$CC -o conftest conftest.c $LDFLAGS -L. -lconftest_sha -lconftest_shb 1>&AS_MESSAGE_LOG_FD 2>&1])
	if AC_TRY_COMMAND([eval "$LIB_PATH_VAR=. ./conftest 1>&AS_MESSAGE_LOG_FD 2>&1"])
	then
		AC_MSG_RESULT([no])
	else
		ld_as_needed_flag_found=no
		LDFLAGS="$saved_before_as_needed_ldflags"
		AC_MSG_RESULT([yes])
	fi
	rm conftest* libconftest*
fi

# check if we have to disable LD_AS_NEEDED_FLAG:
# On some systems for a veriety of reasons linking with
# -Wl,--as-needed -lreadline -lncurses fails
# we have to retest, if these combination is detected before.
# Bugzilla #7209

if test x$ac_cv_lib_readline_rl_callback_handler_install = xyes ; then
	if test x$ld_as_needed_flag_found = xyes ; then
		AC_MSG_CHECKING([if $LD_AS_NEEDED_FLAG works with readline])
		# try if check no fails
		save_LIBS=$LIBS
		LIBS="$LIBS $TERMLIBS"
		AC_TRY_LINK([], [rl_callback_handler_install();], [AC_MSG_RESULT([yes])],[ AC_MSG_RESULT([no]); LDFLAGS="$saved_before_as_needed_ldflags"])
		LIBS="$save_LIBS"
        fi
fi



# for historical reasons almost all linkers don't complain about unresolved
# symbols in shared libs. Except for the internal samba modules we want to get
# errors when we produce a shared lib with unresolved symbols. On some
# platforms unresolved symbols might be intended, so we might have to add
# platform specific exceptions here.

for flags in "-Wl,-z,defs" "-error_unresolved" "-Wl,-error_unresolved" ; do
	saved_ldflags="$LDFLAGS"
	AC_MSG_CHECKING([if $flags works])
	LDFLAGS="$flags $saved_ldflags"
	AC_TRY_LINK([],[],
	[AC_MSG_RESULT([yes])
	LDSHFLAGS_Z_DEFS=$flags
	ldshflags_z_defs_found=yes],
	AC_MSG_RESULT([no]))
	LDFLAGS=$saved_ldflags
	test x"$ldshflags_z_defs_found" = xyes && break
done

AC_MSG_CHECKING([LDSHFLAGS_Z_DEFS])
AC_MSG_RESULT([$LDSHFLAGS_Z_DEFS])
AC_MSG_CHECKING([LDFLAGS])
AC_MSG_RESULT([$LDFLAGS])
AC_MSG_CHECKING([DYNEXP])
AC_MSG_RESULT([$DYNEXP])

#######################################################
# test whether building a shared library actually works
if test $BLDSHARED = true; then

AC_MSG_CHECKING([SHLD])
AC_MSG_RESULT([$SHLD])
AC_MSG_CHECKING([LDSHFLAGS])
AC_MSG_RESULT([$LDSHFLAGS])

AC_MSG_CHECKING([SHLIBEXT])
AC_MSG_RESULT([$SHLIBEXT])
AC_MSG_CHECKING([SONAMEFLAG])
AC_MSG_RESULT([$SONAMEFLAG])

AC_MSG_CHECKING([PICFLAG])
AC_MSG_RESULT([$PICFLAG])

AC_MSG_CHECKING([NSSSONAMEVERSIONSUFFIX])
AC_MSG_RESULT([$NSSSONAMEVERSIONSUFFIX])

AC_CACHE_CHECK([whether building shared libraries actually works],
               [ac_cv_shlib_works],[
   # try building a trivial shared library
   ac_cv_shlib_works=no
   # The $SHLD and $LDSHFLAGS variables may contain references to other
   # variables so they need to be eval'ed.
   if AC_TRY_COMMAND([$CC $CPPFLAGS $CFLAGS $PICFLAG -c -o shlib.o ${srcdir-.}/../tests/shlib.c 1>&AS_MESSAGE_LOG_FD])
   then
     TESTCMD="`eval echo \"$SHLD $LDSHFLAGS $PICFLAG\"`"
     TESTCMD="$TESTCMD -o \"shlib.$SHLIBEXT\" shlib.o"
     if AC_TRY_COMMAND([eval $TESTCMD 1>&AS_MESSAGE_LOG_FD 2>&1])
     then
       ac_cv_shlib_works=yes
     fi
   fi
   rm -f "shlib.$SHLIBEXT" shlib.o

])
if test $ac_cv_shlib_works = no; then
   BLDSHARED=false
fi
fi

if test x"$BLDSHARED" != x"true"; then
	LDSHFLAGS="shared-libraries-disabled"
	SONAMEFLAG="shared-libraries-disabled"
	NSSSONAMEVERSIONSUFFIX="shared-libraries-disabled"
	SHLD="shared-libraries-disabled"
	PICFLAG="${PIE_CFLAGS}"
	SHLIBEXT="shared_libraries_disabled"
	smbtorture4_possible=no
fi

AC_MSG_CHECKING([used PICFLAG])
AC_MSG_RESULT([$PICFLAG])

AC_DEFINE_UNQUOTED(SHLIBEXT, "$SHLIBEXT", [Shared library extension])



###########################################################
#
# Configuration of subsystems / libraries
#
###########################################################

INSTALLLIBCMD_SH=:
INSTALLLIBCMD_A=:
UNINSTALLLIBCMD_SH=:
UNINSTALLLIBCMD_A=:

if test $BLDSHARED = true; then
	INSTALLLIBCMD_SH="\$(INSTALLCMD)"
	UNINSTALLLIBCMD_SH="rm -f"
fi
if test $enable_static = yes; then
	INSTALLLIBCMD_A="\$(INSTALLCMD)"
	UNINSTALLLIBCMD_A="rm -f"
fi

#################################################
# --disable-shared-libs
# can be used to disable the internal use of shared libs altogether
# (this only has an effect when building shared libs is enabled)
#
USESHARED=false
AC_SUBST(USESHARED)

AC_MSG_CHECKING(whether to use shared libraries internally)
AC_ARG_ENABLE([shared-libs],
	AS_HELP_STRING([--enable-shared-libs],
		[Use shared libraries internally (default=yes)]),
	[enable_shared_libs=$enableval],
	[enable_shared_libs=yes])

if test x"$enable_shared_libs" != x"no" ; then
	USESHARED=$BLDSHARED
fi

AC_MSG_RESULT([$USESHARED])

if test x"$enable_shared_libs" = x"yes" -a x"$BLDSHARED" != x"true" ; then
	AC_MSG_WARN([--enable-shared-libs: no support for shared libraries])
fi

#################################################
# --with-static-libs=LIBS:
#   link (internal) libs dynamically or statically?
#
# If a subsystem is built as a library then this controls whether they are
# linked into Samba targets statically or dynamically:
#
# * If we build the shared library at all, we link dynamically by default.
#
# * We only link statically if we don't build shared or if the library
#   appears in the --with-static-libs configure option.
#
# Example:
#   --with-static-libs=libtalloc makes use of libtalloc.a instead
#   of linking the dynamic variant with -ltalloc.
#
# NOTE: This option only affects libraries that we do not only build
# but that samba also links against as libraries (as opposed to linking
# the plain object files. - This has to be configured in Makefile.in.
# So in particular it does not harm to give invalid or unknown names here.
#

AC_ARG_WITH([static-libs],
	[AS_HELP_STRING([--with-static-libs=LIBS],
		[Comma-separated list of names of (internal) libraries to link statically (instead of dynamically)])],
	[AS_IF([test $withval],
		[for lib in `echo $withval | sed -e 's/,/ /g'` ; do
			[lib=`echo $lib | tr '[a-z]' '[A-Z]'`]
			eval LINK_$lib=STATIC
		done], [])],
	[])

#
# WORKAROUND:
#   until we have organized other internal subsystems (as util, registry
#   and smbconf) into shared libraries, we CAN NOT link libnetapi
#   dynamically to samba programs.
#
LINK_LIBNETAPI=STATIC

LINK_LIBSMBCLIENT=STATIC

#
#  The library versions are hardcoded here
#  and filled into the LIBFOO_SOVER variable.
#
#  TODO: for talloc and tdb (at least), these should
#  be extracted from their respective source directories
#
AC_ARG_ENABLE(external_libtalloc,
	[AS_HELP_STRING([--enable-external-libtalloc],
		[Enable external talloc [default=auto]])],
	[ enable_external_libtalloc=$enableval ],
	[ enable_external_libtalloc=auto ])

if test "x$enable_external_libtalloc" != xno
then
	PKG_CHECK_MODULES(LIBTALLOC, talloc >= 2.0.1,
		[ enable_external_libtalloc=yes ],
		[ if test x$enable_external_libtalloc = xyes; then
			AC_MSG_ERROR([Unable to find libtalloc])
		  else
			enable_external_libtalloc=no
		  fi
		])
fi

if test "x$enable_external_libtalloc" = xno
then
	m4_include(../lib/talloc/libtalloc.m4)
	if test x"$USESHARED" = x"no" ; then
		LINK_LIBTALLOC=STATIC
	fi
	LIBTALLOCVERSION=`grep ^VERSION ${tallocdir}/wscript | sed -e "s/'//g" -e 's/.* //'`
	SMB_LIBRARY(talloc, 2, ${LIBTALLOCVERSION})
	LIBTALLOC_OBJ0=""
	for obj in ${TALLOC_OBJ}; do
		LIBTALLOC_OBJ0="${LIBTALLOC_OBJ0} ${tallocdir}/${obj}"
	done
	SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} ${TALLOC_CFLAGS}"
	SAMBA_CONFIGURE_CPPFLAGS="${SAMBA_CONFIGURE_CPPFLAGS} ${TALLOC_CFLAGS}"
	AC_SUBST(LIBTALLOC_OBJ0)

	TALLOCTORT="bin/talloctort\$(EXEEXT)"
	AC_SUBST(TALLOCTORT)
fi

AC_ARG_ENABLE(external_libtevent,
	[AS_HELP_STRING([--enable-external-libtevent],
		[Enable external tevent [default=auto]])],
	[ enable_external_libtevent=$enableval ],
	[ enable_external_libtevent=auto ])

if test "x$enable_external_libtevent" != xno
then
	PKG_CHECK_MODULES(LIBTEVENT, tevent >= 0.9.11,
		[ enable_external_libtevent=yes ],
		[ if test x$enable_external_libtevent = xyes; then
			AC_MSG_ERROR([Unable to find libtevent])
		  else
			enable_external_libtevent=no
		  fi
		])
fi

if test "x$enable_external_libtevent" = xno
then
	m4_include(../lib/tevent/libtevent.m4)
	if test x"$USESHARED" = x"no" ; then
		LINK_LIBTEVENT=STATIC
	fi
	LIBTEVENTVERSION=`grep ^VERSION ${teventdir}/wscript | sed -e "s/'//g" -e 's/.* //'`
	SMB_LIBRARY(tevent, 0, ${LIBTEVENTVERSION})
	LIBTEVENT_OBJ0=""
	for obj in ${TEVENT_OBJ}; do
		LIBTEVENT_OBJ0="${LIBTEVENT_OBJ0} ${teventdir}/${obj}"
	done
	SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} ${TEVENT_CFLAGS}"
	SAMBA_CONFIGURE_CPPFLAGS="${SAMBA_CONFIGURE_CPPFLAGS} ${TEVENT_CFLAGS}"
	AC_SUBST(LIBTEVENT_OBJ0)
fi


AC_ARG_ENABLE(external_libtdb,
	[AS_HELP_STRING([--enable-external-libtdb],
		[Enable external tdb [default=auto]])],
		[ enable_external_libtdb=$enableval ],
		[ enable_external_libtdb=auto ])

if test "x$enable_external_libtdb" != xno
then
	PKG_CHECK_MODULES(LIBTDB, tdb >= 1.2.6,
		[ enable_external_libtdb=yes ],
		[
		if test x$enable_external_libtdb = xyes; then
			AC_MSG_ERROR([Unable to find libtdb])
		else
			enable_external_libtdb=no
		fi
		])
fi

AC_SUBST(LIBTDB_OBJ0)
if test "x$enable_external_libtdb" = xno
then
	m4_include(../lib/tdb/libtdb.m4)
	if test x"$USESHARED" = x"no" ; then
		LINK_LIBTDB=STATIC
	fi
	LIBTDBVERSION=`grep ^VERSION ${tdbdir}/wscript | sed -e "s/'//g" -e 's/.* //'`
	SMB_LIBRARY(tdb, 1, ${LIBTDBVERSION})
	LIBTDB_OBJ0=""
	LIBTDB_LIBS="$LIBTDB_LIBS $TDB_DEPS"
	for obj in ${TDB_OBJ}; do
		LIBTDB_OBJ0="${LIBTDB_OBJ0} ${tdbdir}/${obj}"
	done
	AC_SUBST(LIBTDB_OBJ0)
	SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} ${TDB_CFLAGS}"
	SAMBA_CONFIGURE_CPPFLAGS="${SAMBA_CONFIGURE_CPPFLAGS} ${TDB_CFLAGS}"

	TDBBACKUP="bin/tdbbackup\$(EXEEXT)"
	AC_SUBST(TDBBACKUP)
	TDBDUMP="bin/tdbdump\$(EXEEXT)"
	AC_SUBST(TDBDUMP)
	TDBRESTORE="bin/tdbrestore\$(EXEEXT)"
	AC_SUBST(TDBRESTORE)
	TDBTOOL="bin/tdbtool\$(EXEEXT)"
	AC_SUBST(TDBTOOL)
	TDBTORTURE="bin/tdbtorture\$(EXEEXT)"
	AC_SUBST(TDBTORTURE)
	ac_cv_have_tdb_err_nesting=yes
else
	AC_TRY_COMPILE([#include <tdb.h>],
		       [enum TDB_ERROR err = TDB_ERR_NESTING],
		       ac_cv_have_tdb_err_nesting=yes,
		       ac_cv_have_tdb_err_nesting=no)
fi

if test x"$ac_cv_have_tdb_err_nesting" = xyes; then
   AC_DEFINE(HAVE_TDB_ERR_NESTING, 1, [Whether we have TDB_ERR_NESTING])
fi

SMB_LIBRARY(netapi, 0)
SMB_LIBRARY(smbclient, 0)
SMB_LIBRARY(smbsharemodes, 0)
SMB_LIBRARY(addns, 0, [], no, [undefined API])



################

AC_CACHE_CHECK([for long long],samba_cv_have_longlong,[
AC_TRY_RUN([#include <stdio.h>
main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }],
samba_cv_have_longlong=yes,samba_cv_have_longlong=no,samba_cv_have_longlong=cross)])
if test x"$samba_cv_have_longlong" = x"yes"; then
    AC_DEFINE(HAVE_LONGLONG,1,[Whether the host supports long long's])
    AC_CHECK_TYPE(intptr_t, unsigned long long)
else
    AC_CHECK_TYPE(intptr_t, unsigned long)
fi

#
# Check if the compiler supports the LL prefix on long long integers.
# AIX needs this.

AC_CACHE_CHECK([for LL suffix on long long integers],samba_cv_compiler_supports_ll, [
    AC_TRY_COMPILE([#include <stdio.h>],[long long i = 0x8000000000LL],
	samba_cv_compiler_supports_ll=yes,samba_cv_compiler_supports_ll=no)])
if test x"$samba_cv_compiler_supports_ll" = x"yes"; then
   AC_DEFINE(COMPILER_SUPPORTS_LL,1,[Whether the compiler supports the LL prefix on long long integers])
fi


AC_CACHE_CHECK([for 64 bit time_t],samba_cv_SIZEOF_TIME_T,[
AC_TRY_RUN([#include <time.h>
main() { exit((sizeof(time_t) == 8) ? 0 : 1); }],
samba_cv_SIZEOF_TIME_T=yes,samba_cv_SIZEOF_TIME_T=no,samba_cv_SIZEOF_TIME_T=cross)])
if test x"$samba_cv_SIZEOF_TIME_T" = x"yes"; then
    AC_DEFINE(SIZEOF_TIME_T,8,[The size of the 'time_t' type])
fi

AC_CACHE_CHECK([for TIME_T_MAX],samba_cv_TIME_T_MAX,[
AC_TRY_RUN([#include <time.h>
main() {
	struct tm *tm;
	if (sizeof(time_t) == 8) {
		time_t max_time = 0x7fffffffffffffffll;
		tm = gmtime(&max_time);
		/* This should fail with 32-bit tm_year. */
		if (tm == NULL) {
			/* Max time_t that works with 32-bit int tm_year in struct tm. */
			max_time = 67768036191676799ll;
			tm = gmtime(&max_time);
			if (tm) {
				exit(0);
			}
		}
	}
	exit(1);
}],
samba_cv_TIME_T_MAX=yes,samba_cv_TIME_T_MAX=no,samba_cv_TIME_T_MAX=cross)])
if test x"$samba_cv_TIME_T_MAX" = x"yes"; then
    AC_DEFINE(TIME_T_MAX,67768036191676799ll,[The maximum value of the 'time_t' type])
fi


AC_CACHE_CHECK([for 64 bit off_t],samba_cv_SIZEOF_OFF_T,[
AC_TRY_RUN([#include <stdio.h>
#include <sys/stat.h>
main() { exit((sizeof(off_t) == 8) ? 0 : 1); }],
samba_cv_SIZEOF_OFF_T=yes,samba_cv_SIZEOF_OFF_T=no,samba_cv_SIZEOF_OFF_T=cross)])
if test x"$samba_cv_SIZEOF_OFF_T" = x"yes"; then
    AC_DEFINE(SIZEOF_OFF_T,8,[The size of the 'off_t' type])
fi

AC_CACHE_CHECK([for off64_t],samba_cv_HAVE_OFF64_T,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <sys/stat.h>
main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }],
samba_cv_HAVE_OFF64_T=yes,samba_cv_HAVE_OFF64_T=no,samba_cv_HAVE_OFF64_T=cross)])
if test x"$samba_cv_HAVE_OFF64_T" = x"yes"; then
    AC_DEFINE(HAVE_OFF64_T,1,[Whether off64_t is available])
fi

AC_CACHE_CHECK([for 64 bit ino_t],samba_cv_SIZEOF_INO_T,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <sys/stat.h>
main() { exit((sizeof(ino_t) == 8) ? 0 : 1); }],
samba_cv_SIZEOF_INO_T=yes,samba_cv_SIZEOF_INO_T=no,samba_cv_SIZEOF_INO_T=cross)])
if test x"$samba_cv_SIZEOF_INO_T" = x"yes"; then
    AC_DEFINE(SIZEOF_INO_T,8,[The size of the 'ino_t' type])
fi

AC_CACHE_CHECK([for ino64_t],samba_cv_HAVE_INO64_T,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <sys/stat.h>
main() { struct stat64 st; ino64_t s; if (sizeof(ino_t) == sizeof(ino64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }],
samba_cv_HAVE_INO64_T=yes,samba_cv_HAVE_INO64_T=no,samba_cv_HAVE_INO64_T=cross)])
if test x"$samba_cv_HAVE_INO64_T" = x"yes"; then
    AC_DEFINE(HAVE_INO64_T,1,[Whether the 'ino64_t' type is available])
fi

AC_CACHE_CHECK([for 64 bit dev_t],samba_cv_SIZEOF_DEV_T,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <sys/stat.h>
main() { exit((sizeof(dev_t) == 8) ? 0 : 1); }],
samba_cv_SIZEOF_DEV_T=yes,samba_cv_SIZEOF_DEV_T=no,samba_cv_SIZEOF_DEV_T=cross)])
if test x"$samba_cv_SIZEOF_DEV_T" = x"yes"; then
    AC_DEFINE(SIZEOF_DEV_T,8,[The size of the 'dev_t' type])
fi

AC_CACHE_CHECK([for dev64_t],samba_cv_HAVE_DEV64_T,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <sys/stat.h>
main() { struct stat64 st; dev64_t s; if (sizeof(dev_t) == sizeof(dev64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }],
samba_cv_HAVE_DEV64_T=yes,samba_cv_HAVE_DEV64_T=no,samba_cv_HAVE_DEV64_T=cross)])
if test x"$samba_cv_HAVE_DEV64_T" = x"yes"; then
    AC_DEFINE(HAVE_DEV64_T,1,[Whether the 'dev64_t' type is available])
fi

AC_CACHE_CHECK([for struct dirent64],samba_cv_HAVE_STRUCT_DIR64,[
AC_TRY_COMPILE([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
#include <dirent.h>],
[DIR64 de;],
samba_cv_HAVE_STRUCT_DIR64=yes,samba_cv_HAVE_STRUCT_DIR64=no)])
if test x"$samba_cv_HAVE_STRUCT_DIR64" = x"yes" && test x"$ac_cv_func_readdir64" = x"yes"; then
    AC_DEFINE(HAVE_STRUCT_DIR64,1,[Whether the 'DIR64' abstract data type is available])
fi

AC_CACHE_CHECK([for struct dirent64],samba_cv_HAVE_STRUCT_DIRENT64,[
AC_TRY_COMPILE([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
#include <dirent.h>],
[struct dirent64 de;],
samba_cv_HAVE_STRUCT_DIRENT64=yes,samba_cv_HAVE_STRUCT_DIRENT64=no)])
if test x"$samba_cv_HAVE_STRUCT_DIRENT64" = x"yes" && test x"$ac_cv_func_readdir64" = x"yes"; then
    AC_DEFINE(HAVE_STRUCT_DIRENT64,1,[Whether the 'dirent64' struct is available])
fi

AC_CACHE_CHECK([for major macro],samba_cv_HAVE_DEVICE_MAJOR_FN,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
main() { dev_t dev; int i = major(dev); return 0; }],
samba_cv_HAVE_DEVICE_MAJOR_FN=yes,samba_cv_HAVE_DEVICE_MAJOR_FN=no,samba_cv_HAVE_DEVICE_MAJOR_FN=cross)])
if test x"$samba_cv_HAVE_DEVICE_MAJOR_FN" = x"yes"; then
    AC_DEFINE(HAVE_DEVICE_MAJOR_FN,1,[Whether the major macro for dev_t is available])
fi

AC_CACHE_CHECK([for minor macro],samba_cv_HAVE_DEVICE_MINOR_FN,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
main() { dev_t dev; int i = minor(dev); return 0; }],
samba_cv_HAVE_DEVICE_MINOR_FN=yes,samba_cv_HAVE_DEVICE_MINOR_FN=no,samba_cv_HAVE_DEVICE_MINOR_FN=cross)])
if test x"$samba_cv_HAVE_DEVICE_MINOR_FN" = x"yes"; then
    AC_DEFINE(HAVE_DEVICE_MINOR_FN,1,[Whether the minor macro for dev_t is available])
fi

AC_CACHE_CHECK([for makedev macro],samba_cv_HAVE_MAKEDEV,[
AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
main() { dev_t dev = makedev(1,2); return 0; }],
samba_cv_HAVE_MAKEDEV=yes,samba_cv_HAVE_MAKEDEV=no,samba_cv_HAVE_MAKEDEV=cross)])
if test x"$samba_cv_HAVE_MAKEDEV" = x"yes"; then
    AC_DEFINE(HAVE_MAKEDEV,1,[Whether the macro for makedev is available])
fi

AC_CACHE_CHECK([for unsigned char],samba_cv_HAVE_UNSIGNED_CHAR,[
AC_TRY_RUN([#include <stdio.h>
main() { char c; c=250; exit((c > 0)?0:1); }],
samba_cv_HAVE_UNSIGNED_CHAR=yes,samba_cv_HAVE_UNSIGNED_CHAR=no,samba_cv_HAVE_UNSIGNED_CHAR=cross)])
if test x"$samba_cv_HAVE_UNSIGNED_CHAR" = x"yes"; then
    AC_DEFINE(HAVE_UNSIGNED_CHAR,1,[Whether the 'unsigned char' type is available])
fi

AC_CACHE_CHECK([whether seekdir returns void],samba_cv_SEEKDIR_RETURNS_VOID,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <dirent.h>
void seekdir(DIR *d, long loc) { return; }],[return 0;],
samba_cv_SEEKDIR_RETURNS_VOID=yes,samba_cv_SEEKDIR_RETURNS_VOID=no)])
if test x"$samba_cv_SEEKDIR_RETURNS_VOID" = x"yes"; then
    AC_DEFINE(SEEKDIR_RETURNS_VOID,1,[Whether seekdir returns void])
fi

AC_CACHE_CHECK([for __FUNCTION__ macro],samba_cv_HAVE_FUNCTION_MACRO,[
AC_TRY_COMPILE([#include <stdio.h>], [printf("%s\n", __FUNCTION__);],
samba_cv_HAVE_FUNCTION_MACRO=yes,samba_cv_HAVE_FUNCTION_MACRO=no)])
if test x"$samba_cv_HAVE_FUNCTION_MACRO" = x"yes"; then
    AC_DEFINE(HAVE_FUNCTION_MACRO,1,[Whether there is a __FUNCTION__ macro])
fi

if test x"$libreplace_cv_HAVE_CLOCK_GETTIME_IN_LIBRT" = xyes ; then
	LIBS="$LIBS -lrt"
fi

AC_CACHE_CHECK([for broken readdir name],samba_cv_HAVE_BROKEN_READDIR_NAME,[
AC_TRY_RUN([#include <sys/types.h>
#include <dirent.h>
main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
di->d_name[0] == 0) exit(0); exit(1);} ],
samba_cv_HAVE_BROKEN_READDIR_NAME=yes,samba_cv_HAVE_BROKEN_READDIR_NAME=no,samba_cv_HAVE_BROKEN_READDIR_NAME=cross)])
if test x"$samba_cv_HAVE_BROKEN_READDIR_NAME" = x"yes"; then
    AC_DEFINE(HAVE_BROKEN_READDIR_NAME,1,[Whether readdir() returns the wrong name offset])
fi

AC_CACHE_CHECK([for utimbuf],samba_cv_HAVE_UTIMBUF,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utime.h>],
[struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));],
samba_cv_HAVE_UTIMBUF=yes,samba_cv_HAVE_UTIMBUF=no,samba_cv_HAVE_UTIMBUF=cross)])
if test x"$samba_cv_HAVE_UTIMBUF" = x"yes"; then
    AC_DEFINE(HAVE_UTIMBUF,1,[Whether struct utimbuf is available])
fi

##############
# Check utmp details, but only if our OS offers utmp.h
if test x"$ac_cv_header_utmp_h" = x"yes"; then
dnl  utmp and utmpx come in many flavours
dnl  We need to check for many of them
dnl  But we don't need to do each and every one, because our code uses
dnl  mostly just the utmp (not utmpx) fields.

AC_CHECK_FUNCS(pututline pututxline updwtmp updwtmpx getutmpx getutxent)

AC_CACHE_CHECK([for ut_name in utmp],samba_cv_HAVE_UT_UT_NAME,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_name[0] = 'a';],
samba_cv_HAVE_UT_UT_NAME=yes,samba_cv_HAVE_UT_UT_NAME=no,samba_cv_HAVE_UT_UT_NAME=cross)])
if test x"$samba_cv_HAVE_UT_UT_NAME" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_NAME,1,[Whether the utmp struct has a property ut_name])
fi

AC_CACHE_CHECK([for ut_user in utmp],samba_cv_HAVE_UT_UT_USER,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_user[0] = 'a';],
samba_cv_HAVE_UT_UT_USER=yes,samba_cv_HAVE_UT_UT_USER=no,samba_cv_HAVE_UT_UT_USER=cross)])
if test x"$samba_cv_HAVE_UT_UT_USER" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_USER,1,[Whether the utmp struct has a property ut_user])
fi

AC_CACHE_CHECK([for ut_id in utmp],samba_cv_HAVE_UT_UT_ID,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_id[0] = 'a';],
samba_cv_HAVE_UT_UT_ID=yes,samba_cv_HAVE_UT_UT_ID=no,samba_cv_HAVE_UT_UT_ID=cross)])
if test x"$samba_cv_HAVE_UT_UT_ID" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_ID,1,[Whether the utmp struct has a property ut_id])
fi

AC_CACHE_CHECK([for ut_host in utmp],samba_cv_HAVE_UT_UT_HOST,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_host[0] = 'a';],
samba_cv_HAVE_UT_UT_HOST=yes,samba_cv_HAVE_UT_UT_HOST=no,samba_cv_HAVE_UT_UT_HOST=cross)])
if test x"$samba_cv_HAVE_UT_UT_HOST" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_HOST,1,[Whether the utmp struct has a property ut_host])
fi

AC_CACHE_CHECK([for ut_time in utmp],samba_cv_HAVE_UT_UT_TIME,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  time_t t; ut.ut_time = t;],
samba_cv_HAVE_UT_UT_TIME=yes,samba_cv_HAVE_UT_UT_TIME=no,samba_cv_HAVE_UT_UT_TIME=cross)])
if test x"$samba_cv_HAVE_UT_UT_TIME" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_TIME,1,[Whether the utmp struct has a property ut_time])
fi

AC_CACHE_CHECK([for ut_tv in utmp],samba_cv_HAVE_UT_UT_TV,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  struct timeval tv; ut.ut_tv = tv;],
samba_cv_HAVE_UT_UT_TV=yes,samba_cv_HAVE_UT_UT_TV=no,samba_cv_HAVE_UT_UT_TV=cross)])
if test x"$samba_cv_HAVE_UT_UT_TV" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_TV,1,[Whether the utmp struct has a property ut_tv])
fi

AC_CACHE_CHECK([for ut_type in utmp],samba_cv_HAVE_UT_UT_TYPE,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_type = 0;],
samba_cv_HAVE_UT_UT_TYPE=yes,samba_cv_HAVE_UT_UT_TYPE=no,samba_cv_HAVE_UT_UT_TYPE=cross)])
if test x"$samba_cv_HAVE_UT_UT_TYPE" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_TYPE,1,[Whether the utmp struct has a property ut_type])
fi

AC_CACHE_CHECK([for ut_pid in utmp],samba_cv_HAVE_UT_UT_PID,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_pid = 0;],
samba_cv_HAVE_UT_UT_PID=yes,samba_cv_HAVE_UT_UT_PID=no,samba_cv_HAVE_UT_UT_PID=cross)])
if test x"$samba_cv_HAVE_UT_UT_PID" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_PID,1,[Whether the utmp struct has a property ut_pid])
fi

AC_CACHE_CHECK([for ut_exit in utmp],samba_cv_HAVE_UT_UT_EXIT,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_exit.e_exit = 0;],
samba_cv_HAVE_UT_UT_EXIT=yes,samba_cv_HAVE_UT_UT_EXIT=no,samba_cv_HAVE_UT_UT_EXIT=cross)])
if test x"$samba_cv_HAVE_UT_UT_EXIT" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_EXIT,1,[Whether the utmp struct has a property ut_exit])
fi

dnl Look for the IPv6 varient by preference. Many systems have both.
AC_CACHE_CHECK([for ut_addr_v6 in utmp],samba_cv_HAVE_UT_UT_ADDR_V6,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_addr_v6[0] = 0;],
samba_cv_HAVE_UT_UT_ADDR_V6=yes,samba_cv_HAVE_UT_UT_ADDR_V6=no,samba_cv_HAVE_UT_UT_ADDR_V6=cross)])
if test x"$samba_cv_HAVE_UT_UT_ADDR_V6" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_ADDR_V6,1,[Whether the utmp struct has a property ut_addr_v6])
fi

AC_CACHE_CHECK([for ut_addr in utmp],samba_cv_HAVE_UT_UT_ADDR,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
[struct utmp ut;  ut.ut_addr = 0;],
samba_cv_HAVE_UT_UT_ADDR=yes,samba_cv_HAVE_UT_UT_ADDR=no,samba_cv_HAVE_UT_UT_ADDR=cross)])
if test x"$samba_cv_HAVE_UT_UT_ADDR" = x"yes"; then
    AC_DEFINE(HAVE_UT_UT_ADDR,1,[Whether the utmp struct has a property ut_addr])
fi

if test x$ac_cv_func_pututline = xyes ; then
  AC_CACHE_CHECK([whether pututline returns pointer],samba_cv_PUTUTLINE_RETURNS_UTMP,[
  AC_TRY_COMPILE([#include <sys/types.h>
#include <utmp.h>],
  [struct utmp utarg; struct utmp *utreturn; utreturn = pututline(&utarg);],
  samba_cv_PUTUTLINE_RETURNS_UTMP=yes,samba_cv_PUTUTLINE_RETURNS_UTMP=no)])
  if test x"$samba_cv_PUTUTLINE_RETURNS_UTMP" = x"yes"; then
      AC_DEFINE(PUTUTLINE_RETURNS_UTMP,1,[Whether pututline returns pointer])
  fi
fi

AC_CACHE_CHECK([for ut_syslen in utmpx],samba_cv_HAVE_UX_UT_SYSLEN,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <utmpx.h>],
[struct utmpx ux;  ux.ut_syslen = 0;],
samba_cv_HAVE_UX_UT_SYSLEN=yes,samba_cv_HAVE_UX_UT_SYSLEN=no,samba_cv_HAVE_UX_UT_SYSLEN=cross)])
if test x"$samba_cv_HAVE_UX_UT_SYSLEN" = x"yes"; then
    AC_DEFINE(HAVE_UX_UT_SYSLEN,1,[Whether the utmpx struct has a property ut_syslen])
fi

fi
# end utmp details

AC_CACHE_CHECK([for linux fallocate],samba_cv_HAVE_LINUX_FALLOCATE,[
AC_TRY_COMPILE([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
#define _GNU_SOURCE
#include <fcntl.h>
#if defined(HAVE_LINUX_FALLOC_H)
#include <linux/falloc.h>
#endif],
[int ret = fallocate(0, FALLOC_FL_KEEP_SIZE, 0, 10);],
samba_cv_HAVE_LINUX_FALLOCATE=yes,samba_cv_HAVE_LINUX_FALLOCATE=no)])
if test x"$samba_cv_HAVE_LINUX_FALLOCATE" = x"yes" && test x"$ac_cv_func_fallocate" = x"yes"; then
    AC_DEFINE(HAVE_LINUX_FALLOCATE,1,[Whether the Linux 'fallocate' function is available])
fi

AC_CACHE_CHECK([for linux fallocate64],samba_cv_HAVE_LINUX_FALLOCATE64,[
AC_TRY_COMPILE([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
#define _GNU_SOURCE
#include <fcntl.h>
#if defined(HAVE_LINUX_FALLOC_H)
#include <linux/falloc.h>
#endif],
[int ret = fallocate64(0, FALLOC_FL_KEEP_SIZE, 0, 10);],
samba_cv_HAVE_LINUX_FALLOCATE64=yes,samba_cv_HAVE_LINUX_FALLOCATE64=no)])
if test x"$samba_cv_HAVE_LINUX_FALLOCATE64" = x"yes" && test x"$ac_cv_func_fallocate64" = x"yes"; then
    AC_DEFINE(HAVE_LINUX_FALLOCATE64,1,[Whether the Linux 'fallocate64' function is available])
fi

ICONV_LOOK_DIRS="/usr /usr/local /sw /opt"
AC_ARG_WITH(libiconv,
[AS_HELP_STRING([--with-libiconv=BASEDIR], [Use libiconv in BASEDIR/lib and BASEDIR/include (default=auto)])],
[
  if test "$withval" = "no" ; then
    AC_MSG_ERROR([argument to --with-libiconv must be a directory])
  else
     if test "$withval" != "yes" ; then
	ICONV_PATH_SPEC=yes
        ICONV_LOOK_DIRS="$withval"
     fi
  fi
])

for i in $ICONV_LOOK_DIRS ; do

    save_LIBS="$LIBS"
    save_LDFLAGS="$LDFLAGS"
    save_CPPFLAGS="$CPPFLAGS"

    iconv_current_LIBS=""
    iconv_current_LDFLAGS=""
    iconv_current_CPPFLAGS=""

    ICONV_FOUND="no"
    unset libext

    #  This is here to handle -withval stuff for --with-libiconv
    #  Perhaps we should always add a -L
    CPPFLAGS="$save_CPPFLAGS -I$i/include"

    # Check lib and lib32 library variants to cater for IRIX ABI-specific
    # installation paths. This gets a little tricky since we might have iconv
    # in both libiconv and in libc. In this case the jm_ICONV test will always
    # succeed when the header is found. To counter this, make sure the
    # library directory is there and check the ABI directory first (which
    # should be harmless on other systems, but causes tons of linker warnings on
    # 64bit Ubuntu systems).
    # As the build farm doesn't seem to have any IRIX machines with iconv.h
    # installed, I've decided to fix the linker warnings.
    # -- Kai
    # For IA64 HPUX systems, the libs are located in lib/hpux32 instead of lib.
    for l in "lib" "lib32" "lib/hpux32"; do
        if test -d "$i/$l" ; then
                LDFLAGS="$save_LDFLAGS -L$i/$l"
		LIBS=
		export LDFLAGS LIBS CPPFLAGS
		# Try to find iconv(3)
                jm_ICONV($i/$l)
                if test x"$ICONV_FOUND" = "xyes" ; then
		    libext="$l"
		    break
		fi
        fi
    done

    if test x"$ICONV_FOUND" = "xyes" ; then
	iconv_current_LDFLAGS="-L$i/$libext"
	iconv_current_CPPFLAGS="-I$i/include"

        if test x"$jm_cv_lib_iconv" != x; then
	    iconv_current_LIBS="$LIBS -l$jm_cv_lib_iconv"
	else
	    # We found iconv in libc.
	    iconv_current_LIBS=""
        fi

    fi

    if test x"$ICONV_FOUND" = "xyes" ; then

        LDFLAGS="$save_LDFLAGS $iconv_current_LDFLAGS"
        CPPFLAGS="$save_CPPFLAGS $iconv_current_CPPFLAGS"
	LIBS="$save_LIBS $iconv_current_LIBS"
        export LDFLAGS LIBS CPPFLAGS

	default_dos_charset=no
	default_display_charset=no
	default_unix_charset=no

	# check for default dos charset name
	for j in CP850 IBM850 ; do
	    rjs_CHARSET($j)
	    default_dos_charset="$ICONV_CHARSET"
	    if test x"$default_dos_charset" = x"$j"; then
		break
	    fi
	done

	# check for default display charset name
	for j in ASCII 646 ; do
	    rjs_CHARSET($j)
	    default_display_charset="$ICONV_CHARSET"
	    if test x"$default_display_charset" = x"$j"; then
		break
	    fi
	done

	# check for default unix charset name
	for j in UTF-8 UTF8 ; do
	    rjs_CHARSET($j)
	    default_unix_charset="$ICONV_CHARSET"
	    if test x"$default_unix_charset" = x"$j"; then
		break
	    fi
	done

	if test "$default_dos_charset" != "no" -a \
		"$default_dos_charset" != "cross" -a \
		"$default_display_charset" != "no" -a \
		"$default_display_charset" != "cross" -a \
		"$default_unix_charset" != "no" -a \
		"$default_unix_charset" != "cross"
	then
		samba_cv_HAVE_NATIVE_ICONV=yes
	else
	    if test "$default_dos_charset" = "cross" -o \
		     "$default_display_charset" = "cross" -o \
		     "$default_unix_charset" = "cross"
	    then
		    samba_cv_HAVE_NATIVE_ICONV=cross
	    else
		    samba_cv_HAVE_NATIVE_ICONV=no
	    fi
	fi

	# At this point, we have a libiconv candidate. We know that
	# we have the right headers and libraries, but we don't know
	# whether it does the conversions we want. We can't test this
	# because we are cross-compiling. This is not necessarily a big
	# deal, since we can't guarantee that the results we get now will
	# match the results we get at runtime anyway.
	if test x"$samba_cv_HAVE_NATIVE_ICONV" = x"cross" ; then
	    default_dos_charset="CP850"
	    default_display_charset="ASCII"
	    default_unix_charset="UTF-8"
	    samba_cv_HAVE_NATIVE_ICONV=yes
	    AC_MSG_WARN(assuming the libiconv in $iconv_current_LDFLAGS can convert)
	    AC_MSG_WARN([$default_dos_charset, $default_display_charset and $default_unix_charset to UCS-16LE])
	fi

        if test x"$samba_cv_HAVE_NATIVE_ICONV" = x"yes" ; then

	    CPPFLAGS=$save_CPPFLAGS
	    LDFLAGS=$save_LDFLAGS
	    LIBS=$save_LIBS

	    if test x"$iconv_current_LIBS" != x; then
		LIBS="$LIBS $iconv_current_LIBS"
	    fi

	    # Add the flags we need to CPPFLAGS and LDFLAGS
	    CPPFLAGS="$CPPFLAGS $iconv_current_CPPFLAGS"
	    LDFLAGS="$LDFLAGS $iconv_current_LDFLAGS"

	    # Turn the #defines into string literals
	    default_dos_charset="\"$default_dos_charset\""
	    default_display_charset="\"$default_display_charset\""
	    default_unix_charset="\"$default_unix_charset\""

	    AC_DEFINE(HAVE_NATIVE_ICONV,1,[Whether to use native iconv])
	    AC_DEFINE_UNQUOTED(DEFAULT_DOS_CHARSET,$default_dos_charset,[Default dos charset name])
	    AC_DEFINE_UNQUOTED(DEFAULT_DISPLAY_CHARSET,$default_display_charset,[Default display charset name])
	    AC_DEFINE_UNQUOTED(DEFAULT_UNIX_CHARSET,$default_unix_charset,[Default unix charset name])

           break
        fi

    # We didn't find a working iconv, so keep going
    fi

    #  We only need to clean these up here for the next pass through the loop
    CPPFLAGS=$save_CPPFLAGS
    LDFLAGS=$save_LDFLAGS
    LIBS=$save_LIBS
    export LDFLAGS LIBS CPPFLAGS
done
unset libext


if test x"$ICONV_FOUND" = x"no" -o x"$samba_cv_HAVE_NATIVE_ICONV" != x"yes" ; then
    AC_MSG_WARN([Sufficient support for iconv function was not found.
    Install libiconv from http://freshmeat.net/projects/libiconv/ for better charset compatibility!])
   AC_DEFINE_UNQUOTED(DEFAULT_DOS_CHARSET,"ASCII",[Default dos charset name])
   AC_DEFINE_UNQUOTED(DEFAULT_DISPLAY_CHARSET,"ASCII",[Default display charset name])
   AC_DEFINE_UNQUOTED(DEFAULT_UNIX_CHARSET,"UTF8",[Default unix charset name])
fi


AC_CACHE_CHECK([for Linux kernel oplocks],samba_cv_HAVE_KERNEL_OPLOCKS_LINUX,[
AC_TRY_RUN([
#include <sys/types.h>
#include <fcntl.h>
#ifndef F_GETLEASE
#define F_GETLEASE	1025
#endif
main() {
       int fd = open("/dev/null", O_RDONLY);
       return fcntl(fd, F_GETLEASE, 0) == -1;
}
],
samba_cv_HAVE_KERNEL_OPLOCKS_LINUX=yes,samba_cv_HAVE_KERNEL_OPLOCKS_LINUX=no,samba_cv_HAVE_KERNEL_OPLOCKS_LINUX=cross)])
if test x"$samba_cv_HAVE_KERNEL_OPLOCKS_LINUX" = x"yes"; then
    AC_DEFINE(HAVE_KERNEL_OPLOCKS_LINUX,1,[Whether to use linux kernel oplocks])
fi

AC_CACHE_CHECK([for kernel change notify support],samba_cv_HAVE_KERNEL_CHANGE_NOTIFY,[
AC_TRY_RUN([
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#ifndef F_NOTIFY
#define F_NOTIFY 1026
#endif
main() {
       	exit(fcntl(open("/tmp", O_RDONLY), F_NOTIFY, 0) == -1 ?  1 : 0);
}
],
samba_cv_HAVE_KERNEL_CHANGE_NOTIFY=yes,samba_cv_HAVE_KERNEL_CHANGE_NOTIFY=no,samba_cv_HAVE_KERNEL_CHANGE_NOTIFY=cross)])
if test x"$samba_cv_HAVE_KERNEL_CHANGE_NOTIFY" = x"yes"; then
    AC_DEFINE(HAVE_KERNEL_CHANGE_NOTIFY,1,[Whether kernel notifies changes])
fi

AC_CACHE_CHECK([for inotify support],samba_cv_HAVE_INOTIFY,[
AC_CHECK_HEADERS(linux/inotify.h asm/unistd.h sys/inotify.h)
AC_CHECK_FUNCS(inotify_init)
AC_HAVE_DECL(__NR_inotify_init, [#include <asm/unistd.h>])
],
samba_cv_HAVE_INOTIFY=yes,
samba_cv_HAVE_INOTIFY=no,
samba_cv_HAVE_INOTIFY=cross)

if test x"$ac_cv_func_inotify_init" = x"yes"; then
    if test  x"$ac_cv_header_sys_inotify_h" = x"yes" -o x"$ac_cv_header_linux_inotify_h" = x"yes"; then
        AC_DEFINE(HAVE_INOTIFY,1,[Whether kernel or sys has inotify support])
    fi
fi

#################################################
# Check if FAM notifications are available. For FAM info, see
#	http://oss.sgi.com/projects/fam/
#	http://savannah.nongnu.org/projects/fam/
AC_ARG_ENABLE(fam,
[AS_HELP_STRING([--enable-fam], [Turn on FAM support (default=auto)])])

if test x$enable_fam != xno; then
    AC_CHECK_HEADERS(fam.h, [samba_cv_HAVE_FAM_H=yes], [samba_cv_HAVE_FAM_H=no])
    if test x"$samba_cv_HAVE_FAM_H" = x"yes"; then
        # On IRIX, libfam requires libC, but other FAM implementations
	# might not need it.
        AC_CHECK_LIB(fam, FAMOpen2,
	    [samba_cv_HAVE_LIBFAM=yes; SMB_FAM_LIBS="-lfam";
	    AC_DEFINE(HAVE_FAMOPEN2, 1, Define to 1 if there is support for FAMOpen2)],
	    [samba_cv_HAVE_LIBFAM=no])

        if test x"$samba_cv_HAVE_LIBFAM" = x"no" ; then
            samba_fam_xtra=-lC
            AC_CHECK_LIB_EXT(fam, samba_fam_xtra, FAMOpen2,
		[samba_cv_HAVE_LIBFAM=yes; SMB_FAM_LIBS="-lfam -lC";
		AC_DEFINE(HAVE_FAMOPEN2, 1, Define to 1 if there is support for FAMOpen2)],
		[samba_cv_HAVE_LIBFAM=no])
            unset samba_fam_xtra
        fi
    fi
    if test x"$samba_cv_HAVE_LIBFAM" = x"yes" ; then
        default_shared_modules="$default_shared_modules vfs_notify_fam"
        AC_TRY_COMPILE([#include <fam.h>],
                    [enum FAMCodes code = FAMChanged;],
                    AC_DEFINE(HAVE_FAM_H_FAMCODES_TYPEDEF, 1,
                        [Whether fam.h contains a typedef for enum FAMCodes]),
                    [])
    fi

    if test x"$samba_cv_HAVE_LIBFAM" = x"yes" ; then
	AC_CHECK_LIB(fam, FAMNoExists,
	    [AC_DEFINE(HAVE_FAMNOEXISTS, 1, Define to 1 if there is support for FAMNoExists)])
    fi

    if test x$enable_fam = xyes && test x"$samba_cv_HAVE_LIBFAM" != xyes ; then
        AC_MSG_ERROR(FAM support requested but FAM library not available )
    fi
fi

AC_SUBST(SMB_FAM_LIBS)

#################################################
# Check for DMAPI interfaces in libdm/libjfsdm/libxsdm


with_dmapi_support=auto
AC_MSG_CHECKING(whether to use DMAPI support)
AC_ARG_WITH(dmapi,
[AS_HELP_STRING([--with-dmapi], [Include DMAPI/XDSM support (default=auto)])],
[ case "$withval" in
  yes|no)
    with_dmapi_support=$withval
    ;;
  esac ]
)
AC_MSG_RESULT([$with_dmapi_support])

if test x"$with_dmapi_support" != xno ; then
	SMB_CHECK_DMAPI([], [
		AC_MSG_NOTICE(DMAPI support not present)
		if test x"$with_dmapi_support" = xyes ; then
			AC_MSG_ERROR(no DMAPI support found but requested!)
		fi
		]
	)
fi

# Add TSM SM VFS module only if there are both GPFS and DMAPI support
# Theoretically it should work with AIX JFS2 too but this needs testing
if test x"$ac_cv_header_gpfs_gpl_h" = x"yes" && test x"$samba_dmapi_libs" != x"" ; then
    default_shared_modules="$default_shared_modules vfs_tsmsm"
fi

AC_CACHE_CHECK([for kernel share modes],samba_cv_HAVE_KERNEL_SHARE_MODES,[
AC_TRY_RUN([
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/file.h>
#ifndef LOCK_MAND
#define LOCK_MAND	32
#define LOCK_READ	64
#endif
main() {
       	exit(flock(open("/dev/null", O_RDWR), LOCK_MAND|LOCK_READ) != 0);
}
],
samba_cv_HAVE_KERNEL_SHARE_MODES=yes,samba_cv_HAVE_KERNEL_SHARE_MODES=no,samba_cv_HAVE_KERNEL_SHARE_MODES=cross)])
if test x"$samba_cv_HAVE_KERNEL_SHARE_MODES" = x"yes"; then
    AC_DEFINE(HAVE_KERNEL_SHARE_MODES,1,[Whether the kernel supports share modes])
fi


AC_CACHE_CHECK([for IRIX kernel oplock type definitions],samba_cv_HAVE_KERNEL_OPLOCKS_IRIX,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <fcntl.h>],
[oplock_stat_t t; t.os_state = OP_REVOKE; t.os_dev = 1; t.os_ino = 1;],
samba_cv_HAVE_KERNEL_OPLOCKS_IRIX=yes,samba_cv_HAVE_KERNEL_OPLOCKS_IRIX=no)])
if test x"$samba_cv_HAVE_KERNEL_OPLOCKS_IRIX" = x"yes"; then
    AC_DEFINE(HAVE_KERNEL_OPLOCKS_IRIX,1,[Whether IRIX kernel oplock type definitions are available])
fi

#################################################
# Check for POSIX capability support

AC_CHECK_HEADER(sys/capability.h, [samba_cv_HAVE_SYS_CAPABILITY_H=yes;
    AC_DEFINE(HAVE_SYS_CAPABILITY_H, 1, Whether sys/capability.h is present)],
    [], [])

if test x"$samba_cv_HAVE_SYS_CAPABILITY_H" = x"yes"; then

    ac_save_LIBS=$LIBS
    AC_LIBTESTFUNC(cap, cap_get_proc)

    AC_CACHE_CHECK([for POSIX capabilities],
	    samba_cv_HAVE_POSIX_CAPABILITIES,
	    [
		AC_TRY_RUN([
#include <sys/types.h>
#include <sys/capability.h>
main() {
 cap_t cap;
 cap_value_t vals[1];
 if (!(cap = cap_get_proc()))
   exit(1);
 vals[0] = CAP_CHOWN;
 cap_set_flag(cap, CAP_INHERITABLE, 1, vals, CAP_CLEAR);
 cap_set_proc(cap);
 exit(0);
}],
		samba_cv_HAVE_POSIX_CAPABILITIES=yes,
		samba_cv_HAVE_POSIX_CAPABILITIES=no,
		samba_cv_HAVE_POSIX_CAPABILITIES=cross)
	    ])

if test x"$samba_cv_HAVE_POSIX_CAPABILITIES" = x"yes"; then
    AC_DEFINE(HAVE_POSIX_CAPABILITIES, 1,
	    [Whether POSIX capabilities are available])
else
    LIBS=$ac_save_LIBS
fi

fi

#
# Check for int16, uint16, int32 and uint32 in rpc/types.h included from rpc/rpc.h
# This is *really* broken but some systems (DEC OSF1) do this.... JRA.
#

AC_CACHE_CHECK([for int16 typedef included by rpc/rpc.h],samba_cv_HAVE_INT16_FROM_RPC_RPC_H,[
AC_TRY_COMPILE([#include <sys/types.h>
#if defined(HAVE_RPC_RPC_H)
#include <rpc/rpc.h>
#endif],
[int16 testvar;],
samba_cv_HAVE_INT16_FROM_RPC_RPC_H=yes,samba_cv_HAVE_INT16_FROM_RPC_RPC_H=no)])
if test x"$samba_cv_HAVE_INT16_FROM_RPC_RPC_H" = x"yes"; then
    AC_DEFINE(HAVE_INT16_FROM_RPC_RPC_H,1,[Whether int16 typedef is included by rpc/rpc.h])
fi

AC_CACHE_CHECK([for uint16 typedef included by rpc/rpc.h],samba_cv_HAVE_UINT16_FROM_RPC_RPC_H,[
AC_TRY_COMPILE([#include <sys/types.h>
#if defined(HAVE_RPC_RPC_H)
#include <rpc/rpc.h>
#endif],
[uint16 testvar;],
samba_cv_HAVE_UINT16_FROM_RPC_RPC_H=yes,samba_cv_HAVE_UINT16_FROM_RPC_RPC_H=no)])
if test x"$samba_cv_HAVE_UINT16_FROM_RPC_RPC_H" = x"yes"; then
    AC_DEFINE(HAVE_UINT16_FROM_RPC_RPC_H,1,[Whether uint16 typedef is included by rpc/rpc.h])
fi

AC_CACHE_CHECK([for int32 typedef included by rpc/rpc.h],samba_cv_HAVE_INT32_FROM_RPC_RPC_H,[
AC_TRY_COMPILE([#include <sys/types.h>
#if defined(HAVE_RPC_RPC_H)
#include <rpc/rpc.h>
#endif],
[int32 testvar;],
samba_cv_HAVE_INT32_FROM_RPC_RPC_H=yes,samba_cv_HAVE_INT32_FROM_RPC_RPC_H=no)])
if test x"$samba_cv_HAVE_INT32_FROM_RPC_RPC_H" = x"yes"; then
    AC_DEFINE(HAVE_INT32_FROM_RPC_RPC_H,1,[Whether int32 typedef is included by rpc/rpc.h])
fi

AC_CACHE_CHECK([for uint32 typedef included by rpc/rpc.h],samba_cv_HAVE_UINT32_FROM_RPC_RPC_H,[
AC_TRY_COMPILE([#include <sys/types.h>
#if defined(HAVE_RPC_RPC_H)
#include <rpc/rpc.h>
#endif],
[uint32 testvar;],
samba_cv_HAVE_UINT32_FROM_RPC_RPC_H=yes,samba_cv_HAVE_UINT32_FROM_RPC_RPC_H=no)])
if test x"$samba_cv_HAVE_UINT32_FROM_RPC_RPC_H" = x"yes"; then
    AC_DEFINE(HAVE_UINT32_FROM_RPC_RPC_H,1,[Whether uint32 typedef is included by rpc/rpc.h])
fi

dnl
dnl Some systems (SCO) have a problem including
dnl <prot.h> and <rpc/rpc.h> due to AUTH_ERROR being defined
dnl as a #define in <prot.h> and as part of an enum
dnl in <rpc/rpc.h>.
dnl

AC_CACHE_CHECK([for conflicting AUTH_ERROR define in rpc/rpc.h],samba_cv_HAVE_RPC_AUTH_ERROR_CONFLICT,[
AC_TRY_COMPILE([#include <sys/types.h>
#ifdef HAVE_SYS_SECURITY_H
#include <sys/security.h>
#include <prot.h>
#endif  /* HAVE_SYS_SECURITY_H */
#if defined(HAVE_RPC_RPC_H)
#include <rpc/rpc.h>
#endif],
[int testvar;],
samba_cv_HAVE_RPC_AUTH_ERROR_CONFLICT=no,samba_cv_HAVE_RPC_AUTH_ERROR_CONFLICT=yes)])
if test x"$samba_cv_HAVE_RPC_AUTH_ERROR_CONFLICT" = x"yes"; then
    AC_DEFINE(HAVE_RPC_AUTH_ERROR_CONFLICT,1,[Whether there is a conflicting AUTH_ERROR define in rpc/rpc.h])
fi

AC_MSG_CHECKING([for test routines])
AC_TRY_RUN([#include "${srcdir-.}/../tests/trivial.c"],
           AC_MSG_RESULT(yes),
	   AC_MSG_ERROR([cant find test code. Aborting config]),
	   AC_MSG_WARN([cannot run when cross-compiling]))

AC_CACHE_CHECK([for ftruncate extend],samba_cv_HAVE_FTRUNCATE_EXTEND,[
AC_TRY_RUN([#include "${srcdir-.}/../tests/ftruncate.c"],
           samba_cv_HAVE_FTRUNCATE_EXTEND=yes,samba_cv_HAVE_FTRUNCATE_EXTEND=no,samba_cv_HAVE_FTRUNCATE_EXTEND=cross)])
if test x"$samba_cv_HAVE_FTRUNCATE_EXTEND" = x"yes"; then
    AC_DEFINE(HAVE_FTRUNCATE_EXTEND,1,[Truncate extend])
fi

AC_CACHE_CHECK([for broken getgroups],samba_cv_HAVE_BROKEN_GETGROUPS,[
AC_TRY_RUN([#include "${srcdir-.}/../tests/getgroups.c"],
           samba_cv_HAVE_BROKEN_GETGROUPS=yes,samba_cv_HAVE_BROKEN_GETGROUPS=no,samba_cv_HAVE_BROKEN_GETGROUPS=cross)])
if test x"$samba_cv_HAVE_BROKEN_GETGROUPS" = x"yes"; then
    AC_DEFINE(HAVE_BROKEN_GETGROUPS,1,[Whether getgroups is broken])
fi

SMB_CHECK_SYSCONF(_SC_NGROUPS_MAX)
SMB_CHECK_SYSCONF(_SC_NPROC_ONLN)
SMB_CHECK_SYSCONF(_SC_NPROCESSORS_ONLN)
SMB_CHECK_SYSCONF(_SC_PAGESIZE)
AC_CHECK_FUNCS(getpagesize)

################################################
# look for a method of setting the effective uid
seteuid=no;

if test $seteuid = no; then
AC_CACHE_CHECK([for setreuid],samba_cv_USE_SETREUID,[
AC_TRY_RUN([
#define AUTOCONF_TEST 1
#define USE_SETREUID 1
#include "confdefs.h"
#include "${srcdir-.}/lib/util_sec.c"],
           samba_cv_USE_SETREUID=yes,samba_cv_USE_SETREUID=no,samba_cv_USE_SETREUID=cross)])
if test x"$samba_cv_USE_SETREUID" = x"yes"; then
    seteuid=yes;AC_DEFINE(USE_SETREUID,1,[Whether setreuid() is available])
fi
fi

# we check for setresuid second as it conflicts with AIO on Linux. 
# see http://samba.org/~tridge/junkcode/aio_uid.c
if test $seteuid = no; then
AC_CACHE_CHECK([for setresuid],samba_cv_USE_SETRESUID,[
AC_TRY_RUN([
#define AUTOCONF_TEST 1
#define USE_SETRESUID 1
#include "confdefs.h"
#include "${srcdir-.}/lib/util_sec.c"],
           samba_cv_USE_SETRESUID=yes,samba_cv_USE_SETRESUID=no,samba_cv_USE_SETRESUID=cross)])
if test x"$samba_cv_USE_SETRESUID" = x"yes"; then
    seteuid=yes;AC_DEFINE(USE_SETRESUID,1,[Whether setresuid() is available])
fi
fi

if test $seteuid = no; then
AC_CACHE_CHECK([for seteuid],samba_cv_USE_SETEUID,[
AC_TRY_RUN([
#define AUTOCONF_TEST 1
#define USE_SETEUID 1
#include "confdefs.h"
#include "${srcdir-.}/lib/util_sec.c"],
           samba_cv_USE_SETEUID=yes,samba_cv_USE_SETEUID=no,samba_cv_USE_SETEUID=cross)])
if test x"$samba_cv_USE_SETEUID" = x"yes"; then
    seteuid=yes;AC_DEFINE(USE_SETEUID,1,[Whether seteuid() is available])
fi
fi

if test $seteuid = no; then
AC_CACHE_CHECK([for setuidx],samba_cv_USE_SETUIDX,[
AC_TRY_RUN([
#define AUTOCONF_TEST 1
#define USE_SETUIDX 1
#include "confdefs.h"
#include "${srcdir-.}/lib/util_sec.c"],
           samba_cv_USE_SETUIDX=yes,samba_cv_USE_SETUIDX=no,samba_cv_USE_SETUIDX=cross)])
if test x"$samba_cv_USE_SETUIDX" = x"yes"; then
    seteuid=yes;AC_DEFINE(USE_SETUIDX,1,[Whether setuidx() is available])
fi
fi

AC_CACHE_CHECK([for the Darwin initgroups system call],
	samba_cv_DARWIN_INITGROUPS,
	AC_TRY_LINK([
#include <sys/syscall.h>
#include <unistd.h>
	],
	[ syscall(SYS_initgroups, 16, NULL, NULL, 0); ],
	samba_cv_DARWIN_INITGROUPS=yes,
	samba_cv_DARWIN_INITGROUPS=no)
)

if test x"$samba_cv_DARWIN_INITGROUPS" = x"yes" ; then
    AC_DEFINE(HAVE_DARWIN_INITGROUPS, 1,
	[Whether to use the Darwin-specific initgroups system call])
fi

AC_CACHE_CHECK([for fcntl locking],samba_cv_HAVE_FCNTL_LOCK,[
AC_TRY_RUN([#include "${srcdir-.}/../tests/fcntl_lock.c"],
           samba_cv_HAVE_FCNTL_LOCK=yes,samba_cv_HAVE_FCNTL_LOCK=no,samba_cv_HAVE_FCNTL_LOCK=cross)])
if test x"$samba_cv_HAVE_FCNTL_LOCK" = x"yes"; then
    AC_DEFINE(HAVE_FCNTL_LOCK,1,[Whether fcntl locking is available])
fi

AC_CACHE_CHECK([for broken (glibc2.1/x86) 64 bit fcntl locking],samba_cv_HAVE_BROKEN_FCNTL64_LOCKS,[
AC_TRY_RUN([#include "${srcdir-.}/../tests/fcntl_lock64.c"],
           samba_cv_HAVE_BROKEN_FCNTL64_LOCKS=yes,samba_cv_HAVE_BROKEN_FCNTL64_LOCKS=no,samba_cv_HAVE_BROKEN_FCNTL64_LOCKS=cross)])
if test x"$samba_cv_HAVE_BROKEN_FCNTL64_LOCKS" = x"yes"; then
    AC_DEFINE(HAVE_BROKEN_FCNTL64_LOCKS,1,[Whether fcntl64 locks are broken])

else

dnl
dnl Don't check for 64 bit fcntl locking if we know that the
dnl glibc2.1 broken check has succeeded.
dnl

  AC_CACHE_CHECK([for 64 bit fcntl locking],samba_cv_HAVE_STRUCT_FLOCK64,[
  AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdlib.h>

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_SYS_FCNTL_H
#include <sys/fcntl.h>
#endif
main() { struct flock64 fl64;
#if defined(F_SETLKW64) && defined(F_SETLK64) && defined(F_GETLK64)
exit(0);
#else
exit(1);
#endif
}],
       samba_cv_HAVE_STRUCT_FLOCK64=yes,samba_cv_HAVE_STRUCT_FLOCK64=no,samba_cv_HAVE_STRUCT_FLOCK64=cross)])

  if test x"$samba_cv_HAVE_STRUCT_FLOCK64" = x"yes"; then
      AC_DEFINE(HAVE_STRUCT_FLOCK64,1,[Whether the flock64 struct is available])
  fi
fi

# glibc up to 2.3.6 had dangerously broken posix_fallocate(). DON'T USE IT.
AC_CACHE_CHECK([for broken posix_fallocate],samba_cv_HAVE_BROKEN_POSIX_FALLOCATE,[
AC_TRY_COMPILE([
  #define _XOPEN_SOURCE 600
  #include <stdlib.h>
  #if defined(__GLIBC__) && ((__GLIBC__ < 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 4))
    probably broken posix_fallocate
  #endif
], [
], 
samba_cv_HAVE_BROKEN_POSIX_FALLOCATE=no,samba_cv_HAVE_BROKEN_POSIX_FALLOCATE=yes)])
if test x"$samba_cv_HAVE_BROKEN_POSIX_FALLOCATE" = xyes; then
	AC_DEFINE(HAVE_BROKEN_POSIX_FALLOCATE,, Whether we have a broken posix_fallocate)
fi


AC_CACHE_CHECK([for st_blocks in struct stat],samba_cv_HAVE_STAT_ST_BLOCKS,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>],
[struct stat st;  st.st_blocks = 0;],
samba_cv_HAVE_STAT_ST_BLOCKS=yes,samba_cv_HAVE_STAT_ST_BLOCKS=no,samba_cv_HAVE_STAT_ST_BLOCKS=cross)])
if test x"$samba_cv_HAVE_STAT_ST_BLOCKS" = x"yes"; then
    AC_DEFINE(HAVE_STAT_ST_BLOCKS,1,[Whether the stat struct has a st_block property])
fi

AC_CHECK_TYPES([blksize_t, blkcnt_t], [], [], [[#include <sys/stat.h>]])

AC_CACHE_CHECK([for st_blksize in struct stat],samba_cv_HAVE_STAT_ST_BLKSIZE,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>],
[struct stat st;  st.st_blksize = 0;],
samba_cv_HAVE_STAT_ST_BLKSIZE=yes,samba_cv_HAVE_STAT_ST_BLKSIZE=no,samba_cv_HAVE_STAT_ST_BLKSIZE=cross)])
if test x"$samba_cv_HAVE_STAT_ST_BLKSIZE" = x"yes"; then
    AC_DEFINE(HAVE_STAT_ST_BLKSIZE,1,[Whether the stat struct has a st_blksize property])
fi

AC_CACHE_CHECK([for st_flags in struct stat],
	samba_cv_HAVE_STAT_ST_FLAGS,
	[
	    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>],
	    [struct stat st;  st.st_flags = 0;],
	    samba_cv_HAVE_STAT_ST_FLAGS=yes,
	    samba_cv_HAVE_STAT_ST_FLAGS=no,
	    samba_cv_HAVE_STAT_ST_FLAGS=cross)
	])

if test x"$samba_cv_HAVE_STAT_ST_FLAGS" = x"yes"; then
    AC_DEFINE(HAVE_STAT_ST_FLAGS, 1,
		[Whether the stat struct has a st_flags member])
fi

AC_CACHE_CHECK([for broken nisplus include files],samba_cv_BROKEN_NISPLUS_INCLUDE_FILES,[
AC_TRY_COMPILE([
#include <sys/types.h>
#include <sys/acl.h>
#if defined(HAVE_RPCSVC_NIS_H)
#include <rpcsvc/nis.h>
#endif],
[int i;],
samba_cv_BROKEN_NISPLUS_INCLUDE_FILES=no,samba_cv_BROKEN_NISPLUS_INCLUDE_FILES=yes)])
if test x"$samba_cv_BROKEN_NISPLUS_INCLUDE_FILES" = x"yes"; then
	AC_DEFINE(BROKEN_NISPLUS_INCLUDE_FILES,1,[Whether the nisplus include files are broken])
fi

AC_CACHE_CHECK([if the realpath function allows a NULL argument],samba_cv_REALPATH_TAKES_NULL,[
AC_TRY_RUN([
#include <stdio.h>
#include <limits.h>
#include <signal.h>

void exit_on_core(int ignored) {
	exit(1);
}

main() {
	char *newpath;
	signal(SIGSEGV, exit_on_core);
	newpath = realpath("/tmp", NULL);
	exit((newpath != NULL) ? 0 : 1);
}
],
samba_cv_REALPATH_TAKES_NULL=yes,samba_cv_REALPATH_TAKES_NULL=no,samba_cv_REALPATH_TAKES_NULL=cross)])
if test x"$samba_cv_REALPATH_TAKES_NULL" = x"yes"; then
    AC_DEFINE(REALPATH_TAKES_NULL,1,[Whether the realpath function allows NULL])
fi

#################################################
# check for AFS clear-text auth support
samba_cv_WITH_AFS=no
AC_MSG_CHECKING(whether to use AFS clear-text auth)
AC_ARG_WITH(afs,
[AS_HELP_STRING([--with-afs], [Include AFS clear-text auth support (default=no)])],
[ case "$withval" in
  yes|auto)
    AC_MSG_RESULT($withval)
    samba_cv_WITH_AFS=$withval
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

####################################################
# check for Linux-specific AFS fake-kaserver support
samba_cv_WITH_FAKE_KASERVER=no
AC_MSG_CHECKING(whether to use AFS fake-kaserver)
AC_ARG_WITH(fake-kaserver,
[AS_HELP_STRING([--with-fake-kaserver], [Include AFS fake-kaserver support (default=no)])],
[ case "$withval" in
  yes|auto)
    AC_MSG_RESULT($withval)
    samba_cv_WITH_FAKE_KASERVER=$withval
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

#################################################
# decide whether we can support WITH_AFS and / or WITH_FAKE_KASERVER
if test x"$samba_cv_WITH_AFS" != x"no" ||
   test x"$samba_cv_WITH_FAKE_KASERVER" != x"no"; then

    # see if this box has the OpenSSL DES libraries
    AC_CHECK_LIB( crypto, DES_pcbc_encrypt, LIBS="$LIBS -lcrypto" , [AC_ERROR(OpenSSL library: libcrypto ot found!)] )

    # see if this box has the afs-headers in /usr/include/afs
    AC_MSG_CHECKING(for /usr/include/afs)
    if test -d /usr/include/afs; then
          AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no)
    fi

    # check for afs.h
    have_afs_headers=no
    AC_CHECK_HEADERS(afs.h afs/afs.h)
    if test x"$ac_cv_header_afs_h" = x"no" && test x"$ac_cv_header_afs_afs_h" = x"no"; then
    	if test x"$samba_cv_WITH_FAKE_KASERVER" = x"auto" ||
	   test x"$samba_cv_WITH_AFS" = x"auto"; then
	    	AC_MSG_WARN([AFS cannot be supported without afs.h])
	else
	    	AC_MSG_ERROR([AFS cannot be supported without afs.h])
	fi
    else
    	have_afs_headers=yes
    fi
fi

FAKE_KASERVER_OBJ=""
if test x"$samba_cv_WITH_FAKE_KASERVER" != x"no" && test x"$have_afs_headers" = x"yes"; then
    AC_DEFINE(WITH_FAKE_KASERVER,1,[Whether to include AFS fake-kaserver support])
    FAKE_KASERVER_OBJ="utils/net_afs.o"
fi
AC_SUBST(FAKE_KASERVER_OBJ)

#################################################
# check whether to compile AFS/NT ACL mapping module
samba_cv_WITH_VFS_AFSACL=no
AC_MSG_CHECKING(whether to use AFS ACL mapping module)
AC_ARG_WITH(vfs-afsacl,
[AS_HELP_STRING([--with-vfs-afsacl], [Include AFS to NT ACL mapping module (default=no)])],
[ case "$withval" in
  yes|auto)
    AC_MSG_RESULT($withval)
    samba_cv_WITH_VFS_AFSACL=yes
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

if test x"$samba_cv_WITH_VFS_AFSACL" = x"yes"; then
   default_shared_modules="$default_shared_modules vfs_afsacl"
fi
	
if test x"$samba_cv_WITH_AFS" != x"no" && test x"$have_afs_headers" = x"yes"; then
    AC_DEFINE(WITH_AFS,1,[Whether to include AFS clear-text auth support])
fi

#################################################
# check for the DFS clear-text auth system
AC_MSG_CHECKING(whether to use DFS clear-text auth)
AC_ARG_WITH(dfs,
[AS_HELP_STRING([--with-dce-dfs], [Include DCE/DFS clear-text auth support (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    AC_DEFINE(WITH_DFS,1,[Whether to include DFS support])
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

########################################################
# Compile with LDAP support?

with_ldap_support=auto
AC_MSG_CHECKING([for LDAP support])

AC_ARG_WITH(ldap,
[AS_HELP_STRING([--with-ldap], [LDAP support (default=auto)])],
[ case "$withval" in
    yes|no)
	with_ldap_support=$withval
	;;
  esac ])

AC_MSG_RESULT($with_ldap_support)

SMBLDAP=""
AC_SUBST(SMBLDAP)
SMBLDAPUTIL=""
AC_SUBST(SMBLDAPUTIL)

if test x"$with_ldap_support" != x"no"; then

  ##################################################################
  # first test for ldap.h and lber.h
  # (ldap.h is required for this test)
  AC_CHECK_HEADERS(ldap.h lber.h)

  if test x"$ac_cv_header_ldap_h" != x"yes"; then
	if test x"$with_ldap_support" = x"yes"; then
	 AC_MSG_ERROR(ldap.h is needed for LDAP support)
	else
	 AC_MSG_WARN(ldap.h is needed for LDAP support)
	fi
	
	with_ldap_support=no
  fi

  ##################################################################
  # HP/UX does not have ber_tag_t in lber.h - it must be configured as
  # unsigned int in include/includes.h
  case $host_os in
	*hpux*)
	 AC_MSG_WARN(ber_tag_t is needed for LDAP support)
	 AC_MSG_WARN(ber_tag_t must be configured in includes.h for hpux)
	with_ldap_support=yes
  	;;
	*)
  	AC_CHECK_TYPE(ber_tag_t,,,[#include <lber.h>])
  	if test x"$ac_cv_type_ber_tag_t" != x"yes"; then
		if test x"$with_ldap_support" = x"yes"; then
	 	AC_MSG_ERROR(ber_tag_t is needed for LDAP support)
		else
	 	AC_MSG_WARN(ber_tag_t is needed for LDAP support)
		fi
		with_ldap_support=no
  	fi
  	;;
  esac
fi

if test x"$with_ldap_support" != x"no"; then
  ac_save_LIBS=$LIBS

  ##################################################################
  # we might need the lber lib on some systems. To avoid link errors
  # this test must be before the libldap test
  AC_CHECK_LIB_EXT(lber, LDAP_LIBS, ber_scanf)

  ########################################################
  # If ber_sockbuf_add_io() is available we can add
  # SASL wrapping hooks
  AC_CHECK_FUNC_EXT(ber_sockbuf_add_io,$LDAP_LIBS)

  AC_CACHE_CHECK([for LDAP_OPT_SOCKBUF],samba_cv_HAVE_LDAP_OPT_SOCKBUF,[
		 AC_TRY_COMPILE([#include <ldap.h>],
				[int val = LDAP_OPT_SOCKBUF;],
      			samba_cv_HAVE_LDAP_OPT_SOCKBUF=yes,
			samba_cv_HAVE_LDAP_OPT_SOCKBUF=no)])

  if test x"$ac_cv_func_ext_ber_sockbuf_add_io" = x"yes" -a \
  	  x"$samba_cv_HAVE_LDAP_OPT_SOCKBUF" = x"yes"; then
  	AC_DEFINE(HAVE_LDAP_SASL_WRAPPING, 1, [Support for SASL wrapping])
  fi

  #######################################################
  # if we have LBER_OPT_LOG_PRINT_FN, we can intercept
  # ldap logging and print it out in the samba logs
  AC_CACHE_CHECK([for LBER_OPT_LOG_PRINT_FN],
		 samba_cv_HAVE_LBER_OPT_LOG_PRINT_FN,
		 [AC_TRY_COMPILE([#include <lber.h>],
				 [int val = LBER_OPT_LOG_PRINT_FN;],
				 samba_cv_HAVE_LBER_OPT_LOG_PRINT_FN=yes,
				 samba_cv_HAVE_LBER_OPT_LOG_PRINT_FN=no)])

  if test x"$samba_cv_HAVE_LBER_OPT_LOG_PRINT_FN" = x"yes"; then
	AC_DEFINE(HAVE_LBER_LOG_PRINT_FN, 1,
		  [Support for LDAP/LBER logging interception])
  fi

  ########################################################
  # now see if we can find the ldap libs in standard paths
  AC_CHECK_LIB_EXT(ldap, LDAP_LIBS, ldap_init)

  ########################################################
  # If we have LDAP, does it's rebind procedure take 2 or 3 arguments?
  # Check found in pam_ldap 145.
  AC_CHECK_FUNC_EXT(ldap_set_rebind_proc,$LDAP_LIBS)

  LIBS="$LIBS $LDAP_LIBS"
  AC_CACHE_CHECK(whether ldap_set_rebind_proc takes 3 arguments, smb_ldap_cv_ldap_set_rebind_proc, [
    AC_TRY_COMPILE([
	#include <lber.h>
	#include <ldap.h>],
	[ldap_set_rebind_proc(0, 0, 0);],
	[smb_ldap_cv_ldap_set_rebind_proc=3],
	[smb_ldap_cv_ldap_set_rebind_proc=2]
    )
  ])

  AC_DEFINE_UNQUOTED(LDAP_SET_REBIND_PROC_ARGS, $smb_ldap_cv_ldap_set_rebind_proc, [Number of arguments to ldap_set_rebind_proc])

  AC_CHECK_FUNC_EXT(ldap_initialize,$LDAP_LIBS)

  if test x"$ac_cv_lib_ext_ldap_ldap_init" = x"yes"; then
    AC_DEFINE(HAVE_LDAP,1,[Whether ldap is available])
    CPPFLAGS="$CPPFLAGS -DLDAP_DEPRECATED"
    default_static_modules="$default_static_modules pdb_ldap idmap_ldap";
    default_shared_modules="$default_shared_modules";
    SMBLDAP="lib/smbldap.o"
    SMBLDAPUTIL="lib/smbldap_util.o"
    with_ldap_support=yes
    AC_MSG_CHECKING(whether LDAP support is used)
    AC_MSG_RESULT(yes)
  else
    if test x"$with_ldap_support" = x"yes"; then
	AC_MSG_ERROR(libldap is needed for LDAP support)
    else
	AC_MSG_WARN(libldap is needed for LDAP support)
    fi

    LDAP_LIBS=""
    with_ldap_support=no
  fi
  LIBS=$ac_save_LIBS
fi


#################################################
# active directory support

with_ads_support=auto
AC_MSG_CHECKING([for Active Directory and krb5 support])

AC_ARG_WITH(ads,
[AS_HELP_STRING([--with-ads], [Active Directory support (default=auto)])],
[ case "$withval" in
    yes|no)
	with_ads_support="$withval"
	;;
  esac ])

AC_MSG_RESULT($with_ads_support)

FOUND_KRB5=no
KRB5_LIBS=""

if test x"$with_ldap_support" != x"yes"; then

    if test x"$with_ads_support" = x"yes"; then
	AC_MSG_ERROR(Active Directory Support requires LDAP support)
    elif test x"$with_ads_support" = x"auto"; then
	AC_MSG_WARN(Disabling Active Directory support (requires LDAP support))
	with_ads_support=no
    fi

else

    # Check to see whether there is enough LDAP functionality to be able
    # to build AD support.

# HPUX only has ldap_init; ok, we take care of this in smbldap.c
case "$host_os" in
	*hpux*)
    AC_CHECK_FUNC_EXT(ldap_init,$LDAP_LIBS)

    if test x"$ac_cv_func_ext_ldap_init" != x"yes"; then
	if test x"$with_ads_support" = x"yes"; then
	    AC_MSG_ERROR(Active Directory support on HPUX requires ldap_init)
	elif test x"$with_ads_support" = x"auto"; then
	    AC_MSG_WARN(Disabling Active Directory support (requires ldap_init on HPUX))
	    with_ads_support=no
	fi
    fi
    ;;
	*)
    AC_CHECK_FUNC_EXT(ldap_initialize,$LDAP_LIBS)

    if test x"$ac_cv_func_ext_ldap_initialize" != x"yes"; then
	if test x"$with_ads_support" = x"yes"; then
	    AC_MSG_ERROR(Active Directory support requires ldap_initialize)
	elif test x"$with_ads_support" = x"auto"; then
	    AC_MSG_WARN(Disabling Active Directory support (requires ldap_initialize))
	    with_ads_support=no
	fi
    fi
    ;;
esac


    AC_CHECK_FUNC_EXT(ldap_add_result_entry,$LDAP_LIBS)

    if test x"$ac_cv_func_ext_ldap_add_result_entry" != x"yes"; then
	if test x"$with_ads_support" = x"yes"; then
	    AC_MSG_ERROR(Active Directory support requires ldap_add_result_entry)
	elif test x"$with_ads_support" = x"auto"; then
	    AC_MSG_WARN(Disabling Active Directory support (requires ldap_add_result_entry))
	    with_ads_support=no
	fi
    fi

fi

if test x"$with_ads_support" != x"no"; then

  # Do no harm to the values of CFLAGS and LIBS while testing for
  # Kerberos support.

  if test x$FOUND_KRB5 = x"no"; then
    #################################################
    # check for location of Kerberos 5 install
    AC_MSG_CHECKING(for kerberos 5 install path)
    AC_ARG_WITH(krb5,
    [AS_HELP_STRING([--with-krb5=base-dir], [Locate Kerberos 5 support (default=/usr)])],
    [ case "$withval" in
      no)
        AC_MSG_RESULT(no krb5-path given)
        ;;
      yes)
        AC_MSG_RESULT(/usr)
        FOUND_KRB5=yes
        ;;
      *)
        AC_MSG_RESULT($withval)
        KRB5_CFLAGS="-I$withval/include"
        KRB5_CPPFLAGS="-I$withval/include"
        KRB5_LDFLAGS="-L$withval/lib"
        FOUND_KRB5=yes
	if test -x "$withval/bin/krb5-config"; then
		KRB5CONFIG=$withval/bin/krb5-config
	fi
        ;;
      esac ],
      AC_MSG_RESULT(no krb5-path given)
    )
  fi

  #################################################
  # check for krb5-config from recent MIT and Heimdal kerberos 5
  AC_PATH_PROG(KRB5CONFIG, krb5-config)
  AC_MSG_CHECKING(for working krb5-config)
  if test -x "$KRB5CONFIG" && $KRB5CONFIG --libs gssapi > /dev/null ; then
    ac_save_CFLAGS=$CFLAGS
    CFLAGS="";export CFLAGS
    ac_save_LDFLAGS=$LDFLAGS
    LDFLAGS="";export LDFLAGS
    KRB5_LIBS="`$KRB5CONFIG --libs gssapi`"
    KRB5_LDFLAGS="`$KRB5CONFIG --libs gssapi | sed s/-lgss.*//`"
    KRB5_CFLAGS="`$KRB5CONFIG --cflags | sed s/@INCLUDE_des@//`"
    KRB5_CPPFLAGS="`$KRB5CONFIG --cflags | sed s/@INCLUDE_des@//`"
    CFLAGS=$ac_save_CFLAGS;export CFLAGS
    LDFLAGS=$ac_save_LDFLAGS;export LDFLAGS
    FOUND_KRB5=yes
    AC_MSG_RESULT(yes)
  else
    AC_MSG_RESULT(no. Fallback to previous krb5 detection strategy)
  fi

  if test x$FOUND_KRB5 = x"no"; then
    #################################################
    # see if this box has the SuSE location for the heimdal krb implementation
    AC_MSG_CHECKING(for /usr/include/heimdal)
    if test -d /usr/include/heimdal; then
      if test -f /usr/lib/heimdal/lib/libkrb5.a; then
          KRB5_CFLAGS="-I/usr/include/heimdal"
          KRB5_CPPFLAGS="-I/usr/include/heimdal"
          KRB5_LDFLAGS="-L/usr/lib/heimdal/lib"
	  FOUND_KRB5=yes
          AC_MSG_RESULT(yes)
      else
          KRB5_CFLAGS="-I/usr/include/heimdal"
          KRB5_CPPFLAGS="-I/usr/include/heimdal"
	  FOUND_KRB5=yes
          AC_MSG_RESULT(yes)
      fi
    else
      AC_MSG_RESULT(no)
    fi
  fi

  if test x$FOUND_KRB5 = x"no"; then
    #################################################
    # see if this box has the RedHat location for kerberos
    AC_MSG_CHECKING(for /usr/kerberos)
    if test -d /usr/kerberos -a -f /usr/kerberos/lib/libkrb5.a; then
      KRB5_LDFLAGS="-L/usr/kerberos/lib"
      KRB5_CFLAGS="-I/usr/kerberos/include"
      KRB5_CPPFLAGS="-I/usr/kerberos/include"
      FOUND_KRB5=yes
      AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no)
    fi
  fi

  if test x$FOUND_KRB5 = x"no"; then
    #################################################
    # see if this box has the OpenBSD location for heimdal krb5
    AC_MSG_CHECKING(for /usr/include/kerberosV)
    if test -d /usr/include/kerberosV; then
      KRB5_CPPFLAGS="-I/usr/include/kerberosV"
      KRB5_LIBS="-lcrypto"
      FOUND_KRB5=yes
      AC_MSG_RESULT(yes)
    else
      AC_MSG_RESULT(no)
    fi
  fi

  ac_save_CFLAGS=$CFLAGS
  ac_save_CPPFLAGS=$CPPFLAGS
  ac_save_LDFLAGS=$LDFLAGS

  # remove needless evil rpath stuff as early as possible:
  LIB_REMOVE_USR_LIB(KRB5_LIBS)
  LIB_REMOVE_USR_LIB(KRB5_LDFLAGS)
  CFLAGS="$KRB5_CFLAGS $CFLAGS"
  CPPFLAGS="$KRB5_CPPFLAGS $CPPFLAGS"
  LDFLAGS="$KRB5_LDFLAGS $LDFLAGS"

  KRB5_LIBS="$KRB5_LDFLAGS $KRB5_LIBS"

  # now check for krb5.h. Some systems have the libraries without the headers!
  # note that this check is done here to allow for different kerberos
  # include paths
  AC_CHECK_HEADERS(krb5.h)

  if test x"$ac_cv_header_krb5_h" = x"no"; then

    # Give a warning if AD support was not explicitly requested,
    # i.e with_ads_support = auto, otherwise die with an error.

    if test x"$with_ads_support" = x"yes"; then
      AC_MSG_ERROR([Active Directory cannot be supported without krb5.h])
    else
      AC_MSG_WARN([Active Directory cannot be supported without krb5.h])
    fi

    # Turn off AD support and restore CFLAGS and LIBS variables

    with_ads_support="no"

    CFLAGS=$ac_save_CFLAGS
    CPPFLAGS=$ac_save_CPPFLAGS
    LDFLAGS=$ac_save_LDFLAGS
  fi

  # check for new heimdal KRB5_DEPRECATED handling

  AC_CACHE_CHECK([for KRB5_DEPRECATED define taking an identifier],
                samba_cv_HAVE_KRB5_DEPRECATED_WITH_IDENTIFIER,[
    AC_TRY_COMPILE(
      [#define KRB5_DEPRECATED 1
      #include <krb5.h>],
      [],
      samba_cv_HAVE_KRB5_DEPRECATED_WITH_IDENTIFIER=yes,
      samba_cv_HAVE_KRB5_DEPRECATED_WITH_IDENTIFIER=no)])

  if test x"$samba_cv_HAVE_KRB5_DEPRECATED_WITH_IDENTIFIER" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_DEPRECATED_WITH_IDENTIFIER, 1,
	       [Whether to use deprecated krb5 interfaces])
  fi
fi

# Now we have determined whether we really want ADS support
use_ads=no
if test x"$with_ads_support" != x"no"; then
  use_ads=yes
  have_gssapi=no
  ac_save_LIBS=$LIBS

  # now check for gssapi headers.  This is also done here to allow for
  # different kerberos include paths
  AC_CHECK_HEADERS(gssapi.h gssapi/gssapi_generic.h gssapi/gssapi.h gssapi/gssapi_ext.h com_err.h)

  ##################################################################
  # we might need the k5crypto and com_err libraries on some systems
  AC_CHECK_LIB_EXT(com_err, KRB5_LIBS, _et_list)
  AC_CHECK_LIB_EXT(k5crypto, KRB5_LIBS, krb5_encrypt_data)

  # Heimdal checks.
  AC_CHECK_LIB_EXT(crypto, KRB5_LIBS, des_set_key)
  AC_CHECK_LIB_EXT(asn1, KRB5_LIBS, copy_Authenticator)
  AC_CHECK_LIB_EXT(roken, KRB5_LIBS, roken_getaddrinfo_hostspec)

  # Heimdal checks. On static Heimdal gssapi must be linked before krb5.
  AC_CHECK_LIB_EXT(gssapi, KRB5_LIBS, gss_display_status,[],[],have_gssapi=yes)

  ########################################################
  # now see if we can find the krb5 libs in standard paths
  # or as specified above
  AC_CHECK_LIB_EXT(krb5, KRB5_LIBS, krb5_mk_req_extended)
  AC_CHECK_LIB_EXT(krb5, KRB5_LIBS, krb5_kt_compare)

  ########################################################
  # now see if we can find the gssapi libs in standard paths
  if test x"$have_gssapi" != x"yes"; then
     AC_CHECK_LIB_EXT(gssapi_krb5, KRB5_LIBS,gss_display_status,[],[],have_gssapi=yes)
     AC_CHECK_FUNC_EXT(gss_wrap_iov, $KRB5_LIBS)
  fi

  AC_CHECK_FUNC_EXT(krb5_set_real_time, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_set_default_in_tkt_etypes, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_set_default_tgs_enctypes, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_set_default_tgs_ktypes, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_principal2salt, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_use_enctype, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_string_to_key, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_pw_salt, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_string_to_key_salt, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_auth_con_setkey, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_auth_con_setuseruserkey, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_permitted_enctypes, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_default_in_tkt_etypes, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_free_data_contents, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_principal_get_comp_string, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_free_unparsed_name, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_free_keytab_entry_contents, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_kt_free_entry, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_krbhst_init, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_krbhst_get_addrinfo, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_c_enctype_compare, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_enctypes_compatible_keys, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_crypto_init, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_crypto_destroy, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_decode_ap_req, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(free_AP_REQ, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_verify_checksum, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_c_verify_checksum, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_principal_compare_any_realm, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_parse_name_norealm, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_princ_size, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_set_pac_request, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_renewed_creds, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_kdc_cred, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_free_error_contents, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(initialize_krb5_error_table, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_alloc, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_free, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_init_creds_opt_get_error, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_enctype_to_string, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_fwd_tgt_creds, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_auth_con_set_req_cksumtype, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_creds_opt_alloc, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_creds_opt_set_impersonate, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_creds, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_credentials_for_user, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_get_host_realm, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(krb5_free_host_realm, $KRB5_LIBS)
  AC_CHECK_FUNC_EXT(gss_get_name_attribute, $KRB5_LIBS)

  # MIT krb5 1.8 does not expose this call (yet)
  AC_CHECK_DECLS(krb5_get_credentials_for_user, [], [], [#include <krb5.h>])

  # MIT krb5 1.7beta3 (in Ubuntu Karmic) does not have this declaration
  # but does have the symbol
  AC_CHECK_DECLS(krb5_auth_con_set_req_cksumtype, [], [], [#include <krb5.h>])

  LIBS="$KRB5_LIBS $LIBS"

  AC_CACHE_CHECK(whether krb5_ticket contains kvno and enctype,
	smb_krb5_cv_ticket_has_keyinfo,
	[
	    AC_TRY_COMPILE(
	    [
		#include <krb5.h>
	    ],
	    [
		krb5_ticket ticket;
		krb5_kvno kvno;
		krb5_enctype enctype;

		enctype = ticket.enc_part.enctype;
		kvno = ticket.enc_part.kvno;
	    ],
	    [ smb_krb5_cv_ticket_has_keyinfo=yes ],
	    [ smb_krb5_cv_ticket_has_keyinfo=no ])
	])

  if test x"$smb_krb5_cv_ticket_has_keyinfo" = x"yes" ; then
	AC_DEFINE(KRB5_TICKET_HAS_KEYINFO, 1,
	    [Whether the krb5_ticket structure contains the kvno and enctype])
  fi

  AC_CACHE_CHECK(whether krb5_get_init_creds_opt_free takes a context argument,
	  smb_krb5_cv_creds_opt_free_context,
	  [
		AC_TRY_COMPILE([
		    #include <krb5.h>],
		    [
			krb5_context ctx;
			krb5_get_init_creds_opt *opt = NULL;
			krb5_get_init_creds_opt_free(ctx, opt);
		    ],
		    [smb_krb5_cv_creds_opt_free_context=yes],
		    [smb_krb5_cv_creds_opt_free_context=no]
		)
	  ])

  if test x"$smb_krb5_cv_creds_opt_free_context" = x"yes" ; then
	AC_DEFINE(KRB5_CREDS_OPT_FREE_REQUIRES_CONTEXT, 1,
	    [Whether krb5_get_init_creds_opt_free takes a context argument])
  fi

  AC_CACHE_CHECK(whether krb5_verify_checksum takes 7 arguments, smb_krb5_cv_verify_checksum, [
    AC_TRY_COMPILE([
	#include <krb5.h>],
	[krb5_verify_checksum(0, 0, 0, 0, 0, 0, 0);],
	[smb_krb5_cv_verify_checksum=7],
	[smb_krb5_cv_verify_checksum=6],
    )
  ])
  AC_DEFINE_UNQUOTED(KRB5_VERIFY_CHECKSUM_ARGS, $smb_krb5_cv_verify_checksum, [Number of arguments to krb5_verify_checksum])

  AC_CACHE_CHECK([for checksum in krb5_checksum],
                samba_cv_HAVE_CHECKSUM_IN_KRB5_CHECKSUM,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_checksum cksum; cksum.checksum.length = 0;],
      samba_cv_HAVE_CHECKSUM_IN_KRB5_CHECKSUM=yes,
      samba_cv_HAVE_CHECKSUM_IN_KRB5_CHECKSUM=no)])

  if test x"$samba_cv_HAVE_CHECKSUM_IN_KRB5_CHECKSUM" = x"yes"; then
    AC_DEFINE(HAVE_CHECKSUM_IN_KRB5_CHECKSUM,1,
               [Whether the krb5_checksum struct has a checksum property])
  fi

  AC_CACHE_CHECK([for etype in EncryptedData],
                samba_cv_HAVE_ETYPE_IN_ENCRYPTEDDATA,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [EncryptedData edata; edata.etype = 0;],
      samba_cv_HAVE_ETYPE_IN_ENCRYPTEDDATA=yes,
      samba_cv_HAVE_ETYPE_IN_ENCRYPTEDDATA=no)])

  if test x"$samba_cv_HAVE_ETYPE_IN_ENCRYPTEDDATA" = x"yes"; then
    AC_DEFINE(HAVE_ETYPE_IN_ENCRYPTEDDATA,1,
               [Whether the EncryptedData struct has a etype property])
  fi

  AC_CACHE_CHECK([for ticket pointer in krb5_ap_req],
                samba_cv_HAVE_TICKET_POINTER_IN_KRB5_AP_REQ,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_ap_req *ap_req; ap_req->ticket = NULL;],
      samba_cv_HAVE_TICKET_POINTER_IN_KRB5_AP_REQ=yes,
      samba_cv_HAVE_TICKET_POINTER_IN_KRB5_AP_REQ=no)])

  if test x"$samba_cv_HAVE_TICKET_POINTER_IN_KRB5_AP_REQ" = x"yes"; then
    AC_DEFINE(HAVE_TICKET_POINTER_IN_KRB5_AP_REQ,1,
               [Whether the krb5_ap_req struct has a ticket pointer])
  fi

  AC_CACHE_CHECK([for e_data pointer in krb5_error],
                samba_cv_HAVE_E_DATA_POINTER_IN_KRB5_ERROR,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_error err; err.e_data = NULL;],
      samba_cv_HAVE_E_DATA_POINTER_IN_KRB5_ERROR=yes,
      samba_cv_HAVE_E_DATA_POINTER_IN_KRB5_ERROR=no)])

  if test x"$samba_cv_HAVE_E_DATA_POINTER_IN_KRB5_ERROR" = x"yes"; then
    AC_DEFINE(HAVE_E_DATA_POINTER_IN_KRB5_ERROR,1,
               [Whether the krb5_error struct has a e_data pointer])
  fi

  AC_CACHE_CHECK([for krb5_crypto type],
                samba_cv_HAVE_KRB5_CRYPTO,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_crypto crypto;],
      samba_cv_HAVE_KRB5_CRYPTO=yes,
      samba_cv_HAVE_KRB5_CRYPTO=no)])

  if test x"$samba_cv_HAVE_KRB5_CRYPTO" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_CRYPTO,1,
               [Whether the type krb5_crypto exists])
  fi

  AC_CACHE_CHECK([for krb5_encrypt_block type],
                samba_cv_HAVE_KRB5_ENCRYPT_BLOCK,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_encrypt_block block;],
      samba_cv_HAVE_KRB5_ENCRYPT_BLOCK=yes,
      samba_cv_HAVE_KRB5_ENCRYPT_BLOCK=no)])

  if test x"$samba_cv_HAVE_KRB5_ENCRYPT_BLOCK" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_ENCRYPT_BLOCK,1,
               [Whether the type krb5_encrypt_block exists])
  fi

  AC_CACHE_CHECK([for addrtype in krb5_address],
                samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_address kaddr; kaddr.addrtype = ADDRTYPE_INET;],
      samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS=yes,
      samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS=no)])

  if test x"$samba_cv_HAVE_ADDRTYPE_IN_KRB5_ADDRESS" = x"yes"; then
    AC_DEFINE(HAVE_ADDRTYPE_IN_KRB5_ADDRESS,1,
               [Whether the krb5_address struct has a addrtype property])
  fi

  AC_CACHE_CHECK([for addr_type in krb5_address],
                 samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_address kaddr; kaddr.addr_type = KRB5_ADDRESS_INET;],
      samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS=yes,
      samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS=no)])

  if test x"$samba_cv_HAVE_ADDR_TYPE_IN_KRB5_ADDRESS" = x"yes"; then
    AC_DEFINE(HAVE_ADDR_TYPE_IN_KRB5_ADDRESS,1,
              [Whether the krb5_address struct has a addr_type property])
  fi

  AC_CACHE_CHECK([for enc_part2 in krb5_ticket],
		 samba_cv_HAVE_KRB5_TKT_ENC_PART2,
                 [AC_TRY_COMPILE([#include <krb5.h>],
    [krb5_ticket tkt; tkt.enc_part2->authorization_data[0]->contents = NULL;],
    samba_cv_HAVE_KRB5_TKT_ENC_PART2=yes,samba_cv_HAVE_KRB5_TKT_ENC_PART2=no)])

  if test x"$samba_cv_HAVE_KRB5_TKT_ENC_PART2" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_TKT_ENC_PART2,1,
              [Whether the krb5_ticket struct has a enc_part2 property])
  fi

  AC_CACHE_CHECK([for keyblock in krb5_creds],
                 samba_cv_HAVE_KRB5_KEYBLOCK_IN_CREDS,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_creds creds; krb5_keyblock kb; creds.keyblock = kb;],
      samba_cv_HAVE_KRB5_KEYBLOCK_IN_CREDS=yes,
      samba_cv_HAVE_KRB5_KEYBLOCK_IN_CREDS=no)])

  if test x"$samba_cv_HAVE_KRB5_KEYBLOCK_IN_CREDS" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KEYBLOCK_IN_CREDS,1,
              [Whether the krb5_creds struct has a keyblock property])
  fi

  AC_CACHE_CHECK([for session in krb5_creds],
                 samba_cv_HAVE_KRB5_SESSION_IN_CREDS,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_creds creds; krb5_keyblock kb; creds.session = kb;],
      samba_cv_HAVE_KRB5_SESSION_IN_CREDS=yes,
      samba_cv_HAVE_KRB5_SESSION_IN_CREDS=no)])

  if test x"$samba_cv_HAVE_KRB5_SESSION_IN_CREDS" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_SESSION_IN_CREDS,1,
              [Whether the krb5_creds struct has a session property])
  fi

  AC_CACHE_CHECK([for keyvalue in krb5_keyblock],
                 samba_cv_HAVE_KRB5_KEYBLOCK_KEYVALUE,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keyblock key; key.keyvalue.data = NULL;],
      samba_cv_HAVE_KRB5_KEYBLOCK_KEYVALUE=yes,
      samba_cv_HAVE_KRB5_KEYBLOCK_KEYVALUE=no)])

  if test x"$samba_cv_HAVE_KRB5_KEYBLOCK_KEYVALUE" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KEYBLOCK_KEYVALUE,1,
              [Whether the krb5_keyblock struct has a keyvalue property])
  fi

  found_arcfour_hmac=no
  AC_CACHE_CHECK([for ENCTYPE_ARCFOUR_HMAC_MD5],
                 samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC_MD5,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_enctype enctype; enctype = ENCTYPE_ARCFOUR_HMAC_MD5;],
      samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC_MD5=yes,
      samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC_MD5=no)])
  AC_CACHE_CHECK([for KEYTYPE_ARCFOUR_56],
                 samba_cv_HAVE_KEYTYPE_ARCFOUR_56,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keytype keytype; keytype = KEYTYPE_ARCFOUR_56;],
      samba_cv_HAVE_KEYTYPE_ARCFOUR_56=yes,
      samba_cv_HAVE_KEYTYPE_ARCFOUR_56=no)])
# Heimdals with KEYTYPE_ARCFOUR but not KEYTYPE_ARCFOUR_56 are broken
# w.r.t. arcfour and windows, so we must not enable it here
  if test x"$samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC_MD5" = x"yes" -a\
          x"$samba_cv_HAVE_KEYTYPE_ARCFOUR_56" = x"yes"; then
    AC_DEFINE(HAVE_ENCTYPE_ARCFOUR_HMAC_MD5,1,
              [Whether the ENCTYPE_ARCFOUR_HMAC_MD5 key type definition is available])
    found_arcfour_hmac=yes
  fi
  AC_CACHE_CHECK([for ENCTYPE_ARCFOUR_HMAC],
                 samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_enctype enctype; enctype = ENCTYPE_ARCFOUR_HMAC;],
      samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC=yes,
      samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC=no)])
  if test x"$samba_cv_HAVE_ENCTYPE_ARCFOUR_HMAC" = x"yes"; then
    AC_DEFINE(HAVE_ENCTYPE_ARCFOUR_HMAC,1,
              [Whether the ENCTYPE_ARCFOUR_HMAC key type definition is available])
    found_arcfour_hmac=yes
  fi

  AC_CACHE_CHECK([for ENCTYPE_AES128_CTS_HMAC_SHA1_96],
                 samba_cv_HAVE_ENCTYPE_AES128_CTS_HMAC_SHA1_96,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_enctype enctype; enctype = ENCTYPE_AES128_CTS_HMAC_SHA1_96;],
      samba_cv_HAVE_ENCTYPE_AES128_CTS_HMAC_SHA1_96=yes,
      samba_cv_HAVE_ENCTYPE_AES128_CTS_HMAC_SHA1_96=no)])
  if test x"$samba_cv_HAVE_ENCTYPE_AES128_CTS_HMAC_SHA1_96" = x"yes"; then
    AC_DEFINE(HAVE_ENCTYPE_AES128_CTS_HMAC_SHA1_96,1,
              [Whether the ENCTYPE_AES128_CTS_HMAC_SHA1_96 key type definition is available])
  fi
  AC_CACHE_CHECK([for ENCTYPE_AES256_CTS_HMAC_SHA1_96],
                 samba_cv_HAVE_ENCTYPE_AES256_CTS_HMAC_SHA1_96,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_enctype enctype; enctype = ENCTYPE_AES256_CTS_HMAC_SHA1_96;],
      samba_cv_HAVE_ENCTYPE_AES256_CTS_HMAC_SHA1_96=yes,
      samba_cv_HAVE_ENCTYPE_AES256_CTS_HMAC_SHA1_96=no)])
  if test x"$samba_cv_HAVE_ENCTYPE_AES256_CTS_HMAC_SHA1_96" = x"yes"; then
    AC_DEFINE(HAVE_ENCTYPE_AES256_CTS_HMAC_SHA1_96,1,
              [Whether the ENCTYPE_AES256_CTS_HMAC_SHA1_96 key type definition is available])
  fi

  AC_CACHE_CHECK([for AP_OPTS_USE_SUBKEY],
                 samba_cv_HAVE_AP_OPTS_USE_SUBKEY,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_flags ap_options; ap_options = AP_OPTS_USE_SUBKEY;],
      samba_cv_HAVE_AP_OPTS_USE_SUBKEY=yes,
      samba_cv_HAVE_AP_OPTS_USE_SUBKEY=no)])

  if test x"$samba_cv_HAVE_AP_OPTS_USE_SUBKEY" = x"yes"; then
    AC_DEFINE(HAVE_AP_OPTS_USE_SUBKEY,1,
              [Whether the AP_OPTS_USE_SUBKEY ap option is available])
  fi

  AC_CACHE_CHECK([for KV5M_KEYTAB],
                 samba_cv_HAVE_KV5M_KEYTAB,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keytab_entry entry; entry.magic = KV5M_KEYTAB;],
      samba_cv_HAVE_KV5M_KEYTAB=yes,
      samba_cv_HAVE_KV5M_KEYTAB=no)])

  if test x"$samba_cv_HAVE_KV5M_KEYTAB" = x"yes"; then
      AC_DEFINE(HAVE_KV5M_KEYTAB,1,
             [Whether the KV5M_KEYTAB option is available])
  fi

  AC_CACHE_CHECK([for KRB5_KU_OTHER_CKSUM],
                 samba_cv_HAVE_KRB5_KU_OTHER_CKSUM,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keyusage usage = KRB5_KU_OTHER_CKSUM;],
      samba_cv_HAVE_KRB5_KU_OTHER_CKSUM=yes,
      samba_cv_HAVE_KRB5_KU_OTHER_CKSUM=no)])

  if test x"$samba_cv_HAVE_KRB5_KU_OTHER_CKSUM" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KU_OTHER_CKSUM,1,
              [Whether KRB5_KU_OTHER_CKSUM is available])
  fi

  AC_CACHE_CHECK([for KRB5_KEYUSAGE_APP_DATA_CKSUM],
                 samba_cv_HAVE_KRB5_KEYUSAGE_APP_DATA_CKSUM,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keyusage usage = KRB5_KEYUSAGE_APP_DATA_CKSUM;],
      samba_cv_HAVE_KRB5_KEYUSAGE_APP_DATA_CKSUM=yes,
      samba_cv_HAVE_KRB5_KEYUSAGE_APP_DATA_CKSUM=no)])

  if test x"$samba_cv_HAVE_KRB5_KEYUSAGE_APP_DATA_CKSUM" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KEYUSAGE_APP_DATA_CKSUM,1,
              [Whether KRB5_KEYUSAGE_APP_DATA_CKSUM is available])
  fi

  AC_CACHE_CHECK([for the krb5_princ_component macro],
                samba_cv_HAVE_KRB5_PRINC_COMPONENT,[
    AC_TRY_LINK([#include <krb5.h>],
      [const krb5_data *pkdata; krb5_context context; krb5_principal principal; pkdata = krb5_princ_component(context, principal, 0);],
      samba_cv_HAVE_KRB5_PRINC_COMPONENT=yes,
      samba_cv_HAVE_KRB5_PRINC_COMPONENT=no)])

  if test x"$samba_cv_HAVE_KRB5_PRINC_COMPONENT" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_PRINC_COMPONENT,1,
               [Whether krb5_princ_component is available])
  fi

  AC_CACHE_CHECK([for key in krb5_keytab_entry],
                 samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEY,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keytab_entry entry; krb5_keyblock e; entry.key = e;],
      samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEY=yes,
      samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEY=no)])

  if test x"$samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEY" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KEYTAB_ENTRY_KEY,1,
              [Whether krb5_keytab_entry has key member])
  fi

  AC_CACHE_CHECK([for keyblock in krb5_keytab_entry],
                 samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_keytab_entry entry; entry.keyblock.keytype = 0;],
      samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK=yes,
      samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK=no)])

  if test x"$samba_cv_HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_KEYTAB_ENTRY_KEYBLOCK,1,
              [Whether krb5_keytab_entry has keyblock member])
  fi

  AC_CACHE_CHECK([for magic in krb5_address],
                 samba_cv_HAVE_MAGIC_IN_KRB5_ADDRESS,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_address addr; addr.magic = 0;],
      samba_cv_HAVE_MAGIC_IN_KRB5_ADDRESS=yes,
      samba_cv_HAVE_MAGIC_IN_KRB5_ADDRESS=no)])

  if test x"$samba_cv_HAVE_MAGIC_IN_KRB5_ADDRESS" = x"yes"; then
    AC_DEFINE(HAVE_MAGIC_IN_KRB5_ADDRESS,1,
              [Whether the krb5_address struct has a magic property])
  fi

  AC_CACHE_CHECK([for WRFILE: keytab support],
                samba_cv_HAVE_WRFILE_KEYTAB,[
    AC_TRY_RUN([
#include<krb5.h>
  main()
  {
    krb5_context context;
    krb5_keytab keytab;

    krb5_init_context(&context);
    return krb5_kt_resolve(context, "WRFILE:api", &keytab);
  }],
  samba_cv_HAVE_WRFILE_KEYTAB=yes,
  samba_cv_HAVE_WRFILE_KEYTAB=no)])

  if test x"$samba_cv_HAVE_WRFILE_KEYTAB" = x"yes"; then
      AC_DEFINE(HAVE_WRFILE_KEYTAB,1,
               [Whether the WRFILE:-keytab is supported])
  fi

  AC_CACHE_CHECK([for krb5_realm type],
                samba_cv_HAVE_KRB5_REALM_TYPE,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_realm realm;],
      samba_cv_HAVE_KRB5_REALM_TYPE=yes,
      samba_cv_HAVE_KRB5_REALM_TYPE=no)])

  if test x"$samba_cv_HAVE_KRB5_REALM_TYPE" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_REALM_TYPE,1,
               [Whether the type krb5_realm exists])
  fi

  AC_CACHE_CHECK([for krb5_princ_realm returns krb5_realm or krb5_data],
               samba_cv_KRB5_PRINC_REALM_RETURNS_REALM,[
    AC_TRY_COMPILE([#include <krb5.h>],
    [
    krb5_context context;
    krb5_principal principal;
    krb5_realm realm; realm = *krb5_princ_realm(context, principal);],
    samba_cv_KRB5_PRINC_REALM_RETURNS_REALM=yes,
    samba_cv_KRB5_PRINC_REALM_RETURNS_REALM=no)])

  if test x"$samba_cv_KRB5_PRINC_REALM_RETURNS_REALM" = x"yes"; then
    AC_DEFINE(KRB5_PRINC_REALM_RETURNS_REALM,1,
              [Whether krb5_princ_realm returns krb5_realm or krb5_data])
  fi

  AC_CACHE_CHECK([for krb5_addresses type],
                samba_cv_HAVE_KRB5_ADDRESSES,[
    AC_TRY_COMPILE([#include <krb5.h>],
      [krb5_addresses addr;],
      samba_cv_HAVE_KRB5_ADDRESSES=yes,
      samba_cv_HAVE_KRB5_ADDRESSES=no)])

  if test x"$samba_cv_HAVE_KRB5_ADDRESSES" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_ADDRESSES,1,
               [Whether the type krb5_addresses type exists])
  fi

  AC_CACHE_CHECK([whether krb5_mk_error takes 3 arguments MIT or 9 Heimdal],
		samba_cv_HAVE_SHORT_KRB5_MK_ERROR_INTERFACE, [
    AC_TRY_COMPILE([#include <krb5.h>],
    [
    krb5_mk_error(0,0,0);],
    samba_cv_HAVE_SHORT_KRB5_MK_ERROR_INTERFACE=yes,
    samba_cv_HAVE_SHORT_KRB5_MK_ERROR_INTERFACE=no)])

  if test x"$samba_cv_HAVE_SHORT_KRB5_MK_ERROR_INTERFACE" = x"yes"; then
    AC_DEFINE(HAVE_SHORT_KRB5_MK_ERROR_INTERFACE,1,
              [whether krb5_mk_error takes 3 arguments MIT or 9 Heimdal])
  fi

  if test x"$ac_cv_func_ext_krb5_enctype_to_string" = x"yes"; then
    AC_CACHE_CHECK([for krb5_error_code krb5_enctype_to_string(krb5_context context, krb5_enctype enctype, char **str)],
        smb_krb5_cv_enctype_to_string_takes_krb5_context_arg,[
	AC_TRY_RUN_STRICT([
		#include <stdlib.h>
		#include <krb5.h>
		int main(void) {
			krb5_context context = NULL;
			char *str = NULL;
			krb5_enctype_to_string(context, 1, &str);
			if (str) free (str); 
			return 0;
		}
		],[$CFLAGS $Werror_FLAGS],[$CPPFLAGS],[$LDFLAGS],
		smb_krb5_cv_enctype_to_string_takes_krb5_context_arg=yes,
		smb_krb5_cv_enctype_to_string_takes_krb5_context_arg=no)])

    if test x"$smb_krb5_cv_enctype_to_string_takes_krb5_context_arg" = x"yes"; then
      AC_DEFINE(HAVE_KRB5_ENCTYPE_TO_STRING_WITH_KRB5_CONTEXT_ARG,1,
                [whether krb5_enctype_to_string takes krb5_context argument])
    fi

    AC_CACHE_CHECK([for krb5_error_code krb5_enctype_to_string(krb5_enctype enctype, char *str, size_t len)],
        smb_krb5_cv_enctype_to_string_takes_size_t_arg,[
	AC_TRY_RUN_STRICT([
		#include <krb5.h>
		int main(void) {
			char buf[256];
			krb5_enctype_to_string(1, buf, 256);
			return 0;
		}
		],[$CFLAGS $Werror_FLAGS],[$CPPFLAGS],[$LDFLAGS],
		smb_krb5_cv_enctype_to_string_takes_size_t_arg=yes,
		smb_krb5_cv_enctype_to_string_takes_size_t_arg=no)])

    if test x"$smb_krb5_cv_enctype_to_string_takes_size_t_arg" = x"yes"; then
      AC_DEFINE(HAVE_KRB5_ENCTYPE_TO_STRING_WITH_SIZE_T_ARG,1,
                [whether krb5_enctype_to_string takes size_t argument])
    fi
  fi

  AC_CACHE_CHECK([for krb5_principal_get_realm],
                samba_cv_HAVE_KRB5_PRINCIPAL_GET_REALM,[
    AC_TRY_LINK([#include <krb5.h>],
      [krb5_context ctx = NULL; krb5_principal princ = NULL; const char *str = krb5_principal_get_realm(ctx, princ);],
      samba_cv_HAVE_KRB5_PRINCIPAL_GET_REALM=yes,
      samba_cv_HAVE_KRB5_PRINCIPAL_GET_REALM=no)])

  if test x"$samba_cv_HAVE_KRB5_PRINCIPAL_GET_REALM" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
               [Whether the function krb5_principal_get_realm is defined])
  fi

  AC_CACHE_CHECK([for krb5_princ_realm],
                samba_cv_HAVE_KRB5_PRINC_REALM,[
    AC_TRY_LINK([#include <krb5.h>],
      [krb5_context ctx = NULL; krb5_principal princ = NULL; const char *str = krb5_princ_realm(ctx, princ)->data;],
      samba_cv_HAVE_KRB5_PRINC_REALM=yes,
      samba_cv_HAVE_KRB5_PRINC_REALM=no)])

  if test x"$samba_cv_HAVE_KRB5_PRINC_REALM" = x"yes"; then
    AC_DEFINE(HAVE_KRB5_PRINC_REALM,1,
               [Whether the macro krb5_princ_realm is defined])
  fi

  #
  #
  # Now the decisions whether we can support krb5
  #
  # NOTE: all tests should be done before this block!
  #
  #
  if test x"$found_arcfour_hmac" != x"yes"; then
    AC_MSG_WARN(arcfour-hmac-md5 encryption type not found in -lkrb5)
    use_ads=no
  fi

  if test x"$ac_cv_lib_ext_krb5_krb5_mk_req_extended" != x"yes"; then
    AC_MSG_WARN(krb5_mk_req_extended not found in -lkrb5)
    use_ads=no
  fi

  if test x"$ac_cv_func_ext_krb5_principal2salt" != x"yes" -a \
          x"$ac_cv_func_ext_krb5_get_pw_salt" != x"yes"
  then
    AC_MSG_WARN(no CREATE_KEY_FUNCTIONS detected)
    use_ads=no
  fi

  if test x"$ac_cv_func_ext_krb5_get_permitted_enctypes" != x"yes" -a \
          x"$ac_cv_func_ext_krb5_get_default_in_tkt_etypes" != x"yes"
  then
    AC_MSG_WARN(no GET_ENCTYPES_FUNCTIONS detected)
    use_ads=no
  fi

  if test x"$ac_cv_func_ext_krb5_kt_free_entry" != x"yes" -a \
          x"$ac_cv_func_ext_krb5_free_keytab_entry_contents" != x"yes"
  then
    AC_MSG_WARN(no KT_FREE_FUNCTION detected)
    use_ads=no
  fi

  if test x"$ac_cv_func_ext_krb5_c_verify_checksum" != x"yes" -a \
          x"$ac_cv_func_ext_krb5_verify_checksum" != x"yes"
  then
    AC_MSG_WARN(no KRB5_VERIFY_CHECKSUM_FUNCTION detected)
    use_ads=no
  fi

  if test x"$smb_krb5_cv_ticket_has_keyinfo" != x"yes" ; then

      # We only need the following functions if we can't get the enctype
      # and kvno out of the ticket directly (ie. on Heimdal).

      if test x"$ac_cv_func_ext_free_AP_REQ" != x"yes"
      then
	AC_MSG_WARN(no KRB5_AP_REQ_FREE_FUNCTION detected)
	use_ads=no
      fi

      if test x"$ac_cv_func_ext_krb5_decode_ap_req" != x"yes"
      then
	AC_MSG_WARN(no KRB5_AP_REQ_DECODING_FUNCTION detected)
	use_ads=no
      fi

  fi

  if test x"$use_ads" = x"yes"; then
    AC_DEFINE(WITH_ADS,1,[Whether to include Active Directory support])
    AC_DEFINE(HAVE_KRB5,1,[Whether to have KRB5 support])
    if test x"$have_gssapi" = x"yes"; then
      AC_DEFINE(HAVE_GSSAPI,1,[Whether GSSAPI is available])
    fi
  else
    if test x"$with_ads_support" = x"yes"; then
	AC_MSG_ERROR(krb5 libs don't have all features required for Active Directory support)
    else
	AC_MSG_WARN(krb5 libs don't have all features required for Active Directory support)
    fi
    AC_REMOVE_DEFINE(HAVE_KRB5_H)
    AC_REMOVE_DEFINE(HAVE_GSSAPI_H)
    AC_REMOVE_DEFINE(HAVE_GSSAPI_GSSAPI_GENERIC_H)
    AC_REMOVE_DEFINE(HAVE_GSSAPI_GSSAPI_H)
    KRB5_LIBS=""
    with_ads_support=no
  fi
  AC_MSG_CHECKING(whether Active Directory and krb5 support is used)
  AC_MSG_RESULT([$use_ads])

LIBS="$ac_save_LIBS"
fi

if test x"$use_ads" != xyes; then
	smbtorture4_possible=no
fi

AC_CHECK_LIB_EXT(nscd, NSCD_LIBS, nscd_flush_cache)
PASSDB_LIBS="$PASSDB_LIBS $NSCD_LIBS"


########################################################
# Compile with DNS Updates support?

with_dnsupdate_support=auto
AC_MSG_CHECKING([whether to enable DNS Updates support])

AC_ARG_WITH(dnsupdate,
[AS_HELP_STRING([--with-dnsupdate], [Enable DNS Updates support (default=auto)])],
[ case "$withval" in
    yes|no)
	with_dnsupdate_support=$withval
	;;
  esac ])

AC_MSG_RESULT($with_dnsupdate_support)

if test x"$with_dnsupdate_support" != x"no"; then

  ################################################################
  # first test for AD / GSSAPI support being enabled
	if test x"$have_gssapi" != xyes ; then
		if test x"$with_dnsupdate_support" = x"yes" ; then
			AC_MSG_ERROR(DNS Updates support only possible with AD and GSSAPI support)
		else
			AC_MSG_NOTICE(DNS Updates support only possible with AD and GSSAPI support)
			with_dnsupdate_support=no
		fi
	fi
  ##################################################################
  # then test for uuid.h (necessary to generate unique DNS keynames
  # (uuid.h is required for this test)
	AC_CHECK_HEADERS(uuid/uuid.h)

	
	if test x"$ac_cv_header_uuid_uuid_h" != x"yes"; then
		if test x"$with_dnsupdate_support" = x"yes"; then
			AC_MSG_ERROR(uuid.h is needed to enable DNS Updates support)
		else
			AC_MSG_NOTICE(uuid.h is needed to enable DNS Updates support)
		fi
		with_dnsupdate_support=no
	fi
fi

if test x"$with_dnsupdate_support" != x"no"; then

  ########################################################
  # Now see if we can find the uuid libs in standard paths
  # On some systems, the uuid API is in libc, so we have to
  # be careful not to insert a spurious -luuid.

  UUID_LIBS=""
  AC_LIBTESTFUNC(uuid, uuid_generate,
	  [
	    case " $LIBS " in
		*\ -luuid\ *)
		UUID_LIBS="-luuid"
		SMB_REMOVE_LIB(uuid)
		;;
	    esac

	    with_dnsupdate_support=yes
	    AC_DEFINE(WITH_DNS_UPDATES,1,[Whether to enable DNS Update support])
	],
	[
	    if test x"$with_dnsupdate_support" = x"yes"; then
		AC_MSG_ERROR(libuuid is needed to enable DNS Updates support)
	    else
		AC_MSG_WARN(libuuid is needed to enable DNS Updates support)
	    fi
	    with_dnsupdate_support=no
	])
fi
  # finally print out the result:
AC_MSG_CHECKING(whether DNS Updates support is used)
AC_MSG_RESULT([$with_dnsupdate_support])


#################################################
# check for automount support
AC_MSG_CHECKING(whether to use automount)
AC_ARG_WITH(automount,
[AS_HELP_STRING([--with-automount], [Include automount support (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    AC_DEFINE(WITH_AUTOMOUNT,1,[Whether to include automount support])
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

#################################################
# Check for a PAM clear-text auth, accounts, password
# and session support. Most PAM implementations keep their
# headers in /usr/include/security. Darwin keeps its in
# /usr/include/pam.

with_pam_for_crypt=no
try_pam=auto
AC_MSG_CHECKING(whether to try PAM support)
AC_ARG_WITH(pam,
[AS_HELP_STRING([--with-pam], [Include PAM support (default=auto)])],
[ case "$withval" in
  yes|no|auto)
    try_pam=$withval
    ;;
  esac
])
AC_MSG_RESULT([$try_pam])

use_pam=no
create_pam_modules=no
if test x"${try_pam}" != x"no";then
	use_pam=yes
	create_pam_modules=yes

	# Most systems have PAM headers in /usr/include/security, but Darwin
	# has them in /usr/include/pam.
	AC_CHECK_HEADERS(security/pam_appl.h pam/pam_appl.h)
	if test x"$ac_cv_header_security_pam_appl_h" != x"yes" -a \
		x"$ac_cv_header_pam_pam_appl_h" != x"yes"; then
		if test x"${try_pam}" = x"yes";then
			AC_MSG_ERROR([--with-pam=yes but pam_appl.h not found])
		fi
		use_pam=no
		create_pam_modules=no
	fi

	AC_CHECK_LIB_EXT(pam, PAM_LIBS, pam_get_data)
	if test x"$ac_cv_lib_ext_pam_pam_get_data" != x"yes"; then
		if test x"${try_pam}" = x"yes";then
			AC_MSG_ERROR([--with-pam=yes but libpam not found])
		fi
		use_pam=no
		create_pam_modules=no
	fi

	AC_CHECK_HEADERS(security/pam_modules.h pam/pam_modules.h,,,[[
		#if HAVE_SECURITY_PAM_APPL_H
		#include <security/pam_appl.h>
		#endif
		#if HAVE_PAM_PAM_APPL_H
		#include <pam/pam_appl.h>
		#endif
	]])
	if test x"$ac_cv_header_security_pam_modules_h" = x"no" -a \
		x"$ac_cv_header_pam_pam_modules_h" = x"no" ; then
		if test x"${try_pam}" = x"yes";then
			AC_MSG_ERROR([--with-pam=yes but pam_modules.h not found])
       fi
		create_pam_modules=no
    fi

	if test x"$use_pam" = x"yes"; then
    AC_DEFINE(WITH_PAM,1,[Whether to include PAM support])
		AC_DEFINE(HAVE_LIBPAM,1,[Whether libpam is available])
		AUTH_LIBS="$AUTH_LIBS $PAM_LIBS"
    with_pam_for_crypt=yes

		if test x"$create_pam_modules" = x"yes"; then
			AC_DEFINE(WITH_PAM_MODULES,1,[Whether to include PAM MODULES support])
			# this checks are optional,
			# we don't care about the results here
			AC_CHECK_HEADERS(security/pam_ext.h security/_pam_macros.h)
			AC_CHECK_HEADERS(pam/pam_ext.h pam/_pam_macros.h)
			AC_CHECK_FUNC_EXT(pam_vsyslog,$PAM_LIBS)
		else
			AC_MSG_WARN([PAM support detected but PAM MODULES support is missing])		
		fi
	fi
	AC_MSG_CHECKING(whether to use PAM support)
	AC_MSG_RESULT([$use_pam])

	AC_MSG_CHECKING(whether to have PAM MODULES support)
	AC_MSG_RESULT([$create_pam_modules])

	AC_TRY_COMPILE([
		#if defined(HAVE_SECURITY_PAM_APPL_H)
		#include <security/pam_appl.h>
		#elif defined(HAVE_PAM_PAM_APPL_H)
		#include <pam/pam_appl.h>
		#endif],[
		pam_set_item(0, PAM_RHOST, 0);
		],
		AC_DEFINE(HAVE_PAM_RHOST, 1,
			  [Define to 1 if PAM_RHOST is available]),[])

	AC_TRY_COMPILE([
		#if defined(HAVE_SECURITY_PAM_APPL_H)
		#include <security/pam_appl.h>
		#elif defined(HAVE_PAM_PAM_APPL_H)
		#include <pam/pam_appl.h>
		#endif],[
		pam_set_item(0, PAM_TTY, 0);
		],
		AC_DEFINE(HAVE_PAM_TTY, 1,
			  [Define to 1 if PAM_TTY is available]),[])

fi # try_pam != no

#################################################
# check for PAM_RADIO_TYPE
AC_TRY_COMPILE([
#if (!defined(LINUX))

#define PAM_EXTERN extern
#if defined(HAVE_SECURITY_PAM_APPL_H)
#include <security/pam_appl.h>
#elif defined(HAVE_PAM_PAM_APPL_H)
#include <pam/pam_appl.h>
#endif

#endif

#if defined(HAVE_SECURITY_PAM_MODULES_H)
#include <security/pam_modules.h>
#elif defined(HAVE_PAM_PAM_MODULES_H)
#include <pam/pam_modules.h>
#endif

#if defined(HAVE_SECURITY__PAM_MACROS_H)
#include <security/_pam_macros.h>
#elif defined(HAVE_PAM__PAM_MACROS_H)
#include <pam/_pam_macros.h>
#endif

#ifdef HAVE_SECURITY_PAM_EXT_H
#include <security/pam_ext.h>
#endif
],
[int i; i = PAM_RADIO_TYPE; ],
AC_DEFINE(HAVE_PAM_RADIO_TYPE, 1, [Define to 1 if PAM_RADIO_TYPE is available]),[])

#################################################
# check for pam_smbpass support
PAM_MODULES=""
INSTALL_PAM_MODULES=""
UNINSTALL_PAM_MODULES=""

try_pam_smbpass=auto
AC_MSG_CHECKING(whether to use pam_smbpass)
AC_ARG_WITH(pam_smbpass,
[AS_HELP_STRING([--with-pam_smbpass], [Build PAM module for authenticating against passdb backends (default=auto)])],
[ case "$withval" in
  yes|no|auto)
    try_pam_smbpass=$withval
  ;;
  *)
    AC_MSG_ERROR([valid options are yes,no,auto])
  ;;
  esac
])

if test x"${try_pam_smbpass}" = xno ; then
	use_pam_smbpass=no
else
	use_pam_smbpass=yes
	# Conditions under which pam_smbpass can't be built.
	if test x"$BLDSHARED" != xtrue ; then
		if test x"${try_pam_smbpass}" = xyes ; then
			AC_MSG_ERROR([No support for shared modules])
		fi
		use_pam_smbpass=no
	elif test x"$create_pam_modules" != xyes ; then
		if test x"${try_pam_smbpass}" = xyes ; then
			AC_MSG_ERROR([No support for PAM MODULES])
		fi
		use_pam_smbpass=no
	fi

	if test x"${use_pam_smbpass}" = xyes ; then 
		PAM_MODULES="pam_smbpass"
		INSTALL_PAM_MODULES="installpammodules"
		UNINSTALL_PAM_MODULES="uninstallpammodules"
	fi
fi
AC_MSG_RESULT([$use_pam_smbpass])


##
## moved after the check for -lcrypt in order to
## ensure that the necessary libraries are included
## check checking for truncated salt.  Wrapped by the
## $with_pam_for_crypt variable as above   --jerry
##
if test $with_pam_for_crypt = no; then
AC_CACHE_CHECK([for a crypt that needs truncated salt],samba_cv_HAVE_TRUNCATED_SALT,[
crypt_LIBS="$LIBS"
LIBS="$AUTH_LIBS $LIBS"
AC_TRY_RUN([#include "${srcdir-.}/../tests/crypttest.c"],
	samba_cv_HAVE_TRUNCATED_SALT=no,samba_cv_HAVE_TRUNCATED_SALT=yes,samba_cv_HAVE_TRUNCATED_SALT=cross)
LIBS="$crypt_LIBS"])
if test x"$samba_cv_HAVE_TRUNCATED_SALT" = x"yes"; then
	AC_DEFINE(HAVE_TRUNCATED_SALT,1,[Whether crypt needs truncated salt])
fi
fi

#################################################
# check for a NISPLUS_HOME support
AC_MSG_CHECKING(whether to use NISPLUS_HOME)
AC_ARG_WITH(nisplus-home,
[AS_HELP_STRING([--with-nisplus-home], [Include NISPLUS_HOME support (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    AC_DEFINE(WITH_NISPLUS_HOME,1,[Whether to include nisplus_home support])
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

#################################################
# check for syslog logging
AC_MSG_CHECKING(whether to use syslog logging)
AC_ARG_WITH(syslog,
[AS_HELP_STRING([--with-syslog], [Include experimental SYSLOG support (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    AC_DEFINE(WITH_SYSLOG,1,[Whether to include experimental syslog support])
    ;;
  *)
    AC_MSG_RESULT(no)
    ;;
  esac ],
  AC_MSG_RESULT(no)
)

#################################################
# check for custom syslog facility
AC_MSG_CHECKING(whether to use a custom syslog facility)
AC_ARG_WITH(syslog-facility,
[AS_HELP_STRING([--with-syslog-facility], [Use a custom syslog facility (default=none)])],
[
  if test "$withval" = "no" ; then
    AC_MSG_ERROR([argument to --with-syslog-facility must be a string])
  else
     AC_MSG_RESULT([$withval])
     if test "$withval" != "yes" ; then
        syslog_facility="$withval"
	AC_DEFINE_UNQUOTED(SYSLOG_FACILITY,$syslog_facility, [syslog facility to log to])
     fi
  fi
],
AC_MSG_RESULT(no)
)

#################################################
# check for experimental disk-quotas support

samba_cv_WITH_QUOTAS=auto
samba_cv_TRY_QUOTAS=no
samba_cv_RUN_QUOTA_TESTS=auto
samba_cv_WITH_SYS_QUOTAS=auto
samba_cv_TRY_SYS_QUOTAS=auto
samba_cv_SYSQUOTA_FOUND=no

AC_MSG_CHECKING(whether to try disk-quotas support)
AC_ARG_WITH(quotas,
[AS_HELP_STRING([--with-quotas], [Include disk-quota support (default=no)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    samba_cv_WITH_QUOTAS=yes
    samba_cv_TRY_QUOTAS=yes
    samba_cv_RUN_QUOTA_TESTS=yes
    #set sys quotas to auto in this case
    samba_cv_TRY_SYS_QUOTAS=auto
    ;;
  auto)
    AC_MSG_RESULT(auto)
    samba_cv_WITH_QUOTAS=auto
    samba_cv_TRY_QUOTAS=auto
    samba_cv_RUN_QUOTA_TESTS=auto
    #set sys quotas to auto in this case
    samba_cv_TRY_SYS_QUOTAS=auto
    ;;
  no)
    AC_MSG_RESULT(no)
    samba_cv_WITH_QUOTAS=no
    samba_cv_TRY_QUOTAS=no
    samba_cv_RUN_QUOTA_TESTS=no
    ;;
  *)
    AC_MSG_RESULT(${samba_cv_TRY_QUOTAS})
    ;;
  esac ],
  AC_MSG_RESULT(${samba_cv_TRY_QUOTAS})
)

AC_MSG_CHECKING(whether to try the new lib/sysquotas.c interface)
AC_ARG_WITH(sys-quotas,
[AS_HELP_STRING([--with-sys-quotas], [Include lib/sysquotas.c support (default=auto)])],
[ case "$withval" in
  yes)
    AC_MSG_RESULT(yes)
    samba_cv_WITH_SYS_QUOTAS=yes
    samba_cv_TRY_SYS_QUOTAS=yes
    samba_cv_RUN_QUOTA_TESTS=yes
    ;;
  auto)
    AC_MSG_RESULT(auto)
    samba_cv_WITH_SYS_QUOTAS=auto
    samba_cv_TRY_SYS_QUOTAS=auto
    samba_cv_RUN_QUOTA_TESTS=auto
    ;;
  no)
    AC_MSG_RESULT(no)
    samba_cv_WITH_SYS_QUOTAS=no
    samba_cv_TRY_SYS_QUOTAS=no
    ;;
  *)
    AC_MSG_RESULT(${samba_cv_TRY_SYS_QUOTAS})
    ;;
  esac ],
  AC_MSG_RESULT(${samba_cv_TRY_SYS_QUOTAS})
)

if test x"$samba_cv_TRY_SYS_QUOTAS" = x"auto"; then
AC_MSG_CHECKING(whether to try the lib/sysquotas.c interface on ${host_os})
  case "$host_os" in
	*linux*)
	    AC_MSG_RESULT(yes)
            samba_cv_TRY_SYS_QUOTAS=yes
            samba_cv_RUN_QUOTA_TESTS=yes
	    ;;
	*)
	    AC_MSG_RESULT(no)
            samba_cv_TRY_SYS_QUOTAS=no
	    ;;
  esac
fi

#############################################
# only check for quota stuff if --with-quotas
if test x"$samba_cv_RUN_QUOTA_TESTS" != x"no"; then

case "$host_os" in
	# on linux we didn't need to test we have builtin support
	*linux*)
	    samba_cv_SYSQUOTA_FOUND=yes
	    AC_DEFINE(HAVE_QUOTACTL_LINUX,1,[Whether Linux quota support is available])
	    samba_cv_sysquotas_file="lib/sysquotas_linux.c"
	    AC_MSG_CHECKING(whether to use the lib/sysquotas_linux.c builtin support)
	    AC_MSG_RESULT(yes)

	    AC_DEFINE(HAVE_LINUX_XFS_QUOTAS,1,[Whether Linux xfs quota support is available])
	    samba_cv_found_xfs_header=yes
	    AC_MSG_CHECKING(whether to use the lib/sysquotas_xfs.c builtin support)
	    AC_MSG_RESULT(yes)
	    ;;
	*solaris*)
	    # need to set this define when using static linking (BUG 1473)
	    CPPFLAGS="$CPPFLAGS -DSUNOS5"
	    ;;
	*)
	    ;;
esac

# some broken header files need this
AC_CHECK_HEADER(asm/types.h,[
	    AC_DEFINE(HAVE_ASM_TYPES_H,1,[check for <asm/types.h>])
	    AC_ADD_INCLUDE(<asm/types.h>)
	    ])

# For quotas on Veritas VxFS filesystems
AC_CHECK_HEADERS(sys/fs/vx_quota.h)

# For quotas on Linux XFS filesystems
AC_CHECK_HEADERS(linux/dqblk_xfs.h)

# For sys/quota.h and linux/quota.h
AC_CHECK_HEADERS(sys/quota.h)

if test x"$samba_cv_found_xfs_header" != x"yes"; then
# if we have xfs quota support <sys/quota.h> (IRIX) we should use it
AC_CACHE_CHECK([for XFS QUOTA in <sys/quota.h>],samba_cv_HAVE_SYS_QUOTA_XFS, [
AC_TRY_COMPILE([
#include "confdefs.h"
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_ASM_TYPES_H
#include <asm/types.h>
#endif
#include <sys/quota.h>
],[int i = Q_XGETQUOTA;],
samba_cv_HAVE_SYS_QUOTA_XFS=yes,samba_cv_HAVE_SYS_QUOTA_XFS=no)])
if test "$samba_cv_HAVE_SYS_QUOTA_XFS"x = "yes"x; then
	samba_cv_found_xfs_header=yes
fi
fi

# if we have struct dqblk .dqb_fsoftlimit instead of .dqb_isoftlimit on IRIX
AC_CACHE_CHECK([if struct dqblk has .dqb_fsoftlimit],samba_cv_HAVE_DQB_FSOFTLIMIT, [
AC_TRY_COMPILE([
#include "confdefs.h"
#ifdef HAVE_SYS_QUOTA_H
#include <sys/quota.h>
#endif
],[
struct dqblk D;
D.dqb_fsoftlimit = 0;],
samba_cv_HAVE_DQB_FSOFTLIMIT=yes,samba_cv_HAVE_DQB_FSOFTLIMIT=no)])
if test "$samba_cv_HAVE_DQB_FSOFTLIMIT"x = "yes"x; then
	AC_DEFINE(HAVE_DQB_FSOFTLIMIT,1,[struct dqblk .dqb_fsoftlimit])
fi

##################
# look for a working quota system

if test x"$samba_cv_SYSQUOTA_FOUND" != x"yes"; then
AC_CACHE_CHECK([for long quotactl(int cmd, char *special, qid_t id, caddr_t addr)],samba_cv_HAVE_QUOTACTL_4A,[
AC_TRY_RUN_STRICT([
#define HAVE_QUOTACTL_4A 1
#define AUTOCONF_TEST 1
#include "confdefs.h"
#include "${srcdir-.}/../tests/sysquotas.c"],[$CFLAGS $Werror_FLAGS],[$CPPFLAGS],[$LDFLAGS],
           samba_cv_HAVE_QUOTACTL_4A=yes,samba_cv_HAVE_QUOTACTL_4A=no,samba_cv_HAVE_QUOTACTL_4A=cross)])
if test x"$samba_cv_HAVE_QUOTACTL_4A" = x"yes"; then
    samba_cv_SYSQUOTA_FOUND=yes;
    AC_DEFINE(HAVE_QUOTACTL_4A,1,[Whether long quotactl(int cmd, char *special, qid_t id, caddr_t addr) is available])
    samba_cv_sysquotas_file="lib/sysquotas_4A.c"
fi
fi

if test x"$samba_cv_SYSQUOTA_FOUND" != x"yes"; then
AC_CACHE_CHECK([for int quotactl(const char *path, int cmd, int id, char *addr)],samba_cv_HAVE_QUOTACTL_4B,[
AC_TRY_RUN_STRICT([
#define HAVE_QUOTACTL_4B 1
#define AUTOCONF_TEST 1
#include "confdefs.h"
#include "${srcdir-.}/../tests/sysquotas.c"],[$CFLAGS $Werror_FLAGS],[$CPPFLAGS],[$LDFLAGS],
           samba_cv_HAVE_QUOTACTL_4B=yes,samba_cv_HAVE_QUOTACTL_4B=no,samba_cv_HAVE_QUOTACTL_4B=cross)])
if test x"$samba_cv_HAVE_QUOTACTL_4B" = x"yes"; then
    echo "int quotactl(const char *path, int cmd, int id, char *addr) is not reworked for the new sys_quota api"
    samba_cv_SYSQUOTA_FOUND=yes;
    AC_DEFINE(HAVE_QUOTACTL_4B,1,[Whether int quotactl(const char *path, int cmd, int id, char *addr) is available])
    samba_cv_sysquotas_file="lib/sysquotas_4B.c"
fi
fi

if test x"$samba_cv_SYSQUOTA_FOUND" != x"yes"; then
AC_CACHE_CHECK([for CRAY int quotactl (char *spec, int request, char *arg)],samba_cv_HAVE_QUOTACTL_3,[
AC_TRY_RUN_STRICT([
#define HAVE_QUOTACTL_3 1
#define AUTOCONF_TEST 1
#include "confdefs.h"
#include "${srcdir-.}/../tests/sysquotas.c"],[$CFLAGS $Werror_FLAGS],[$CPPFLAGS],[$LDFLAGS],
           samba_cv_HAVE_QUOTACTL_3=yes,samba_cv_HAVE_QUOTACTL_3=no,samba_cv_HAVE_QUOTACTL_3=cross)])
if test x"$samba_cv_HAVE_QUOTACTL_3" = x"yes"; then
    echo "CRAY int quotactl (char *spec, int request, char *arg) is NOT reworked for the sys_quota api"
    samba_cv_SYSQUOTA_FOUND=yes;
    AC_DEFINE(HAVE_QUOTACTL_3,1,[Whether CRAY int quotactl (char *spec, int request, char *arg); is available])
    samba_cv_sysquotas_file="lib/sysquotas_3.c"
fi
fi

#################################################
# check for mntent.h and struct mntent
AC_CHECK_HEADERS(mntent.h)
#################################################
# check for setmntent,getmntent,endmntent
AC_CHECK_FUNCS(setmntent getmntent endmntent)

#################################################
# check for devnm.h and struct mntent
AC_CHECK_HEADERS(devnm.h)
#################################################
# check for devnm
AC_CHECK_FUNCS(devnm)

if test x"$samba_cv_WITH_SYS_QUOTAS" = x"yes"; then
    if test x"$samba_cv_SYSQUOTA_FOUND" != x"yes"; then
	# if --with-sys-quotas=yes then build it
	# you have can use the get/set quota command smb.conf
	# options then
	samba_cv_SYSQUOTA_FOUND=auto
    fi
    if test x"$samba_cv_TRY_SYS_QUOTAS" != x"yes"; then
	# if --with-sys-quotas=yes then build it
	# you have can use the get/set quota command smb.conf
	# options then
	samba_cv_TRY_SYS_QUOTAS=auto
    fi
fi

if test x"$samba_cv_SYSQUOTA_FOUND" != x"no"; then
AC_CACHE_CHECK([whether the sys_quota interface works],samba_cv_SYSQUOTA_WORKS,[
SAVE_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS ${SAMBA_CONFIGURE_CPPFLAGS}"
AC_TRY_COMPILE([
#include "confdefs.h"
#define NO_PROTO_H 1
#define NO_CONFIG_H 1
#define HAVE_SYS_QUOTAS 1
#include "${srcdir-.}/${samba_cv_sysquotas_file}"
#include "${srcdir-.}/lib/sysquotas.c"
],[],samba_cv_SYSQUOTA_WORKS=yes,samba_cv_SYSQUOTA_WORKS=no)
CPPFLAGS="$SAVE_CPPFLAGS"
])
if test x"$samba_cv_SYSQUOTA_WORKS" = x"yes"; then
AC_MSG_CHECKING(whether to use the new lib/sysquotas.c interface)
    if test x"$samba_cv_TRY_SYS_QUOTAS" != x"no"; then
	AC_DEFINE(WITH_QUOTAS,1,[Whether to use disk quota support])
	AC_DEFINE(HAVE_SYS_QUOTAS,1,[Whether the new lib/sysquotas.c interface can be used])
	samba_cv_WE_USE_SYS_QUOTAS=yes
	AC_MSG_RESULT(yes)
    else
        AC_MSG_RESULT(no)
    fi
fi
fi

if test x"$samba_cv_SYSQUOTA_FOUND" != x"no"; then
AC_CACHE_CHECK([whether the sys_quota interface works with NFS],samba_cv_SYSQUOTA_WORKS_NFS,[
SAVE_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS ${SAMBA_CONFIGURE_CPPFLAGS}"
AC_TRY_COMPILE([
#include "confdefs.h"
#define NO_PROTO_H 1
#define NO_CONFIG_H 1
#define HAVE_SYS_QUOTAS 1
#define HAVE_NFS_QUOTAS 1
#include "${srcdir-.}/lib/sysquotas_nfs.c"
],[],samba_cv_SYSQUOTA_WORKS_NFS=yes,samba_cv_SYSQUOTA_WORKS_NFS=no)
CPPFLAGS="$SAVE_CPPFLAGS"
])
if test x"$samba_cv_SYSQUOTA_WORKS_NFS" = x"yes"; then
    if test x"$samba_cv_WE_USE_SYS_QUOTAS" = x"yes"; then
	AC_DEFINE(HAVE_NFS_QUOTAS,1,[Whether nfs quota support is available])
    fi
fi
fi

if test x"$samba_cv_SYSQUOTA_FOUND" != x"no" -a x"$samba_cv_found_xfs_header" = x"yes"; then
AC_CACHE_CHECK([whether the sys_quota interface works with XFS],samba_cv_SYSQUOTA_WORKS_XFS,[
SAVE_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS ${SAMBA_CONFIGURE_CPPFLAGS}"
AC_TRY_COMPILE([
#include "confdefs.h"
#define NO_PROTO_H 1
#define NO_CONFIG_H 1
#define HAVE_SYS_QUOTAS 1
#define HAVE_XFS_QUOTAS 1
#include "${srcdir-.}/lib/sysquotas_xfs.c"
],[],samba_cv_SYSQUOTA_WORKS_XFS=yes,samba_cv_SYSQUOTA_WORKS_XFS=no)
CPPFLAGS="$SAVE_CPPFLAGS"
])
if test x"$samba_cv_SYSQUOTA_WORKS_XFS" = x"yes"; then
    if test x"$samba_cv_WE_USE_SYS_QUOTAS" = x"yes"; then
	AC_DEFINE(HAVE_XFS_QUOTAS,1,[Whether xfs quota support is available])
    fi
fi
fi

AC_CACHE_CHECK([whether the old quota support works],samba_cv_QUOTA_WORKS,[
SAVE_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS ${SAMBA_CONFIGURE_CPPFLAGS}"
AC_TRY_COMPILE([
#include "confdefs.h"
#define NO_PROTO_H 1
#define NO_CONFIG_H 1
#include "${srcdir-.}/smbd/quotas.c"
],[],samba_cv_QUOTA_WORKS=yes,samba_cv_QUOTA_WORKS=no)
CPPFLAGS="$SAVE_CPPFLAGS"
])
if test x"$samba_cv_QUOTA_WORKS" = x"yes"; then
AC_MSG_CHECKING(whether to use the old quota support)
    if test x"$samba_cv_WE_USE_SYS_QUOTAS" != x"yes"; then
      if test x"$samba_cv_TRY_QUOTAS" != x"no"; then
        AC_DEFINE(WITH_QUOTAS,1,[Whether to use disk quota support])
	AC_MSG_RESULT(yes)
      else
	AC_MSG_RESULT(no)
      fi
    else
      AC_MSG_RESULT(no)
    fi
fi

####################
# End of quota check samba_cv_RUN_QUOTA_TESTS
fi

#################################################
# check for experimental utmp accounting

AC_MSG_CHECKING(whether to support utmp accounting)
WITH_UTMP=yes
AC_ARG_WITH(utmp,
[AS_HELP_STRING([--with-utmp], [Include utmp accounting (default, if supported by OS)])],
[ case "$withval" in
  no)
		WITH_UTMP=no
		;;
  *)
		WITH_UTMP=yes
                ;;
  esac ],
)

# utmp requires utmp.h
# Note similar check earlier, when checking utmp details.

if test x"$WITH_UTMP" = x"yes" -a x"$ac_cv_header_utmp_h" = x"no"; then
	utmp_no_reason=", no utmp.h on $host_os"
	WITH_UTMP=no
fi

# Display test results

if test x"$WITH_UTMP" = x"yes"; then
        AC_MSG_RESULT(yes)
	AC_DEFINE(WITH_UTMP,1,[Whether to include experimental utmp accounting])
else
        AC_MSG_RESULT(no$utmp_no_reason)
fi


#################################################
# these tests are taken from the GNU fileutils package
AC_CHECKING(how to get filesystem space usage)
space=no

# Test for statvfs64.
if test $space = no; then
  # SVR4
  AC_CACHE_CHECK([statvfs64 function (SVR4)], fu_cv_sys_stat_statvfs64,
  [AC_TRY_RUN([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <sys/types.h>
#include <sys/statvfs.h>
  main ()
  {
    struct statvfs64 fsd;
    exit (statvfs64 (".", &fsd));
  }],
  fu_cv_sys_stat_statvfs64=yes,
  fu_cv_sys_stat_statvfs64=no,
  fu_cv_sys_stat_statvfs64=cross)])
  if test $fu_cv_sys_stat_statvfs64 = yes; then
    space=yes
    AC_DEFINE(STAT_STATVFS64,1,[Whether statvfs64() is available])
  fi
fi

# Perform only the link test since it seems there are no variants of the
# statvfs function.  This check is more than just AC_CHECK_FUNCS(statvfs)
# because that got a false positive on SCO OSR5.  Adding the declaration
# of a `struct statvfs' causes this test to fail (as it should) on such
# systems.  That system is reported to work fine with STAT_STATFS4 which
# is what it gets when this test fails.
if test $space = no; then
  # SVR4
  AC_CACHE_CHECK([statvfs function (SVR4)], fu_cv_sys_stat_statvfs,
		 [AC_TRY_LINK([#include <sys/types.h>
#include <sys/statvfs.h>],
			      [struct statvfs fsd; statvfs (0, &fsd);],
			      fu_cv_sys_stat_statvfs=yes,
			      fu_cv_sys_stat_statvfs=no)])
  if test $fu_cv_sys_stat_statvfs = yes; then
    space=yes
    AC_DEFINE(STAT_STATVFS,1,[Whether statvfs() is available])
  fi
fi

# smbd/statvfs.c assumes that statvfs.f_fsid is an integer.
# This is not the case on ancient Linux systems.

AC_CACHE_CHECK([that statvfs.f_fsid is an integer],samba_cv_fsid_int, [
    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/statvfs.h>],[struct statvfs buf; buf.f_fsid = 0],
	samba_cv_fsid_int=yes,samba_cv_fsid_int=no)])
if test x"$samba_cv_fsid_int" = x"yes"; then
    AC_DEFINE(HAVE_FSID_INT, 1, [Whether statvfs.f_fsid is an integer])
fi

# fsusage.c assumes that statvfs has an f_frsize entry. Some weird
# systems use f_bsize.
AC_CACHE_CHECK([that statvfs.f_frsize works],samba_cv_frsize, [
    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/statvfs.h>],[struct statvfs buf; buf.f_frsize = 0],
	samba_cv_frsize=yes,samba_cv_frsize=no)])
if test x"$samba_cv_frsize" = x"yes"; then
    AC_DEFINE(HAVE_FRSIZE, 1, [Whether statvfs.f_frsize exists])
fi

# Some systems use f_flag in struct statvfs while others use f_flags
AC_CACHE_CHECK([that statvfs.statvfs_f_flag works],samba_cv_statvfs_f_flag, [
    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/statvfs.h>],[struct statvfs buf; buf.f_flag = 0],
	samba_cv_statvfs_f_flag=yes,samba_cv_statvfs_f_flag=no)])
if test x"$samba_cv_statvfs_f_flag" = x"yes"; then
    AC_DEFINE(HAVE_STATVFS_F_FLAG, 1, [Whether statvfs.f_flag exists])
fi

AC_CACHE_CHECK([that statvfs.statvfs_f_flags works],samba_cv_statvfs_f_flags, [
    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/statvfs.h>],[struct statvfs buf; buf.f_flags = 0],
	samba_cv_statvfs_f_flags=yes,samba_cv_statvfs_f_flags=no)])
if test x"$samba_cv_statvfs_f_flags" = x"yes"; then
    AC_DEFINE(HAVE_STATVFS_F_FLAGS, 1, [Whether statvfs.f_flags exists])
fi

if test $space = no; then
  # DEC Alpha running OSF/1
  AC_MSG_CHECKING([for 3-argument statfs function (DEC OSF/1)])
  AC_CACHE_VAL(fu_cv_sys_stat_statfs3_osf1,
  [AC_TRY_RUN([
#include <sys/param.h>
#include <sys/types.h>
#include <sys/mount.h>
  main ()
  {
    struct statfs fsd;
    fsd.f_fsize = 0;
    exit (statfs (".", &fsd, sizeof (struct statfs)));
  }],
  fu_cv_sys_stat_statfs3_osf1=yes,
  fu_cv_sys_stat_statfs3_osf1=no,
  fu_cv_sys_stat_statfs3_osf1=no)])
  AC_MSG_RESULT($fu_cv_sys_stat_statfs3_osf1)
  if test $fu_cv_sys_stat_statfs3_osf1 = yes; then
    space=yes
    AC_DEFINE(STAT_STATFS3_OSF1,1,[Whether statfs requires 3 arguments])
  fi
fi

if test $space = no; then
# AIX
  AC_MSG_CHECKING([for two-argument statfs with statfs.bsize dnl
member (AIX, 4.3BSD)])
  AC_CACHE_VAL(fu_cv_sys_stat_statfs2_bsize,
  [AC_TRY_RUN([
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
  main ()
  {
  struct statfs fsd;
  fsd.f_bsize = 0;
  exit (statfs (".", &fsd));
  }],
  fu_cv_sys_stat_statfs2_bsize=yes,
  fu_cv_sys_stat_statfs2_bsize=no,
  fu_cv_sys_stat_statfs2_bsize=no)])
  AC_MSG_RESULT($fu_cv_sys_stat_statfs2_bsize)
  if test $fu_cv_sys_stat_statfs2_bsize = yes; then
    space=yes
    AC_DEFINE(STAT_STATFS2_BSIZE,1,[Whether statfs requires two arguments and struct statfs has bsize property])
  fi
fi

if test $space = no; then
# SVR3
  AC_MSG_CHECKING([for four-argument statfs (AIX-3.2.5, SVR3)])
  AC_CACHE_VAL(fu_cv_sys_stat_statfs4,
  [AC_TRY_RUN([#include <sys/types.h>
#include <sys/statfs.h>
  main ()
  {
  struct statfs fsd;
  exit (statfs (".", &fsd, sizeof fsd, 0));
  }],
    fu_cv_sys_stat_statfs4=yes,
    fu_cv_sys_stat_statfs4=no,
    fu_cv_sys_stat_statfs4=no)])
  AC_MSG_RESULT($fu_cv_sys_stat_statfs4)
  if test $fu_cv_sys_stat_statfs4 = yes; then
    space=yes
    AC_DEFINE(STAT_STATFS4,1,[Whether statfs requires 4 arguments])
  fi
fi

if test $space = no; then
# 4.4BSD and NetBSD
  AC_MSG_CHECKING([for two-argument statfs with statfs.fsize dnl
member (4.4BSD and NetBSD)])
  AC_CACHE_VAL(fu_cv_sys_stat_statfs2_fsize,
  [AC_TRY_RUN([#include <sys/types.h>
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
  main ()
  {
  struct statfs fsd;
  fsd.f_fsize = 0;
  exit (statfs (".", &fsd));
  }],
  fu_cv_sys_stat_statfs2_fsize=yes,
  fu_cv_sys_stat_statfs2_fsize=no,
  fu_cv_sys_stat_statfs2_fsize=no)])
  AC_MSG_RESULT($fu_cv_sys_stat_statfs2_fsize)
  if test $fu_cv_sys_stat_statfs2_fsize = yes; then
    space=yes
	AC_DEFINE(STAT_STATFS2_FSIZE,1,[Whether statfs requires 2 arguments and struct statfs has fsize])
  fi
fi

if test $space = no; then
  # Ultrix
  AC_MSG_CHECKING([for two-argument statfs with struct fs_data (Ultrix)])
  AC_CACHE_VAL(fu_cv_sys_stat_fs_data,
  [AC_TRY_RUN([#include <sys/types.h>
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
#ifdef HAVE_SYS_FS_TYPES_H
#include <sys/fs_types.h>
#endif
  main ()
  {
  struct fs_data fsd;
  /* Ultrix's statfs returns 1 for success,
     0 for not mounted, -1 for failure.  */
  exit (statfs (".", &fsd) != 1);
  }],
  fu_cv_sys_stat_fs_data=yes,
  fu_cv_sys_stat_fs_data=no,
  fu_cv_sys_stat_fs_data=no)])
  AC_MSG_RESULT($fu_cv_sys_stat_fs_data)
  if test $fu_cv_sys_stat_fs_data = yes; then
    space=yes
    AC_DEFINE(STAT_STATFS2_FS_DATA,1,[Whether statfs requires 2 arguments and struct fs_data is available])
  fi
fi

#
# As a gating factor for large file support, in order to
# use <4GB files we must have the following minimal support
# available.
# long long, and a 64 bit off_t or off64_t.
# If we don't have all of these then disable large
# file support.
#
AC_MSG_CHECKING([if large file support can be enabled])
AC_TRY_COMPILE([
#if defined(HAVE_LONGLONG) && (defined(HAVE_OFF64_T) || (defined(SIZEOF_OFF_T) && (SIZEOF_OFF_T == 8)))
#include <sys/types.h>
#else
__COMPILE_ERROR_
#endif
],
[int i],
samba_cv_HAVE_EXPLICIT_LARGEFILE_SUPPORT=yes,samba_cv_HAVE_EXPLICIT_LARGEFILE_SUPPORT=no)
if test x"$samba_cv_HAVE_EXPLICIT_LARGEFILE_SUPPORT" = x"yes"; then
	AC_DEFINE(HAVE_EXPLICIT_LARGEFILE_SUPPORT,1,[Whether large file support can be enabled])
fi
AC_MSG_RESULT([$samba_cv_HAVE_EXPLICIT_LARGEFILE_SUPPORT])


#################################################
# check for cluster extensions

AC_MSG_CHECKING(cluster support)
AC_ARG_WITH(cluster-support,
[AS_HELP_STRING([--with-cluster-support], [Enable cluster extensions (default=auto)])])

if test x"$with_cluster_support" = x ; then
	with_cluster_support="auto"
fi

AC_MSG_RESULT($with_cluster_support)

AC_ARG_WITH(ctdb,
[AS_HELP_STRING([--with-ctdb=DIR], [Where to find ctdb sources])],
[ case "$withval" in
  yes|no)
    AC_MSG_WARN([--with-ctdb called without argument])
    ;;
  *)
    CTDB_CPPFLAGS="-I$withval/include"
    ;;
  esac])

AC_ARG_ENABLE(old-ctdb,
	[AS_HELP_STRING([--enable-old-ctdb],
		[Enable build against (too) old ctdb version (default=no)])],,
		[enable_old_ctdb=no])


if test "$with_cluster_support" != "no" ; then

AC_MSG_NOTICE(checking whether cluster support is available)

have_cluster_support="yes"
ctdb_broken="no"

SAVED_CPPFLAGS="$CPPFLAGS"
CPPFLAGS="$CPPFLAGS ${SAMBA_CONFIGURE_CPPFLAGS} $CTDB_CPPFLAGS"

AC_CHECK_HEADERS(ctdb.h ctdb_private.h,,,[
#include "confdefs.h"
#define NO_CONFIG_H
#include "replace.h"
#include "system/wait.h"
#include "system/network.h"
#define private #error __USED_RESERVED_WORD_private__
#include <talloc.h>
#include <tdb.h>
#include <ctdb.h>
])

if test "x$have_cluster_support" = "xyes" -a \
	"x$ac_cv_header_ctdb_h" != "xyes"
then
	have_cluster_support=no
	ctdb_broken="ctdb.h is required for cluster support"
fi

if test "x$have_cluster_support" = "xyes" -a \
	"x$ac_cv_header_ctdb_h" != "xyes"
then
	have_cluster_support=no
	ctdb_broken="ctdb_private.h is required for cluster support"
fi


if test "x$have_cluster_support" = "xyes" ; then
	AC_HAVE_DECL(CTDB_CONTROL_TRANS3_COMMIT,[
	#include "confdefs.h"
	#define NO_CONFIG_H
	#include "replace.h"
	#include "system/wait.h"
	#include "system/network.h"
	#include <talloc.h>
	#include <tdb.h>
	#include <ctdb.h>
	#include <ctdb_private.h>
	])
	if test x"$ac_cv_have_CTDB_CONTROL_TRANS3_COMMIT_decl" != x"yes"; then
		ctdb_broken="ctdb transaction support missing or too old"
		have_cluster_support=no
	fi
fi

if test "x$have_cluster_support" = "xyes" ; then
	AC_HAVE_DECL(CTDB_CONTROL_SCHEDULE_FOR_DELETION,[
	#include "confdefs.h"
	#define NO_CONFIG_H
	#include "replace.h"
	#include "system/wait.h"
	#include "system/network.h"
	#include <talloc.h>
	#include <tdb.h>
	#include <ctdb.h>
	#include <ctdb_private.h>
	])
	if test x"$ac_cv_have_CTDB_CONTROL_SCHEDULE_FOR_DELETION_decl" != x"yes"
	then
		if test "x$enable_old_ctdb" = "xyes" ; then
			AC_MSG_WARN([ignoring missing SCHEDULE_FOR_DELETION (--enable-old-ctdb)])
		else
			ctdb_broken="support for SCHEDULE_FOR_DELETION control missing"
			have_cluster_support=no
		fi
	fi
fi

if test "x$have_cluster_support" = "xyes" ; then
	# In ctdb 1.0.57, ctdb_control_tcp was temporarily renamed
	# to ctdb_tcp_client.
	AC_CHECK_TYPE(struct ctdb_tcp_client,[
		AC_DEFINE([ctdb_control_tcp],[ctdb_tcp_client],[ctdb ipv4 support])
	],,[
	#include "confdefs.h"
	#define NO_CONFIG_H
	#include "replace.h"
	#include "system/wait.h"
	#include "system/network.h"
	#include <talloc.h>
	#include <tdb.h>
	#include <ctdb.h>
	#include <ctdb_private.h>
	])
fi

if test "x$have_cluster_support" = "xyes" ; then
	AC_CHECK_TYPE(struct ctdb_control_tcp,[
		AC_DEFINE([HAVE_STRUCT_CTDB_CONTROL_TCP],[1],[ctdb ipv4 support])
	],[
		ctdb_broken="missing struct ctdb_control_tcp"
		have_cluster_support=no
	],[
	#include "confdefs.h"
	#define NO_CONFIG_H
	#include "replace.h"
	#include "system/wait.h"
	#include "system/network.h"
	#include <talloc.h>
	#include <tdb.h>
	#include <ctdb.h>
	#include <ctdb_private.h>
	])
fi

# test for optional ipv6 support in ctdb:
if test "x$have_cluster_support" = "xyes" ; then
	AC_CHECK_TYPE(struct ctdb_control_tcp_addr,[
		AC_DEFINE([HAVE_STRUCT_CTDB_CONTROL_TCP_ADDR],[1],[ctdb ipv6 support])
	],,[
	#include "confdefs.h"
	#define NO_CONFIG_H
	#include "replace.h"
	#include "system/wait.h"
	#include "system/network.h"
	#include <talloc.h>
	#include <tdb.h>
	#include <ctdb.h>
	#include <ctdb_private.h>
	])
fi

CPPFLAGS="$SAVED_CPPFLAGS"

fi # (if test "$with_cluster_support" != "no")

if test x"$have_cluster_support" = "xno" ; then
	case "$with_cluster_support" in
	yes)
		AC_MSG_ERROR(["cluster support not available: $ctdb_broken"])
		;;
	auto)
		AC_MSG_WARN(["cluster support not available: $ctdb_broken"])
		;;
	esac
	with_cluster_support=no
fi

if test "x$with_cluster_support" != "xno"; then
    AC_DEFINE(CLUSTER_SUPPORT,1,[Whether to enable cluster extensions])
    SAMBA_CPPFLAGS="${SAMBA_CPPFLAGS} ${CTDB_CPPFLAGS}"
    AC_MSG_NOTICE(Building with cluster support)
else
    AC_MSG_NOTICE(Building without cluster support)
fi


#################################################
# check for rtnetlink

AC_CHECK_HEADERS([linux/netlink.h],
  AC_CHECK_HEADERS([linux/rtnetlink.h],[],[],
                   [#include <bits/sockaddr.h>
                    #include <linux/netlink.h>]),
  [],[#include <bits/sockaddr.h>])

#################################################
# check for ACL support

AC_MSG_CHECKING(whether to support ACLs)
AC_ARG_WITH(acl-support,
[AS_HELP_STRING([--with-acl-support], [Include ACL support (default=auto)])],
[ case "$withval" in
	yes|no)
		with_acl_support="$withval"
		;;
  esac ])

if test x"$with_acl_support" = x ; then
	with_acl_support="auto"
fi

AC_MSG_RESULT($with_acl_support)

if test x"$with_acl_support" = x"no"; then
	AC_MSG_RESULT(Disabling ACL support)
	AC_DEFINE(HAVE_NO_ACLS,1,[Whether no ACLs support should be built in])
else
	AC_MSG_NOTICE(checking whether ACL support is available:)
	case "$host_os" in
	*sysv5*)
		AC_MSG_NOTICE(Using UnixWare ACLs)
		AC_DEFINE(HAVE_UNIXWARE_ACLS,1,[Whether UnixWare ACLs are available])
		default_static_modules="$default_static_modules vfs_solarisacl"
		;;
	*solaris*)
		AC_MSG_NOTICE(Using solaris ACLs)
		AC_DEFINE(HAVE_SOLARIS_ACLS,1,[Whether solaris ACLs are available])
		ACL_LIBS="$ACL_LIBS -lsec"
		default_static_modules="$default_static_modules vfs_solarisacl"
		;;
	*hpux*)
		AC_MSG_NOTICE(Using HPUX ACLs)
		AC_DEFINE(HAVE_HPUX_ACLS,1,[Whether HPUX ACLs are available])
		default_static_modules="$default_static_modules vfs_hpuxacl"
		;;
	*irix*)
		AC_MSG_NOTICE(Using IRIX ACLs)
		AC_DEFINE(HAVE_IRIX_ACLS,1,[Whether IRIX ACLs are available])
		default_static_modules="$default_static_modules vfs_irixacl"
		;;
	*aix*)
		AC_MSG_NOTICE(Using AIX ACLs)
		AC_DEFINE(HAVE_AIX_ACLS,1,[Whether AIX ACLs are available])
		default_static_modules="$default_static_modules vfs_aixacl"
		;;
	*osf*)
		AC_MSG_NOTICE(Using Tru64 ACLs)
		AC_DEFINE(HAVE_TRU64_ACLS,1,[Whether Tru64 ACLs are available])
		ACL_LIBS="$ACL_LIBS -lpacl"
		default_static_modules="$default_static_modules vfs_tru64acl"
		;;
	*darwin*)
		AC_MSG_NOTICE(ACLs on Darwin currently not supported)
		AC_DEFINE(HAVE_NO_ACLS,1,[Whether no ACLs support is available])
		;;
	*)
		AC_CHECK_LIB(acl,acl_get_file,[ACL_LIBS="$ACL_LIBS -lacl"])
		case "$host_os" in
		*linux*)
			AC_CHECK_LIB(attr,getxattr,[ACL_LIBS="$ACL_LIBS -lattr"])
			;;
		esac
		AC_CACHE_CHECK([for POSIX ACL support],samba_cv_HAVE_POSIX_ACLS,[
			acl_LIBS=$LIBS
			LIBS="$LIBS $ACL_LIBS"
			AC_TRY_LINK([
				#include <sys/types.h>
				#include <sys/acl.h>
			],[
				acl_t acl;
				int entry_id;
				acl_entry_t *entry_p;
				return acl_get_entry(acl, entry_id, entry_p);
			],
			[samba_cv_HAVE_POSIX_ACLS=yes],
			[samba_cv_HAVE_POSIX_ACLS=no])
			LIBS=$acl_LIBS
		])
		if test x"$samba_cv_HAVE_POSIX_ACLS" = x"yes"; then
			AC_MSG_NOTICE(Using posix ACLs)
			AC_DEFINE(HAVE_POSIX_ACLS,1,[Whether POSIX ACLs are available])
			AC_CACHE_CHECK([for acl_get_perm_np],samba_cv_HAVE_ACL_GET_PERM_NP,[
				acl_LIBS=$LIBS
				LIBS="$LIBS $ACL_LIBS"
				AC_TRY_LINK([
					#include <sys/types.h>
					#include <sys/acl.h>
				],[
					acl_permset_t permset_d;
					acl_perm_t perm;
					return acl_get_perm_np(permset_d, perm);
				],
				[samba_cv_HAVE_ACL_GET_PERM_NP=yes],
				[samba_cv_HAVE_ACL_GET_PERM_NP=no])
				LIBS=$acl_LIBS
			])
			if test x"$samba_cv_HAVE_ACL_GET_PERM_NP" = x"yes"; then
				AC_DEFINE(HAVE_ACL_GET_PERM_NP,1,[Whether acl_get_perm_np() is available])
			fi
   			default_static_modules="$default_static_modules vfs_posixacl"
		else
			AC_MSG_NOTICE(ACL support is not avaliable)
			AC_DEFINE(HAVE_NO_ACLS,1,[Whether no ACLs support is available])
		fi
		;;
        esac
fi # with_acl_support

#################################################
# check if we have FreeBSD sunacl
case "$host_os" in
*freebsd*)
    AC_CHECK_HEADER(sunacl.h)
    if test x"$ac_cv_header_sunacl_h" = xyes ; then
       AC_DEFINE(HAVE_FREEBSD_SUNACL_H,1,[Whether we have FreeBSD sunacl around])
       ZFSACL_LIBS=-lsunacl
       AC_SUBST(ZFSACL_LIBS)
       default_shared_modules="$default_shared_modules vfs_zfsacl"
    fi
    ;;
esac

#################################################
# check for AIO support

AC_MSG_CHECKING(whether to support asynchronous io)
AC_ARG_WITH(aio-support,
[AS_HELP_STRING([--with-aio-support], [Include asynchronous io support (default=no)])],
[ case "$withval" in
  yes)

	AC_MSG_RESULT(yes)
	case "$host_os" in
	*)
		AIO_LIBS=$LIBS
		no_rt_LIBS=$LIBS
		AC_CHECK_LIB(rt,aio_read,[AIO_LIBS="$LIBS -lrt"])
		LIBS=$no_rt_LIBS
		AC_CHECK_LIB(aio,aio_read,[AIO_LIBS="$LIBS -laio"])
		AC_CACHE_CHECK([for asynchronous io support],samba_cv_HAVE_AIO,[
		aio_LIBS=$LIBS
		LIBS=$AIO_LIBS
		AC_TRY_LINK([#include <sys/types.h>
#include <aio.h>],
[ struct aiocb a; return aio_read(&a);],
samba_cv_HAVE_AIO=yes,samba_cv_HAVE_AIO=no)
		LIBS=$aio_LIBS])
		AC_CACHE_CHECK([for 64-bit asynchronous io support],samba_cv_HAVE_AIO64,[
		aio_LIBS=$LIBS
		LIBS=$AIO_LIBS
		AC_TRY_LINK([#include <sys/types.h>
#include <aio.h>],
[ struct aiocb64 a; return aio_read64(&a);],
samba_cv_HAVE_AIO64=yes,samba_cv_HAVE_AIO64=no)
		LIBS=$aio_LIBS])
		if test x"$samba_cv_HAVE_AIO64" = x"yes"; then
			AC_DEFINE(HAVE_AIOCB64,1,[Whether 64 bit aio is available])
			AC_DEFINE(WITH_AIO, 1, [Using asynchronous io])
			LIBS=$AIO_LIBS
		elif test x"$samba_cv_HAVE_AIO" = x"yes"; then
			AC_DEFINE(WITH_AIO, 1, [Using asynchronous io])
			LIBS=$AIO_LIBS
		fi

		if test x"$samba_cv_HAVE_AIO" = x"yes"; then
			AC_MSG_CHECKING(for aio_read)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_read(&a); }],
[AC_DEFINE(HAVE_AIO_READ, 1, [Have aio_read]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_write)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_write(&a); }],
[AC_DEFINE(HAVE_AIO_WRITE, 1, [Have aio_write]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_fsync)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_fsync(1, &a); }],
[AC_DEFINE(HAVE_AIO_FSYNC, 1, [Have aio_fsync]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_return)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_return(&a); }],
[AC_DEFINE(HAVE_AIO_RETURN, 1, [Have aio_return]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_error)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_error(&a); }],
[AC_DEFINE(HAVE_AIO_ERROR, 1, [Have aio_error]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_cancel)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_cancel(1, &a); }],
[AC_DEFINE(HAVE_AIO_CANCEL, 1, [Have aio_cancel]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_suspend)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; struct timespec t; return aio_suspend(&a, 1, &t); }],
[AC_DEFINE(HAVE_AIO_SUSPEND, 1, [Have aio_suspend]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])
		fi

		if test x"$samba_cv_HAVE_AIO64" = x"yes"; then
			AC_MSG_CHECKING(for aio_read64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_read64(&a); }],
[AC_DEFINE(HAVE_AIO_READ64, 1, [Have aio_read64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_write64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_write64(&a); }],
[AC_DEFINE(HAVE_AIO_WRITE64, 1, [Have aio_write64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_fsync64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_fsync64(1, &a); }],
[AC_DEFINE(HAVE_AIO_FSYNC64, 1, [Have aio_fsync64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_return64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_return64(&a); }],
[AC_DEFINE(HAVE_AIO_RETURN64, 1, [Have aio_return64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_error64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_error64(&a); }],
[AC_DEFINE(HAVE_AIO_ERROR64, 1, [Have aio_error64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_cancel64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_cancel64(1, &a); }],
[AC_DEFINE(HAVE_AIO_CANCEL64, 1, [Have aio_cancel64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])

			AC_MSG_CHECKING(for aio_suspend64)
			AC_LINK_IFELSE([#include <aio.h>
int main() { struct aiocb a; return aio_suspend64(&a, 1, NULL); }],
[AC_DEFINE(HAVE_AIO_SUSPEND64, 1, [Have aio_suspend64]) AC_MSG_RESULT(yes)],
[AC_MSG_RESULT(no)])
		fi
            ;;
        esac
        ;;
  *)
    AC_MSG_RESULT(no)
    AC_DEFINE(HAVE_NO_AIO,1,[Whether no asynchronous io support is available])
    ;;
  esac ],
  AC_DEFINE(HAVE_NO_AIO,1,[Whether no asynchronous io support should be built in])
  AC_MSG_RESULT(no)
)

if test x"$samba_cv_HAVE_AIO" = x"yes"; then
	if test x"$samba_cv_msghdr_msg_control" = x"yes" -o \
		x"$samba_cv_msghdr_msg_acctright" = x"yes"; then
		default_shared_modules="$default_shared_modules vfs_aio_fork"
	fi
fi

#################################################
# check for sendfile support

AC_MSG_CHECKING(whether sendfile support should be built in)
AC_ARG_WITH(sendfile-support,
[AS_HELP_STRING([--with-sendfile-support], [Whether sendfile support should be built in (default=auto)])],
[ case "$withval" in
  yes|no)
	AC_MSG_RESULT($withval);
	with_sendfile_support=$withval
	;;
  *)
	AC_MSG_RESULT(yes)
	with_sendfile_support=auto
	;;
  esac ],
)

if test x$with_sendfile_support != xno ; then
    case "$host_os" in
	*linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu)
		AC_CACHE_CHECK([for linux sendfile64 support],samba_cv_HAVE_SENDFILE64,[
		AC_TRY_LINK([#include <sys/sendfile.h>],
[\
int tofd, fromfd;
off64_t offset;
size_t total;
ssize_t nwritten = sendfile64(tofd, fromfd, &offset, total);
],
samba_cv_HAVE_SENDFILE64=yes,samba_cv_HAVE_SENDFILE64=no)])

		AC_CACHE_CHECK([for linux sendfile support],samba_cv_HAVE_SENDFILE,[
		AC_TRY_LINK([#include <sys/sendfile.h>],
[\
int tofd, fromfd;
off_t offset;
size_t total;
ssize_t nwritten = sendfile(tofd, fromfd, &offset, total);
],
samba_cv_HAVE_SENDFILE=yes,samba_cv_HAVE_SENDFILE=no)])

# Try and cope with broken Linux sendfile....
		AC_CACHE_CHECK([for broken linux sendfile support],samba_cv_HAVE_BROKEN_LINUX_SENDFILE,[
		AC_TRY_LINK([\
#if defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS == 64)
#undef _FILE_OFFSET_BITS
#endif
#include <sys/sendfile.h>],
[\
int tofd, fromfd;
off_t offset;
size_t total;
ssize_t nwritten = sendfile(tofd, fromfd, &offset, total);
],
samba_cv_HAVE_BROKEN_LINUX_SENDFILE=yes,samba_cv_HAVE_BROKEN_LINUX_SENDFILE=no)])

	if test x"$samba_cv_HAVE_SENDFILE64" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILE64,1,[Whether 64-bit sendfile() is available])
		AC_DEFINE(LINUX_SENDFILE_API,1,[Whether linux sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() should be used])
	elif test x"$samba_cv_HAVE_SENDFILE" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILE,1,[Whether sendfile() is available])
		AC_DEFINE(LINUX_SENDFILE_API,1,[Whether linux sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() should be used])
	elif test x"$samba_cv_HAVE_BROKEN_LINUX_SENDFILE" = x"yes"; then
		AC_DEFINE(LINUX_BROKEN_SENDFILE_API,1,[Whether (linux) sendfile() is broken])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile should be used])
	else
		AC_MSG_RESULT(no);
	fi

	;;
	*freebsd* | *dragonfly* )
		AC_CACHE_CHECK([for freebsd sendfile support],samba_cv_HAVE_SENDFILE,[
		AC_TRY_LINK([\
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/uio.h>],
[\
	int fromfd, tofd, ret, total=0;
	off_t offset, nwritten;
	struct sf_hdtr hdr;
	struct iovec hdtrl;
	hdr.headers = &hdtrl;
	hdr.hdr_cnt = 1;
	hdr.trailers = NULL;
	hdr.trl_cnt = 0;
	hdtrl.iov_base = NULL;
	hdtrl.iov_len = 0;
	ret = sendfile(fromfd, tofd, offset, total, &hdr, &nwritten, 0);
],
samba_cv_HAVE_SENDFILE=yes,samba_cv_HAVE_SENDFILE=no)])

	if test x"$samba_cv_HAVE_SENDFILE" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILE,1,[Whether sendfile() support is available])
		AC_DEFINE(FREEBSD_SENDFILE_API,1,[Whether the FreeBSD sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() support should be included])
	else
		AC_MSG_RESULT(no);
	fi
	;;

	*hpux*)
		AC_CACHE_CHECK([for hpux sendfile64 support],samba_cv_HAVE_SENDFILE64,[
		AC_TRY_LINK([\
#include <sys/socket.h>
#include <sys/uio.h>],
[\
	int fromfd, tofd;
	size_t total=0;
	struct iovec hdtrl[2];
	ssize_t nwritten;
	off64_t offset;

	hdtrl[0].iov_base = 0;
	hdtrl[0].iov_len = 0;

	nwritten = sendfile64(tofd, fromfd, offset, total, &hdtrl[0], 0);
],
samba_cv_HAVE_SENDFILE64=yes,samba_cv_HAVE_SENDFILE64=no)])
	if test x"$samba_cv_HAVE_SENDFILE64" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILE64,1,[Whether sendfile64() is available])
		AC_DEFINE(HPUX_SENDFILE_API,1,[Whether the hpux sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() support should be included])
	else
		AC_MSG_RESULT(no);
	fi

		AC_CACHE_CHECK([for hpux sendfile support],samba_cv_HAVE_SENDFILE,[
		AC_TRY_LINK([\
#include <sys/socket.h>
#include <sys/uio.h>],
[\
	int fromfd, tofd;
	size_t total=0;
	struct iovec hdtrl[2];
	ssize_t nwritten;
	off_t offset;

	hdtrl[0].iov_base = 0;
	hdtrl[0].iov_len = 0;

	nwritten = sendfile(tofd, fromfd, offset, total, &hdtrl[0], 0);
],
samba_cv_HAVE_SENDFILE=yes,samba_cv_HAVE_SENDFILE=no)])
	if test x"$samba_cv_HAVE_SENDFILE" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILE,1,[Whether sendfile() is available])
		AC_DEFINE(HPUX_SENDFILE_API,1,[Whether the hpux sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() support should be included])
	else
		AC_MSG_RESULT(no);
	fi
	;;

	*solaris*)
		AC_CHECK_LIB(sendfile,sendfilev)
		AC_CACHE_CHECK([for solaris sendfilev64 support],samba_cv_HAVE_SENDFILEV64,[
		AC_TRY_LINK([\
#include <sys/sendfile.h>],
[\
        int sfvcnt;
        size_t xferred;
        struct sendfilevec vec[2];
	ssize_t nwritten;
	int tofd;

	sfvcnt = 2;

	vec[0].sfv_fd = SFV_FD_SELF;
	vec[0].sfv_flag = 0;
	vec[0].sfv_off = 0;
	vec[0].sfv_len = 0;

	vec[1].sfv_fd = 0;
	vec[1].sfv_flag = 0;
	vec[1].sfv_off = 0;
	vec[1].sfv_len = 0;
	nwritten = sendfilev64(tofd, vec, sfvcnt, &xferred);
],
samba_cv_HAVE_SENDFILEV64=yes,samba_cv_HAVE_SENDFILEV64=no)])

	if test x"$samba_cv_HAVE_SENDFILEV64" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILEV64,1,[Whether sendfilev64() is available])
		AC_DEFINE(SOLARIS_SENDFILE_API,1,[Whether the soloris sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether sendfile() support should be included])
	else
		AC_MSG_RESULT(no);
	fi

		AC_CACHE_CHECK([for solaris sendfilev support],samba_cv_HAVE_SENDFILEV,[
		AC_TRY_LINK([\
#include <sys/sendfile.h>],
[\
        int sfvcnt;
        size_t xferred;
        struct sendfilevec vec[2];
	ssize_t nwritten;
	int tofd;

	sfvcnt = 2;

	vec[0].sfv_fd = SFV_FD_SELF;
	vec[0].sfv_flag = 0;
	vec[0].sfv_off = 0;
	vec[0].sfv_len = 0;

	vec[1].sfv_fd = 0;
	vec[1].sfv_flag = 0;
	vec[1].sfv_off = 0;
	vec[1].sfv_len = 0;
	nwritten = sendfilev(tofd, vec, sfvcnt, &xferred);
],
samba_cv_HAVE_SENDFILEV=yes,samba_cv_HAVE_SENDFILEV=no)])

	if test x"$samba_cv_HAVE_SENDFILEV" = x"yes"; then
    		AC_DEFINE(HAVE_SENDFILEV,1,[Whether sendfilev() is available])
		AC_DEFINE(SOLARIS_SENDFILE_API,1,[Whether the solaris sendfile() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether to include sendfile() support])
	else
		AC_MSG_RESULT(no);
	fi
	;;
	*aix*)
		AC_CACHE_CHECK([for AIX send_file support],samba_cv_HAVE_SENDFILE,[
		AC_TRY_LINK([\
#include <sys/socket.h>],
[\
	int fromfd, tofd;
	size_t total=0;
	struct sf_parms hdtrl;
	ssize_t nwritten;
	off64_t offset;

	hdtrl.header_data = 0;
	hdtrl.header_length = 0;
	hdtrl.file_descriptor = fromfd;
	hdtrl.file_offset = 0;
	hdtrl.file_bytes = 0;
	hdtrl.trailer_data = 0;
	hdtrl.trailer_length = 0;

	nwritten = send_file(&tofd, &hdtrl, 0);
],
samba_cv_HAVE_SENDFILE=yes,samba_cv_HAVE_SENDFILE=no)])
	if test x"$samba_cv_HAVE_SENDFILE" = x"yes"; then
		AC_DEFINE(HAVE_SENDFILE,1,[Whether sendfile() is available])
		AC_DEFINE(AIX_SENDFILE_API,1,[Whether the AIX send_file() API is available])
		AC_DEFINE(WITH_SENDFILE,1,[Whether to include sendfile() support])
	else
		AC_MSG_RESULT(no);
	fi
	;;
	*)
	;;
    esac
fi

if test x$with_sendfile_support = xyes -a x"$samba_cv_HAVE_SENDFILE" != xyes ; then
	AC_MSG_ERROR(sendfile support requested but sendfile not available )
fi

############################################
# See if we have the Linux readahead syscall.

AC_CACHE_CHECK([for Linux readahead],
                samba_cv_HAVE_LINUX_READAHEAD,[
    AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <fcntl.h>],
    [ssize_t err = readahead(0,0,0x80000);],
    samba_cv_HAVE_LINUX_READAHEAD=yes,
    samba_cv_HAVE_LINUX_READAHEAD=no)])

if test x"$samba_cv_HAVE_LINUX_READAHEAD" = x"yes"; then
  AC_DEFINE(HAVE_LINUX_READAHEAD,1,
             [Whether Linux readahead is available])
fi

AC_HAVE_DECL(readahead, [#include <fcntl.h>])

############################################
# See if we have the posix_fadvise syscall.

AC_CACHE_CHECK([for posix_fadvise],
                samba_cv_HAVE_POSIX_FADVISE,[
    AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <fcntl.h>],
    [ssize_t err = posix_fadvise(0,0,0x80000,POSIX_FADV_WILLNEED);],
    samba_cv_HAVE_POSIX_FADVISE=yes,
    samba_cv_HAVE_POSIX_FADVISE=no)])

if test x"$samba_cv_HAVE_POSIX_FADVISE" = x"yes"; then
  AC_DEFINE(HAVE_POSIX_FADVISE,1,
             [Whether posix_fadvise is available])
fi

############################################
# See if we have the Linux splice syscall.

case "$host_os" in
*linux*)
AC_CACHE_CHECK([for Linux splice],
                samba_cv_HAVE_LINUX_SPLICE,[
    AC_TRY_LINK([
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#include <fcntl.h>],
    [long ret = splice(0,0,1,0,400,0);],
    samba_cv_HAVE_LINUX_SPLICE=yes,
    samba_cv_HAVE_LINUX_SPLICE=no)])
;;
*)
samba_cv_HAVE_LINUX_SPLICE=no
;;
esac

if test x"$samba_cv_HAVE_LINUX_SPLICE" = x"yes"; then
  AC_DEFINE(HAVE_LINUX_SPLICE,1,
             [Whether Linux splice is available])
fi

AC_HAVE_DECL(splice, [#include <fcntl.h>])

############################################
# See if we have the a broken readlink syscall.

AC_CACHE_CHECK([for a broken readlink syscall],samba_cv_HAVE_BROKEN_READLINK,[
AC_TRY_RUN([#include "${srcdir-.}/../tests/readlink.c"],
	samba_cv_HAVE_BROKEN_READLINK=no,samba_cv_HAVE_BROKEN_READLINK=yes,samba_cv_HAVE_BROKEN_READLINK=cross)
])
if test x"$samba_cv_HAVE_BROKEN_READLINK" = x"yes"; then
	AC_DEFINE(HAVE_BROKEN_READLINK,1,[Whether the readlink syscall is broken])
fi

#################################################
# Check whether winbind is supported on this platform.  If so we need to
# build and install client programs, sbin programs and shared libraries

AC_MSG_CHECKING(whether to build winbind)

# Initially, the value of $host_os decides whether winbind is supported

HAVE_WINBIND=yes
HAVE_WBCLIENT=no

# Define external wbclient library to link against.  This disables winbind.
# We define this here so --with-winbind can override it.
AC_ARG_WITH(wbclient,
[AS_HELP_STRING([--with-wbclient], [Use external wbclient (optional)])],
[
  case "$withval" in
        no)
		HAVE_WBCLIENT=no
		;;
	yes)
		HAVE_WBCLIENT=yes
		HAVE_WINBIND=no
		;;
        *)
		HAVE_WBCLIENT=yes
		HAVE_WINBIND=no
		WBCLIENT_INCLUDES="-I$withval/include"
		WBCLIENT_LDFLAGS="-L$withval/lib"
		;;
  esac ],
)

AC_SUBST(WBCLIENT_INCLUDES)
AC_SUBST(WBCLIENT_LDFLAGS)
AC_SUBST(WBCLIENT_LIBS)


# Define the winbind shared library name and any specific linker flags
# it needs to be built with.

WINBIND_NSS="../nsswitch/libnss_winbind.$SHLIBEXT"
WINBIND_WINS_NSS="../nsswitch/libnss_wins.$SHLIBEXT"
WINBIND_NSS_LDSHFLAGS=$LDSHFLAGS
NSSSONAMEVERSIONSUFFIX=""

case "$host_os" in
	*linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu)
		NSSSONAMEVERSIONSUFFIX=".2"
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_linux.o"
		;;
	*freebsd[[5-9]]*)
		# FreeBSD winbind client is implemented as a wrapper around
		# the Linux version.
		NSSSONAMEVERSIONSUFFIX=".1"
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_freebsd.o \
		    ../nsswitch/winbind_nss_linux.o"
		WINBIND_NSS="../nsswitch/nss_winbind.$SHLIBEXT"
		WINBIND_WINS_NSS="../nsswitch/nss_wins.$SHLIBEXT"
		;;

	*netbsd*[[3-9]]*)
		# NetBSD winbind client is implemented as a wrapper
		# around the Linux version. It needs getpwent_r() to
		# indicate libc's use of the correct nsdispatch API.
		#
		if test x"$ac_cv_func_getpwent_r" = x"yes"; then
			WINBIND_NSS_EXTRA_OBJS="\
			    ../nsswitch/winbind_nss_netbsd.o \
			    ../nsswitch/winbind_nss_linux.o"
			WINBIND_NSS="../nsswitch/nss_winbind.$SHLIBEXT"
			WINBIND_WINS_NSS="../nsswitch/nss_wins.$SHLIBEXT"
		else
			HAVE_WINBIND=no
			winbind_no_reason=", getpwent_r is missing on $host_os so winbind is unsupported"
		fi
		;;
	*irix*)
		# IRIX has differently named shared libraries
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_irix.o"
		WINBIND_NSS="../nsswitch/libns_winbind.$SHLIBEXT"
		WINBIND_WINS_NSS="../nsswitch/libns_wins.$SHLIBEXT"
		;;
	*solaris*)
		# Solaris winbind client is implemented as a wrapper around
		# the Linux version.
		NSSSONAMEVERSIONSUFFIX=".1"
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_solaris.o \
		    ../nsswitch/winbind_nss_linux.o"
		;;
	*hpux11*)
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_solaris.o"
		;;
	*aix*)
		# AIX has even differently named shared libraries.  No
		# WINS support has been implemented yet.
		WINBIND_NSS_EXTRA_OBJS="../nsswitch/winbind_nss_aix.o"
		WINBIND_NSS_LDSHFLAGS="-Wl,-bexpall,-bM:SRE,-ewb_aix_init"
		WINBIND_NSS="../nsswitch/WINBIND"
		WINBIND_WINS_NSS=""
		;;
	*)
		HAVE_WINBIND=no
		winbind_no_reason=", unsupported on $host_os"
		;;
esac

# Check the setting of --with-winbind

AC_ARG_WITH(winbind,
[AS_HELP_STRING([--with-winbind], [Build winbind (default, if supported by OS)])],
[
  case "$withval" in
	yes)
		HAVE_WINBIND=yes
		HAVE_WBCLIENT=no
		;;
        no)
		HAVE_WINBIND=no
                winbind_reason=""
                ;;
  esac ],
)

# We need unix domain sockets for winbind

if test x"$HAVE_WINBIND" = x"yes"; then
	if test x"$libreplace_cv_HAVE_UNIXSOCKET" = x"no"; then
		winbind_no_reason=", no unix domain socket support on $host_os"
		HAVE_WINBIND=no
	fi
fi

# Display test results

if test x"$HAVE_WINBIND" = x"no"; then
	WINBIND_NSS=""
	WINBIND_WINS_NSS=""
fi
if test x"$HAVE_WBCLIENT" = x"yes"; then
        AC_CHECK_LIB(wbclient, wbcInterfaceDetails,
		     [LIBWBCLIENT_LIBS="-lwbclient"], AC_MSG_ERROR([Could not find wbclient]), [$WBCLIENT_LDFLAGS])
	LIBWBCLIENT_LIBS="$LIBWBCLIENT_LIBS $WBCLIENT_LDFLAGS"
	AC_MSG_RESULT(yes)
	AC_DEFINE(WITH_WINBIND,1,[Whether to link to wbclient])
	EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/wbinfo\$(EXEEXT)"
else
	if test x"$enable_developer" = x"yes" -a x"$LINK_LIBWBCLIENT" = x"STATIC" ; then
		BUILD_LIBWBCLIENT_SHARED=no
	else
		BUILD_LIBWBCLIENT_SHARED=yes
	fi

	LIBWBCLIENT_SHARED_TARGET=bin/libwbclient.$SHLIBEXT
	LIBWBCLIENT_STATIC_TARGET=bin/libwbclient.a
	LIBWBCLIENT_SOVER=0
	LIBWBCLIENT_FULLVER=0
	LIBWBCLIENT_SHARED_TARGET_SOVER=$LIBWBCLIENT_SHARED_TARGET.$LIBWBCLIENT_SOVER
	LIBWBCLIENT_SHARED_TARGET_FULLVER=$LIBWBCLIENT_SHARED_TARGET.$LIBWBCLIENT_FULLVER
	if test $BLDSHARED = true -a x"$HAVE_WINBIND" = x"yes" -a x"$BUILD_LIBWBCLIENT_SHARED" = x"yes"; then
		NSS_MODULES="${WINBIND_NSS} ${WINBIND_WINS_NSS}"
		## Only worry about libwbclient if we have shared
		# library support
		LIBWBCLIENT_SHARED=$LIBWBCLIENT_SHARED_TARGET
		LIBWBCLIENT=libwbclient
		INSTALL_LIBWBCLIENT=installlibwbclient
		UNINSTALL_LIBWBCLIENT=uninstalllibwbclient
		LIBWBCLIENT_LIBS="-lwbclient"
	else
		LIBWBCLIENT_STATIC=$LIBWBCLIENT_STATIC_TARGET
		LIBWBCLIENT_LIBS=$LIBWBCLIENT_STATIC_TARGET
	fi
fi

if test x"$HAVE_WINBIND" = x"yes"; then
        AC_MSG_RESULT(yes)
	AC_DEFINE(WITH_WINBIND,1,[Whether to build winbind])

	EXTRA_BIN_PROGS="$EXTRA_BIN_PROGS bin/wbinfo\$(EXEEXT)"
	EXTRA_SBIN_PROGS="$EXTRA_SBIN_PROGS bin/winbindd\$(EXEEXT)"
        if test $BLDSHARED = true -a x"$create_pam_modules" = x"yes"; then
		PAM_MODULES="$PAM_MODULES pam_winbind"
		INSTALL_PAM_MODULES="installpammodules"
		UNINSTALL_PAM_MODULES="uninstallpammodules"
	fi

	# we use winbind, check for krb5 locate_plugin support:
	AC_CHECK_HEADERS([krb5/locate_plugin.h], [], [],
		[[#ifdef HAVE_KRB5_H
		 #include <krb5.h>
		 #endif
	]])
	if test x"$ac_cv_header_krb5_locate_plugin_h" = x"yes"; then
		WINBIND_KRB5_LOCATOR="bin/winbind_krb5_locator.$SHLIBEXT"
		if test x"$BLDSHARED" = x"true" ; then
			EXTRA_ALL_TARGETS="$EXTRA_ALL_TARGETS $WINBIND_KRB5_LOCATOR"
		fi
	fi
	# end of krb5 locate_plugin check
else
        AC_MSG_RESULT(no$winbind_no_reason)
fi

AC_SUBST(WINBIND_NSS)
AC_SUBST(WINBIND_WINS_NSS)
AC_SUBST(WINBIND_NSS_LDSHFLAGS)
AC_SUBST(WINBIND_NSS_EXTRA_OBJS)
AC_SUBST(NSSSONAMEVERSIONSUFFIX)

AC_SUBST(WINBIND_KRB5_LOCATOR)

# Solaris 10 does have new member in nss_XbyY_key
AC_CHECK_MEMBER(union nss_XbyY_key.ipnode.af_family,
		AC_DEFINE(HAVE_NSS_XBYY_KEY_IPNODE, 1, [Defined if union nss_XbyY_key has ipnode field]),,
		[#include <nss_dbdefs.h>])

# Solaris has some extra fields in struct passwd that need to be
# initialised otherwise nscd crashes.

AC_CHECK_MEMBER(struct passwd.pw_comment,
		AC_DEFINE(HAVE_PASSWD_PW_COMMENT, 1, [Defined if struct passwd has pw_comment field]),,
		[#include <pwd.h>])

AC_CHECK_MEMBER(struct passwd.pw_age,
		AC_DEFINE(HAVE_PASSWD_PW_AGE, 1, [Defined if struct passwd has pw_age field]),,
		[#include <pwd.h>])

# AIX 4.3.x and 5.1 do not have as many members in
# struct secmethod_table as AIX 5.2
AC_CHECK_MEMBERS([struct secmethod_table.method_attrlist], , ,
       [#include <usersec.h>])
AC_CHECK_MEMBERS([struct secmethod_table.method_version], , ,
       [#include <usersec.h>])

AC_CACHE_CHECK([for SO_PEERCRED],samba_cv_HAVE_PEERCRED,[
AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/socket.h>],
[struct ucred cred;
 socklen_t cred_len;
 int ret = getsockopt(0, SOL_SOCKET, SO_PEERCRED, &cred, &cred_len);
],
samba_cv_HAVE_PEERCRED=yes,samba_cv_HAVE_PEERCRED=no,samba_cv_HAVE_PEERCRED=cross)])
if test x"$samba_cv_HAVE_PEERCRED" = x"yes"; then
    AC_DEFINE(HAVE_PEERCRED,1,[Whether we can use SO_PEERCRED to get socket credentials])
fi

AC_CACHE_CHECK([for getpeereid],samba_cv_HAVE_GETPEEREID,[
AC_TRY_LINK([#include <sys/types.h>
#include <unistd.h>],
[uid_t uid; gid_t gid; int ret;
 ret = getpeereid(0, &uid, &gid);
],
samba_cv_HAVE_GETPEEREID=yes,samba_cv_HAVE_GETPEEREID=no)])
if test x"$samba_cv_HAVE_GETPEEREID" = xyes; then
   AC_DEFINE(HAVE_GETPEEREID,1,
	     [Whether we have getpeereid to get socket credentials])
fi


#################################################
# Check to see if we should use the included popt

AC_ARG_WITH(included-popt,
[AS_HELP_STRING([--with-included-popt], [use bundled popt library, not from system])],
[
  case "$withval" in
	yes)
		INCLUDED_POPT=yes
		;;
        no)
		INCLUDED_POPT=no
                ;;
  esac ],
)
if test x"$INCLUDED_POPT" != x"yes"; then
    AC_CHECK_LIB(popt, poptGetContext,
	         INCLUDED_POPT=no, INCLUDED_POPT=yes)
fi

AC_MSG_CHECKING(whether to use included popt)
if test x"$INCLUDED_POPT" = x"yes"; then
    AC_MSG_RESULT(yes)
    BUILD_POPT='$(POPT_OBJ)'
    POPTLIBS='$(POPT_OBJ)'
    FLAGS1="-I\$(srcdir)/../lib/popt"
else
    AC_MSG_RESULT(no)
	BUILD_POPT=""
    POPTLIBS="-lpopt"
fi
AC_SUBST(BUILD_POPT)
AC_SUBST(POPTLIBS)
AC_SUBST(FLAGS1)

#################################################
# Check if user wants DNS service discovery support

AC_ARG_ENABLE(dnssd,
[AS_HELP_STRING([--enable-dnssd], [Enable DNS service discovery support (default=no)])])

AC_SUBST(DNSSD_LIBS)
if test x"$enable_dnssd" = x"yes"; then
    have_dnssd_support=yes

    AC_CHECK_HEADERS(dns_sd.h)
    if test x"$ac_cv_header_dns_sd_h" != x"yes"; then
	have_dnssd_support=no
    fi

    # On Darwin the DNSSD API is in libc, but on other platforms it's
    # probably in -ldns_sd
    AC_CHECK_FUNCS(DNSServiceRegister)
    AC_CHECK_LIB_EXT(dns_sd, DNSSD_LIBS, DNSServiceRegister)
    if test x"$ac_cv_func_DNSServiceRegister" != x"yes" -a \
            x"$ac_cv_lib_ext_dns_sd_DNSServiceRegister" != x"yes"; then
	have_dnssd_support=no
    fi

    if test x"$have_dnssd_support" = x"yes"; then
	AC_DEFINE(WITH_DNSSD_SUPPORT, 1,
		[Whether to enable DNS service discovery support])
    else
    	if test x"$enable_dnssd" = x"yes"; then
	    AC_MSG_ERROR(DNS service discovery support not available)
	fi
    fi

fi

#################################################
# Check if user wants avahi support

AC_ARG_ENABLE(avahi,
[AS_HELP_STRING([--enable-avahi], [Enable Avahi support (default=auto)])])

if test x"$enable_avahi" != x"no"; then
    have_avahi_support=yes

    AC_CHECK_HEADERS(avahi-common/watch.h)
    if test x"$ac_cv_header_avahi_common_watch_h" != x"yes"; then
	have_avahi_support=no
    fi

    AC_CHECK_HEADERS(avahi-client/client.h)
    if test x"$ac_cv_header_avahi_common_watch_h" != x"yes"; then
	have_avahi_support=no
    fi

    save_LIBS="$LIBS"
    AC_CHECK_LIB(avahi-client, avahi_client_new,[have_avahi_client_new=yes])
    AC_CHECK_LIB(avahi-common, avahi_strerror,[have_avahi_strerror=yes])
    LIBS="$save_LIBS"

    if test x"$have_avahi_client_new" != x"yes" -o \
       x"$have_avahi_strerror" != x"yes" ; then
	have_avahi_support=no
    fi

    if test x"$have_avahi_support" = x"yes"; then
        AC_SUBST(AVAHI_LIBS, "-lavahi-client -lavahi-common")
	AC_DEFINE(WITH_AVAHI_SUPPORT, 1,
		[Whether to enable avahi support])
	AC_SUBST(AVAHI_OBJ, "lib/avahi.o smbd/avahi_register.o")
    else
	if test x"$enable_avahi" = x"yes"; then
	    AC_MSG_ERROR(avahi support not available)
	fi
    fi
fi


#################################################
# Set pthread stuff

PTHREAD_CFLAGS=error
PTHREAD_LDFLAGS=error

# If it's error, then the user didn't 
# define it.
if test "x$PTHREAD_LDFLAGS" = xerror; then
  AC_CHECK_LIB(pthread, pthread_attr_init, [
	     PTHREAD_CFLAGS="-D_REENTRANT -D_POSIX_PTHREAD_SEMANTICS"
	     PTHREAD_LDFLAGS="-lpthread" ])
fi

if test "x$PTHREAD_LDFLAGS" = xerror; then
  AC_CHECK_LIB(pthreads, pthread_attr_init, [
	     PTHREAD_CFLAGS="-D_THREAD_SAFE"
	     PTHREAD_LDFLAGS="-lpthreads" ])
fi

if test "x$PTHREAD_LDFLAGS" = xerror; then
   AC_CHECK_LIB(c_r, pthread_attr_init, [
		PTHREAD_CFLAGS="-D_THREAD_SAFE -pthread"
		PTHREAD_LDFLAGS="-pthread" ])
fi

if test "x$PTHREAD_LDFLAGS" = xerror; then
   AC_CHECK_FUNC(pthread_attr_init, [
		 PTHREAD_CFLAGS="-D_REENTRANT"
		 PTHREAD_LDFLAGS="-lpthread" ])
fi

# especially for HP-UX, where the AC_CHECK_FUNC macro fails to test for
# pthread_attr_init. On pthread_mutex_lock it works there...
if test "x$PTHREAD_LDFLAGS" = xerror; then
   AC_CHECK_LIB(pthread, pthread_mutex_lock, [
		PTHREAD_CFLAGS="-D_REENTRANT"
		PTHREAD_LDFLAGS="-lpthread" ])
fi

AC_SUBST(PTHREAD_CFLAGS)
AC_SUBST(PTHREAD_LDFLAGS)

samba_cv_HAVE_PTHREAD=no
if test x"$PTHREAD_CFLAGS" != xerror -a x"$PTHREAD_LDFLAGS" != xerror; then
	samba_cv_HAVE_PTHREAD=yes
	# now check for pthread.h with pthread-correct CFLAGS and LDFLAGS:
	ac_save_CFLAGS=$CFLAGS
	CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
	ac_save_LDFLAGS=$LDFLAGS
	LDFLAGS="$LDFLAGS $PTHREAD_LDFLAGS"
	AC_CHECK_HEADERS(pthread.h)
	CFLAGS=$ac_save_CFLAGS
	LDFLAGS=$ac_save_LDFLAGS
	AC_DEFINE(HAVE_PTHREAD, 1, [Do we have pthreads around?])
fi

#################################################
# Check if user wants pthreadpool support

AC_ARG_ENABLE(pthreadpool,
[AS_HELP_STRING([--enable-pthreadpool], [Enable pthreads pool helper support (default=no)])])

if test x"$enable_pthreadpool" = xyes -a x"$samba_cv_HAVE_PTHREAD" != x"yes"; then
	AC_MSG_ERROR([pthreadpool support cannot be enabled when pthread support was not found])
fi

if test x"$enable_pthreadpool" = x"yes" -a x"$samba_cv_HAVE_PTHREAD" = x"yes"; then
    LIBS="$LIBS $PTHREAD_LDFLAGS"
    CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
    AC_DEFINE(WITH_PTHREADPOOL, 1, [Whether to include pthreadpool helpers])
    AC_SUBST(PTHREADPOOL_OBJ, "lib/pthreadpool/pthreadpool.o")
    PTHREADPOOLTEST="bin/pthreadpooltest\$(EXEEXT)"
    AC_SUBST(PTHREADPOOLTEST)
    if test x"$samba_cv_HAVE_AIO" = x"yes"; then
        default_shared_modules="$default_shared_modules vfs_aio_pthread"
    fi
fi

#################################################
# Check to see if we should use the included iniparser

AC_ARG_WITH(included-iniparser,
[AS_HELP_STRING([--with-included-iniparser], [use bundled iniparser library, not from system])],
[
  case "$withval" in
	yes)
		INCLUDED_INIPARSER=yes
		;;
        no)
		INCLUDED_INIPARSER=no
                ;;
  esac ],
)
if test x"$INCLUDED_INIPARSER" != x"yes"; then
    AC_CHECK_LIB(iniparser, iniparser_load,
	         INCLUDED_INIPARSER=no, INCLUDED_INIPARSER=yes)
fi

AC_MSG_CHECKING(whether to use included iniparser)
if test x"$INCLUDED_INIPARSER" = x"yes"; then
    AC_MSG_RESULT(yes)
    BUILD_INIPARSER='$(INIPARSER_OBJ)'
	INIPARSERLIBS=""
    FLAGS1="$FLAGS1 -I\$(srcdir)/../lib/iniparser/src"
else
    AC_MSG_RESULT(no)
	BUILD_INIPARSER=""
    INIPARSERLIBS="-liniparser"
fi
AC_SUBST(BUILD_INIPARSER)
AC_SUBST(INIPARSERLIBS)
AC_SUBST(FLAGS1)

###################################################
# Check for different/missing (set|get|end)netgrent prototypes
CFLAGS_SAVE=$CFLAGS
if test x"$samba_cv_HAVE_Werror_implicit_function_declaration" = x"yes"; then
	CFLAGS="$CFLAGS -Werror-implicit-function-declaration"
fi
AC_CACHE_CHECK([for setnetgrent prototype],samba_cv_setnetgrent_prototype, [
    AC_TRY_COMPILE([#include<netdb.h>
                    #ifdef HAVE_NETGROUP_H
                    #include<netgroup.h>
                    #endif],[setnetgrent("foo")],
                    samba_cv_setnetgrent_prototype=yes, samba_cv_setnetgrent_prototype=no)])
if test x"$samba_cv_setnetgrent_prototype" = x"yes"; then
    AC_DEFINE(HAVE_SETNETGRENT_PROTOTYPE, 1, [If setnetgrent prototype is defined])
fi
AC_CACHE_CHECK([for getnetgrent prototype],samba_cv_getnetgrent_prototype, [
    AC_TRY_COMPILE([#include<netdb.h>
                    #ifdef HAVE_NETGROUP_H
                    #include<netgroup.h>
                    #endif],[char *dom, *user,*host; getnetgrent(&dom,&user,&host)],
                    samba_cv_getnetgrent_prototype=yes, samba_cv_getnetgrent_prototype=no)])
if test x"$samba_cv_getnetgrent_prototype" = x"yes"; then
    AC_DEFINE(HAVE_GETNETGRENT_PROTOTYPE, 1, [If getnetgrent prototype is defined])
fi
AC_CACHE_CHECK([for endnetgrent prototype],samba_cv_endnetgrent_prototype, [
    AC_TRY_COMPILE([#include<netdb.h>
                    #ifdef HAVE_NETGROUP_H
                    #include<netgroup.h>
                    #endif],[endnetgrent()],
                    samba_cv_endnetgrent_prototype=yes, samba_cv_endnetgrent_prototype=no)])
if test x"$samba_cv_endnetgrent_prototype" = x"yes"; then
    AC_DEFINE(HAVE_ENDNETGRENT_PROTOTYPE, 1, [If endnetgrent prototype is defined])
fi

CFLAGS=$CFLAGS_SAVE

# Checks for the vfs_fileid module
# Start
AC_CHECK_FUNC(getmntent)

AC_CHECK_HEADERS(sys/statfs.h)

AC_MSG_CHECKING([vfs_fileid: checking for statfs() and struct statfs.f_fsid)])
AC_CACHE_VAL(vfsfileid_cv_statfs,[
	     AC_TRY_RUN([
		#include <sys/types.h>
		#include <sys/statfs.h>
		int main(void)
		{
			struct statfs fsd;
			fsid_t fsid = fsd.f_fsid;
			return statfs (".", &fsd);
		}],
		vfsfileid_cv_statfs=yes,
		vfsfileid_cv_statfs=no,
		vfsfileid_cv_statfs=cross)
])
AC_MSG_RESULT($vfsfileid_cv_statfs)

if test x"$ac_cv_func_getmntent" = x"yes" -a \
	x"$vfsfileid_cv_statfs" = x"yes"; then
	default_shared_modules="$default_shared_modules vfs_fileid"
fi
# End
# Checks for the vfs_fileid module


for i in `echo $default_static_modules | sed -e 's/,/ /g'`
do
	eval MODULE_DEFAULT_$i=STATIC
done

for i in `echo $default_shared_modules | sed -e 's/,/ /g'`
do
	dnl Fall back to static if we cannot build shared libraries
	eval MODULE_DEFAULT_$i=STATIC

	if test $BLDSHARED = true; then
		eval MODULE_DEFAULT_$i=SHARED
	fi
done

dnl Always build these modules static
MODULE_rpc_spoolss=STATIC
MODULE_rpc_srvsvc=STATIC
MODULE_idmap_tdb=STATIC
MODULE_idmap_passdb=STATIC
MODULE_idmap_nss=STATIC

MODULE_nss_info_template=STATIC

AC_ARG_WITH(static-modules,
[AS_HELP_STRING([--with-static-modules=MODULES], [Comma-separated list of names of modules to statically link in])],
[ if test $withval; then
	for i in `echo $withval | sed -e 's/,/ /g'`
	do
		eval MODULE_$i=STATIC
	done
fi ])

AC_ARG_WITH(shared-modules,
[AS_HELP_STRING([--with-shared-modules=MODULES], [Comma-separated list of names of modules to build shared])],
[ if test $withval; then
	for i in `echo $withval | sed -e 's/,/ /g'`
	do
			eval MODULE_$i=SHARED
	done
fi ])

if test x"$MODULE_DEFAULT_vfs_notify_fam" = xSTATIC -o \
		x"$MODULE_vfs_notify_fam" = xSTATIC ; then
	SMBD_FAM_LIBS="$SMB_FAM_LIBS"
	AC_SUBST(SMBD_FAM_LIBS)
fi

SMB_MODULE(pdb_ldap, passdb/pdb_ldap.o passdb/pdb_nds.o passdb/pdb_ipa.o,
		   "bin/ldapsam.$SHLIBEXT", PDB,
		   [ PASSDB_LIBS="$PASSDB_LIBS $LDAP_LIBS" ] )
SMB_MODULE(pdb_ads, passdb/pdb_ads.o \$(TLDAP_OBJ), "bin/ads.$SHLIBEXT", PDB)
SMB_MODULE(pdb_smbpasswd, passdb/pdb_smbpasswd.o, "bin/smbpasswd.$SHLIBEXT", PDB)
SMB_MODULE(pdb_tdbsam, passdb/pdb_tdb.o, "bin/tdbsam.$SHLIBEXT", PDB)
SMB_MODULE(pdb_wbc_sam, passdb/pdb_wbc_sam.o, "bin/wbc_sam.$SHLIBEXT", PDB)
SMB_SUBSYSTEM(PDB,passdb/pdb_interface.o)

SMB_MODULE(idmap_ldap, winbindd/idmap_ldap.o, "bin/ldap.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_tdb, winbindd/idmap_tdb.o, "bin/tdb.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_tdb2, winbindd/idmap_tdb2.o, "bin/tdb2.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_passdb, winbindd/idmap_passdb.o, "bin/passdb.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_nss, winbindd/idmap_nss.o, "bin/nss.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_rid, winbindd/idmap_rid.o, "bin/rid.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_autorid, winbindd/idmap_autorid.o, "bin/autorid.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_ad, winbindd/idmap_ad.o, "bin/ad.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_hash, \$(IDMAP_HASH_OBJ), "bin/hash.$SHLIBEXT", IDMAP)
SMB_MODULE(idmap_adex, \$(IDMAP_ADEX_OBJ), "bin/adex.$SHLIBEXT", IDMAP)
SMB_SUBSYSTEM(IDMAP, winbindd/idmap.o)

SMB_MODULE(nss_info_template, winbindd/nss_info_template.o, "bin/template.$SHLIBEXT", NSS_INFO)
SMB_SUBSYSTEM(NSS_INFO, winbindd/nss_info.o)

SMB_MODULE(charset_weird, modules/weird.o, "bin/weird.$SHLIBEXT", CHARSET)
SMB_MODULE(charset_CP850, modules/CP850.o, "bin/CP850.$SHLIBEXT", CHARSET)
SMB_MODULE(charset_CP437, modules/CP437.o, "bin/CP437.$SHLIBEXT", CHARSET)
SMB_MODULE(charset_macosxfs, modules/charset_macosxfs.o,"bin/macosxfs.$SHLIBEXT", CHARSET)
SMB_SUBSYSTEM(CHARSET,lib/iconv.o)

SMB_MODULE(auth_sam, \$(AUTH_SAM_OBJ), "bin/sam.$SHLIBEXT", AUTH)
SMB_MODULE(auth_unix, \$(AUTH_UNIX_OBJ), "bin/unix.$SHLIBEXT", AUTH)
SMB_MODULE(auth_winbind, \$(AUTH_WINBIND_OBJ), "bin/winbind.$SHLIBEXT", AUTH)
SMB_MODULE(auth_wbc, \$(AUTH_WBC_OBJ), "bin/wbc.$SHLIBEXT", AUTH)
SMB_MODULE(auth_server, \$(AUTH_SERVER_OBJ), "bin/smbserver.$SHLIBEXT", AUTH)
SMB_MODULE(auth_domain, \$(AUTH_DOMAIN_OBJ), "bin/domain.$SHLIBEXT", AUTH)
SMB_MODULE(auth_builtin, \$(AUTH_BUILTIN_OBJ), "bin/builtin.$SHLIBEXT", AUTH)
SMB_MODULE(auth_script, \$(AUTH_SCRIPT_OBJ), "bin/script.$SHLIBEXT", AUTH)
SMB_MODULE(auth_netlogond, \$(AUTH_NETLOGOND_OBJ), "bin/netlogond.$SHLIBEXT", AUTH)
SMB_SUBSYSTEM(AUTH,auth/auth.o)

SMB_MODULE(vfs_default, \$(VFS_DEFAULT_OBJ), "bin/default.$SHLIBEXT", VFS)
SMB_MODULE(vfs_recycle, \$(VFS_RECYCLE_OBJ), "bin/recycle.$SHLIBEXT", VFS)
SMB_MODULE(vfs_audit, \$(VFS_AUDIT_OBJ), "bin/audit.$SHLIBEXT", VFS)
SMB_MODULE(vfs_extd_audit, \$(VFS_EXTD_AUDIT_OBJ), "bin/extd_audit.$SHLIBEXT", VFS)
SMB_MODULE(vfs_full_audit, \$(VFS_FULL_AUDIT_OBJ), "bin/full_audit.$SHLIBEXT", VFS)
SMB_MODULE(vfs_netatalk, \$(VFS_NETATALK_OBJ), "bin/netatalk.$SHLIBEXT", VFS)
SMB_MODULE(vfs_fake_perms, \$(VFS_FAKE_PERMS_OBJ), "bin/fake_perms.$SHLIBEXT", VFS)
SMB_MODULE(vfs_default_quota, \$(VFS_DEFAULT_QUOTA_OBJ), "bin/default_quota.$SHLIBEXT", VFS)
SMB_MODULE(vfs_readonly, \$(VFS_READONLY_OBJ), "bin/readonly.$SHLIBEXT", VFS)
SMB_MODULE(vfs_cap, \$(VFS_CAP_OBJ), "bin/cap.$SHLIBEXT", VFS)
SMB_MODULE(vfs_expand_msdfs, \$(VFS_EXPAND_MSDFS_OBJ), "bin/expand_msdfs.$SHLIBEXT", VFS)
SMB_MODULE(vfs_shadow_copy, \$(VFS_SHADOW_COPY_OBJ), "bin/shadow_copy.$SHLIBEXT", VFS)
SMB_MODULE(vfs_shadow_copy2, \$(VFS_SHADOW_COPY2_OBJ), "bin/shadow_copy2.$SHLIBEXT", VFS)
SMB_MODULE(vfs_afsacl, \$(VFS_AFSACL_OBJ), "bin/afsacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_xattr_tdb, \$(VFS_XATTR_TDB_OBJ), "bin/xattr_tdb.$SHLIBEXT", VFS)
SMB_MODULE(vfs_posixacl, \$(VFS_POSIXACL_OBJ), "bin/posixacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_aixacl, \$(VFS_AIXACL_OBJ), "bin/aixacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_aixacl2, \$(VFS_AIXACL2_OBJ), "bin/aixacl2.$SHLIBEXT", VFS)
SMB_MODULE(vfs_solarisacl, \$(VFS_SOLARISACL_OBJ), "bin/solarisacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_irixacl, \$(VFS_IRIXACL_OBJ), "bin/irixacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_hpuxacl, \$(VFS_HPUXACL_OBJ), "bin/hpuxacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_tru64acl, \$(VFS_TRU64ACL_OBJ), "bin/tru64acl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_catia, \$(VFS_CATIA_OBJ), "bin/catia.$SHLIBEXT", VFS)
SMB_MODULE(vfs_streams_xattr, \$(VFS_STREAMS_XATTR_OBJ), "bin/streams_xattr.$SHLIBEXT", VFS)
SMB_MODULE(vfs_streams_depot, \$(VFS_STREAMS_DEPOT_OBJ), "bin/streams_depot.$SHLIBEXT", VFS)
SMB_MODULE(vfs_cacheprime, \$(VFS_CACHEPRIME_OBJ), "bin/cacheprime.$SHLIBEXT", VFS)
SMB_MODULE(vfs_prealloc, \$(VFS_PREALLOC_OBJ), "bin/prealloc.$SHLIBEXT", VFS)
SMB_MODULE(vfs_commit, \$(VFS_COMMIT_OBJ), "bin/commit.$SHLIBEXT", VFS)
SMB_MODULE(vfs_gpfs, \$(VFS_GPFS_OBJ), "bin/gpfs.$SHLIBEXT", VFS)
SMB_MODULE(vfs_gpfs_hsm_notify, \$(VFS_GPFS_PREFETCH_OBJ), "bin/gpfs_hsm_notify.$SHLIBEXT", VFS)
SMB_MODULE(vfs_readahead, \$(VFS_READAHEAD_OBJ), "bin/readahead.$SHLIBEXT", VFS)
SMB_MODULE(vfs_tsmsm, \$(VFS_TSMSM_OBJ), "bin/tsmsm.$SHLIBEXT", VFS)
SMB_MODULE(vfs_fileid, \$(VFS_FILEID_OBJ), "bin/fileid.$SHLIBEXT", VFS)
SMB_MODULE(vfs_aio_fork, \$(VFS_AIO_FORK_OBJ), "bin/aio_fork.$SHLIBEXT", VFS)
SMB_MODULE(vfs_aio_pthread, \$(VFS_AIO_PTHREAD_OBJ), "bin/aio_pthread.$SHLIBEXT", VFS)
SMB_MODULE(vfs_preopen, \$(VFS_PREOPEN_OBJ), "bin/preopen.$SHLIBEXT", VFS)
SMB_MODULE(vfs_syncops, \$(VFS_SYNCOPS_OBJ), "bin/syncops.$SHLIBEXT", VFS)
SMB_MODULE(vfs_zfsacl, \$(VFS_ZFSACL_OBJ), "bin/zfsacl.$SHLIBEXT", VFS)
SMB_MODULE(vfs_notify_fam, \$(VFS_NOTIFY_FAM_OBJ), "bin/notify_fam.$SHLIBEXT", VFS)
SMB_MODULE(vfs_acl_xattr, \$(VFS_ACL_XATTR_OBJ), "bin/acl_xattr.$SHLIBEXT", VFS)
SMB_MODULE(vfs_acl_tdb, \$(VFS_ACL_TDB_OBJ), "bin/acl_tdb.$SHLIBEXT", VFS)
SMB_MODULE(vfs_smb_traffic_analyzer, \$(VFS_SMB_TRAFFIC_ANALYZER_OBJ), "bin/smb_traffic_analyzer.$SHLIBEXT", VFS)
SMB_MODULE(vfs_onefs, \$(VFS_ONEFS), "bin/onefs.$SHLIBEXT", VFS)
SMB_MODULE(vfs_onefs_shadow_copy, \$(VFS_ONEFS_SHADOW_COPY), "bin/onefs_shadow_copy.$SHLIBEXT", VFS)
SMB_MODULE(vfs_dirsort, \$(VFS_DIRSORT_OBJ), "bin/dirsort.$SHLIBEXT", VFS)
SMB_MODULE(vfs_scannedonly, \$(VFS_SCANNEDONLY_OBJ), "bin/scannedonly.$SHLIBEXT", VFS)
SMB_MODULE(vfs_crossrename, \$(VFS_CROSSRENAME_OBJ), "bin/crossrename.$SHLIBEXT", VFS)
SMB_MODULE(vfs_linux_xfs_sgid, \$(VFS_LINUX_XFS_SGID_OBJ), "bin/linux_xfs_sgid.$SHLIBEXT", VFS)
SMB_MODULE(vfs_time_audit, \$(VFS_TIME_AUDIT_OBJ), "bin/time_audit.$SHLIBEXT", VFS)

SMB_SUBSYSTEM(VFS,smbd/vfs.o)

SMB_MODULE(perfcount_onefs, \$(PERFCOUNT_ONEFS), "bin/pc_onefs.$SHLIBEXT", PERFCOUNT)
SMB_MODULE(perfcount_test, \$(PERFCOUNT_TEST), "bin/pc_test.$SHLIBEXT", PERFCOUNT)
SMB_SUBSYSTEM(PERFCOUNT,smbd/perfcount.o)

SMB_MODULE(gpext_registry, libgpo/gpext/registry.o, "bin/registry.$SHLIBEXT", GPEXT)
SMB_MODULE(gpext_scripts, libgpo/gpext/scripts.o, "bin/scripts.$SHLIBEXT", GPEXT)
SMB_MODULE(gpext_security, libgpo/gpext/security.o, "bin/security.$SHLIBEXT", GPEXT)
SMB_SUBSYSTEM(GPEXT, libgpo/gpext/gpext.o)

AC_DEFINE_UNQUOTED(STRING_STATIC_MODULES, "$string_static_modules", [String list of builtin modules])

#################################################
# do extra things if we are running insure

if test "${ac_cv_prog_CC}" = "insure"; then
	CPPFLAGS="$CPPFLAGS -D__INSURE__"
fi

#################################################
# If run from the build farm, enable NASTY hacks
#################################################
AC_MSG_CHECKING(whether to enable build farm hacks)
if test x"$RUN_FROM_BUILD_FARM" = x"yes"; then
	AC_MSG_RESULT(yes)
	AC_DEFINE(ENABLE_BUILD_FARM_HACKS, 1, [Defined if running in the build farm])
else
	AC_MSG_RESULT(no)
fi

#################################################
# check for bad librt/libpthread interactions

if test x"$samba_cv_HAVE_KERNEL_OPLOCKS_LINUX" = x"yes" -o \
    x"$samba_cv_HAVE_KERNEL_CHANGE_NOTIFY" = x"yes" -o \
    x"$samba_cv_HAVE_AIO64" = x"yes" -o \
    x"$samba_cv_HAVE_AIO" = x"yes" ; then

SMB_IF_RTSIGNAL_BUG(
	[
	    # Have RT_SIGNAL bug, need to check whether the problem will
	    # affect anything we have configured.

	    rt_do_error=no
	    if test x"$samba_cv_HAVE_KERNEL_OPLOCKS_LINUX" = x"yes"; then
		if test x"$rt_signal_lease_ok" = x"no" ; then
		    rt_do_error=yes
		fi
	    fi

	    if test x"$samba_cv_HAVE_KERNEL_CHANGE_NOTIFY" = x"yes"; then
		if test x"$rt_signal_notify_ok" = x"no" ; then
		    rt_do_error=yes
		fi
	    fi

	    if test x"$samba_cv_HAVE_AIO64" = x"yes" -o \
		    x"$samba_cv_HAVE_AIO" = x"yes" ; then
		if test x"$rt_signal_aio_ok" = x"no" ; then
		    rt_do_error=yes
		fi
	    fi

	    if test x"$rt_do_error" = x"yes" ; then
		SMB_IS_LIBPTHREAD_LINKED(
		    [
			cat<<MSG

*** On this platforms, linking Samba against pthreads causes problems
*** with the oplock and change notification mechanisms. You may be
*** using pthreads as a side-effect of using the --with-aio-support
*** or --with-profiling-data options. Please remove these and try again.

MSG
		    ],
		    [
			cat<<MSG

*** On this platform, the oplock and change notification mechanisms do not
*** appear to work. Please report this problem to samba-technical@samba.org
*** and attach the config.log file from this directory.

MSG
		    ])
		AC_MSG_ERROR(unable to use realtime signals on this platform)
	    fi
	],
	[
	    # no RT_SIGNAL bug, we are golden
	    SMB_IS_LIBPTHREAD_LINKED(
		[
		    AC_MSG_WARN(using libpthreads - this may degrade performance)
		])

	],
	[
	    # cross compiling, I hope you know what you are doing
	    true
	])

fi

m4_include(../lib/zlib/zlib.m4)

if test x$smbtorture4_possible = xyes; then
	saved_USESHARED="$USESHARED"
	USESHARED="false"
	smbtorture4_path="bin/smbtorture4"
	smbtorture4_option="-t bin/smbtorture4"
	AC_SUBST(smbtorture4_path)
	AC_SUBST(smbtorture4_option)
	USESHARED="$saved_USESHARED"
	SMBTORTURE4="bin/smbtorture4"
	AC_SUBST(SMBTORTURE4)
fi

AC_SUBST(ZLIB_LIBS)
AC_SUBST(ZLIB_OBJS)
AC_ZLIB([ZLIB_OBJS=""], [
	ZLIB_LIBS=""
	for o in adler32.o compress.o crc32.o gzio.o uncompr.o \
		     deflate.o trees.o zutil.o inflate.o infback.o \
			 inftrees.o inffast.o
	do
		ZLIB_OBJS="$ZLIB_OBJS ../lib/zlib/$o"
	done
	CFLAGS="-I../lib/zlib $CFLAGS"
])

AC_ARG_ENABLE(dmalloc, [AS_HELP_STRING([--enable-dmalloc], [Enable heap debugging [default=no]])])

if test "x$enable_dmalloc" = xyes
then
	AC_DEFINE(ENABLE_DMALLOC, 1, [Define to turn on dmalloc debugging])
	AC_DEFINE(DMALLOC_FUNC_CHECK, 1,
                  [Define to check invariants around some common functions])
	LIBS="$LIBS -ldmalloc"
fi

dnl Remove -L/usr/lib/? from LDFLAGS and LIBS
LIB_REMOVE_USR_LIB(LDFLAGS)
LIB_REMOVE_USR_LIB(LIBS)

dnl Remove -I/usr/include/? from CFLAGS and CPPFLAGS
CFLAGS_REMOVE_USR_INCLUDE(CFLAGS)
CFLAGS_REMOVE_USR_INCLUDE(CPPFLAGS)

#################################################
# Display summary of libraries detected

AC_MSG_RESULT([Using libraries:])
AC_MSG_RESULT([    LIBS = $LIBS])
if test x"$with_ads_support" != x"no"; then
    AC_MSG_RESULT([    KRB5_LIBS = $KRB5_LIBS])
fi
if test x"$with_ldap_support" != x"no"; then
    AC_MSG_RESULT([    LDAP_LIBS = $LDAP_LIBS])
fi
if test x"$with_dnsupdate_support" != x"no"; then
    AC_MSG_RESULT([    UUID_LIBS = $UUID_LIBS])
fi
if test x"$have_dnssd_support" != x"no"; then
    AC_MSG_RESULT([    DNSSD_LIBS = $DNSSD_LIBS])
fi
AC_MSG_RESULT([    AUTH_LIBS = $AUTH_LIBS])

#################################################
# final configure stuff

AC_MSG_CHECKING([configure summary])
AC_TRY_RUN([#include "${srcdir-.}/../tests/summary.c"],
           AC_MSG_RESULT(yes),
	   AC_MSG_ERROR([summary failure. Aborting config]); exit 1;,
	   AC_MSG_WARN([cannot run when cross-compiling]))

dnl Merge in developer cflags from now on
AC_SUBST(DEVELOPER_CFLAGS)
if test x"$krb5_developer" = x"yes" -o x"$developer" = x"yes" -o x"$picky_developer" = x"yes"; then
    CFLAGS="${CFLAGS} \$(DEVELOPER_CFLAGS)"
fi

# Stuff the smbd-only libraries at the end of the smbd link
# path (if we have them).
SMBD_LIBS="$samba_dmapi_libs"
AC_SUBST(SMBD_LIBS)

CFLAGS="${CFLAGS} \$(FLAGS)"
CFLAGS="${CFLAGS} -D_SAMBA_BUILD_=3"

# If we had to expand the includes, make tsure the output file is moved back
AC_OUTPUT_COMMANDS([
if test -f Makefile-noincludes -a ! -f Makefile -a ! -h Makefile ; then
	ln -s Makefile-noincludes Makefile
fi
])

AC_OUTPUT(Makefile
	  script/findsmb smbadduser script/gen-8bit-gap.sh script/installbin.sh script/uninstallbin.sh
	  lib/netapi/examples/Makefile
	  lib/netapi/tests/Makefile
	  pkgconfig/smbclient.pc
	  pkgconfig/wbclient.pc
	  pkgconfig/netapi.pc
	  pkgconfig/smbsharemodes.pc
	  ../examples/libsmbclient/Makefile.internal
	  )

#################################################
# Print very concise instructions on building/use
if test "x$enable_dmalloc" = xyes
then
	AC_MSG_RESULT([Note: The dmalloc debug library will be included.  To turn it on use])
	AC_MSG_RESULT([      \$ eval \`dmalloc samba\`.])
fi
