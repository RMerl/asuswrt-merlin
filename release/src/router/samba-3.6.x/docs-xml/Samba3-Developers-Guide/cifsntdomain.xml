<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE chapter PUBLIC "-//Samba-Team//DTD DocBook V4.2-Based Variant V1.0//EN" "http://www.samba.org/samba/DTD/samba-doc">
<chapter id="ntdomain">
<chapterinfo>
	<author>
		<firstname>Luke</firstname><surname>Leighton</surname>
		<affiliation><address><email>lkcl@switchboard.net</email></address></affiliation>
	</author>
	<author>
		<firstname>Paul</firstname><surname>Ashton</surname>
		<affiliation><address><email>paul@argo.demon.co.uk</email></address></affiliation>
	</author>
	<author>
		<firstname>Duncan</firstname><surname>Stansfield</surname>
		<affiliation><address><email>duncans@sco.com</email></address></affiliation>
	</author>

	<pubdate>01 November 97(version 0.0.24)</pubdate>
</chapterinfo>

<title>NT Domain RPC's</title>

<sect1>
<title>Introduction</title>


<para>
This document contains information to provide an NT workstation with login
services, without the need for an NT server. It is the sgml version of <ulink url="http://mailhost.cb1.com/~lkcl/cifsntdomain.txt">http://mailhost.cb1.com/~lkcl/cifsntdomain.txt</ulink>, controlled by Luke.
</para>

<para>
It should be possible to select a domain instead of a workgroup (in the NT
workstation's TCP/IP settings) and after the obligatory reboot, type in a
username, password, select a domain and successfully log in.  I would
appreciate any feedback on your experiences with this process, and any
comments, corrections and additions to this document.
</para>

<para>
The packets described here can be easily derived from (and are probably
better understood using) Netmon.exe.  You will need to use the version
of Netmon that matches your system, in order to correctly decode the
NETLOGON, lsarpc and srvsvc Transact pipes.  This document is derived from
NT Service Pack 1 and its corresponding version of Netmon.  It is intended
that an annotated packet trace be produced, which will likely be more
instructive than this document.
</para>

<para>
Also needed, to fully implement NT Domain Login Services, is the 
document describing the cryptographic part of the NT authentication.
This document is available from comp.protocols.smb; from the ntsecurity.net
digest and from the samba digest, amongst other sources.
</para>

<para>
A copy is available from:
</para>

<para><ulink url="http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935">http://ntbugtraq.rc.on.ca/SCRIPTS/WA.EXE?A2=ind9708;L=ntbugtraq;O=A;P=2935</ulink></para>

<para><ulink url="http://mailhost.cb1.com/~lkcl/crypt.html">http://mailhost.cb1.com/~lkcl/crypt.html</ulink></para>

<para>
A c-code implementation, provided by <ulink url="mailto:linus@incolumitas.se">Linus Nordberg</ulink>
of this protocol is available from:
</para>

<para><ulink url="http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html">http://samba.org/cgi-bin/mfs/01/digest/1997/97aug/0391.html</ulink></para>
<para><ulink url="http://mailhost.cb1.com/~lkcl/crypt.txt">http://mailhost.cb1.com/~lkcl/crypt.txt</ulink></para>

<para>
Also used to provide debugging information is the Check Build version of
NT workstation, and enabling full debugging in NETLOGON.  This is
achieved by setting the following REG_SZ registry key to 0x1ffffff:
</para>

<para><filename>HKLM\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters</filename></para>

<para><emphasis>Incorrect direct editing of the registry can cause your
machine to fail. Then again, so can incorrect implementation of this 
protocol. See "Liability:" above.</emphasis></para>

<para>
Bear in mind that each packet over-the-wire will have its origin in an
API call.  Therefore, there are likely to be structures, enumerations
and defines that are usefully documented elsewhere.
</para>

<para>
This document is by no means complete or authoritative.  Missing sections
include, but are not limited to:
</para>


<orderedlist>

<listitem><para>Mappings of RIDs to usernames (and vice-versa).</para></listitem>

<listitem><para>What a User ID is and what a Group ID is.</para></listitem>

<listitem><para>The exact meaning/definition of various magic constants or enumerations.</para></listitem>

<listitem><para>The reply error code and use of that error code when a
workstation becomes a member of a domain (to be described later).  
Failure to return this error code will make the workstation report 
that it is already a member of the domain.</para></listitem>

<listitem><para>the cryptographic side of the NetrServerPasswordSet command, 
which would allow the workstation to change its password.  This password is
used to generate the long-term session key.  [It is possible to reject this
command, and keep the default workstation password].</para></listitem>

</orderedlist>

<sect2>
<title>Sources</title>

<simplelist>
<member>cket Traces from Netmonitor (Service Pack 1 and above)</member>
<member>ul Ashton and Luke Leighton's other "NT Domain" doc.</member>
<member>FS documentation - cifs6.txt</member>
<member>FS documentation - cifsrap2.txt</member>
</simplelist>

</sect2>

<sect2>
<title>Credits</title>

<simplelist> 
<member>Paul Ashton: loads of work with Net Monitor; understanding the NT authentication system; reference implementation of the NT domain support on which this document is originally based.</member>
<member>Duncan Stansfield: low-level analysis of MSRPC Pipes.</member>
<member>Linus Nordberg: producing c-code from Paul's crypto spec.</member>
<member>Windows Sourcer development team</member>
</simplelist>

</sect2>

</sect1>

<sect1>
<title>Notes and Structures</title>

<sect2>
<title>Notes</title>

<orderedlist>
<listitem><para>
In the SMB Transact pipes, some "Structures", described here, appear to be
4-byte aligned with the SMB header, at their start.  Exactly which
"Structures" need aligning is not precisely known or documented.
</para></listitem>

<listitem><para>
In the UDP NTLOGON Mailslots, some "Structures", described here, appear to be
2-byte aligned with the start of the mailslot, at their start.
</para></listitem>

<listitem><para>
Domain SID is of the format S-revision-version-auth1-auth2...authN.
e.g S-1-5-123-456-789-123-456.  the 5 could be a sub-revision.
</para></listitem>

<listitem><para>
any undocumented buffer pointers must be non-zero if the string buffer it
refers to contains characters.  exactly what value they should be is unknown.
0x0000 0002 seems to do the trick to indicate that the buffer exists.  a
NULL buffer pointer indicates that the string buffer is of zero length.
If the buffer pointer is NULL, then it is suspected that the structure it
refers to is NOT put into (or taken out of) the SMB data stream.  This is
empirically derived from, for example, the LSA SAM Logon response packet,
where if the buffer pointer is NULL, the user information is not inserted
into the data stream.  Exactly what happens with an array of buffer pointers
is not known, although an educated guess can be made.
</para></listitem>

<listitem><para>
an array of structures (a container) appears to have a count and a pointer.
if the count is zero, the pointer is also zero.  no further data is put
into or taken out of the SMB data stream.  if the count is non-zero, then
the pointer is also non-zero.  immediately following the pointer is the
count again, followed by an array of container sub-structures.  the count
appears a third time after the last sub-structure.
</para></listitem>
</orderedlist>

</sect2>

<sect2>
<title>Enumerations</title>

<sect3>
<title>MSRPC Header type</title>
<para>command number in the msrpc packet header</para>

<variablelist>
<varlistentry>
	<term>MSRPC_Request:</term>
	<listitem><para>0x00</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_Response:</term>
	<listitem><para>0x02</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_Bind:</term>
	<listitem><para>0x0B</para></listitem>
</varlistentry>
<varlistentry>
	<term>MSRPC_BindAck:</term>
	<listitem><para>0x0C</para></listitem>
</varlistentry>
</variablelist>
</sect3>

<sect3>
<title>MSRPC Packet info</title>

<para>The meaning of these flags is undocumented</para>

<variablelist>
<varlistentry>
	<term>FirstFrag:</term>
	<listitem><para>0x01 </para></listitem>
</varlistentry>
<varlistentry>
	<term>LastFrag:</term>
	<listitem><para>0x02 </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotaFrag:</term>
	<listitem><para>0x04  </para></listitem>
</varlistentry>
<varlistentry>
	<term>RecRespond:</term>
	<listitem><para>0x08  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NoMultiplex:</term>
	<listitem><para>0x10  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotForIdemp:</term>
	<listitem><para>0x20  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NotforBcast:</term>
	<listitem><para>0x40  </para></listitem>
</varlistentry>
<varlistentry>
	<term>NoUuid:</term>
	<listitem><para>0x80 </para></listitem>
</varlistentry>
</variablelist>

</sect3>

</sect2>

<sect2>
<title>Structures</title>

<sect3><title>VOID *</title>
<para>sizeof VOID* is 32 bits.</para>
</sect3>

<sect3><title>char</title>
<para>sizeof char is 8 bits.</para>
</sect3>

<sect3><title>UTIME</title>
<para>UTIME is 32 bits, indicating time in seconds since 01jan1970.  documented in cifs6.txt (section 3.5 page, page 30).</para>
</sect3>

<sect3><title>NTTIME</title>
<para>NTTIME is 64 bits.  documented in cifs6.txt (section 3.5 page, page 30).</para>
</sect3>

<sect3>
<title>DOM_SID (domain SID structure)</title>

<variablelist>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>num of sub-authorities in domain SID</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT8</term>
	<listitem><para>SID revision number</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8</term>
	<listitem><para>num of sub-authorities in domain SID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[6]</term>
	<listitem><para>6 bytes for domain SID - Identifier Authority.</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT16[n_subauths]</term>
	<listitem><para>domain SID sub-authorities</para></listitem>
</varlistentry>

</variablelist>

<para><emphasis>Note: the domain SID is documented elsewhere.</emphasis>
</para>

</sect3>

<sect3>
<title>STR (string)</title>

<para>STR (string) is a char[] : a null-terminated string of ascii characters.</para>

</sect3>

<sect3>
<title>UNIHDR (unicode string header) </title>

<variablelist>

<varlistentry>
	<term>UINT16</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT16</term>
	<listitem><para>max length of unicode string</para></listitem>
</varlistentry>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>4 - undocumented.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNIHDR2 (unicode string header plus buffer pointer)</title>

<variablelist>

<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>unicode string header</para></listitem>
</varlistentry>


<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNISTR (unicode string)</title>

<variablelist>

<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>null-terminated string of unicode characters.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>NAME (length-indicated unicode string)</title>

<variablelist>

<varlistentry>
	<term>UINT32</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>null-terminated string of unicode characters.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>UNISTR2 (aligned unicode string)</title>

<variablelist>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with the start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>max length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>length of unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16[]</term>
	<listitem><para>string of uncode characters</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>OBJ_ATTR (object attributes)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>0x18 - length (in bytes) including the length field.</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - root directory (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - object name (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>0 - attributes (undocumented)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>0 - security descriptior (pointer)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - security quality of service</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>POL_HND (LSA policy handle)</title>

<variablelist>
<varlistentry>
	<term>char[20]</term>
	<listitem><para>policy handle</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_SID2 (domain SID structure, SIDS stored in unicode)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - SID type</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2</term>
	<listitem><para>domain SID unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain SID unicode string</para></listitem>
</varlistentry>
</variablelist>

<para><emphasis>Note:	there is a conflict between the unicode string header and the unicode string itself as to which to use to indicate string length.  this will need to be resolved.</emphasis></para>

<para><emphasis>Note:	the SID type indicates, for example, an alias; a well-known group etc. this is documented somewhere.</emphasis></para>

</sect3>

<sect3>
<title>DOM_RID (domain RID structure)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>5 - well-known SID.  1 - user SID (see ShowACLs)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>domain RID </para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - domain index out of above reference domains</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>LOG_INFO (server, account, client structure)</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<para><emphasis>Note:	account name is the logon client name from the LSA Request Challenge, with a $ on the end of it, in upper case.</emphasis></para>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>account name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>sec_chan - security channel type</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client machine unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_SRV (server, client names structure)</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client machine unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CREDS (credentials + time stamp)</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>credentials</para></listitem>
</varlistentry>
<varlistentry>
	<term>UTIME</term>
	<listitem><para>time stamp</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_INFO2 (server, client structure, client credentials)</title>

<para><emphasis>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will beused in subsequent credential checks.  the presumed intention is to
	maintain an authenticated request/response trail.</emphasis></para>

<variablelist>
<varlistentry>
	<term>CLNT_SRV</term>
	<listitem><para>client and server names</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>???? padding, for 4-byte alignment with SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to client credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>client-calculated credentials + client time</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>CLNT_INFO (server, account, client structure, client credentials)</title>
<para><emphasis>Note: whenever this structure appears in a request, you must take a copy of the client-calculated credentials received, because they will be used in subsequent credential checks.  the presumed intention is to maintain an authenticated request/response trail.</emphasis></para>

<variablelist>
<varlistentry>
	<term>LOG_INFO</term>
	<listitem><para>logon account info</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>client-calculated credentials + client time</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>ID_INFO_1 (id info structure, auth level 1)</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>ptr_id_info_1</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>domain name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>param control</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT64</term>
	<listitem><para>logon ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>user name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>workgroup name unicode header</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>arc4 LM OWF Password</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>arc4 NT OWF Password</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>domain name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>user name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>workstation name unicode string</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SAM_INFO (sam logon/logoff id info structure)</title>

<para><emphasis>Note: presumably, the return credentials is supposedly for the server to verify that the credential chain hasn't been compromised.</emphasis></para>

<variablelist>
<varlistentry>
	<term>CLNT_INFO2</term>
	<listitem><para>client identification/authentication info</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to return credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>CRED</term>
	<listitem><para>return credentials - ignored.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>logon level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>

</variablelist>

<para><programlisting>
        switch (switch_value)
        case 1:
        {
            ID_INFO_1     id_info_1;
        }
</programlisting></para>

</sect3>

<sect3>
<title>GID (group id info)</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
<listitem><para>group id</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>user attributes (only used by NT 3.1 and 3.51)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_REF (domain reference info)</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num referenced domains?</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>32 - max number of entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>4 - num referenced domains?</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2</term>
	<listitem><para>domain name unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR2[num_ref_doms-1]</term>
	<listitem><para>referenced domain unicode string headers</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID[num_ref_doms]</term>
	<listitem><para>referenced domain SIDs</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>DOM_INFO (domain info, levels 3 and 5 are the same))</title>

<variablelist>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>??? padding to get 4-byte alignment with start of SMB header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>domain name string length * 2</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>domain name string length * 2</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name string buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented domain SID string buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UNISTR2</term>
<listitem><para>domain name (unicode string)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_SID</term>
	<listitem><para>domain SID</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>USER_INFO (user logon info)</title>

<para><emphasis>Note: it would be nice to know what the 16 byte user session key is for.</emphasis></para>

<variablelist>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>logon time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>logoff time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>kickoff time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password last set time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password can change time</para></listitem>
</varlistentry>
<varlistentry>
	<term>NTTIME</term>
	<listitem><para>password must change time</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>username unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>user's full name unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon script unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>profile path unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>home directory unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>home directory drive unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>logon count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>bad password count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>User ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>Group ID</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num groups</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer to groups.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>user flags</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>user session key</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon server unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNIHDR</term>
	<listitem><para>logon domain unicode string header</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented logon domain id pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[40]</term>
	<listitem><para>40 undocumented padding bytes.  future expansion?</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - num_other_sids?</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>NULL - undocumented pointer to other domain SIDs.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>username unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>user's full name unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon script unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>profile path unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>home directory unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>home directory drive unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num groups</para></listitem>
</varlistentry>
<varlistentry>
	<term>GID[num_groups]</term>
	<listitem><para>group info</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon domain unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID</term>
	<listitem><para>domain SID</para></listitem>
</varlistentry>
<varlistentry>
	<term>DOM_SID[num_sids]</term>
	<listitem><para>other domain SIDs?</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SH_INFO_1_PTR (pointers to level 1 share info strings)</title>

<para><emphasis>Note:	see cifsrap2.txt section5, page 10.</emphasis></para>

<simplelist>
<member>0 for shi1_type indicates a  Disk.</member>
<member>1 for shi1_type indicates a  Print Queue.</member>
<member>2 for shi1_type indicates a  Device.</member>
<member>3 for shi1_type indicates an IPC pipe.</member>
<member>0x8000 0000 (top bit set in shi1_type) indicates a hidden share.</member>
</simplelist>

<variablelist>

<varlistentry>
	<term>VOID*</term>
	<listitem><para>shi1_netname - pointer to net name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>shi1_type    - type of share.  0 - undocumented.</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>shi1_remark  - pointer to comment.</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>SH_INFO_1_STR (level 1 share info strings)</title>

<variablelist>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>shi1_netname - unicode string of net name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>shi1_remark  - unicode string of comment.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>SHARE_INFO_1_CTR</title>

<para>share container with 0 entries:</para>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - Buffer</para></listitem>
</varlistentry>
</variablelist>

<para>share container with > 0 entries:</para>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>non-zero - Buffer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>SH_INFO_1_PTR[EntriesRead]</term>
	<listitem><para>share entry pointers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SH_INFO_1_STR[EntriesRead]</term>
	<listitem><para>share entry strings</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>EntriesRead</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - padding</para></listitem>
</varlistentry>

</variablelist>

</sect3>

<sect3>
<title>SERVER_INFO_101</title>

<para><emphasis>Note:	see cifs6.txt section 6.4 - the fields described therein will be of assistance here.  for example, the type listed below is the 	same as fServerType, which is described in 6.4.1. </emphasis></para>

<variablelist>
<varlistentry>
	<term>SV_TYPE_WORKSTATION</term>
	<listitem><para>0x00000001  All workstations</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SERVER</term>
	<listitem><para>0x00000002  All servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SQLSERVER</term>
	<listitem><para>0x00000004  Any server running with SQL server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_CTRL</term>
	<listitem><para>0x00000008  Primary domain controller</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_BAKCTRL</term>
	<listitem><para>0x00000010  Backup domain controller</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_TIME_SOURCE</term>
	<listitem><para>0x00000020  Server running the timesource service</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_AFP</term>
	<listitem><para>0x00000040  Apple File Protocol servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_NOVELL</term>
	<listitem><para>0x00000080  Novell servers</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_MEMBER</term>
	<listitem><para>0x00000100  Domain Member</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_PRINTQ_SERVER</term>
	<listitem><para>0x00000200  Server sharing print queue</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DIALIN_SERVER</term>
	<listitem><para>0x00000400  Server running dialin service.</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_XENIX_SERVER</term>
	<listitem><para>0x00000800  Xenix server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_NT</term>
	<listitem><para>0x00001000  NT server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_WFW</term>
	<listitem><para>0x00002000  Server running Windows for </para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_SERVER_NT</term>
	<listitem><para>0x00008000  Windows NT non DC server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_POTENTIAL_BROWSER</term>
	<listitem><para>0x00010000  Server that can run the browser service</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_BACKUP_BROWSER</term>
	<listitem><para>0x00020000  Backup browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_MASTER_BROWSER</term>
	<listitem><para>0x00040000  Master browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_MASTER</term>
	<listitem><para>0x00080000  Domain Master Browser server</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_LOCAL_LIST_ONLY</term>
	<listitem><para>0x40000000  Enumerate only entries marked "local"</para></listitem>
</varlistentry>
<varlistentry>
	<term>SV_TYPE_DOMAIN_ENUM</term>
	<listitem><para>0x80000000  Enumerate Domains. The pszServer and pszDomain parameters must be NULL.</para></listitem>
</varlistentry>

</variablelist>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>500 - platform_id</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>5 - major version</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>4 - minor version</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>type (SV_TYPE_... bit field)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to comment</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>sv101_name - unicode string of server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>sv_101_comment  - unicode string of server comment.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with start of the SMB header.</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>
</sect1>

<sect1>
<title>MSRPC over Transact Named Pipe</title>

<para>For details on the SMB Transact Named Pipe, see cifs6.txt</para>

<sect2>
<title>MSRPC Pipes</title>

<para>
The MSRPC is conducted over an SMB Transact Pipe with a name of 
<filename>\PIPE\</filename>.  You must first obtain a 16 bit file handle, by
sending a SMBopenX with the pipe name <filename>\PIPE\srvsvc</filename> for
example.  You can then perform an SMB Trans,
and must carry out an SMBclose on the file handle once you are finished.
</para>

<para>
Trans Requests must be sent with two setup UINT16s, no UINT16 params (none
known about), and UINT8 data parameters sufficient to contain the MSRPC
header, and MSRPC data.  The first UINT16 setup parameter must be either
0x0026 to indicate an RPC, or 0x0001 to indicate Set Named Pipe Handle
state.  The second UINT16 parameter must be the file handle for the pipe,
obtained above.
</para>

<para>
The Data section for an API Command of 0x0026 (RPC pipe) in the Trans
Request is the RPC Header, followed by the RPC Data.  The Data section for
an API Command of 0x0001 (Set Named Pipe Handle state) is two bytes.  The
only value seen for these two bytes is 0x00 0x43.
</para>

<para>
MSRPC Responses are sent as response data inside standard SMB Trans
responses, with the MSRPC Header, MSRPC Data and MSRPC tail.
</para>

<para>
It is suspected that the Trans Requests will need to be at least 2-byte
aligned (probably 4-byte).  This is standard practice for SMBs.  It is also
independent of the observed 4-byte alignments with the start of the MSRPC
header, including the 4-byte alignment between the MSRPC header and the
MSRPC data.
</para>

<para>
First, an SMBtconX connection is made to the IPC$ share.  The connection
must be made using encrypted passwords, not clear-text.  Then, an SMBopenX
is made on the pipe.  Then, a Set Named Pipe Handle State must be sent,
after which the pipe is ready to accept API commands.  Lastly, and SMBclose
is sent.
</para>

<para>
To be resolved:
</para>

<para>
lkcl/01nov97 there appear to be two additional bytes after the null-terminated \PIPE\ name for the RPC pipe.  Values seen so far are
listed below:</para>

<para><programlisting>
        initial SMBopenX request:         RPC API command 0x26 params:
        "\\PIPE\\lsarpc"                  0x65 0x63; 0x72 0x70; 0x44 0x65;
        "\\PIPE\\srvsvc"                  0x73 0x76; 0x4E 0x00; 0x5C 0x43;
</programlisting></para>

</sect2>

<sect2>
<title>Header</title>

<para>[section to be rewritten, following receipt of work by Duncan Stansfield]</para>

<para>Interesting note: if you set packed data representation to 0x0100 0000
then all 4-byte and 2-byte word ordering is turned around!</para>

<para>The start of each of the NTLSA and NETLOGON named pipes begins with:</para>

<segmentedlist>
<segtitle>offset</segtitle><segtitle>Variable type</segtitle><segtitle>Variable data</segtitle>
<seglistitem><seg>00</seg><seg>UINT8</seg><seg>5 - RPC major version</seg></seglistitem>
<seglistitem><seg>01</seg><seg>UINT8</seg><seg>0 - RPC minor version</seg></seglistitem>
<seglistitem><seg>02</seg><seg>UINT8</seg><seg>2 - RPC response packet</seg></seglistitem>
<seglistitem><seg>03</seg><seg>UINT8</seg><seg>3 - (FirstFrag bit-wise or with LastFrag)</seg></seglistitem>
<seglistitem><seg>04</seg><seg>UINT32</seg><seg>0x1000 0000 - packed data representation</seg></seglistitem>
<seglistitem><seg>08</seg><seg>UINT16</seg><seg>fragment length - data size (bytes) inc header and tail.</seg></seglistitem>
<seglistitem><seg>0A</seg><seg>UINT16</seg><seg>0 - authentication length </seg></seglistitem>
<seglistitem><seg>0C</seg><seg>UINT32</seg><seg>call identifier. matches 12th UINT32 of incoming RPC data.</seg></seglistitem>
<seglistitem><seg>10</seg><seg>UINT32</seg><seg>allocation hint - data size (bytes) minus header and tail.</seg></seglistitem>
<seglistitem><seg>14</seg><seg>UINT16</seg><seg>0 - presentation context identifier</seg></seglistitem>
<seglistitem><seg>16</seg><seg>UINT8</seg><seg>0 - cancel count</seg></seglistitem>
<seglistitem><seg>17</seg><seg>UINT8</seg><seg>in replies: 0 - reserved; in requests: opnum - see #defines.</seg></seglistitem>
<seglistitem><seg>18</seg><seg>......</seg><seg>start of data (goes on for allocation_hint bytes)</seg></seglistitem>
</segmentedlist>

<sect3>
<title>RPC_Packet for request, response, bind and bind acknowledgement</title>

<variablelist>
<varlistentry>
	<term>UINT8 versionmaj</term>
<listitem><para>reply same as request (0x05)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 versionmin</term>
<listitem><para>reply same as request (0x00)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 type</term>
<listitem><para>one of the MSRPC_Type enums</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 flags</term>
<listitem><para>reply same as request (0x00 for Bind, 0x03 for Request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 representation</term>
<listitem><para>reply same as request (0x00000010)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 fraglength</term>
<listitem><para>the length of the data section of the SMB trans packet</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 authlength</term>
	<listitem><para></para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32 callid</term>
<listitem><para>call identifier. (e.g. 0x00149594)</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para>the remainder of the packet depending on the "type"</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Interface identification</title>

<para>the interfaces are numbered. as yet I haven't seen more than one interface used on the same pipe name srvsvc</para>

<para><programlisting>
abstract (0x4B324FC8, 0x01D31670, 0x475A7812, 0x88E16EBF, 0x00000003)
transfer (0x8A885D04, 0x11C91CEB, 0x0008E89F, 0x6048102B, 0x00000002)
</programlisting></para>

</sect3>

<sect3>
<title>RPC_Iface RW</title>

<variablelist>
<varlistentry>
	<term>UINT8 byte[16]</term>
<listitem><para>16 bytes of number</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 version</term>
<listitem><para>the interface number</para></listitem></varlistentry>
</variablelist>


</sect3>

<sect3>
<title>RPC_ReqBind RW</title>

<para>the remainder of the packet after the header if "type" was Bind in the response header, "type" should be BindAck</para>

<variablelist>
<varlistentry>
	<term>UINT16 maxtsize</term>
<listitem><para>maximum transmission fragment size (0x1630)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 maxrsize</term>
<listitem><para>max receive fragment size (0x1630)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 assocgid</term>
<listitem><para>associated group id (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 numelements</term>
<listitem><para>the number of elements (0x1)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 contextid</term>
<listitem><para>presentation context identifier (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 numsyntaxes</term>
<listitem><para>the number of syntaxes (has always been 1?)(0x1)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>* abstractint USE RPC_Iface</term>
<listitem><para>num and vers. of interface client is using</para></listitem></varlistentry>
<varlistentry>
	<term>* transferint USE RPC_Iface</term>
	<listitem><para>num and vers. of interface to use for replies</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_Address RW</title>

<variablelist>
<varlistentry>
	<term>UINT16 length</term>
<listitem><para>length of the string including null terminator</para></listitem></varlistentry>
<varlistentry>
	<term>* port USE string</term>
<listitem><para>the string above in single byte, null terminated form</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ResBind RW</title>

<para>the response to place after the header in the reply packet</para>

<variablelist>
<varlistentry>
	<term>UINT16 maxtsize</term>
<listitem><para>same as request</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 maxrsize</term>
<listitem><para>same as request</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32 assocgid</term>
<listitem><para>zero</para></listitem></varlistentry>
<varlistentry>
	<term>* secondaddr USE RPC_Address</term>
<listitem><para>the address string, as described earlier</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 numresults</term>
<listitem><para>the number of results (0x01)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>4-byte alignment padding, against SMB header</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 result</term>
<listitem><para>result (0x00 = accept)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 reason</term>
<listitem><para>reason (0x00 = no reason specified)</para></listitem></varlistentry>
<varlistentry>
	<term>* transfersyntax USE RPC_Iface</term>
<listitem><para>the transfer syntax from the request</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ReqNorm RW</title>

<para>the remainder of the packet after the header for every other other request</para>

<variablelist>
<varlistentry>
	<term>UINT32 allochint</term>
<listitem><para>the size of the stub data in bytes</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 prescontext</term>
<listitem><para>presentation context identifier (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 opnum</term>
<listitem><para>operation number (0x15)</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para>a packet dependent on the pipe name (probably the interface) and the op number)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>RPC_ResNorm RW</title>

<variablelist>
<varlistentry>
	<term>UINT32 allochint</term>
<listitem><para># size of the stub data in bytes</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16 prescontext</term>
<listitem><para># presentation context identifier (same as request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 cancelcount</term>
<listitem><para># cancel count? (0x0)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8 reserved</term>
<listitem><para># 0 - one byte padding</para></listitem></varlistentry>
<varlistentry>
	<term>* stub USE TvPacket</term>
<listitem><para># the remainder of the reply</para></listitem></varlistentry>
</variablelist>
</sect3>

</sect2>

<sect2>
<title>Tail</title>

<para>The end of each of the NTLSA and NETLOGON named pipes ends with:</para>

<variablelist>
<varlistentry>
	<term>......</term>
	<listitem><para>end of data</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>return code</para></listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
<title>RPC Bind / Bind Ack</title>

<para>
RPC Binds are the process of associating an RPC pipe (e.g \PIPE\lsarpc)
with a "transfer syntax" (see RPC_Iface structure).  The purpose for doing
this is unknown.
</para>

<para><emphasis>Note: The RPC_ResBind SMB Transact request is sent with two uint16 setup parameters.  The first is 0x0026; the second is the file handle
	returned by the SMBopenX Transact response.</emphasis></para>

<para><emphasis>Note:	The RPC_ResBind members maxtsize, maxrsize and assocgid are the same in the response as the same members in the RPC_ReqBind.  The
	RPC_ResBind member transfersyntax is the same in the response as
	the</emphasis></para>

<para><emphasis>Note:	The RPC_ResBind response member secondaddr contains the name of what is presumed to be the service behind the RPC pipe.  The
	mapping identified so far is:</emphasis></para>

<variablelist>

<varlistentry>
	<term>initial SMBopenX request:</term>
	<listitem><para>RPC_ResBind response:</para></listitem>
</varlistentry>

<varlistentry>
	<term>"\\PIPE\\srvsvc"</term>
	<listitem><para>"\\PIPE\\ntsvcs"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\samr"</term>
	<listitem><para>"\\PIPE\\lsass"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\lsarpc"</term>
	<listitem><para>"\\PIPE\\lsass"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\wkssvc"</term>
	<listitem><para>"\\PIPE\\wksvcs"</para></listitem>
</varlistentry>
<varlistentry>
	<term>"\\PIPE\\NETLOGON"</term>
	<listitem><para>"\\PIPE\\NETLOGON"</para></listitem>
</varlistentry>
</variablelist>

<para><emphasis>Note:	The RPC_Packet fraglength member in both the Bind Request and Bind Acknowledgment must contain the length of the entire RPC data, including the RPC_Packet header.</emphasis></para>

<para>Request:</para>

<simplelist>
<member>RPC_Packet</member>
<member>RPC_ReqBind</member>
</simplelist>

<para>Response:</para>
<simplelist>
<member>RPC_Packet</member>
<member>RPC_ResBind</member>
</simplelist>

</sect2>

<sect2>
<title>NTLSA Transact Named Pipe</title>

<para>The sequence of actions taken on this pipe are:</para>

<simplelist>
<member>Establish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</member>
<member>Open an RPC Pipe with the name "\\PIPE\\lsarpc".  Store the file handle.</member>
<member>Using the file handle, send a Set Named Pipe Handle state to 0x4300.</member>
<member>Send an LSA Open Policy request.  Store the Policy Handle.</member>
<member>Using the Policy Handle, send LSA Query Info Policy requests, etc.</member>
<member>Using the Policy Handle, send an LSA Close.</member>
<member>Close the IPC$ share.</member>
</simplelist>

<para>Defines for this pipe, identifying the query are:</para>
<variablelist>
<varlistentry>
	<term>LSA Open Policy:</term>
	<listitem><para>0x2c</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Query Info Policy:</term>
	<listitem><para>0x07</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Enumerate Trusted Domains:</term>
	<listitem><para>0x0d</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Open Secret:</term>
	<listitem><para>0xff</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Lookup SIDs:</term>
	<listitem><para>0xfe</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Lookup Names:</term>
	<listitem><para>0xfd</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Close:</term>
	<listitem><para>0x00</para></listitem>
</varlistentry>
</variablelist>

</sect2>

<sect2>
<title>LSA Open Policy</title>

<para><emphasis>Note:	The policy handle can be anything you like.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name - unicode string starting with two '\'s</para></listitem>
</varlistentry>
<varlistentry>
	<term>OBJ_ATTR</term>
	<listitem><para>object attributes</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>1 - desired access</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>

<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>

<varlistentry>
	<term>return</term>
	<listitem><para>0 - indicates success</para></listitem>
</varlistentry>

</variablelist>

</sect3>

</sect2>

<sect2>
<title>LSA Query Info Policy</title>

<para><emphasis>Note:	The info class in response must be the same as that in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
<listitem><para>LSA policy handle</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>info class (also a policy handle?)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>info class (same as info class in request).</para></listitem>
</varlistentry>

</variablelist>

<para><programlisting>
switch (info class)
case 3:
case 5:
{
DOM_INFO domain info, levels 3 and 5 (are the same).
}

return    0 - indicates success
</programlisting></para>

</sect3>

</sect2>

<sect2>
<title>LSA Enumerate Trusted Domains</title>

<sect3>
<title>Request</title>

<para>no extra data</para>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - enumeration context</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - entries read</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - trust information</para></listitem>
</varlistentry>
<varlistentry>
	<term>return</term>
	<listitem><para>0x8000 001a - "no trusted domains" success code</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>LSA Open Secret</title>

<sect3>
<title>Request</title>

<para>no extra data</para>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>0 - undocumented</para></listitem>
</varlistentry>
</variablelist>

<para>return    0x0C00 0034 - "no such secret" success code</para>

</sect3>

</sect2>

<sect2>
<title>LSA Close</title>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>policy handle to be closed</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
<listitem><para>0s - closed policy handle (all zeros)</para></listitem></varlistentry>
</variablelist>

<para>return    0 - indicates success</para>

</sect3>
</sect2>

<sect2>
<title>LSA Lookup SIDS</title>

<para><emphasis>Note:	num_entries in response must be same as num_entries in request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain SID buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*[num_entries] undocumented domain SID pointers to be looked up.
</term>
<listitem><para>DOM_SID[num_entries] domain SIDs to be looked up.</para></listitem></varlistentry>
<varlistentry>
	<term>char[16]</term>
	<listitem><para>completely undocumented 16 bytes.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>DOM_REF</term>
<listitem><para>domain reference response</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_SID2[num_entries]</term>
<listitem><para>domain SIDs (from Request, listed above).</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
</variablelist>

<para>return                0 - indicates success</para>

</sect3>

</sect2>

<sect2>
<title>LSA Lookup Names</title>

<para><emphasis>Note:	num_entries in response must be same as num_entries in request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>POL_HND</term>
	<listitem><para>LSA policy handle</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>num_entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain SID buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented domain name buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>NAME[num_entries]</term>
	<listitem><para>names to be looked up.</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[]</term>
	<listitem><para>undocumented bytes - falsely translated SID structure?</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>DOM_REF</term>
<listitem><para>domain reference response</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>undocumented buffer pointer</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
<varlistentry>
	<term>DOM_RID[num_entries]</term>
<listitem><para>domain SIDs (from Request, listed above).</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>num_entries (listed above)</para></listitem></varlistentry>
</variablelist>

<para>return                0 - indicates success</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>NETLOGON rpc Transact Named Pipe</title>

<para>The sequence of actions taken on this pipe are:</para>

<simplelist>
<member>tablish a connection to the IPC$ share (SMBtconX).  use encrypted passwords.</member>
<member>en an RPC Pipe with the name "\\PIPE\\NETLOGON".  Store the file handle.</member>
<member>ing the file handle, send a Set Named Pipe Handle state to 0x4300.</member>
<member>eate Client Challenge. Send LSA Request Challenge.  Store Server Challenge.</member>
<member>lculate Session Key.  Send an LSA Auth 2 Challenge.  Store Auth2 Challenge.</member>
<member>lc/Verify Client Creds.  Send LSA Srv PW Set.  Calc/Verify Server Creds.</member>
<member>lc/Verify Client Creds.  Send LSA SAM Logon .  Calc/Verify Server Creds.</member>
<member>lc/Verify Client Creds.  Send LSA SAM Logoff.  Calc/Verify Server Creds.</member>
<member>ose the IPC$ share.</member>
</simplelist>

<para>Defines for this pipe, identifying the query are</para>

<variablelist>
<varlistentry>
	<term>LSA Request Challenge:</term>
	<listitem><para>0x04</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Server Password Set:</term>
	<listitem><para>0x06</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA SAM Logon:</term>
	<listitem><para>0x02</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA SAM Logoff:</term>
	<listitem><para>0x03</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Auth 2:</term>
	<listitem><para>0x0f</para></listitem>
</varlistentry>
<varlistentry>
	<term>LSA Logon Control:</term>
	<listitem><para>0x0e</para></listitem>
</varlistentry>
</variablelist>

<sect2>
<title>LSA Request Challenge</title>

<para><emphasis>Note:	logon server name starts with two '\' characters and is upper case.</emphasis></para>

<para><emphasis>Note:	logon client is the machine, not the user.</emphasis></para>

<para><emphasis>Note:	the initial LanManager password hash, against which the challenge is issued, is the machine name itself (lower case).  there will becalls issued (LSA Server Password Set) which will change this, later. refusing these calls allows you to always deal with the same password (i.e the LM# of the machine name in lower case).</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon server unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>logon client unicode string</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>client challenge</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>server challenge</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success</para>

</sect3>

</sect2>

<sect2>
<title>LSA Authenticate 2</title>

<para><emphasis>Note:	in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</emphasis></para>

<para><emphasis>Note:	neg_flags in the response is the same as that in the request.</emphasis></para>

<para><emphasis>Note:	you must take a copy of the client-calculated credentials received 	here, because they will be used in subsequent authentication packets.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>LOG_INFO</term>
	<listitem><para>client identification info</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>client-calculated credentials</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
<listitem><para>padding to 4-byte align with start of SMB header.</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>neg_flags - negotiated flags (usual value is 0x0000 01ff)</para></listitem></varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>char[8]</term>
	<listitem><para>server credentials.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>neg_flags - same as neg_flags in request.</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success.  failure value unknown.</para>

</sect3>

</sect2>

<sect2>
<title>LSA Server Password Set</title>

<para><emphasis>Note: the new password is suspected to be a DES encryption using the old password to generate the key.</emphasis></para>

<para><emphasis>Note: in between request and response, calculate the client credentials, and check them against the client-calculated credentials (this process uses the previously received client credentials).</emphasis></para>

<para><emphasis>Note: the server credentials are constructed from the client-calculated credentials and the client time + 1 second.</emphasis></para>

<para><emphasis>Note: you must take a copy of the client-calculated credentials received here, because they will be used in subsequent authentication packets.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>CLNT_INFO</term>
	<listitem><para>client identification/authentication info</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[]</term>
	<listitem><para>new password - undocumented.</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para>return    0 - indicates success; 0xC000 006a indicates failure</para>

</sect3>
</sect2>

<sect2>
<title>LSA SAM Logon</title>

<para><emphasis>
Note:	valid_user is True iff the username and password hash are valid for
	the requested domain.
</emphasis></para>

<sect3>
<title>Request</title>
<variablelist>
<varlistentry>
	<term>SAM_INFO</term>
	<listitem><para>sam_id structure</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para><programlisting>
if (valid_user)
{
	UINT16      3 - switch value indicating USER_INFO structure.
    VOID*     non-zero - pointer to USER_INFO structure
    USER_INFO user logon information

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0 - indicates success
}
else
{
	UINT16    0 - switch value.  value to indicate no user presumed.
    VOID*     0x0000 0000 - indicates no USER_INFO structure.

    UINT32    1 - Authoritative response; 0 - Non-Auth?

    return    0xC000 0064 - NT_STATUS_NO_SUCH_USER.
}
</programlisting></para>

</sect3>

</sect2>

<sect2>
<title>LSA SAM Logoff</title>

<para><emphasis>
Note:	presumably, the SAM_INFO structure is validated, and a (currently
	undocumented) error code returned if the Logoff is invalid.
</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>SAM_INFO</term>
	<listitem><para>sam_id structure</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>undocumented buffer pointer</para></listitem>
</varlistentry>
<varlistentry>
	<term>CREDS</term>
	<listitem><para>server credentials.  server time stamp appears to be ignored.</para></listitem>
</varlistentry>
</variablelist>

<para>return      0 - indicates success.  undocumented failure indication.</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>\\MAILSLOT\NET\NTLOGON</title>

<para><emphasis>
Note:	mailslots will contain a response mailslot, to which the response
	should be sent.  the target NetBIOS name is REQUEST_NAME&lt;20&gt;, where
	REQUEST_NAME is the name of the machine that sent the request.
</emphasis></para>

<sect2>
<title>Query for PDC</title>

<para><emphasis>Note:	NTversion, LMNTtoken, LM20token in response are the same as those 	given in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0007 - Query for PDC</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>response mailslot</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to 2-byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
<listitem><para>0x000A - Respose to Query for PDC</para></listitem></varlistentry>
<varlistentry>
	<term>STR</term>
<listitem><para>machine name (in uppercase)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to 2-byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
<listitem><para>domain name</para></listitem></varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>NTversion (same as received in request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>LMNTtoken (same as received in request)</para></listitem></varlistentry>
<varlistentry>
	<term>UINT16</term>
<listitem><para>LM20token (same as received in request)</para></listitem></varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>SAM Logon</title>

<para><emphasis>Note: machine name in response is preceded by two '\' characters.</emphasis></para>

<para><emphasis>Note:	NTversion, LMNTtoken, LM20token in response are the same as those given in the request.</emphasis></para>

<para><emphasis>Note:	user name in the response is presumably the same as that in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0012 - SAM Logon</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>request count</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>user name</para></listitem>
</varlistentry>
<varlistentry>
	<term>STR</term>
	<listitem><para>response mailslot</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>alloweable account</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>domain SID size</para></listitem>
</varlistentry>
<varlistentry>
	<term>char[sid_size]</term>
	<listitem><para>domain SID, of sid_size bytes.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>???? padding to 4? 2? -byte align with start of mailslot.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>0x0013 - Response to SAM Logon</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>machine name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>user name - workstation trust account</para></listitem>
</varlistentry>
<varlistentry>
	<term>UNISTR</term>
	<listitem><para>domain name </para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>NTversion</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LMNTtoken</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT16</term>
	<listitem><para>LM20token</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>
</sect1>

<sect1>
<title>SRVSVC Transact Named Pipe</title>

<para>Defines for this pipe, identifying the query are:</para>

<variablelist>
<varlistentry>
	<term>Net Share Enum</term>
	<listitem><para>0x0f</para></listitem>
</varlistentry>
<varlistentry>
	<term>Net Server Get Info</term>
	<listitem><para>0x15</para></listitem>
</varlistentry>

</variablelist>

<sect2>
<title>Net Share Enum</title>

<para><emphasis>Note:	share level and switch value in the response are presumably the same as those in the request.</emphasis></para>

<para><emphasis>Note:	cifsrap2.txt (section 5) may be of limited assistance here.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>VOID*</term>
<listitem><para>pointer (to server name?)</para></listitem></varlistentry>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT8[]</term>
	<listitem><para>padding to get unicode string 4-byte aligned with the start of the SMB header.</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>share level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to SHARE_INFO_1_CTR</para></listitem>
</varlistentry>
<varlistentry>
	<term>SHARE_INFO_1_CTR</term>
	<listitem><para>share info with 0 entries</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
<listitem><para>preferred maximum length (0xffff ffff)</para></listitem></varlistentry>
</variablelist>
</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>share level</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch value</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
<listitem><para>pointer to SHARE_INFO_1_CTR</para></listitem></varlistentry>
<varlistentry>
	<term>SHARE_INFO_1_CTR</term>
<listitem><para>share info (only added if share info ptr is non-zero)</para></listitem></varlistentry>
</variablelist>

<para>return            0 - indicates success</para>

</sect3>
</sect2>

<sect2>
<title>Net Server Get Info</title>

<para><emphasis>Note:	level is the same value as in the request.</emphasis></para>

<sect3>
<title>Request</title>

<variablelist>
<varlistentry>
	<term>UNISTR2</term>
	<listitem><para>server name</para></listitem>
</varlistentry>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch level</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>Response</title>

<variablelist>
<varlistentry>
	<term>UINT32</term>
	<listitem><para>switch level</para></listitem>
</varlistentry>
<varlistentry>
	<term>VOID*</term>
	<listitem><para>pointer to SERVER_INFO_101</para></listitem>
</varlistentry>
<varlistentry>
	<term>SERVER_INFO_101</term>
<listitem><para>server info (only added if server info ptr is non-zero)</para></listitem></varlistentry>
</variablelist>

<para>return            0 - indicates success</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Cryptographic side of NT Domain Authentication</title>

<sect2>
<title>Definitions</title>

<variablelist>
<varlistentry>
<term>Add(A1,A2)</term>
<listitem><para>Intel byte ordered addition of corresponding 4 byte words in arrays A1 and A2</para></listitem>
</varlistentry>

<varlistentry>
<term>E(K,D)</term>
<listitem><para>DES ECB encryption of 8 byte data D using 7 byte key K</para></listitem>
</varlistentry>

<varlistentry>
<term>lmowf()</term>
<listitem><para>Lan man hash</para></listitem>
</varlistentry>

<varlistentry>
<term>ntowf()</term>
<listitem><para>NT hash</para></listitem>
</varlistentry>

<varlistentry>
<term>PW</term>
<listitem><para>md4(machine_password) == md4(lsadump $machine.acc) ==
pwdump(machine$) (initially) == md4(lmowf(unicode(machine)))
</para></listitem>
</varlistentry>

<varlistentry>
<term>ARC4(K,Lk,D,Ld)</term>
<listitem><para>ARC4 encryption of data D of length Ld with key K of length Lk</para></listitem>
</varlistentry>

<varlistentry>
<term>v[m..n(,l)]</term>
<listitem><para>subset of v from bytes m to n, optionally padded with zeroes to length l</para></listitem>
</varlistentry>

<varlistentry>
<term>Cred(K,D)</term>
<listitem><para>E(K[7..7,7],E(K[0..6],D)) computes a credential</para></listitem>
</varlistentry>

<varlistentry>
<term>Time()</term>
<listitem><para>4 byte current time</para></listitem>
</varlistentry>

<varlistentry>
<term>Cc,Cs</term>
<listitem><para>8 byte client and server challenges Rc,Rs: 8 byte client and server credentials</para></listitem>
</varlistentry>

</variablelist>

</sect2>

<sect2>
<title>Protocol</title>

<programlisting>
C-&gt;S ReqChal,Cc
S-&gt;C Cs
</programlisting>

<programlisting>
C &amp; S compute session key Ks = E(PW[9..15],E(PW[0..6],Add(Cc,Cs)))
</programlisting>

<programlisting>
C: Rc = Cred(Ks,Cc)
C-&gt;S Authenticate,Rc
S: Rs = Cred(Ks,Cs), assert(Rc == Cred(Ks,Cc))
S-&gt;C Rs
C: assert(Rs == Cred(Ks,Cs))
</programlisting>

<para>
On joining the domain the client will optionally attempt to change its
password and the domain controller may refuse to update it depending
on registry settings. This will also occur weekly afterwards.
</para>

<programlisting>
C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc)
C-&gt;S ServerPasswordSet,Rc',Tc,arc4(Ks[0..7,16],lmowf(randompassword())
C: Rc = Cred(Ks,Rc+Tc+1)
S: assert(Rc' == Cred(Ks,Rc+Tc)), Ts = Time()
S: Rs' = Cred(Ks,Rs+Tc+1)
S-&gt;C Rs',Ts
C: assert(Rs' == Cred(Ks,Rs+Tc+1))
S: Rs = Rs'
</programlisting>

<para>
User: U with password P wishes to login to the domain (incidental data
such as workstation and domain omitted)
</para>

<programlisting>
C: Tc = Time(), Rc' = Cred(Ks,Rc+Tc)
C-&gt;S NetLogonSamLogon,Rc',Tc,U,arc4(Ks[0..7,16],16,ntowf(P),16), arc4(Ks[0..7,16],16,lmowf(P),16)
S: assert(Rc' == Cred(Ks,Rc+Tc)) assert(passwords match those in SAM)
S: Ts = Time()
</programlisting>

<programlisting>
S-&gt;C Cred(Ks,Cred(Ks,Rc+Tc+1)),userinfo(logon script,UID,SIDs,etc)
C: assert(Rs == Cred(Ks,Cred(Rc+Tc+1))
C: Rc = Cred(Ks,Rc+Tc+1)
</programlisting>

</sect2>

<sect2>
<title>Comments</title>

<para>
On first joining the domain the session key could be computed by
anyone listening in on the network as the machine password has a well
known value. Until the machine is rebooted it will use this session
key to encrypt NT and LM one way functions of passwords which are
password equivalents. Any user who logs in before the machine has been
rebooted a second time will have their password equivalent exposed. Of
course the new machine password is exposed at this time anyway.
</para>

<para>
None of the returned user info such as logon script, profile path and
SIDs *appear* to be protected by anything other than the TCP checksum.
</para>

<para>
The server time stamps appear to be ignored.
</para>

<para>
The client sends a ReturnAuthenticator in the SamLogon request which I
can't find a use for.  However its time is used as the timestamp
returned by the server.
</para>

<para>
The password OWFs should NOT be sent over the network reversibly
encrypted. They should be sent using ARC4(Ks,md4(owf)) with the server
computing the same function using the owf values in the SAM.
</para>

</sect2>
</sect1>

<sect1>
<title>SIDs and RIDs</title>

<para>
SIDs and RIDs are well documented elsewhere.
</para>

<para>
A SID is an NT Security ID (see DOM_SID structure).  They are of the form:
</para>

<simplelist>
<member>revision-NN-SubAuth1-SubAuth2-SubAuth3... </member>
<member>revision-0xNNNNNNNNNNNN-SubAuth1-SubAuth2-SubAuth3...</member>
</simplelist>

<para>
currently, the SID revision is 1.
The Sub-Authorities are known as Relative IDs (RIDs).
</para>

<sect2>
<title>Well-known SIDs</title>

<sect3>
<title>Universal well-known SIDs</title>

<variablelist>
<varlistentry>
	<term>Null SID</term>
	<listitem><para>S-1-0-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>World</term>
	<listitem><para>S-1-1-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Local</term>
	<listitem><para>S-1-2-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Owner ID</term>
	<listitem><para>S-1-3-0</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Group ID</term>
	<listitem><para>S-1-3-1</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Owner Server ID</term>
	<listitem><para>S-1-3-2</para></listitem>
</varlistentry>
<varlistentry>
	<term>Creator Group Server ID</term>
	<listitem><para>S-1-3-3</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Non-unique IDs)</term>
	<listitem><para>S-1-4</para></listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3>
<title>NT well-known SIDs</title>

<variablelist>
<varlistentry>
	<term>NT Authority</term>
	<listitem><para>S-1-5</para></listitem>
</varlistentry>
<varlistentry>
	<term>Dialup</term>
	<listitem><para>S-1-5-1</para></listitem>
</varlistentry>
<varlistentry>
	<term>Network</term>
	<listitem><para>S-1-5-2</para></listitem>
</varlistentry>
<varlistentry>
	<term>Batch</term>
	<listitem><para>S-1-5-3</para></listitem>
</varlistentry>
<varlistentry>
	<term>Interactive</term>
	<listitem><para>S-1-5-4</para></listitem>
</varlistentry>
<varlistentry>
	<term>Service</term>
<listitem><para>S-1-5-6</para></listitem></varlistentry>
<varlistentry>
	<term>AnonymousLogon(aka null logon session)</term>
	<listitem><para>S-1-5-7</para></listitem>
</varlistentry>
<varlistentry>
	<term>Proxy</term>
<listitem><para>S-1-5-8</para></listitem></varlistentry>
<varlistentry>
	<term>ServerLogon(aka domain controller account)</term>
	<listitem><para>S-1-5-8</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Logon IDs)</term>
	<listitem><para>S-1-5-5-X-Y</para></listitem>
</varlistentry>
<varlistentry>
	<term>(NT non-unique IDs)</term>
	<listitem><para>S-1-5-0x15-...</para></listitem>
</varlistentry>
<varlistentry>
	<term>(Built-in domain)</term>
	<listitem><para>s-1-5-0x20</para></listitem>
</varlistentry>
</variablelist>

</sect3>
</sect2>

<sect2>
<title>Well-known RIDS</title>

<para>
A RID is a sub-authority value, as part of either a SID, or in the case
of Group RIDs, part of the DOM_GID structure, in the USER_INFO_1
structure, in the LSA SAM Logon response.
</para>

<sect3>
<title>Well-known RID users</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>DOMAIN_USER_RID_ADMIN</seg><seg>0x0000</seg><seg>01F4</seg></seglistitem>
<seglistitem><seg>DOMAIN_USER_RID_GUEST</seg><seg>0x0000</seg><seg>01F5</seg></seglistitem>
</segmentedlist>

</sect3>

<sect3>
<title>Well-known RID groups</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>	DOMAIN_GROUP_RID_ADMINS</seg><seg>0x0000</seg><seg>0200</seg></seglistitem>
<seglistitem><seg>	DOMAIN_GROUP_RID_USERS</seg><seg>0x0000</seg><seg>0201</seg></seglistitem>
<seglistitem><seg>	DOMAIN_GROUP_RID_GUESTS</seg><seg>0x0000</seg><seg>0202</seg></seglistitem>
</segmentedlist>

</sect3>

<sect3>
<title>Well-known RID aliases</title>

<segmentedlist>
<segtitle>Groupname</segtitle>
<segtitle>????</segtitle>
<segtitle>RID</segtitle>
<seglistitem><seg>	DOMAIN_ALIAS_RID_ADMINS</seg><seg>0x0000</seg><seg>0220</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_USERS</seg><seg>0x0000</seg><seg>0221</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_GUESTS</seg><seg>0x0000</seg><seg>0222</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_POWER_USERS</seg><seg>0x0000</seg><seg>0223</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_ACCOUNT_OPS</seg><seg>0x0000</seg><seg>0224</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_SYSTEM_OPS</seg><seg>0x0000</seg><seg>0225</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_PRINT_OPS</seg><seg>0x0000</seg><seg>0226</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_BACKUP_OPS</seg><seg>0x0000</seg><seg>0227</seg></seglistitem>
<seglistitem><seg>	DOMAIN_ALIAS_RID_REPLICATOR</seg><seg>0x0000</seg><seg>0228</seg></seglistitem>
</segmentedlist>

</sect3>
</sect2>
</sect1>
</chapter>
