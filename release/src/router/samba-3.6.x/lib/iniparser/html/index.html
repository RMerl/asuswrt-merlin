<html>
<head>
	<meta name="author"    content="ndevilla@free.fr">
	<meta name="keywords"  content="ini file, config file, parser, C library">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
<title>iniparser 2.x</title>
</head>

<body text="#000000" bgcolor="#ffffff">



<!-- Generated by Doxygen 1.5.1 -->
<h1>iniparser documentation</h1>
<p>
<h3 align="center">2.x </h3><hr>
<h2><a class="anchor" name="welcome">
Introduction</a></h2>
iniParser is a simple C library offering ini file parsing services. The library is pretty small (less than 1500 lines of C) and robust, and does not depend on any other external library to compile. It is written in ANSI C and should compile anywhere without difficulty.<p>
<hr>
<h2><a class="anchor" name="inidef">
What is an ini file?</a></h2>
An ini file is an ASCII file describing simple parameters (character strings, integers, floating-point values or booleans) in an explicit format, easy to use and modify for users.<p>
An ini file is segmented into Sections, declared by the following syntax:<p>
<div class="fragment"><pre class="fragment">
    [Section Name]
	</pre></div><p>
i.e. the section name enclosed in square brackets, alone on a line. Sections names are allowed to contain any character but square brackets or linefeeds. Slashes (/) are also reserved for hierarchical sections (see below).<p>
In any section are zero or more variables, declared with the following syntax:<p>
<div class="fragment"><pre class="fragment">
    Key = value ; comment
	</pre></div><p>
The key is any string (possibly containing blanks). The value is any character on the right side of the equal sign. Values can be given enclosed with quotes. If no quotes are present, the value is understood as containing all characters between the first and the last non-blank characters. The following declarations are identical:<p>
<div class="fragment"><pre class="fragment">
    Hello = "this is a long string value" ; comment
    Hello = this is a long string value ; comment
	</pre></div><p>
The semicolon and comment at the end of the line are optional. If there is a comment, it starts from the first character after the semicolon up to the end of the line.<p>
Comments in an ini file are:<p>
<ul>
<li>Lines starting with a hash sign</li><li>Blank lines (only blanks or tabs)</li><li>Comments given on value lines after the semicolon (if present)</li></ul>
<p>
<hr>
<h2><a class="anchor" name="install">
Compiling/installing the library</a></h2>
Edit the Makefile to indicate the C compiler you want to use, the options to provide to compile ANSI C, and possibly the options to pass to the <code>ar</code> program on your machine to build a library (.a) from a set of object (.o) files.<p>
Defaults are set for the gcc compiler and the standard ar library builder.<p>
Type 'make', that should do it.<p>
To use the library in your programs, add the following line on top of your module:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include "<a class="code" href="iniparser_8h.html">iniparser.h</a>"</span>
</pre></div><p>
And link your program with the iniparser library by adding <code>-liniparser.a</code> to the compile line.<p>
See the file test/initest.c for an example.<p>
<hr>
<h2><a class="anchor" name="reference">
Library reference</a></h2>
The library is completely documented in its header file. On-line documentation has been generated and can be consulted here:<p>
<ul>
<li><a class="el" href="iniparser_8h.html">iniparser.h</a></li></ul>
<p>
<hr>
<h2><a class="anchor" name="usage">
Using the parser</a></h2>
Comments are discarded by the parser. Then sections are identified, and in each section a new entry is created for every keyword found. The keywords are stored with the following syntax:<p>
<div class="fragment"><pre class="fragment">
    [Section]
    Keyword = value ; comment
	</pre></div><p>
is converted to the following key pair:<p>
<div class="fragment"><pre class="fragment">
    ("section:keyword", "value")
	</pre></div><p>
This means that if you want to retrieve the value that was stored in the section called <code>Pizza</code>, in the keyword <code>Cheese</code>, you would make a request to the dictionary for <code>"pizza:cheese"</code>. All section and keyword names are converted to lowercase before storage in the structure. The value side is conserved as it has been parsed, though.<p>
Section names are also stored in the structure. They are stored using as key the section name, and a NULL associated value. They can be queried through <a class="el" href="iniparser_8h.html#3d67c98bbc0cb5239f024ad54bdc63f1">iniparser_find_entry()</a>.<p>
To launch the parser, simply use the function called <a class="el" href="iniparser_8h.html#b0be559bfb769224b3f1b75e26242a67">iniparser_load()</a>, which takes an input file name and returns a newly allocated <em>dictionary</em> structure. This latter object should remain opaque to the user and only accessed through the following accessor functions:<p>
<ul>
<li><a class="el" href="iniparser_8h.html#587eafb48937fdee8ae414ad7a666db8">iniparser_getstr()</a></li><li><a class="el" href="iniparser_8h.html#694eb1110f4200db8648820a0bb405fa">iniparser_getint()</a></li><li><a class="el" href="iniparser_8h.html#480d35322f1252344cf2246ac21ee559">iniparser_getdouble()</a></li><li><a class="el" href="iniparser_8h.html#eb93c13fcbb75efaa396f53bfd73ff4d">iniparser_getboolean()</a></li></ul>
<p>
Finally, discard this structure using <a class="el" href="iniparser_8h.html#90549ee518523921886b74454ff872eb">iniparser_freedict()</a>.<p>
All values parsed from the ini file are stored as strings. The getint, getdouble and getboolean accessors are just converting these strings to the requested type on the fly, but you could basically perform this conversion by yourself after having called the getstr accessor.<p>
Notice that the <a class="el" href="iniparser_8h.html#eb93c13fcbb75efaa396f53bfd73ff4d">iniparser_getboolean()</a> function will return an integer (0 or 1), trying to make sense of what was found in the file. Strings starting with "y", "Y", "t", "T" or "1" are considered true values (return 1), strings starting with "n", "N", "f", "F", "0" are considered false (return 0). This allows flexible handling of boolean answers.<p>
If you want to add extra information into the structure that was not present in the ini file, you can use <a class="el" href="iniparser_8h.html#605a88057bac4c3249513fc588421c32">iniparser_setstr()</a> to insert a string.<p>
<hr>
<h2><a class="anchor" name="implementation">
A word about the implementation</a></h2>
The dictionary structure is a pretty simple dictionary implementation which might find some uses in other applications. If you are curious, look into the source.<p>
<hr>
<h2><a class="anchor" name="hierarchical">
Hierarchical ini files</a></h2>
ini files are nice to present informations to the user in a readable format, but lack a very useful feature: the possibility of organizing data in a hierarchical (tree-like) fashion. The following convention can be used to make ini files obtain this second dimension:<p>
A section depends on another section if it contains its name as a prefix, separated by slashes (/). For example: we have 2 main sections in the ini file. The first one is called <code>Pizza</code> and has two child subsections called <code>Cheese</code> and <code>Ham</code>. The second main section in the ini file is called <code>Wine</code> and has two child subsections called <code>Year</code> and <code>Grape</code>. As a tree, this could appear as:<p>
<div class="fragment"><pre class="fragment">
    |
    +-- Pizza
    |     +-- Cheese
    |     +-- Ham
    +-- Wine
         +--- Year
         +--- Grape
	</pre></div><p>
In an ini file, that would be converted to:<p>
<div class="fragment"><pre class="fragment">
    [Pizza]

    [Pizza/Cheese]
    Name   = Gorgonzola ;
    Origin = Italy ;

    [Pizza/Ham]
    Name   = Parma ;
    Origin = Italy ;

    [Wine]

    [Wine/Year]
    Value = 1998 ;

    [Wine/Grape]
    Name   = Cabernet Sauvignon ;
    Origin = Chile ;
	</pre></div><p>
This proposal is actually more related to the way people write ini files, more than the parser presented here. But it is certainly a useful way of making tree-like data declarations without going through painful formats like XML.<p>
Accessing the above tree would give something like (error checking removed for clarity sake):<p>
<div class="fragment"><pre class="fragment">    dictionary * d ;

    d = <a class="code" href="iniparser_8h.html#b0be559bfb769224b3f1b75e26242a67">iniparser_load</a>(<span class="stringliteral">"example.ini"</span>);

    printf(<span class="stringliteral">"cheese name is %s\n"</span>, <a class="code" href="iniparser_8h.html#587eafb48937fdee8ae414ad7a666db8">iniparser_getstr</a>(d, <span class="stringliteral">"pizza/cheese:name"</span>));
    printf(<span class="stringliteral">"grape name is %s\n"</span>,  <a class="code" href="iniparser_8h.html#587eafb48937fdee8ae414ad7a666db8">iniparser_getstr</a>(d, <span class="stringliteral">"wine/grape:name"</span>));

    <a class="code" href="iniparser_8h.html#90549ee518523921886b74454ff872eb">iniparser_freedict</a>(d);
</pre></div><p>
The whole ini file above is represented in the dictionary as the following list of pairs:<p>
<div class="fragment"><pre class="fragment">
    key                             value

    "pizza"                         NULL
    "pizza/cheese"                  NULL
    "pizza/cheese:name"             "Gorgonzola"
    "pizza/cheese:origin"           "Italy"
    "pizza/ham"                     NULL
    "pizza/ham:name"                "Parma"
    "pizza/ham:origin"              "Italy"
    "wine"                          NULL
    "wine/year"                     NULL
    "wine/year:value"               "1998"
    "wine/grape"                    NULL
    "wine/grape:name"               "Cabernet Sauvignon"
    "wine/grape:origin"             "Chile"
	</pre></div><p>
<hr>
<h2><a class="anchor" name="authors">
Authors</a></h2>
Nicolas Devillard (ndevilla AT free DOT fr). 
</body>
</html>
