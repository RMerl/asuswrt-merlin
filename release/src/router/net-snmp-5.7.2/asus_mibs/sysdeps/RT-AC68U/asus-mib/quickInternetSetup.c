/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "quickInternetSetup.h"
#include <nmp.h>

#define MAXDHCPSTATIC   32
#define DHCPSTATICSTRNUM    40
#define MACSTRNUM   18
#define STATICROUTESTRNUM   80
#define MAXSTATICROUTE  32
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static int sw_mode = 0;
wlc_ap_list_info_t ap_list[WLC_MAX_AP_SCAN_LIST_LEN];
ap_info_t apinfo[WLC_MAX_AP_SCAN_LIST_LEN];
int ap_count;

/* 
 * quickInternetSetup_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid quickInternetSetup_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,12 };

/* 
 * variable7 quickInternetSetup_variables:
 *   this variable defines function callbacks and type return information 
 *   for the quickInternetSetup mib section 
 */

struct variable7 quickInternetSetup_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define QRCONNECTIONTYPE		1
{QRCONNECTIONTYPE,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 3,  { 1,1,1 }},
#define QRAHOSTNAME		2
{QRAHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,2,1 }},
#define QRAMACADDRESS		3
{QRAMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,2,2 }},
#define QRACONNECTTODNSSERVERAUTOMATICALLY		4
{QRACONNECTTODNSSERVERAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,2,3 }},
#define QRADNSSERVER1		5
{QRADNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,2,4 }},
#define QRADNSSERVER2		6
{QRADNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,2,5 }},
#define QRPPPOEUSERNAME		7
{QRPPPOEUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,3,1 }},
#define QRPPPOEPASSWORD		8
{QRPPPOEPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,3,2 }},
#define QRIPADDRESS		9
{QRIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,1 }},
#define QRSUBNETMASK		10
{QRSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,2 }},
#define QRDEFAULTGATEWAY		11
{QRDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,3 }},
#define QRDNSSERVER1		12
{QRDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,4 }},
#define QRDNSSERVER2		13
{QRDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,5 }},
#define QRMACADDRESS		14
{QRMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,4,6 }},
#define QRUSERNAME		15
{QRUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,1 }},
#define QRPASSWORD		16
{QRPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,2 }},
#define QRPIPADDRESS		17
{QRPIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,3 }},
#define QRPSUBNETMASK		18
{QRPSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,4 }},
#define QRPDEFAULTGATEWAY		19
{QRPDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,5 }},
#define QRPCONNECTTODNSSERVERAUTOMATICALLY		20
{QRPCONNECTTODNSSERVERAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,6 }},
#define QRPDNSSERVER1		21
{QRPDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,7 }},
#define QRPDNSSERVER2		22
{QRPDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,8 }},
#define QRPVPNSERVER		23
{QRPVPNSERVER,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,5,9 }},
#define QRSELECTISPPROFILE		24
{QRSELECTISPPROFILE,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,1 }},
#define QRIPTVSTBPORT		25
{QRIPTVSTBPORT,  ASN_OCTET_STR,  RONLY ,  var_quickInternetSetup, 4,  { 1,1,6,2 }},
#define QRVOIPPORT		26
{QRVOIPPORT,  ASN_OCTET_STR,  RONLY ,  var_quickInternetSetup, 4,  { 1,1,6,3 }},
#define QRINTERNETVID		27
{QRINTERNETVID,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,4 }},
#define QRINTERNETPRIO		28
{QRINTERNETPRIO,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,5 }},
#define QRLAN4PORTVID		29
{QRLAN4PORTVID,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,6 }},
#define QRLAN4PORTPRIO		30
{QRLAN4PORTPRIO,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,7 }},
#define QRLAN3PORTVID		31
{QRLAN3PORTVID,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,8 }},
#define QRLAN3PORTPRIO		32
{QRLAN3PORTPRIO,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 4,  { 1,1,6,9 }},
#define QRNETWORKNAMEWL2G		33
{QRNETWORKNAMEWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 1,2,1 }},
#define QRNETWORKKEYWL2G		34
{QRNETWORKKEYWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 1,2,2 }},
#define QRNETWORKNAMEWL5G		35
{QRNETWORKNAMEWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 1,2,3 }},
#define QRNETWORKKEYWL5G		36
{QRNETWORKKEYWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 1,2,4 }},
#define QAPSCANACT		37
{QAPSCANACT,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,1 }},
#define QWLCBAND		38
{QWLCBAND,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,3 }},
#define QWLCSSID		39
{QWLCSSID,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 2,4 }},
#define QWLCAUTHENTICATION		40
{QWLCAUTHENTICATION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,5 }},
#define QWLCWEPENCRYPTION		41
{QWLCWEPENCRYPTION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,6 }},
#define QWLCKEYINDEX		42
{QWLCKEYINDEX,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,7 }},
#define QWLCWEPKEYVALUE		43
{QWLCWEPKEYVALUE,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 2,8 }},
#define QWLCWPAENCRYPTION		44
{QWLCWPAENCRYPTION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 2,9 }},
#define QWLCWPAPRESHAREDKEY		45
{QWLCWPAPRESHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 2,10 }},
#define QTUSEDEFAULTSETTINGS		46
{QTUSEDEFAULTSETTINGS,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 3,  { 2,11,1 }},
#define QTNETWORKNAMEWL2G		47
{QTNETWORKNAMEWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 2,11,2 }},
#define QTNETWORKKEYWL2G		48
{QTNETWORKKEYWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 2,11,3 }},
#define QTNETWORKNAMEWL5G		49
{QTNETWORKNAMEWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 2,11,4 }},
#define QTNETWORKKEYWL5G		50
{QTNETWORKKEYWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 2,11,5 }},
#define QLANGETIPAUTOMATICALLY		51
{QLANGETIPAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,1 }},
#define QLANIPADDRESS		52
{QLANIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,2 }},
#define QLANSUBNETMASK		53
{QLANSUBNETMASK,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,3 }},
#define QLANDEFAULTGATEWAY		54
{QLANDEFAULTGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,4 }},
#define QLANCONNECTTODNSSERVERAUTOMATICALLY		55
{QLANCONNECTTODNSSERVERAUTOMATICALLY,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,5 }},
#define QLANDNSSERVER1		56
{QLANDNSSERVER1,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,6 }},
#define QLANDNSSERVER2		57
{QLANDNSSERVER2,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,1,7 }},
#define QPNETWORKNAMEWL2G		58
{QPNETWORKNAMEWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,2,1 }},
#define QPNETWORKKEYWL2G		59
{QPNETWORKKEYWL2G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,2,2 }},
#define QPNETWORKNAMEWL5G		60
{QPNETWORKNAMEWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,2,3 }},
#define QPNETWORKKEYWL5G		61
{QPNETWORKKEYWL5G,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 3,  { 3,2,4 }},
#define QMAPSCANACT		62
{QMAPSCANACT,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,1 }},
#define QMWLCBAND		63
{QMWLCBAND,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,3 }},
#define QMWLCSSID		64
{QMWLCSSID,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 4,4 }},
#define QMWLCAUTHENTICATION		65
{QMWLCAUTHENTICATION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,5 }},
#define QMWLCWEPENCRYPTION		66
{QMWLCWEPENCRYPTION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,6 }},
#define QMWLCKEYINDEX		67
{QMWLCKEYINDEX,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,7 }},
#define QMWLCWEPKEYVALUE		68
{QMWLCWEPKEYVALUE,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 4,8 }},
#define QMWLCWPAENCRYPTION		69
{QMWLCWPAENCRYPTION,  ASN_INTEGER,  RWRITE,  var_quickInternetSetup, 2,  { 4,9 }},
#define QMWLCWPAPRESHAREDKEY		70
{QMWLCWPAPRESHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_quickInternetSetup, 2,  { 4,10 }},

#define QAPRESULTINDEX		71
{QAPRESULTINDEX,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 1 }},
#define QAPRESULTBAND		72
{QAPRESULTBAND,  ASN_OCTET_STR,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 2 }},
#define QAPRESULTSSID		73
{QAPRESULTSSID,  ASN_OCTET_STR,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 3 }},
#define QAPRESULTCHANNEL		74
{QAPRESULTCHANNEL,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 4 }},
#define QAPRESULTAUTHENTICATION		75
{QAPRESULTAUTHENTICATION,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 5 }},
#define QAPRESULTENCRYPTION		76
{QAPRESULTENCRYPTION,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 6 }},
#define QAPRESULTRSSI		77
{QAPRESULTRSSI,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 7 }},
#define QAPRESULTBSSID		78
{QAPRESULTBSSID,  ASN_OCTET_STR,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 8 }},
#define QAPRESULTMODE		79
{QAPRESULTMODE,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 9 }},
#define QAPRESULTSTATUS		80
{QAPRESULTSTATUS,  ASN_INTEGER,  RONLY,   var_qAPScanTable, 4,  { 2,2, 1, 10 }},
#define QMAPRESULTINDEX		81
{QMAPRESULTINDEX,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 1 }},
#define QMAPRESULTBAND		82
{QMAPRESULTBAND,  ASN_OCTET_STR,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 2 }},
#define QMAPRESULTSSID		83
{QMAPRESULTSSID,  ASN_OCTET_STR,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 3 }},
#define QMAPRESULTCHANNEL		84
{QMAPRESULTCHANNEL,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 4 }},
#define QMAPRESULTAUTHENTICATION		85
{QMAPRESULTAUTHENTICATION,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 5 }},
#define QMAPRESULTENCRYPTION		86
{QMAPRESULTENCRYPTION,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 6 }},
#define QMAPRESULTRSSI		87
{QMAPRESULTRSSI,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 7 }},
#define QMAPRESULTBSSID		88
{QMAPRESULTBSSID,  ASN_OCTET_STR,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 8 }},
#define QMAPRESULTMODE		89
{QMAPRESULTMODE,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 9 }},
#define QMAPRESULTSTATUS		90
{QMAPRESULTSTATUS,  ASN_INTEGER,  RONLY,   var_qmAPScanTable, 4,  { 4,2, 1, 10 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the quickInternetSetup module */
void
init_quickInternetSetup(void)
{

    DEBUGMSGTL(("quickInternetSetup", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("quickInternetSetup", quickInternetSetup_variables, variable7,
               quickInternetSetup_variables_oid);

    /* place any other initialization junk you need here */  
}

/*
 * var_quickInternetSetup():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_quickInternetSetup(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    char macstr[MACSTRNUM];

    sw_mode = nmp_get_int("sw_mode");  

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL; 

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case QRCONNECTIONTYPE:
        if(sw_mode == SW_MODE_ROUTER)
        {     
            *write_method = write_qRConnectionType;
            if(nmp_safe_get("wan0_proto") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("wan0_proto"));
                if(!strcmp(tmpstr, "dhcp")) /* dhcp */
                    tmpval = 1;
                else if(!strcmp(tmpstr, "pppoe")) /* pppoe */
                    tmpval = 2;
                else if(!strcmp(tmpstr, "static")) /* static */
                    tmpval = 3;
                else if(!strcmp(tmpstr, "pptp")) /* pptp */
                    tmpval = 4;
                else if(!strcmp(tmpstr, "l2tp")) /* l2tp */
                    tmpval = 5;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }               
        }
        return NULL;
    case QRAHOSTNAME:    
        if(sw_mode == SW_MODE_ROUTER)
        {    
            *write_method = write_qRAHostName;
            if(!strcmp(nmp_safe_get("wan0_proto"), "dhcp"))
            {   
                if(nmp_safe_get("wan0_hostname") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);                    
                    strcpy(tmpstr, nmp_safe_get("wan0_hostname"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRAMACADDRESS:
        if(sw_mode == SW_MODE_ROUTER)
        {     
            *write_method = write_qRAMacAddress;
            if(!strcmp(nmp_safe_get("wan0_proto"), "dhcp"))
            {              
                if(nmp_safe_get("wan0_hwaddr_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);             
                    memset(macstr, 0, sizeof(macstr));                    
                    strcpy(macstr, nmp_safe_get("wan0_hwaddr_x"));
                    ether_atoe(macstr, tmpstr);
                    *var_len = 6;
                    return ( u_char * )tmpstr;
                }
            }
        }
        return NULL;
    case QRACONNECTTODNSSERVERAUTOMATICALLY:
        if(sw_mode == SW_MODE_ROUTER)
        {     
            *write_method = write_qRAConnectToDnsServerAutomatically;
            if(!strcmp(nmp_safe_get("wan0_proto"), "dhcp"))
            {                           
                if(nmp_safe_get("wan0_dnsenable_x") != NULL)
                {
                    tmpval = nmp_get_int("wan0_dnsenable_x");
                    if(tmpval == 1) /* yes */
                        tmpval = 1;
                    else if(tmpval == 0) /* no */
                        tmpval = 2;
                    *var_len = sizeof( long );
                    return ( u_char * ) &tmpval;
                }
            }
        }
        return NULL;
    case QRADNSSERVER1:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRADnsServer1;
            if(!strcmp(nmp_safe_get("wan0_proto"), "dhcp"))
            {                             
                if(nmp_safe_get("wan0_dns1_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns1_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRADNSSERVER2:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRADnsServer2;
            if(!strcmp(nmp_safe_get("wan0_proto"), "dhcp"))
            {                      
                if(nmp_safe_get("wan0_dns2_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns2_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPPPOEUSERNAME:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPPPoEUserName;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pppoe"))
            {                      
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                if(nmp_safe_get("wan0_pppoe_username") != NULL)
                {
                    strcpy(tmpstr, nmp_safe_get("wan0_pppoe_username"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPPPOEPASSWORD:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPPPoEPassword;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pppoe"))
            {                      
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                if(nmp_safe_get("wan0_pppoe_passwd") != NULL)
                {
                    strcpy(tmpstr, nmp_safe_get("wan0_pppoe_passwd"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRIPADDRESS:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRIPAddress;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_ipaddr_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_ipaddr_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }
            }
        }
        return NULL;
    case QRSUBNETMASK:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRSubnetMask;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_netmask_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_netmask_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }
            }
        }
        return NULL;
    case QRDEFAULTGATEWAY:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRDefaultGateway;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_gateway_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_gateway_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }                
            }
        }
        return NULL;
    case QRDNSSERVER1:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRDnsServer1;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_dns1_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns1_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRDNSSERVER2:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRDnsServer2;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_dns2_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns2_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRMACADDRESS:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRMacAddress;
            if(!strcmp(nmp_safe_get("wan0_proto"), "static"))
            {                      
                if(nmp_safe_get("wan0_hwaddr_x") != NULL)
                {
                    strcpy(macstr, nmp_safe_get("wan0_hwaddr_x"));
                    ether_atoe(macstr, tmpstr);
                    *var_len = 6;
                    return ( u_char * )tmpstr;
                }
            }
        }
        return NULL;
    case QRUSERNAME:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRUserName;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                if(nmp_safe_get("wan0_pppoe_username") != NULL)
                {
                    strcpy(tmpstr, nmp_safe_get("wan0_pppoe_username"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPASSWORD:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPassword;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                if(nmp_safe_get("wan0_pppoe_passwd") != NULL)
                {
                    strcpy(tmpstr, nmp_safe_get("wan0_pppoe_passwd"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPIPADDRESS:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPIPAddress;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_ipaddr_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_ipaddr_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }
            }
        }
        return NULL;
    case QRPSUBNETMASK:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPSubnetMask;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_netmask_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_netmask_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }
            }
        }
        return NULL;
    case QRPDEFAULTGATEWAY:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPDefaultGateway;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_gateway_x") != NULL)
                {
                    tmpval_u = inet_addr(nmp_safe_get("wan0_gateway_x"));
                    *var_len = sizeof( unsigned long );
                    return ( u_char * ) &tmpval_u;
                }     
            }
        }
        return NULL;
    case QRPCONNECTTODNSSERVERAUTOMATICALLY:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPConnectToDnsServerAutomatically;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_dnsenable_x") != NULL)
                {
                    tmpval = nmp_get_int("wan0_dnsenable_x");
                    if(tmpval == 1) /* yes */
                        tmpval = 1;
                    else if(tmpval == 0) /* no */
                        tmpval = 2;
                    *var_len = sizeof( long );
                    return ( u_char * ) &tmpval;
                }
            }
        }
        return NULL;
    case QRPDNSSERVER1:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPDnsServer1;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_dns1_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns1_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPDNSSERVER2:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPDnsServer2;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                if(nmp_safe_get("wan0_dns2_x") != NULL)
                {
                    memset(tmpstr, 0, SPRINT_MAX_LEN);
                    strcpy(tmpstr, nmp_safe_get("wan0_dns2_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRPVPNSERVER:
        if(sw_mode == SW_MODE_ROUTER)
        {         
            *write_method = write_qRPvpnServer;
            if(!strcmp(nmp_safe_get("wan0_proto"), "pptp") || !strcmp(nmp_safe_get("wan0_proto"), "l2tp"))
            {                      
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                if(nmp_safe_get("wan0_heartbeat_x") != NULL)
                {
                    strcpy(tmpstr, nmp_safe_get("wan0_heartbeat_x"));
                    tmpstr[strlen(tmpstr)] = '\0';
                    *var_len = strlen( tmpstr );
                    return ( u_char * ) tmpstr; 
                }
            }
        }
        return NULL;
    case QRSELECTISPPROFILE:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRSelectISPProfile;
            if(nmp_safe_get("switch_wantag") != NULL)
            {
                if(!strcmp(nmp_get("switch_wantag"), "none")) /* none */
                    tmpval = 1;
                else if(!strcmp(nmp_get("switch_wantag"), "unifi_home")) /* unifi-home */
                    tmpval = 2;
                else if(!strcmp(nmp_get("switch_wantag"), "unifi_biz")) /* unifi-business */
                    tmpval = 3;
                else if(!strcmp(nmp_get("switch_wantag"), "singtel_mio")) /* singtel-mio */
                    tmpval = 4;
                else if(!strcmp(nmp_get("switch_wantag"), "singtel_others")) /* singtel-others */
                    tmpval = 5;
                else if(!strcmp(nmp_get("switch_wantag"), "m1_fiber")) /* m1-fiber */
                    tmpval = 6;
                else if(!strcmp(nmp_get("switch_wantag"), "maxis_fiber")) /* maxis-fiber */
                    tmpval = 7;
                else if(!strcmp(nmp_get("switch_wantag"), "maxis_fiber_sp")) /* maxis-fiber-special */
                    tmpval = 8;
                else if(!strcmp(nmp_get("switch_wantag"), "manual")) /* manual */
                    tmpval = 9;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QRIPTVSTBPORT:
        if(sw_mode == SW_MODE_ROUTER)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            if(!strcmp(nmp_safe_get("switch_wantag"), "unifi_home") || 
                !strcmp(nmp_safe_get("switch_wantag"), "singtel_mio") ||
                !strcmp(nmp_safe_get("switch_wantag"), "singtel_others") ||
                !strcmp(nmp_safe_get("switch_wantag"), "manual") )
            {
                strcpy(tmpstr, "LAN4");
                tmpstr[strlen(tmpstr)] = '\0';
            }

            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;         
        }
        return NULL;
    case QRVOIPPORT:
        if(sw_mode == SW_MODE_ROUTER)
        {
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            if(!strcmp(nmp_get("switch_wantag"), "singtel_mio") || 
                !strcmp(nmp_get("switch_wantag"), "m1_fiber") ||
                !strcmp(nmp_get("switch_wantag"), "maxis_fiber") ||
                !strcmp(nmp_get("switch_wantag"), "maxis_fiber_sp") ||
                !strcmp(nmp_get("switch_wantag"), "manual") )
            {
                strcpy(tmpstr, "LAN3");
                tmpstr[strlen(tmpstr)] = '\0';
            }

            *var_len = strlen( tmpstr );
            return ( u_char * ) tmpstr;         
        }
        return NULL;
    case QRINTERNETVID:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRInternetVID;
            if(nmp_safe_get("switch_wan0tagid") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                sprintf(tmpstr, nmp_safe_get("switch_wan0tagid"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr;
            }
        }
        return NULL;
    case QRINTERNETPRIO:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRInternetPRIO;
            if(nmp_safe_get("switch_wan0prio") != NULL)
            {
                tmpval = nmp_get_int("switch_wan0prio");
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QRLAN4PORTVID:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRLan4PortVID;
            if(nmp_safe_get("switch_wan1tagid") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                sprintf(tmpstr, nmp_safe_get("switch_wan1tagid"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr;
            }
        }
        return NULL;
    case QRLAN4PORTPRIO:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRLan4PortPRIO;
            if(nmp_safe_get("switch_wan1prio") != NULL)
            {
                tmpval = nmp_get_int("switch_wan1prio");
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QRLAN3PORTVID:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRLan3PortVID;
            if(nmp_safe_get("switch_wan2tagid") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                sprintf(tmpstr, nmp_safe_get("switch_wan2tagid"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr;
            }
        }
        return NULL;
    case QRLAN3PORTPRIO:
        if(sw_mode == SW_MODE_ROUTER)
        {
            *write_method = write_qRLan3PortPRIO;
            if(nmp_safe_get("switch_wan2prio") != NULL)
            {
                tmpval = nmp_get_int("switch_wan2prio");
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QRNETWORKNAMEWL2G:
        if(sw_mode == SW_MODE_ROUTER)
        {    
            *write_method = write_qRnetworkNameWl2g;
            if(nmp_safe_get("wl0_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_get("wl0_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }             
        }            
        return NULL;
    case QRNETWORKKEYWL2G:
        if(sw_mode == SW_MODE_ROUTER)
        {           
            *write_method = write_qRnetworkKeyWl2g;            
            if(nmp_safe_get("wl0_wpa_psk") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_safe_get("wl0_wpa_psk"));
                tmpstr[strlen(tmpstr)] = '\0';
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }
        }
        return NULL;
    case QRNETWORKNAMEWL5G:
        if(sw_mode == SW_MODE_ROUTER)
        {      
            *write_method = write_qRnetworkNameWl5g;
            if(nmp_safe_get("wl1_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_get("wl1_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }         
        }
        return NULL;
    case QRNETWORKKEYWL5G:
        if(sw_mode == SW_MODE_ROUTER)
        {      
            *write_method = write_qRnetworkKeyWl5g;
            if(nmp_safe_get("wl1_wpa_psk") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_safe_get("wl1_wpa_psk"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }            
        }
        return NULL;
    case QAPSCANACT:
        if(sw_mode == SW_MODE_REPEATER)        
        {            
            *write_method = write_qAPScanAct;
            *var_len = sizeof( long );
            tmpval = 2; /* 1: scan  2: nothing */
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case QWLCBAND:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        { 
            *write_method = write_qWlcBand;
            if(nmp_safe_get("wlc_band") != NULL)
            {
                tmpval = nmp_get_int("wlc_band");
                if(tmpval == 0) /* 2g */
                    tmpval = 1;
                else if(tmpval == 1) /* 5g */
                    tmpval = 2;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QWLCSSID:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        { 
            *write_method = write_qWlcSsid;
            if(nmp_safe_get("wlc_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                  
                strcpy(tmpstr, nmp_get("wlc_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }  
        }
        return NULL;
    case QWLCAUTHENTICATION:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {     
            *write_method = write_qWlcAuthentication;
            if(nmp_safe_get("wlc_auth_mode") != NULL)
            {
                strcpy(tmpstr, nmp_safe_get("wlc_auth_mode"));
                if(!strcmp(tmpstr, "open")) /* open system */
                    tmpval = 1;
                else if(!strcmp(tmpstr, "shared")) /* shared key */
                    tmpval = 2;
                else if(!strcmp(tmpstr, "psk")) /* wpa personal */
                    tmpval = 3;
                else if(!strcmp(tmpstr, "psk2")) /* wpa2 personal */
                    tmpval = 4;
                else if(!strcmp(tmpstr, "wpa")) /* wpa enterprise */
                    tmpval = 5;
                else if(!strcmp(tmpstr, "wpa2")) /* wpa2 enterprise */
                    tmpval = 6; 
                else if(!strcmp(tmpstr, "radius")) /* radius with 802.1x */
                    tmpval = 7;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }            
        }
        return NULL;
    case QWLCWEPENCRYPTION:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {    
            *write_method = write_qWlcWepEncryption;
            if(nmp_safe_get("wlc_wep") != NULL)
            {
                tmpval = nmp_get_int("wlc_wep");
                if(tmpval == 0) /* none */
                    tmpval = 1;
                else if(tmpval == 1) /* wep 64bits */
                    tmpval = 2;
                else if(tmpval == 2)    /* wep 128bits */
                    tmpval = 3;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }            
        }
        return NULL;
    case QWLCKEYINDEX:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {      
            *write_method = write_qWlcKeyIndex;
            if(strlen(nmp_safe_get("wlc_key")))
            {
                tmpval = nmp_get_int("wlc_key");
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }        
        }
        return NULL;
    case QWLCWEPKEYVALUE:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {       
            *write_method = write_qWlcWepKeyValue;
            if(nmp_safe_get("wlc_wep_key")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_get("wlc_wep_key"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }              
        }
        return NULL;
    case QWLCWPAENCRYPTION:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {
            *write_method = write_qWlcWpaEncryption;            
            tmpval = 0;
            if(nmp_safe_get("wlc_crypto") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);            
                strcpy(tmpstr, nmp_safe_get("wlc_crypto")); 
                if(!strcmp(tmpstr, "tkip")) /* TKIP */
                    tmpval = 1;
                else if(!strcmp(tmpstr, "aes")) /* AES */
                    tmpval = 2;
                else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
                    tmpval = 3;
                  
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;    
            }        
        }
        return NULL;
    case QWLCWPAPRESHAREDKEY:
        if(sw_mode == SW_MODE_REPEATER)/* Repeater */
        {    
            *write_method = write_qWlcWpaPreSharedKey;
             if(nmp_safe_get("wlc_wpa_psk")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);   
                strcpy(tmpstr, nmp_get("wlc_wpa_psk"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }             
        }
        return NULL;
    case QTUSEDEFAULTSETTINGS:
        if(sw_mode == SW_MODE_REPEATER)  
        {    
            *write_method = write_qTUseDefaultSettings;
            tmpval = 2; /* nothing */
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;             
        }
        return NULL;
    case QTNETWORKNAMEWL2G:
        if(sw_mode == SW_MODE_REPEATER)  
        {    
            *write_method = write_qTnetworkNameWl2g;
            if(nmp_safe_get("wl0_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_get("wl0_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            } 
        }        
        return NULL;
    case QTNETWORKKEYWL2G:
        if(sw_mode == SW_MODE_REPEATER)
        {           
            *write_method = write_qTnetworkKeyWl2g;            
            if(nmp_safe_get("wl0_wpa_psk") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_safe_get("wl0_wpa_psk"));
                tmpstr[strlen(tmpstr)] = '\0';
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }
        }
        return NULL;
    case QTNETWORKNAMEWL5G:
        if(sw_mode == SW_MODE_REPEATER)
        {      
            *write_method = write_qTnetworkNameWl5g;
            if(nmp_safe_get("wl1_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_get("wl1_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }         
        }
        return NULL;
    case QTNETWORKKEYWL5G:
        if(sw_mode == SW_MODE_REPEATER)
        {      
            *write_method = write_qTnetworkKeyWl5g;
            if(nmp_safe_get("wl1_wpa_psk") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_safe_get("wl1_wpa_psk"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }            
        }
        return NULL;
    case QLANGETIPAUTOMATICALLY:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {        
            *write_method = write_qlanGetIpAutomatically;            
            if(nmp_safe_get("lan_proto") != NULL)
            {
                if(!strcmp(nmp_get("lan_proto"), "dhcp")) /* dhcp */
                    tmpval = 1;
                else if(!strcmp(nmp_get("lan_proto"), "static")) /* static */
                    tmpval = 2;

                *var_len = sizeof( long );        
                return ( u_char * ) &tmpval;                    
            }
        }
        return NULL;        
    case QLANIPADDRESS:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {        
            *write_method = write_qlanIPAddress;            
            if(nmp_safe_get("lan_ipaddr") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("lan_ipaddr"));
                if(strlen(tmpstr))
                    tmpval_u = inet_addr(tmpstr);
                else
                    tmpval_u = inet_addr("0.0.0.0");

                *var_len = sizeof( unsigned long );
                return ( u_char * ) &tmpval_u;                
            }
        }
        return NULL;
    case QLANSUBNETMASK:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {  
            *write_method = write_qlanSubnetMask;            
            if(nmp_safe_get("lan_netmask") != NULL)
            {
                tmpval_u = inet_addr(nmp_safe_get("lan_netmask"));
                *var_len = sizeof( unsigned long );
                return ( u_char * ) &tmpval_u;
            }
        }
        return NULL;
    case QLANDEFAULTGATEWAY:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0")) 
        {          
            *write_method = write_qlanDefaultGateway;            
            if(nmp_safe_get("lan_gateway") != NULL)
            {
                memset(tmpstr, 0x0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("lan_gateway"));  
                if(strlen(tmpstr))              
                    tmpval_u = inet_addr(nmp_safe_get("lan_gateway"));
                else
                    tmpval_u = inet_addr("0.0.0.0");  

                *var_len = sizeof( unsigned long );
                return ( u_char * ) &tmpval_u;                
            }
        }
        return NULL;
    case QLANCONNECTTODNSSERVERAUTOMATICALLY:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {         
            *write_method = write_qlanConnectToDnsServerAutomatically;            
            if(nmp_safe_get("lan_dnsenable_x") != NULL)
            {
                tmpval = nmp_get_int("lan_dnsenable_x");
                if(tmpval == 1) /* enable */
                    tmpval = 1;
                else if(tmpval == 0) /* disable */
                    tmpval = 2;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;                
            }
        }
        return NULL;
    case QLANDNSSERVER1:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {         
            *write_method = write_qlanDnsServer1;            
            if(nmp_safe_get("lan_dns1_x") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("lan_dns1_x"));
                tmpstr[strlen(tmpstr)] = '\0';
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr;
            }
        }
        return NULL;
    case QLANDNSSERVER2:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {          
            *write_method = write_qlanDnsServer2;            
            if(nmp_safe_get("lan_dns2_x") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("lan_dns2_x"));
                tmpstr[strlen(tmpstr)] = '\0';
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr;
            }
        }
        return NULL;
    case QPNETWORKNAMEWL2G:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {        
            *write_method = write_qPnetworkNameWl2g;            
            if(nmp_safe_get("wl0_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_get("wl0_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }    
        }
        return NULL;
    case QPNETWORKKEYWL2G:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {           
            *write_method = write_qPnetworkKeyWl2g;            
            if(nmp_safe_get("wl0_wpa_psk") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_safe_get("wl0_wpa_psk"));
                tmpstr[strlen(tmpstr)] = '\0';
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }
        }
        return NULL;
    case QPNETWORKNAMEWL5G:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {       
            *write_method = write_qPnetworkNameWl5g;            
            if(nmp_safe_get("wl1_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                  
                strcpy(tmpstr, nmp_get("wl1_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }   
        } 
        return NULL;
    case QPNETWORKKEYWL5G:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "0"))
        {          
            *write_method = write_qPnetworkKeyWl5g;            
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            if(nmp_safe_get("wl1_wpa_psk") != NULL)
            {
                strcpy(tmpstr, nmp_safe_get("wl1_wpa_psk"));
                *var_len = strlen( tmpstr );
                return ( u_char * ) tmpstr; 
            }
        }
        return NULL;
    case QMAPSCANACT:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))//Media Bridge
        { 
            *write_method = write_qmAPScanAct;
            *var_len = sizeof( long );
            tmpval = 2; /* 1: scan  2: nothing */
            return ( u_char * ) &tmpval;
        }
        return NULL;
    case QMWLCBAND:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        { 
            *write_method = write_qmWlcBand;
            if(nmp_safe_get("wlc_band") != NULL)
            {
                tmpval = nmp_get_int("wlc_band");
                if(tmpval == 0) /* 2g */
                    tmpval = 1;
                else if(tmpval == 1) /* 5g */
                    tmpval = 2;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }
        }
        return NULL;
    case QMWLCSSID:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        { 
            *write_method = write_qmWlcSsid;
            if(nmp_safe_get("wlc_ssid")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                  
                strcpy(tmpstr, nmp_get("wlc_ssid"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }  
        }
        return NULL;
    case QMWLCAUTHENTICATION:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {     
            *write_method = write_qmWlcAuthentication;
            if(nmp_safe_get("wlc_auth_mode") != NULL)
            {
                strcpy(tmpstr, nmp_safe_get("wlc_auth_mode"));
                if(!strcmp(tmpstr, "open")) /* open system */
                    tmpval = 1;
                else if(!strcmp(tmpstr, "shared")) /* shared key */
                    tmpval = 2;
                else if(!strcmp(tmpstr, "psk")) /* wpa personal */
                    tmpval = 3;
                else if(!strcmp(tmpstr, "psk2")) /* wpa2 personal */
                    tmpval = 4;
                else if(!strcmp(tmpstr, "wpa")) /* wpa enterprise */
                    tmpval = 5;
                else if(!strcmp(tmpstr, "wpa2")) /* wpa2 enterprise */
                    tmpval = 6; 
                else if(!strcmp(tmpstr, "radius")) /* radius with 802.1x */
                    tmpval = 7;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }            
        }
        return NULL;
    case QMWLCWEPENCRYPTION:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {    
            *write_method = write_qmWlcWepEncryption;
            if(nmp_safe_get("wlc_wep") != NULL)
            {
                tmpval = nmp_get_int("wlc_wep");
                if(tmpval == 0) /* none */
                    tmpval = 1;
                else if(tmpval == 1) /* wep 64bits */
                    tmpval = 2;
                else if(tmpval == 2)    /* wep 128bits */
                    tmpval = 3;
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }            
        }
        return NULL;
    case QMWLCKEYINDEX:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {      
            *write_method = write_qmWlcKeyIndex;
            if(strlen(nmp_safe_get("wlc_key")))
            {
                tmpval = nmp_get_int("wlc_key");
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;
            }        
        }
        return NULL;
    case QMWLCWEPKEYVALUE:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {       
            *write_method = write_qmWlcWepKeyValue;
            if(nmp_safe_get("wlc_wep_key")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);                
                strcpy(tmpstr, nmp_get("wlc_wep_key"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }              
        }
        return NULL;
    case QMWLCWPAENCRYPTION:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {
            *write_method = write_qmWlcWpaEncryption;            
            tmpval = 0;
            if(nmp_safe_get("wlc_crypto") != NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);            
                strcpy(tmpstr, nmp_safe_get("wlc_crypto")); 
                if(!strcmp(tmpstr, "tkip")) /* TKIP */
                    tmpval = 1;
                else if(!strcmp(tmpstr, "aes")) /* AES */
                    tmpval = 2;
                else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
                    tmpval = 3;
                  
                *var_len = sizeof( long );
                return ( u_char * ) &tmpval;    
            }        
        }
        return NULL;
    case QMWLCWPAPRESHAREDKEY:
        if(sw_mode == SW_MODE_AP && !strcmp(nmp_safe_get("wlc_psta"), "1"))/* Media Bridge */
        {    
            *write_method = write_qmWlcWpaPreSharedKey;
             if(nmp_safe_get("wlc_wpa_psk")!=NULL)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);   
                strcpy(tmpstr, nmp_get("wlc_wpa_psk"));
                *var_len = strlen(tmpstr);
                return ( u_char * ) tmpstr;
            }             
        }
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_qAPScanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_quickInternetSetup above.
 */
unsigned char *
var_qAPScanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    long index = 0;

    sw_mode = nmp_get_int("sw_mode");  

    if(sw_mode != SW_MODE_REPEATER)
        return NULL;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 32/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case QAPRESULTINDEX:
        return NULL;
    case QAPRESULTBAND:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].band);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }   
        return NULL;
    case QAPRESULTSSID:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].ssid);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }   
        return NULL;
    case QAPRESULTCHANNEL:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            *var_len = sizeof( long );
            tmpval = apinfo[index].channel;
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QAPRESULTAUTHENTICATION:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            if(!strcmp(apinfo[index].auth, "Open System"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].auth, "WPA"))     
                tmpval = 2;
            else if(!strcmp(apinfo[index].auth, "WPA2"))        
                tmpval = 3;
            else if(!strcmp(apinfo[index].auth, "WPA-PSK"))     
                tmpval = 4;
            else if(!strcmp(apinfo[index].auth, "WPA2-PSK"))        
                tmpval = 5;
            else if(!strcmp(apinfo[index].auth, "NONE"))        
                tmpval = 6;
            else if(!strcmp(apinfo[index].auth, "IEEE 802.1X"))     
                tmpval = 7;
            else if(!strcmp(apinfo[index].auth, "Unknown"))     
                tmpval = 8;

            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QAPRESULTENCRYPTION:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            if(!strcmp(apinfo[index].enc, "NONE"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].enc, "WEP"))      
                tmpval = 2;
            else if(!strcmp(apinfo[index].enc, "TKIP"))     
                tmpval = 3;
            else if(!strcmp(apinfo[index].enc, "AES"))      
                tmpval = 4;
            else if(!strcmp(apinfo[index].enc, "TKIP+AES"))     
                tmpval = 5;
            else if(!strcmp(apinfo[index].enc, "Unknown"))      
                tmpval = 6;

            *var_len = sizeof( long );            
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QAPRESULTRSSI:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            tmpval = apinfo[index].rssi;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QAPRESULTBSSID:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].bssid);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;      
        }   
        return NULL;
    case QAPRESULTMODE:
        index = name[*length-1]-1;
        if(index < ap_count)
        {       
            if(!strcmp(apinfo[index].mode, "a"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].mode, "b"))       
                tmpval = 2;
            else if(!strcmp(apinfo[index].mode, "an"))      
                tmpval = 3;
            else if(!strcmp(apinfo[index].mode, "bg"))      
                tmpval = 4;
            else if(!strcmp(apinfo[index].mode, "bgn"))     
                tmpval = 5;

            *var_len = sizeof( long );        
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QAPRESULTSTATUS:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            tmpval = apinfo[index].status;
            *var_len = sizeof( long );            
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_qmAPScanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_quickInternetSetup above.
 */
unsigned char *
var_qmAPScanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    long index = 0;

    sw_mode = nmp_get_int("sw_mode");  
    
    if(sw_mode != SW_MODE_AP && strcmp(nmp_safe_get("wlc_psta"), "1"))
        return NULL;
    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 32/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case QMAPRESULTINDEX:     
        return NULL;
    case QMAPRESULTBAND:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].band);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }        
        return NULL;
    case QMAPRESULTSSID:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].ssid);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;          
        }          
        return NULL;
    case QMAPRESULTCHANNEL:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            *var_len = sizeof( long );
            tmpval = apinfo[index].channel;
            return ( u_char * ) &tmpval;        
        }       
        return NULL;
    case QMAPRESULTAUTHENTICATION:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            if(!strcmp(apinfo[index].auth, "Open System"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].auth, "WPA"))     
                tmpval = 2;
            else if(!strcmp(apinfo[index].auth, "WPA2"))        
                tmpval = 3;
            else if(!strcmp(apinfo[index].auth, "WPA-PSK"))     
                tmpval = 4;
            else if(!strcmp(apinfo[index].auth, "WPA2-PSK"))        
                tmpval = 5;
            else if(!strcmp(apinfo[index].auth, "NONE"))        
                tmpval = 6;
            else if(!strcmp(apinfo[index].auth, "IEEE 802.1X"))     
                tmpval = 7;
            else if(!strcmp(apinfo[index].auth, "Unknown"))     
                tmpval = 8;

            *var_len = sizeof( long );            
            return ( u_char * ) &tmpval;        
        }      
        return NULL;
    case QMAPRESULTENCRYPTION:
        index = name[*length-1]-1;
        if(index < ap_count)
        {           
            if(!strcmp(apinfo[index].enc, "NONE"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].enc, "WEP"))      
                tmpval = 2;
            else if(!strcmp(apinfo[index].enc, "TKIP"))     
                tmpval = 3;
            else if(!strcmp(apinfo[index].enc, "AES"))      
                tmpval = 4;
            else if(!strcmp(apinfo[index].enc, "TKIP+AES"))     
                tmpval = 5;
            else if(!strcmp(apinfo[index].enc, "Unknown"))      
                tmpval = 6;

            *var_len = sizeof( long );        
            return ( u_char * ) &tmpval;        
        }          
        return NULL;
    case QMAPRESULTRSSI:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            tmpval = apinfo[index].rssi;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;        
        }       
        return NULL;
    case QMAPRESULTBSSID:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpstr,"%s", apinfo[index].bssid);
            *var_len = strlen(tmpstr);
            return ( u_char * )tmpstr;      
        }    
        return NULL;
    case QMAPRESULTMODE:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            if(!strcmp(apinfo[index].mode, "a"))
                tmpval = 1;
            else if(!strcmp(apinfo[index].mode, "b"))       
                tmpval = 2;
            else if(!strcmp(apinfo[index].mode, "an"))      
                tmpval = 3;
            else if(!strcmp(apinfo[index].mode, "bg"))      
                tmpval = 4;
            else if(!strcmp(apinfo[index].mode, "bgn"))     
                tmpval = 5;

            *var_len = sizeof( long );        
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    case QMAPRESULTSTATUS:
        index = name[*length-1]-1;
        if(index < ap_count)
        {
            tmpval = apinfo[index].status;            
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;        
        }   
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_qRConnectionType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 5) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* dhcp */
                    nmp_set("wan0_proto", "dhcp");
                    break;
                case 2:/* pppoe */
                    nmp_set("wan0_proto", "pppoe");
                    break;
                case 3:  /* static */
                    nmp_set("wan0_proto", "static");
                    break;
                case 4:/* pptp */
                    nmp_set("wan0_proto", "pptp");
                    break;
                case 5:/* l2tp */
                    nmp_set("wan0_proto", "l2tp");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRAHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 32 ) {
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_hostname", tmpstr);                       
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRAMacAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char macaddr[MACSTRNUM];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(macaddr, 0, MACSTRNUM);
            ether_etoa(var_val, macaddr);
            if(strcmp("00:00:00:00:00:00", macaddr))
                nmp_set("wan0_hwaddr_x", macaddr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRAConnectToDnsServerAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(!strcmp(nmp_safe_get("wan0_dhcpenable_x"), "0")){
                if(value == 1)
                    return SNMP_ERR_WRONGVALUE;
                else
                    nmp_set("wan0_dnsenable_x", "0");
            }
            else{
                if(value == 1)
                    nmp_set("wan0_dnsenable_x", "1");
                else if(value == 2)
                    nmp_set("wan0_dnsenable_x", "0");
            }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRADnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns1_x", tmpstr);                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRADnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns2_x", tmpstr);                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPPPoEUserName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_pppoe_username", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPPPoEPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_pppoe_passwd", tmpstr);                    
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_ipaddr_x", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_netmask_x", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_gateway_x", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRDnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns1_x", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRDnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns2_x", tmpstr);                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRMacAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char macaddr[MACSTRNUM];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(macaddr, 0, MACSTRNUM);
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
                  nmp_set("wan0_hwaddr_x", macaddr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRUserName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }   
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_pppoe_username", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 64 ) {
              fprintf(stderr, "write to lPassword: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }   
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_pppoe_passwd", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_ipaddr_x", tmpstr);                 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_netmask_x", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("wan0_gateway_x", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPConnectToDnsServerAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(!strcmp(nmp_safe_get("wan0_dhcpenable_x"), "0")){
                if(value == 1)
                    return SNMP_ERR_WRONGVALUE;
                else
                    nmp_set("wan0_dnsenable_x", "0");
            }
            else{
                if(value == 1)
                    nmp_set("wan0_dnsenable_x", "1");
                else if(value == 2)
                    nmp_set("wan0_dnsenable_x", "0");
            }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPDnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns1_x", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPDnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wan0_dns2_x", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRPvpnServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 1 || var_val_len > 256 ) {
              fprintf(stderr, "write to wvpnServer: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
              memset(tmpstr, 0, SPRINT_MAX_LEN);
              strncpy(tmpstr, (u_char *)var_val, var_val_len); 
              tmpstr[var_val_len] = '\0';
              nmp_set("wan0_heartbeat_x", tmpstr);                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRSelectISPProfile(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* none */
                    nmp_set("switch_wantag", "none");
                    nmp_set("switch_stb_x", "0");
                    break;
                case 2:/* unifi-home */
                    nmp_set("switch_wantag", "unifi_home");
                    nmp_set("switch_stb_x", "4");
                    nmp_set("switch_wan0tagid", "500");
                    nmp_set("switch_wan0tagid", "500");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "600");
                    nmp_set("switch_wan1prio", "0");
                    nmp_set("switch_wan2tagid", "");
                    nmp_set("switch_wan2prio", "0");
                    break;
                case 3: /* unifi-business */
                    nmp_set("switch_wantag", "unifi_biz");
                    nmp_set("switch_stb_x", "0");
                    nmp_set("switch_wan0tagid", "500");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "");
                    nmp_set("switch_wan1prio", "0");
                    nmp_set("switch_wan2tagid", "");
                    nmp_set("switch_wan2prio", "0");
                    break;
                case 4:/* singtel-mio */
                    nmp_set("switch_wantag", "singtel_mio");
                    nmp_set("switch_stb_x", "6");
                    nmp_set("switch_wan0tagid", "10");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "20");
                    nmp_set("switch_wan1prio", "4");
                    nmp_set("switch_wan2tagid", "30");
                    nmp_set("switch_wan2prio", "4");    
                    break;
                case 5:/* singtel-others */
                    nmp_set("switch_wantag", "singtel_others");
                    nmp_set("switch_stb_x", "4");
                    nmp_set("switch_wan0tagid", "10");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "20");
                    nmp_set("switch_wan1prio", "4");
                    nmp_set("switch_wan2tagid", "");
                    nmp_set("switch_wan2prio", "0");
                    break;
                case 6: /* m1-fiber */
                    nmp_set("switch_wantag", "m1_fiber");
                    nmp_set("switch_stb_x", "3");
                    nmp_set("switch_wan0tagid", "1103");
                    nmp_set("switch_wan0prio", "1");
                    nmp_set("switch_wan1tagid", "");
                    nmp_set("switch_wan1prio", "0");
                    nmp_set("switch_wan2tagid", "1107");
                    nmp_set("switch_wan2prio", "1");
                    break;
                case 7:/* maxis-fiber */
                    nmp_set("switch_wantag", "maxis_fiber");
                    nmp_set("switch_stb_x", "3");
                    nmp_set("switch_wan0tagid", "621");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "");
                    nmp_set("switch_wan1prio", "0");
                    nmp_set("switch_wan2tagid", "821,822");
                    nmp_set("switch_wan2prio", "0");
                    break;
                case 8:/* maxis-fiber-special */
                    nmp_set("switch_wantag", "maxis_fiber_sp");
                    nmp_set("switch_stb_x", "3");
                    nmp_set("switch_wan0tagid", "11");
                    nmp_set("switch_wan0prio", "0");
                    nmp_set("switch_wan1tagid", "");
                    nmp_set("switch_wan1prio", "0");
                    nmp_set("switch_wan2tagid", "14");
                    nmp_set("switch_wan2prio", "0");
                    break;
                case 9: /* manual */
                    nmp_set("switch_wantag", "manual");
                    break;
            }                      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRInternetVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;        

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( value_i != 0 && (value_i < 2 || value_i > 4094) ) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set("switch_wan0tagid", string);                 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRInternetPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to internetPRIO: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("switch_wan0prio", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRLan4PortVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value_i != 0 && (value_i < 2 || value_i > 4094)) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("switch_wan1tagid", string);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRLan4PortPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("switch_wan1prio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRLan3PortVID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int value_i;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;

    strncpy(string, (u_char *)var_val, var_val_len);
    string[var_val_len] = '\0';
    value_i = atoi(string);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 4) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value_i != 0 && (value_i < 2 || value_i > 4094)) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("switch_wan2tagid", string);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRLan3PortPRIO(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    if( strcmp(nmp_safe_get("switch_wantag"), "manual") )/* This variable can be set only when selectISPProfile is 'manual'. */
    return SNMP_ERR_NOTWRITABLE;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 7) {
              fprintf(stderr, "write to quickInternetSetup: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("switch_wan2prio", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRnetworkNameWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl0_ssid", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRnetworkKeyWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }

          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl0_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl0_auth_mode_x", "psk2");
                nmp_set("wl0_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl0_wpa_psk", tmpstr);       
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRnetworkNameWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }   
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl1_ssid", tmpstr);                      
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qRnetworkKeyWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl1_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl1_auth_mode_x", "psk2");
                nmp_set("wl1_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl1_wpa_psk", tmpstr);       
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qAPScanAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }               
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)              
                ap_count = wlcscan_core(&apinfo, 0);   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcBand(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qWlcBand not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qWlcBand: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to qWlcBand: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* 2g */
                    nmp_set("wlc_band", "0");
                    break;
                case 2:/* 5g */
                    nmp_set("wlc_band", "1");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcSsid(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to qWlcSsid not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr,"write to qWlcSsid: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_ssid", tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcAuthentication(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qWlcAuthentication not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qWlcAuthentication: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 7) {
              fprintf(stderr, "write to qWlcAuthentication: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* open system */
                    nmp_set("wlc_auth_mode", "open");
                    break;
                case 2:/* shared key */
                    nmp_set("wlc_auth_mode", "shared");
                    break;
                case 3: /* wpa personal */
                    nmp_set("wlc_auth_mode", "psk");
                    break;
                case 4:/* wpa2 personal */
                    nmp_set("wlc_auth_mode", "psk2");
                    break;
                case 5: /* wpa enterprise */
                    nmp_set("wlc_auth_mode", "wpa");
                    break;
                case 6:/* wpa2 enterprise */
                    nmp_set("wlc_auth_mode", "wpa2");
                    break;
                case 7: /* radius with 802.1x */
                    nmp_set("wlc_auth_mode", "radius");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcWepEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qWlcWepEncryption not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qWlcWepEncryption: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf(stderr, "write to qWlcWepEncryption: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* none */
                    nmp_set("wlc_wep", "0");
                    break;
                case 2:/* wep 64bits */
                    nmp_set("wlc_wep", "1");
                    break;
                case 3: /* wep 128bits */
                    nmp_set("wlc_wep", "2");
                    break;
            }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcKeyIndex(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qWlcKeyIndex not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qWlcKeyIndex: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to qWlcKeyIndex: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("wlc_key", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcWepKeyValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to qWlcWepKeyValue not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26) {
              fprintf(stderr,"write to qWlcWepKeyValue: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_wep_key", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcWpaEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qWlcWpaEncryption not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qWlcWpaEncryption: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write qWlcWpaEncryption: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }

          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* TKIP */
                    nmp_set("wlc_crypto", "tkip");
                    break;
                case 2:/* AES */
                    nmp_set("wlc_crypto", "aes");
                    break;
                case 3:/* TKIP+AES */
                    nmp_set("wlc_crypto", "tkip+aes");
                    break;
            }                 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qWlcWpaPreSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to qWlcWpaPreSharedKey not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to qWlcWpaPreSharedKey: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_wpa_psk", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qTUseDefaultSettings(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int is5Gsupport;

    value = * (long *) var_val;
    is5Gsupport = strstr(nmp_safe_get("rc_support"), "5G");

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
            {
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strcpy(tmpstr, nmp_safe_get("wlc_ssid"));                    
                if(!strcmp(nmp_safe_get("wlc_band"), "0"))
                {                
                    nmp_set("wl0_ssid", tmpstr); 
                    if(is5Gsupport)
                        nmp_set("wl1_ssid", strcat(tmpstr, "_5G"));            
                }                    
                else if(!strcmp(nmp_safe_get("wlc_band"), "1"))
                {
                    if(is5Gsupport)
                        nmp_set("wl1_ssid", tmpstr);   
                    nmp_set("wl0_ssid", strcat(tmpstr, "_2G"));   
                }   

                if( !strcmp(nmp_safe_get("wlc_auth_mode"), "shared") || 
                   (!strcmp(nmp_safe_get("wlc_auth_mode"), "open") && nmp_get_int("wlc_wep") != 0 ) )
                {

                    nmp_set("wl0_wep_x", nmp_safe_get("wlc_wep"));           
                    nmp_set("wl0_wpa_psk", nmp_safe_get("wlc_wep_key"));
                    nmp_set("wl0_key", nmp_safe_get("wlc_key"));
                    if(nmp_get_int("wl0_key") == 1)
                        nmp_set("wl0_key1", nmp_safe_get("wlc_wep_key"));
                    else if(nmp_get_int("wl0_key") == 2)
                         nmp_set("wl0_key2", nmp_safe_get("wlc_wep_key"));
                    else if(nmp_get_int("wl0_key") == 3)
                         nmp_set("wl0_key3", nmp_safe_get("wlc_wep_key"));
                    else if(nmp_get_int("wl0_key") == 4)
                         nmp_set("wl0_key4", nmp_safe_get("wlc_wep_key")); 
                
                    if(is5Gsupport)
                    {
                        nmp_set("wl1_wep_x", nmp_safe_get("wlc_wep"));           
                        nmp_set("wl1_wpa_psk", nmp_safe_get("wlc_wep_key"));
                        nmp_set("wl1_key", nmp_safe_get("wlc_key"));
                        if(nmp_get_int("wl1_key") == 1)
                            nmp_set("wl1_key1", nmp_safe_get("wlc_wep_key"));
                        else if(nmp_get_int("wl1_key") == 2)
                             nmp_set("wl1_key2", nmp_safe_get("wlc_wep_key"));
                        else if(nmp_get_int("wl0_key") == 3)
                             nmp_set("wl0_key3", nmp_safe_get("wlc_wep_key"));
                        else if(nmp_get_int("wl0_key") == 4)
                             nmp_set("wl0_key4", nmp_safe_get("wlc_wep_key"));  
                    }
                }
                else
                {
                    nmp_set("wl0_wpa_psk", nmp_safe_get("wlc_wpa_psk"));
                    if(is5Gsupport)   
                        nmp_set("wl1_wpa_psk", nmp_safe_get("wlc_wpa_psk"));   
                }
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qTnetworkNameWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          } 
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl0_ssid", tmpstr);                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qTnetworkKeyWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl0_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl0_auth_mode_x", "psk2");
                nmp_set("wl0_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl0_wpa_psk", tmpstr);       
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qTnetworkNameWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl1_ssid", tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qTnetworkKeyWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }

          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl1_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl1_auth_mode_x", "psk2");
                nmp_set("wl1_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl1_wpa_psk", tmpstr);       
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanGetIpAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
                nmp_set("lan_proto", "dhcp");
            else if(value == 2)
                nmp_set("lan_proto", "static");              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_ipaddr", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanSubnetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_netmask", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanDefaultGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    struct in_addr addr;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to quickInternetSetup not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             tmpval_u = *(u_long *)var_val;
             addr.s_addr = tmpval_u;
             strcpy(tmpstr, (char *)inet_ntoa(addr));
             nmp_set("lan_gateway", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanConnectToDnsServerAutomatically(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)
                nmp_set("lan_dnsenable_x", "1");
            else if(value == 2)
                nmp_set("lan_dnsenable_x", "0");              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanDnsServer1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }   
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';              
            nmp_set("lan_dns1_x", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qlanDnsServer2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 15) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          } 
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';              
            nmp_set("lan_dns2_x", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qPnetworkNameWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          } 
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl0_ssid", tmpstr);                   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qPnetworkKeyWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl0_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl0_auth_mode_x", "psk2");
                nmp_set("wl0_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl0_wpa_psk", tmpstr);       
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qPnetworkNameWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }           
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wl1_ssid", tmpstr);                  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qPnetworkKeyWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(var_val_len == 0)
                nmp_set("wl1_auth_mode_x", "open");  
            else
            {  
                nmp_set("wl1_auth_mode_x", "psk2");
                nmp_set("wl1_crypto", "aes"); 
                memset(tmpstr, 0, SPRINT_MAX_LEN);
                strncpy(tmpstr, (u_char *)var_val, var_val_len);
                tmpstr[var_val_len] = '\0';
                nmp_set("wl1_wpa_psk", tmpstr);    
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmAPScanAct(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to quickInternetSetup not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to quickInternetSetup: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to quickInternetSetup: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1)              
                ap_count = wlcscan_core(&apinfo, 0);       
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcBand(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qmWlcBand not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qmWlcBand: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2) {
              fprintf(stderr, "write to qmWlcBand: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* 2g */
                    nmp_set("wlc_band", "0");
                    break;
                case 2:/* 5g */
                    nmp_set("wlc_band", "1");
                    break;
            }                
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcSsid(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to qmWlcSsid not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
              fprintf(stderr,"write to qmWlcSsid: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);              
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_ssid", tmpstr);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcAuthentication(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qmWlcAuthentication not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qmWlcAuthentication: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 7) {
              fprintf(stderr, "write to qmWlcAuthentication: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* open system */
                    nmp_set("wlc_auth_mode", "open");
                    break;
                case 2:/* shared key */
                    nmp_set("wlc_auth_mode", "shared");
                    break;
                case 3: /* wpa personal */
                    nmp_set("wlc_auth_mode", "psk");
                    break;
                case 4:/* wpa2 personal */
                    nmp_set("wlc_auth_mode", "psk2");
                    break;
                case 5: /* wpa enterprise */
                    nmp_set("wlc_auth_mode", "wpa");
                    break;
                case 6:/* wpa2 enterprise */
                    nmp_set("wlc_auth_mode", "wpa2");
                    break;
                case 7: /* radius with 802.1x */
                    nmp_set("wlc_auth_mode", "radius");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcWepEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qmWlcWepEncryption not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qmWlcWepEncryption: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf(stderr, "write to qmWlcWepEncryption: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* none */
                    nmp_set("wlc_wep", "0");
                    break;
                case 2:/* wep 64bits */
                    nmp_set("wlc_wep", "1");
                    break;
                case 3: /* wep 128bits */
                    nmp_set("wlc_wep", "2");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcKeyIndex(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qmWlcKeyIndex not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qmWlcKeyIndex: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to qmWlcKeyIndex: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }           
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            nmp_set_int("wlc_key", value);              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcWepKeyValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to qmWlcWepKeyValue not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26) {
              fprintf(stderr,"write to qmWlcWepKeyValue: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_wep_key", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcWpaEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to qmWlcWpaEncryption not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to qmWlcWpaEncryption: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
         if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write qmWlcWpaEncryption: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            switch(value)
            {
                case 1:/* TKIP */
                    nmp_set("wlc_crypto", "tkip");
                    break;
                case 2:/* AES */
                    nmp_set("wlc_crypto", "aes");
                    break;
                case 3:/* TKIP+AES */
                    nmp_set("wlc_crypto", "tkip+aes");
                    break;
            }              
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_qmWlcWpaPreSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to quickInternetSetup not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to qWlcWpaPreSharedKey: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0, SPRINT_MAX_LEN);
            strncpy(tmpstr, (u_char *)var_val, var_val_len); 
            tmpstr[var_val_len] = '\0';
            nmp_set("wlc_wpa_psk", tmpstr);               
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

