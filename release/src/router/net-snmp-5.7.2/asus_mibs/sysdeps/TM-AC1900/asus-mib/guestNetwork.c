/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "guestNetwork.h"
#include <nmp.h>

#define DUAL_BAND	1
static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static unsigned long tmpval_u = 0;
static char tmpname[32];
static int sw_mode = 0;

/* 
 * guestNetwork_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid guestNetwork_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,10 };

/* 
 * variable7 guestNetwork_variables:
 *   this variable defines function callbacks and type return information 
 *   for the guestNetwork mib section 
 */

struct variable7 guestNetwork_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define GINDEXWL2G		1
{GINDEXWL2G,  ASN_INTEGER,  RONLY,   var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 1 }},
#define GENABLEWL2G		2
{GENABLEWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 2 }},
#define GSSIDWL2G		3
{GSSIDWL2G,  ASN_OCTET_STR,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 3 }},
#define GAUTHENTICATIONWL2G		4
{GAUTHENTICATIONWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 4 }},
#define GWEPENCRYPTIONWL2G		5
{GWEPENCRYPTIONWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 5 }},
#define GKEYINDEXWL2G		6
{GKEYINDEXWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 6 }},
#define GPASSPHRASEWL2G		7
{GPASSPHRASEWL2G,  ASN_OCTET_STR,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 7 }},
#define GWPAENCRYPTIONWL2G		8
{GWPAENCRYPTIONWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 8 }},
#define GWPAPRESHAREDKEYWL2G		9
{GWPAPRESHAREDKEYWL2G,  ASN_OCTET_STR,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 9 }},
#define GACCESSTIMEWL2G		10
{GACCESSTIMEWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 10 }},
#define GACCESSTIMEHWL2G		11
{GACCESSTIMEHWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 11 }},
#define GACCESSTIMEMWL2G		12
{GACCESSTIMEMWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 12 }},
#define GACCESSINTRANETWL2G		13
{GACCESSINTRANETWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 13 }},
#define GENABLEMACFILTERWL2G		14
{GENABLEMACFILTERWL2G,  ASN_INTEGER,  RWRITE,  var_wl2gGuestNetworkTable, 4,  { 1,1, 1, 14 }},
#define GWEPKEYINDEX1WL2G		15
{GWEPKEYINDEX1WL2G,  ASN_INTEGER,  RONLY,   var_gWl2gSSID1WepKeyTable, 5,  { 1,2,1, 1, 1 }},
#define GWEPKEYVALUE1WL2G		16
{GWEPKEYVALUE1WL2G,  ASN_OCTET_STR,  RWRITE,  var_gWl2gSSID1WepKeyTable, 5,  { 1,2,1, 1, 2 }},
#define GWEPKEYINDEX2WL2G		17
{GWEPKEYINDEX2WL2G,  ASN_INTEGER,  RONLY,   var_gWl2gSSID2WepKeyTable, 5,  { 1,2,2, 1, 1 }},
#define GWEPKEYVALUE2WL2G		18
{GWEPKEYVALUE2WL2G,  ASN_OCTET_STR,  RWRITE,  var_gWl2gSSID2WepKeyTable, 5,  { 1,2,2, 1, 2 }},
#define GWEPKEYINDEX3WL2G		19
{GWEPKEYINDEX3WL2G,  ASN_INTEGER,  RONLY,   var_gWl2gSSID3WepKeyTable, 5,  { 1,2,3, 1, 1 }},
#define GWEPKEYVALUE3WL2G		20
{GWEPKEYVALUE3WL2G,  ASN_OCTET_STR,  RWRITE,  var_gWl2gSSID3WepKeyTable, 5,  { 1,2,3, 1, 2 }},
#ifdef DUAL_BAND
#define GINDEXWL5G		21
{GINDEXWL5G,  ASN_INTEGER,  RONLY,   var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 1 }},
#define GENABLEWL5G		22
{GENABLEWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 2 }},
#define GSSIDWL5G		23
{GSSIDWL5G,  ASN_OCTET_STR,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 3 }},
#define GAUTHENTICATIONWL5G		24
{GAUTHENTICATIONWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 4 }},
#define GWEPENCRYPTIONWL5G		25
{GWEPENCRYPTIONWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 5 }},
#define GKEYINDEXWL5G		26
{GKEYINDEXWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 6 }},
#define GPASSPHRASEWL5G		27
{GPASSPHRASEWL5G,  ASN_OCTET_STR,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 7 }},
#define GWPAENCRYPTIONWL5G		28
{GWPAENCRYPTIONWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 8 }},
#define GWPAPRESHAREDKEYWL5G		29
{GWPAPRESHAREDKEYWL5G,  ASN_OCTET_STR,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 9 }},
#define GACCESSTIMEWL5G		30
{GACCESSTIMEWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 10 }},
#define GACCESSTIMEHWL5G		31
{GACCESSTIMEHWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 11 }},
#define GACCESSTIMEMWL5G		32
{GACCESSTIMEMWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 12 }},
#define GACCESSINTRANETWL5G		33
{GACCESSINTRANETWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 13 }},
#define GENABLEMACFILTERWL5G		34
{GENABLEMACFILTERWL5G,  ASN_INTEGER,  RWRITE,  var_wl5gGuestNetworkTable, 4,  { 2,1, 1, 14 }},
#define GWEPKEYINDEX1WL5G		35
{GWEPKEYINDEX1WL5G,  ASN_INTEGER,  RONLY,   var_gWl5gSSID1WepKeyTable, 5,  { 2,2,1, 1, 1 }},
#define GWEPKEYVALUE1WL5G		36
{GWEPKEYVALUE1WL5G,  ASN_OCTET_STR,  RWRITE,  var_gWl5gSSID1WepKeyTable, 5,  { 2,2,1, 1, 2 }},
#define GWEPKEYINDEX2WL5G		37
{GWEPKEYINDEX2WL5G,  ASN_INTEGER,  RONLY,   var_gWl5gSSID2WepKeyTable, 5,  { 2,2,2, 1, 1 }},
#define GWEPKEYVALUE2WL5G		38
{GWEPKEYVALUE2WL5G,  ASN_OCTET_STR,  RWRITE,  var_gWl5gSSID2WepKeyTable, 5,  { 2,2,2, 1, 2 }},
#define GWEPKEYINDEX3WL5G		39
{GWEPKEYINDEX3WL5G,  ASN_INTEGER,  RONLY,   var_gWl5gSSID3WepKeyTable, 5,  { 2,2,3, 1, 1 }},
#define GWEPKEYVALUE3WL5G		40
{GWEPKEYVALUE3WL5G,  ASN_OCTET_STR,  RWRITE,  var_gWl5gSSID3WepKeyTable, 5,  { 2,2,3, 1, 2 }},
#endif	//#ifdef DUAL_BAND
};
/*    (L = length of the oidsuffix) */


/** Initializes the guestNetwork module */
void
init_guestNetwork(void)
{

    DEBUGMSGTL(("guestNetwork", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("guestNetwork", guestNetwork_variables, variable7,
               guestNetwork_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_guestNetwork():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_guestNetwork(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{

    if(sw_mode == SW_MODE_REPEATER)	//Doesn't support in repeater mode
        return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_wl2gGuestNetworkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_wl2gGuestNetworkTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 3 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GINDEXWL2G:
        return NULL;
    case GENABLEWL2G:
        *write_method = write_gEnableWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_bss_enabled", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval == 1) /* enable */
    			tmpval = 1;
    		else if(tmpval == 0) /* disable */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GSSIDWL2G:
        *write_method = write_gSSIDWl2g;
        index = name[*length-1];
        sprintf(tmpname, "wl0.%d_ssid", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		strcpy(tmpstr, nmp_get(tmpname));
    		*var_len = strlen(tmpstr);
    		return ( u_char * ) tmpstr;
      	}	
        return NULL;
    case GAUTHENTICATIONWL2G:
        *write_method = write_gAuthenticationWl2g;
        index = name[*length-1];
        sprintf(tmpname, "wl0.%d_auth_mode_x", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = 0;
    		if(!strcmp(nmp_get(tmpname), "open")) /* open system */
    			tmpval = 1;
    		else if(!strcmp(nmp_get(tmpname), "shared")) /* shared key */
    			tmpval = 2;
    		else if(!strcmp(nmp_get(tmpname), "psk")) /* wpa personal */
    			tmpval = 3;
    		else if(!strcmp(nmp_get(tmpname), "psk2")) /* wpa2 personal */
    			tmpval = 4;
    		else if(!strcmp(nmp_get(tmpname), "pskpsk2")) /* wpa auto personal */
    			tmpval = 5;
            else if(!strcmp(nmp_get(tmpname), "wpa")) /* wpa enterprise */
                tmpval = 6;
            else if(!strcmp(nmp_get(tmpname), "wpa2")) /* wpa2 enterprise */
                tmpval = 7;
            else if(!strcmp(nmp_get(tmpname), "wpawpa2")) /* wpa auto enterprise */
                tmpval = 8;
            else if(!strcmp(nmp_get(tmpname), "radius")) /* radius with 802.1x */
                tmpval = 9;                
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GWEPENCRYPTIONWL2G:
        *write_method = write_gWepEncryptionWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_wep_x", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval == 0) /* none */
    			tmpval = 1;
    		else if(tmpval == 1) /* wep 64bits */
    			tmpval = 2;
    		else if(tmpval == 2)	/* wep 128bits */
    			tmpval = 3;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case GKEYINDEXWL2G:
        *write_method = write_gKeyIndexWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_key", index);
        if(strlen(nmp_safe_get(tmpname)))
      	{
    		tmpval = nmp_get_int(tmpname);
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case GPASSPHRASEWL2G:
        *write_method = write_gPassphraseWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_phrase_x", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
    		strcpy(tmpstr, nmp_safe_get(tmpname));
    		tmpstr[strlen(tmpstr)] = '\0';
        }
        *var_len = strlen(tmpstr);
        return ( u_char * ) tmpstr;         
    case GWPAENCRYPTIONWL2G:
        *write_method = write_gWpaEncryptionWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_crypto", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
        	tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get(tmpname));	
    		if(!strcmp(tmpstr, "tkip")) /* TKIP */
    			tmpval = 1;
    		else if(!strcmp(tmpstr, "aes")) /* AES */
    			tmpval = 2;
    		else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
    			tmpval = 3;
    		
    		*var_len = sizeof( long );
            return ( u_char * ) &tmpval;	
        }
	   return NULL;
    case GWPAPRESHAREDKEYWL2G:
        *write_method = write_gWpaPreSharedKeyWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_wpa_psk", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
    		strcpy(tmpstr, nmp_safe_get(tmpname));
    		tmpstr[strlen(tmpstr)] = '\0';
    		*var_len = strlen( tmpstr );
    		return ( u_char * ) tmpstr;	
        }
        return NULL;
    case GACCESSTIMEWL2G:
        *write_method = write_gAccessTimeWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = 1;
    		else		/* limitless */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSTIMEHWL2G:
        *write_method = write_gAccessTimeHWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = tmpval / 3600;
    		else		/* limitless */
    			tmpval = 0;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSTIMEMWL2G:
        *write_method = write_gAccessTimeMWl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = (tmpval % 3600) / 60;
    		else		/* limitless */
    			tmpval = 0;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSINTRANETWL2G:
        *write_method = write_gAccessIntranetWl2g;
        index = name[*length-1];
        sprintf(tmpname, "wl0.%d_lanaccess", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		if(!strcmp(nmp_get(tmpname), "on")) /* enable */
    			tmpval = 1;
    		else if(!strcmp(nmp_get(tmpname), "off")) /* disable */
    			tmpval = 2;
          	*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GENABLEMACFILTERWL2G:
        *write_method = write_gEnableMacFilterWl2g;
        index = name[*length-1];
        sprintf(tmpname, "wl0.%d_macmode", index);
        if(nmp_safe_get(tmpname) != NULL)
        {
            if(!strcmp(nmp_get(tmpname), "disabled"))
                tmpval = 2;
            else
                tmpval = 1;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }   
        return NULL;        
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl2gSSID1WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl2gSSID1WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX1WL2G:
        return NULL;
    case GWEPKEYVALUE1WL2G:
        *write_method = write_gWepKeyValue1Wl2g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl0.1_key%d", index);
    	if(nmp_safe_get(tmpname) != NULL) {
    		strcpy(tmpstr, nmp_safe_get(tmpname));
    		*var_len = strlen(tmpstr);
    		return ( u_char * ) tmpstr;
    	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl2gSSID2WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl2gSSID2WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX2WL2G:
        return NULL;
    case GWEPKEYVALUE2WL2G:
        *write_method = write_gWepKeyValue2Wl2g;
	index = name[*length-1];
	sprintf(tmpname, "wl0.2_key%d", index);
	if(nmp_safe_get(tmpname) != NULL) {
		strcpy(tmpstr, nmp_safe_get(tmpname));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl2gSSID3WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl2gSSID3WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX3WL2G:
        return NULL;
    case GWEPKEYVALUE3WL2G:
        *write_method = write_gWepKeyValue3Wl2g;
	index = name[*length-1];
	sprintf(tmpname, "wl0.3_key%d", index);
	if(nmp_safe_get(tmpname) != NULL) {
		strcpy(tmpstr, nmp_safe_get(tmpname));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

#ifdef DUAL_BAND
/*
 * var_wl5gGuestNetworkTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_wl5gGuestNetworkTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 3 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GINDEXWL5G:
        return NULL;
    case GENABLEWL5G:
        *write_method = write_gEnableWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_bss_enabled", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval == 1) /* enable */
    			tmpval = 1;
    		else if(tmpval == 0) /* disable */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GSSIDWL5G:
        *write_method = write_gSSIDWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_ssid", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		strcpy(tmpstr, nmp_get(tmpname));
    		*var_len = strlen(tmpstr);
    		return ( u_char * ) tmpstr;
      	}	
        return NULL;
    case GAUTHENTICATIONWL5G:
        *write_method = write_gAuthenticationWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_auth_mode_x", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
            tmpval = 0;
    		if(!strcmp(nmp_get(tmpname), "open")) /* open system */
    			tmpval = 1;
    		else if(!strcmp(nmp_get(tmpname), "shared")) /* shared key */
    			tmpval = 2;
    		else if(!strcmp(nmp_get(tmpname), "psk")) /* wpa personal */
    			tmpval = 3;
    		else if(!strcmp(nmp_get(tmpname), "psk2")) /* wpa2 personal */
    			tmpval = 4;
    		else if(!strcmp(nmp_get(tmpname), "pskpsk2")) /* wpa auto personal */
    			tmpval = 5;
            else if(!strcmp(nmp_get(tmpname), "wpa")) /* wpa enterprise */
                tmpval = 6;
            else if(!strcmp(nmp_get(tmpname), "wpa2")) /* wpa2 enterprise */
                tmpval = 7;
            else if(!strcmp(nmp_get(tmpname), "wpawpa2")) /* wpa auto enterprise */
                tmpval = 8;
            else if(!strcmp(nmp_get(tmpname), "radius")) /* radius with 802.1x */
                tmpval = 9;                     
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GWEPENCRYPTIONWL5G:
        *write_method = write_gWepEncryptionWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_wep_x", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval == 0) /* none */
    			tmpval = 1;
    		else if(tmpval == 1) /* wep 64bits */
    			tmpval = 2;
    		else if(tmpval == 2)	/* wep 128bits */
    			tmpval = 3;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case GKEYINDEXWL5G:
        *write_method = write_gKeyIndexWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_key", index);
        if(strlen(nmp_safe_get(tmpname)))
      	{
    		tmpval = nmp_get_int(tmpname);
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case GPASSPHRASEWL5G:
        *write_method = write_gPassphraseWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_phrase_x", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
    		strcpy(tmpstr, nmp_safe_get(tmpname));
    		tmpstr[strlen(tmpstr)] = '\0';
    		*var_len = strlen(tmpstr);
    		return ( u_char * ) tmpstr;	
        }
        return NULL;
    case GWPAENCRYPTIONWL5G:
        *write_method = write_gWpaEncryptionWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_crypto", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
        	tmpval = 0;
    		strcpy(tmpstr, nmp_safe_get(tmpname));	
    		if(!strcmp(tmpstr, "tkip")) /* TKIP */
    			tmpval = 1;
    		else if(!strcmp(tmpstr, "aes")) /* AES */
    			tmpval = 2;
    		else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
    			tmpval = 3;
    		
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;	
        }
        return NULL;
    case GWPAPRESHAREDKEYWL5G:
        *write_method = write_gWpaPreSharedKeyWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_wpa_psk", index);
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get(tmpname) != NULL)
        {
    		strcpy(tmpstr, nmp_safe_get(tmpname));
    		tmpstr[strlen(tmpstr)] = '\0';
    		*var_len = strlen( tmpstr );
    		return ( u_char * ) tmpstr;	
        }
        return NULL;
    case GACCESSTIMEWL5G:
        *write_method = write_gAccessTimeWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = 1;
    		else		/* limitless */
    			tmpval = 2;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSTIMEHWL5G:
        *write_method = write_gAccessTimeHWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = tmpval / 3600;
    		else		/* limitless */
    			tmpval = 0;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSTIMEMWL5G:
        *write_method = write_gAccessTimeMWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_expire", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		tmpval = nmp_get_int(tmpname);
    		if(tmpval)	/* specific time */
    			tmpval = (tmpval % 3600) / 60;
    		else		/* limitless */
    			tmpval = 0;
    		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GACCESSINTRANETWL5G:
        *write_method = write_gAccessIntranetWl5g;
    	index = name[*length-1];
    	sprintf(tmpname, "wl1.%d_lanaccess", index);
        if(nmp_safe_get(tmpname) != NULL)
      	{
    		if(!strcmp(nmp_get(tmpname), "on")) /* enable */
    			tmpval = 1;
    		else if(!strcmp(nmp_get(tmpname), "off")) /* disable */
    			tmpval = 2;
          		*var_len = sizeof( long );
    		return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case GENABLEMACFILTERWL5G:
        *write_method = write_gEnableMacFilterWl5g;
        index = name[*length-1];
        sprintf(tmpname, "wl1.%d_macmode", index);
        if(nmp_safe_get(tmpname) != NULL)
        {
            if(!strcmp(nmp_get(tmpname), "disabled"))
                tmpval = 2;
            else
                tmpval = 1;
            *var_len = sizeof( long );
            return ( u_char * ) &tmpval;
        }  
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl5gSSID1WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl5gSSID1WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX1WL5G:
        return NULL;
    case GWEPKEYVALUE1WL5G:
        *write_method = write_gWepKeyValue1Wl5g;
	index = name[*length-1];
	sprintf(tmpname, "wl1.1_key%d", index);
	if(nmp_safe_get(tmpname) != NULL) {
		strcpy(tmpstr, nmp_safe_get(tmpname));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl5gSSID2WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl5gSSID2WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX2WL5G:
        return NULL;
    case GWEPKEYVALUE2WL5G:
        *write_method = write_gWepKeyValue2Wl5g;
	index = name[*length-1];
	sprintf(tmpname, "wl1.2_key%d", index);
	if(nmp_safe_get(tmpname) != NULL) {
		strcpy(tmpstr, nmp_safe_get(tmpname));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_gWl5gSSID3WepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_guestNetwork above.
 */
unsigned char *
var_gWl5gSSID3WepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    memset(tmpname, 0, sizeof(tmpname));

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 4 /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GWEPKEYINDEX3WL5G:
        return NULL;
    case GWEPKEYVALUE3WL5G:
        *write_method = write_gWepKeyValue3Wl5g;
	index = name[*length-1];
	sprintf(tmpname, "wl1.3_key%d", index);
	if(nmp_safe_get(tmpname) != NULL) {
		strcpy(tmpstr, nmp_safe_get(tmpname));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
#endif	//#ifdef DUAL_BAND



int
write_gEnableWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		sprintf(tmpname, "wl0.%d_bss_enabled", index);
		if(value >= 1 && value <= 2) {
			if(value == 1)
				nmp_set(tmpname, "1");
		     	else if(value == 2)
				nmp_set(tmpname, "0");
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gSSIDWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guest_network not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		sprintf(tmpname, "wl0.%d_ssid", index);
		if(var_val_len <= 32) {
			strncpy(string, (u_char *)var_val, var_val_len); 
			string[var_val_len] = '\0';
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			nmp_set(tmpname, string);
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAuthenticationWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl0.%d_auth_mode_x", index);
      		switch(value)
      		{
      			case 1:/* open system */
    				nmp_set(tmpname, "open");
    				break;
      			case 2:/* shared key */
                    if(!strcmp(nmp_get("wl0_nmode_x"), "2"))//wireless mode: Legacy
    				    nmp_set(tmpname, "shared");
                    else
                        return SNMP_ERR_WRONGVALUE;    
    				break;
      			case 3:	/* wpa personal */
    				nmp_set(tmpname, "psk");
    				break;
                case 4:/* wpa2 personal */
    				nmp_set(tmpname, "psk2");
    				break;
      			case 5:/* wpa auto personal */
    				nmp_set(tmpname, "pskpsk2");
                    break;
                case 6: /* wpa enterprise */
                    nmp_set(tmpname, "wpa");
                    break;
                case 7:/* wpa2 enterprise */
                    nmp_set(tmpname, "wpa2");
                    break;
                case 8:/* wpa auto enterprise */
                    nmp_set(tmpname, "wpawpa2");
                    break;
                case 9: /* radius with 802.1x */
                    if(!strcmp(nmp_get("wl0_nmode_x"), "2"))//wireless mode: Legacy                    
                        nmp_set(tmpname, "radius");
                    else
                        return SNMP_ERR_WRONGVALUE;  
                    break;                  
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepEncryptionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl0.%d_wep_x", index);
      		switch(value)
      		{
      			case 1:/* none */
				nmp_set(tmpname, "0");
				break;
      			case 2:/* wep 64bits */
				nmp_set(tmpname, "1");
				break;
      			case 3:	/* wep 128bits */
				nmp_set(tmpname, "2");
				break;
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gKeyIndexWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.%d_key", index);
             if(value >= 1 && value <= 4)
		nmp_set_int(tmpname, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gPassphraseWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guest_network not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.%d_phrase_x", index);
             strncpy(string, (u_char *)var_val, var_val_len); 
             string[var_val_len] = '\0';
             nmp_set(tmpname, string);
             mssid_generateWepKey(0, index, string);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWpaEncryptionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);              
            sprintf(tmpname, "wl0.%d_crypto", index);
            sprintf(tmpstr, "wl0.%d_auth_mode_x", index);
      		switch(value)
      		{
                case 1:/* TKIP */
                if( strstr(nmp_get(tmpstr), "psk2") || strstr(nmp_get(tmpstr), "wpa2") )
                    return SNMP_ERR_WRONGVALUE;                 
                    nmp_set(tmpname, "tkip");
                    break;
                case 2:/* AES */
                if( !strcmp(nmp_get(tmpstr), "psk") || !strcmp(nmp_get(tmpstr), "wpa") )
                    return SNMP_ERR_WRONGVALUE;                    
                    nmp_set(tmpname, "aes");
                    break;
                case 3:/* TKIP+AES */
                if( !strcmp(nmp_get(tmpstr), "psk") || !strcmp(nmp_get(tmpstr), "wpa") )
                    return SNMP_ERR_WRONGVALUE;                    
                    nmp_set(tmpname, "tkip+aes");
                    break;     
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWpaPreSharedKeyWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guest_network not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.%d_wpa_psk", index);
             if(var_val_len >= 8 || var_val_len <= 63)
             {
		strncpy(string, (u_char *)var_val, var_val_len); 
		string[var_val_len] = '\0';
        	nmp_set(tmpname, string); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.%d_expire", index);
             if(value >= 1 && value <= 2)
             {
      		switch(value)
      		{
      			case 1:/* specific time */
      				break;
      			case 2:/* limitless */
      				nmp_set(tmpname, "0");
      				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeHWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;
    long timeM = 0;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guest_network not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guest_network: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 23){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	sprintf(tmpname, "wl0.%d_expire", index);
             	tmpval = nvram_get_int(tmpname);
		timeM = (tmpval % 3600);
		tmpval = value * 3600 + timeM;
		nmp_set_int(tmpname, tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeMWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;
    long timeH = 0;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 59){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	sprintf(tmpname, "wl0.%d_expire", index);
             	tmpval = nvram_get_int(tmpname);
		timeH = (tmpval / 3600) * 3600;
		tmpval = timeH + (value * 60);
		nmp_set_int(tmpname, tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessIntranetWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.%d_lanaccess", index);
             if(value >= 1 && value <= 2)
             {
          		switch(value)
          		{
          			case 1:/* enable */
          				nmp_set(tmpname, "on");
          				break;
          			case 2:/* disable */
          				nmp_set(tmpname, "off");
          				break;
                }
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_gEnableMacFilterWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    strcpy(tmpstr, nmp_safe_get("wl0_macmode"));
    if(!strcmp(tmpstr, "disabled")) //MAC Filter of primary SSID must be enabled first.
        return SNMP_ERR_WRONGVALUE;    

    value = * (long *) var_val;
    index = name[name_len-1];    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }          
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl0.%d_macmode", index);              
            if( value == 1 )//yes
                nmp_set(tmpname, tmpstr);
            else
                nmp_set(tmpname, "disabled");           
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_gWepKeyValue1Wl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26){
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl0.1_key%d", index);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);             
            if(var_val_len == 10 || var_val_len == 26)
            {
        		for(i = 0; i < var_val_len; i++)
        		{
        			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
        			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
        				return SNMP_ERR_WRONGVALUE;
        		}
            }
            nmp_set(tmpname, tmpstr);             
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepKeyValue2Wl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 10 && var_val_len != 26) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.2_key%d", index);
             if(var_val_len == 10 || var_val_len == 26)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len);
		for(i = 0; i < var_val_len; i++)
		{
			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
				return SNMP_ERR_WRONGVALUE;
		}
		nmp_set(tmpname, tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepKeyValue3Wl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];


    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 10 && var_val_len != 26) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl0.3_key%d", index);
             if(var_val_len == 10 || var_val_len == 26)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len);
		for(i = 0; i < var_val_len; i++)
		{
			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
				return SNMP_ERR_WRONGVALUE;
		}
		nmp_set(tmpname, tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#ifdef DUAL_BAND
int
write_gEnableWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		sprintf(tmpname, "wl1.%d_bss_enabled", index);
		if(value >= 1 && value <= 2) {
			if(value == 1)
				nmp_set(tmpname, "1");
		     	else if(value == 2)
				nmp_set(tmpname, "0");
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gSSIDWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		sprintf(tmpname, "wl1.%d_ssid", index);
		if(var_val_len <= 32) {
			strncpy(string, (u_char *)var_val, var_val_len); 
			string[var_val_len] = '\0';
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			nmp_set(tmpname, string);
		}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAuthenticationWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_auth_mode_x", index);
      		switch(value)
      		{
      			case 1:/* open system */
    				nmp_set(tmpname, "open");
    				break;
      			case 2:/* shared key */
                    if(!strcmp(nmp_get("wl1_nmode_x"), "2"))//wireless mode: Legacy
    				    nmp_set(tmpname, "shared");
                    else
                        return SNMP_ERR_WRONGVALUE;  
    				break;
      			case 3:	/* wpa personal */
    				nmp_set(tmpname, "psk");
    				break; 
                case 4:/* wpa2 personal */
    				nmp_set(tmpname, "psk2");
    				break;
      			case 5:/* wpa auto personal */
    				nmp_set(tmpname, "pskpsk2");
    				break;
                case 6: /* wpa enterprise */
                    nmp_set(tmpname, "wpa");
                    break;
                case 7:/* wpa2 enterprise */
                    nmp_set(tmpname, "wpa2");
                    break;
                case 8:/* wpa auto enterprise */
                    nmp_set(tmpname, "wpawpa2");
                    break;
                case 9: /* radius with 802.1x */
                    if(!strcmp(nmp_get("wl1_nmode_x"), "2"))//wireless mode: Legacy                    
                        nmp_set(tmpname, "radius");
                    else
                        return SNMP_ERR_WRONGVALUE;                    
                    break;                
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepEncryptionWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_wep_x", index);
             if(value >= 1 && value <= 3) {
      		switch(value)
      		{
      			case 1:/* none */
				nmp_set(tmpname, "0");
				break;
      			case 2:/* wep 64bits */
				nmp_set(tmpname, "1");
				break;
      			case 3:	/* wep 128bits */
				nmp_set(tmpname, "2");
				break;
		}
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gKeyIndexWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to guest_network: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_key", index);
             if(value >= 1 && value <= 4)
		nmp_set_int(tmpname, value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gPassphraseWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_phrase_x", index);
             strncpy(string, (u_char *)var_val, var_val_len); 
             string[var_val_len] = '\0';
             nmp_set(tmpname, string);
             mssid_generateWepKey(1, index, string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWpaEncryptionWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            memset(tmpstr, 0x0, SPRINT_MAX_LEN);
            sprintf(tmpname, "wl1.%d_crypto", index);
            sprintf(tmpstr, "wl1.%d_auth_mode_x", index);
      		switch(value)
      		{
      			case 1:/* TKIP */
                if( strstr(nmp_get(tmpstr), "psk2") || strstr(nmp_get(tmpstr), "wpa2") )
                    return SNMP_ERR_WRONGVALUE;                 
      				nmp_set(tmpname, "tkip");
      				break;
      			case 2:/* AES */
                if( !strcmp(nmp_get(tmpstr), "psk") || !strcmp(nmp_get(tmpstr), "wpa") )
                    return SNMP_ERR_WRONGVALUE;                    
      				nmp_set(tmpname, "aes");
      				break;
                case 3:/* TKIP+AES */
                if( !strcmp(nmp_get(tmpstr), "psk") || !strcmp(nmp_get(tmpstr), "wpa") )
                    return SNMP_ERR_WRONGVALUE;                    
      				nmp_set(tmpname, "tkip+aes");
      				break;               
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWpaPreSharedKeyWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_wpa_psk", index);
             if(var_val_len >= 8 || var_val_len <= 63)
             {
        		strncpy(string, (u_char *)var_val, var_val_len); 
        		string[var_val_len] = '\0';
            	nmp_set(tmpname, string); 			
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_expire", index);
          	switch(value)
          	{
          		case 1:/* specific time */
          			break;
          		case 2:/* limitless */
          			nmp_set(tmpname, "0");
          			break;
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeHWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;
    long timeM = 0;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 23){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             	sprintf(tmpname, "wl1.%d_expire", index);
             	tmpval = nvram_get_int(tmpname);
		timeM = (tmpval % 3600);
		tmpval = value * 3600 + timeM;
		nmp_set_int(tmpname, tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessTimeMWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;
    long timeH = 0;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 59){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl1.%d_expire", index);
            tmpval = nvram_get_int(tmpname);
    		timeH = (tmpval / 3600) * 3600;
    		tmpval = timeH + (value * 60);
    		nmp_set_int(tmpname, tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gAccessIntranetWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    value = * (long *) var_val;
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.%d_lanaccess", index);
             if(value >= 1 && value <= 2)
             {
      		switch(value)
      		{
      			case 1:/* enable */
      				nmp_set(tmpname, "on");
      				break;
      			case 2:/* disable */
      				nmp_set(tmpname, "off");
      				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_gEnableMacFilterWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index;
    long value;

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    strcpy(tmpstr, nmp_safe_get("wl1_macmode"));
    if(!strcmp(tmpstr, "disabled")) //MAC Filter of primary SSID must be enabled first.
        return SNMP_ERR_WRONGVALUE;    

    value = * (long *) var_val;
    index = name[name_len-1];    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to guestNetwork not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write guest_network: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }            
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl1.%d_macmode", index);              
            if( value == 1 )//yes
                nmp_set(tmpname, tmpstr);
            else
                nmp_set(tmpname, "disabled");                     
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_gWepKeyValue1Wl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 &&var_val_len != 26) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            sprintf(tmpname, "wl1.1_key%d", index);
            strncpy(tmpstr, (u_char *)var_val, var_val_len);             
            if(var_val_len == 10 || var_val_len == 26)
            {
                for(i = 0; i < var_val_len; i++)
        		{
        			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
        			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
        				return SNMP_ERR_WRONGVALUE;
        		}
            }
            nmp_set(tmpname, tmpstr);            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepKeyValue2Wl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 10 && var_val_len != 26) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.2_key%d", index);
             if(var_val_len == 10 || var_val_len == 26)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len);
		for(i = 0; i < var_val_len; i++)
		{
			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
				return SNMP_ERR_WRONGVALUE;
		}
		nmp_set(tmpname, tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_gWepKeyValue3Wl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    static long index;
    static int i = 0;

    memset(string, 0, SPRINT_MAX_LEN);
    index = name[name_len-1];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to guestNetwork not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 10 && var_val_len != 26) {
              fprintf(stderr,"write to guestNetwork: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             sprintf(tmpname, "wl1.3_key%d", index);
             if(var_val_len == 10 || var_val_len == 26)
             {
		strncpy(tmpstr, (u_char *)var_val, var_val_len);
		for(i = 0; i < var_val_len; i++)
		{
			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
				return SNMP_ERR_WRONGVALUE;
		}
		nmp_set(tmpname, tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif	//#ifdef DUAL_BAND
