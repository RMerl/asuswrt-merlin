/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "wireless.h"
#include <nmp.h>

#define DUAL_BAND       1

#define MAXWEPKEY	4 /* Maximum number of wep key */
#define MAXRBRIDGE	4 /* Maximum number of remote bridge entries */
#define MACSTRNUM	18
#define MAXMACFILTER	32	/* Maximum number of mac filter entries */

static unsigned char tmpstr[SPRINT_MAX_LEN];
static long tmpval = 0;
static int sw_mode = 0;
//struct apinfo apinfos[32];
wlc_ap_list_info_t ap_list[WLC_MAX_AP_SCAN_LIST_LEN];
int ap_count;

/* 
 * wireless_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid wireless_variables_oid[] = { 1,3,6,1,4,1,2623,4,1,1,1 };

struct variable7 wireless_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define SSIDWL2G                1
{SSIDWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,1,1 }},
#define HIDESSIDWL2G            2
{HIDESSIDWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,2 }},
#define WIRELESSMODEWL2G                3
{WIRELESSMODEWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,3 }},
#define OPTIMIZEDFORXBOXWL2G            4
{OPTIMIZEDFORXBOXWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,4 }},
#define PROTECTIONWL2G          5
{PROTECTIONWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,5 }},
#define CHANNELBANDWIDTHWL2G            6
{CHANNELBANDWIDTHWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,6 }},
#define CONTROLCHANNELWL2G              7
{CONTROLCHANNELWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,7 }},
#define EXTENSIONCHANNELWL2G            8
{EXTENSIONCHANNELWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,8 }},
#define AUTHENTICATIONWL2G              9
{AUTHENTICATIONWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,9 }},
#define WEPENCRYPTIONWL2G               10
{WEPENCRYPTIONWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,10 }},
#define KEYINDEXWL2G            11
{KEYINDEXWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,11 }},
#define PASSPHRASEWL2G          12
{PASSPHRASEWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,1,13 }},
#define WPAENCRYPTIONWL2G               13
{WPAENCRYPTIONWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,14 }},
#define WPAPRESHAREDKEYWL2G             14
{WPAPRESHAREDKEYWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,1,15 }},
#define KEYROTATIONINTERVALWL2G         15
{KEYROTATIONINTERVALWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,1,17 }},
#define ENABLEWPSWL2G           16
{ENABLEWPSWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,2,1 }},
#define SWITCHFREQUENCYTO5G             17
{SWITCHFREQUENCYTO5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,2,2 }},
#define CONNECTIONSTATUSWL2G            18
{CONNECTIONSTATUSWL2G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 1,2,3 }},
#define CONFIGUREDWL2G          19
{CONFIGUREDWL2G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 1,2,4 }},
#define APPINCODEWL2G           20
{APPINCODEWL2G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 1,2,5 }},
#define CLIENTPINCODEWL2G               21
{CLIENTPINCODEWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,2,6 }},
#define WPSMETHODWL2G           22
{WPSMETHODWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,2,7 }},
#define WBMACADDRWL2G           23
{WBMACADDRWL2G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 1,3,1 }},
#define WBAPMODEWL2G            24
{WBAPMODEWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,3,2 }},
#define WBCONNECTREMOTEBRIDEGEAPWL2G            25
{WBCONNECTREMOTEBRIDEGEAPWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,3,3 }},
#define WBBRIDGEAPSCANACTWL2G           26
{WBBRIDGEAPSCANACTWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 4,  { 1,3,5,1 }},
#define MACFILTERMODEWL2G               27
{MACFILTERMODEWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,4,1 }},
#define RADIUSSERVERIPADDRWL2G          28
{RADIUSSERVERIPADDRWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,5,1 }},
#define RADIUSPORTWL2G          29
{RADIUSPORTWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,5,2 }},
#define RADIUSCONNECTIONSECRETWL2G              30
{RADIUSCONNECTIONSECRETWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,5,3 }},
#define RADIOWL2G               31
{RADIOWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,1 }},
#define ENABLESCHEDWL2G         32
{ENABLESCHEDWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,2 }},
#define WEEKDAYSENABLERADIOWL2G         33
{WEEKDAYSENABLERADIOWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,6,3 }},
#define WEEKDAYSRADIOSTARTTIMEHWL2G             34
{WEEKDAYSRADIOSTARTTIMEHWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,4 }},
#define WEEKDAYSRADIOSTARTTIMEMWL2G             35
{WEEKDAYSRADIOSTARTTIMEMWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,5 }},
#define WEEKDAYSRADIOENDTIMEHWL2G               36
{WEEKDAYSRADIOENDTIMEHWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,6 }},
#define WEEKDAYSRADIOENDTIMEMWL2G               37
{WEEKDAYSRADIOENDTIMEMWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,7 }},
#define WEEKENDENABLERADIOWL2G          38
{WEEKENDENABLERADIOWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 1,6,8 }},
#define WEEKENDRADIOSTARTTIMEHWL2G              39
{WEEKENDRADIOSTARTTIMEHWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,9 }},
#define WEEKENDRADIOSTARTTIMEMWL2G              40
{WEEKENDRADIOSTARTTIMEMWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,10 }},
#define WEEKENDRADIOENDTIMEHWL2G                41
{WEEKENDRADIOENDTIMEHWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,11 }},
#define WEEKENDRADIOENDTIMEMWL2G                42
{WEEKENDRADIOENDTIMEMWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,12 }},
#define APISOLATEDWL2G          43
{APISOLATEDWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,13 }},
#define ROAMINGASSISTANTWL2G            44
{ROAMINGASSISTANTWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,14 }},
#define DISCONNECTCLIENTRSSIWL2G                45
{DISCONNECTCLIENTRSSIWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,15 }},
#define IGMPSNOOPINGWL2G                46
{IGMPSNOOPINGWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,16 }},
#define MULTICASTRATEWL2G               47
{MULTICASTRATEWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,17 }},
#define PREAMBLETYPEWL2G                48
{PREAMBLETYPEWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,18 }},
#define AMPDURTSWL2G            49
{AMPDURTSWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,19 }},
#define RTSTHRESHOLDWL2G                50
{RTSTHRESHOLDWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,20 }},
#define DTIMINTERVALWL2G                51
{DTIMINTERVALWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,21 }},
#define BEACONINTERVALWL2G              52
{BEACONINTERVALWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,22 }},
#define TXBURSTINGWL2G          53
{TXBURSTINGWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,23 }},
#define WMMAPSDWL2G             54
{WMMAPSDWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,24 }},
#define OPTIMIZEAMPDUAGGREGWL2G         55
{OPTIMIZEAMPDUAGGREGWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,25 }},
#define OPTIMIZEACKSUPPRESSIONWL2G              56
{OPTIMIZEACKSUPPRESSIONWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,26 }},
#define TXPOWERADJUSTMENTWL2G           57
{TXPOWERADJUSTMENTWL2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 1,6,27 }},
#define SSIDWL5G                58
{SSIDWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,1,1 }},
#define HIDESSIDWL5G            59
{HIDESSIDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,2 }},
#define WIRELESSMODEWL5G                60
{WIRELESSMODEWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,3 }},
#define OPTIMIZEDFORXBOXWL5G            61
{OPTIMIZEDFORXBOXWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,4 }},
#define CHANNELBANDWIDTHWL5G            62
{CHANNELBANDWIDTHWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,5 }},
#define CONTROLCHANNELWL5G              63
{CONTROLCHANNELWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,6 }},
#define EXTENSIONCHANNELWL5G            64
{EXTENSIONCHANNELWL5G,  ASN_INTEGER,  RONLY,
 var_wireless, 3,  { 2,1,7 }},
#define AUTHENTICATIONWL5G              65
{AUTHENTICATIONWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,8 }},
#define WEPENCRYPTIONWL5G               66
{WEPENCRYPTIONWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,9 }},
#define KEYINDEXWL5G            67
{KEYINDEXWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,10 }},
#define PASSPHRASEWL5G          68
{PASSPHRASEWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,1,12 }},
#define WPAENCRYPTIONWL5G               69
{WPAENCRYPTIONWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,13 }},
#define WPAPRESHAREDKEYWL5G             70
{WPAPRESHAREDKEYWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,1,14 }},
#define KEYROTATIONINTERVALWL5G         71
{KEYROTATIONINTERVALWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,1,16 }},
#define ENABLEWPSWL5G           72
{ENABLEWPSWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,2,1 }},
#define SWITCHFREQUENCYTO2G             73
{SWITCHFREQUENCYTO2G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,2,2 }},
#define CONNECTIONSTATUSWL5G            74
{CONNECTIONSTATUSWL5G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 2,2,3 }},
#define CONFIGUREDWL5G          75
{CONFIGUREDWL5G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 2,2,4 }},
#define APPINCODEWL5G           76
{APPINCODEWL5G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 2,2,5 }},
#define CLIENTPINCODEWL5G               77
{CLIENTPINCODEWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,2,6 }},
#define WPSMETHODWL5G           78
{WPSMETHODWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,2,7 }},
#define WBMACADDRWL5G           79
{WBMACADDRWL5G,  ASN_OCTET_STR,  RONLY,
 var_wireless, 3,  { 2,3,1 }},
#define WBAPMODEWL5G            80
{WBAPMODEWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,3,2 }},
#define WBCONNECTREMOTEBRIDEGEAPWL5G            81
{WBCONNECTREMOTEBRIDEGEAPWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,3,3 }},
#define WBBRIDGEAPSCANACTWL5G           82
{WBBRIDGEAPSCANACTWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 4,  { 2,3,5,1 }},
#define MACFILTERMODEWL5G               83
{MACFILTERMODEWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,4,1 }},
#define RADIUSSERVERIPADDRWL5G          84
{RADIUSSERVERIPADDRWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,5,1 }},
#define RADIUSPORTWL5G          85
{RADIUSPORTWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,5,2 }},
#define RADIUSCONNECTIONSECRETWL5G              86
{RADIUSCONNECTIONSECRETWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,5,3 }},
#define RADIOWL5G               87
{RADIOWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,1 }},
#define ENABLESCHEDWL5G         88
{ENABLESCHEDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,2 }},
#define WEEKDAYSENABLERADIOWL5G         89
{WEEKDAYSENABLERADIOWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,6,3 }},
#define WEEKDAYSRADIOSTARTTIMEHWL5G             90
{WEEKDAYSRADIOSTARTTIMEHWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,4 }},
#define WEEKDAYSRADIOSTARTTIMEMWL5G             91
{WEEKDAYSRADIOSTARTTIMEMWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,5 }},
#define WEEKDAYSRADIOENDTIMEHWL5G               92
{WEEKDAYSRADIOENDTIMEHWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,6 }},
#define WEEKDAYSRADIOENDTIMEMWL5G               93
{WEEKDAYSRADIOENDTIMEMWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,7 }},
#define WEEKENDENABLERADIOWL5G          94
{WEEKENDENABLERADIOWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wireless, 3,  { 2,6,8 }},
#define WEEKENDRADIOSTARTTIMEHWL5G              95
{WEEKENDRADIOSTARTTIMEHWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,9 }},
#define WEEKENDRADIOSTARTTIMEMWL5G              96
{WEEKENDRADIOSTARTTIMEMWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,10 }},
#define WEEKENDRADIOENDTIMEHWL5G                97
{WEEKENDRADIOENDTIMEHWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,11 }},
#define WEEKENDRADIOENDTIMEMWL5G                98
{WEEKENDRADIOENDTIMEMWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,12 }},
#define APISOLATEDWL5G          99
{APISOLATEDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,13 }},
#define ROAMINGASSISTANTWL5G            100
{ROAMINGASSISTANTWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,14 }},
#define DISCONNECTCLIENTRSSIWL5G                101
{DISCONNECTCLIENTRSSIWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,15 }},
#define IGMPSNOOPINGWL5G                102
{IGMPSNOOPINGWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,16 }},
#define MULTICASTRATEWL5G               103
{MULTICASTRATEWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,17 }},
#define PREAMBLETYPEWL5G                104
{PREAMBLETYPEWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,18 }},
#define FRAGTHRESHOLDWL5G               105
{FRAGTHRESHOLDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,19 }},
#define RTSTHRESHOLDWL5G                106
{RTSTHRESHOLDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,20 }},
#define DTIMINTERVALWL5G                107
{DTIMINTERVALWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,21 }},
#define BEACONINTERVALWL5G              108
{BEACONINTERVALWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,22 }},
#define TXBURSTINGWL5G          109
{TXBURSTINGWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,23 }},
#define WMMWL5G         110
{WMMWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,24 }},
#define WMMNOACKNOWLEDGEMENTWL5G                111
{WMMNOACKNOWLEDGEMENTWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,25 }},
#define WMMAPSDWL5G             112
{WMMAPSDWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,26 }},
#define OPTIMIZEAMPDUAGGREGWL5G         113
{OPTIMIZEAMPDUAGGREGWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,27 }},
#define OPTIMIZEACKSUPPRESSIONWL5G              114
{OPTIMIZEACKSUPPRESSIONWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,28 }},
#define EXPLICITBEAMFORMINGWL5G         115
{EXPLICITBEAMFORMINGWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,29 }},
#define TXPOWERADJUSTMENTWL5G           116
{TXPOWERADJUSTMENTWL5G,  ASN_INTEGER,  RWRITE,
 var_wireless, 3,  { 2,6,30 }},

#define WEPKEYINDEXWL2G         117
{WEPKEYINDEXWL2G,  ASN_INTEGER,  RONLY,
 var_wl2gWepKeyTable, 5,  { 1,1,12, 1, 1 }},
#define WEPKEYVALUEWL2G         118
{WEPKEYVALUEWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wl2gWepKeyTable, 5,  { 1,1,12, 1, 2 }},
#define WBAPRESULTINDEXWL2G             119
{WBAPRESULTINDEXWL2G,  ASN_INTEGER,  RONLY,
 var_wbWl2gBridgeAPScanTable, 6,  { 1,3,5,2, 1, 1 }},
#define WBAPRESULTBSSIDWL2G             120
{WBAPRESULTBSSIDWL2G,  ASN_OCTET_STR,  RONLY,
 var_wbWl2gBridgeAPScanTable, 6,  { 1,3,5,2, 1, 2 }},
#define WBAPRESULTSSIDWL2G              121
{WBAPRESULTSSIDWL2G,  ASN_OCTET_STR,  RONLY,
 var_wbWl2gBridgeAPScanTable, 6,  { 1,3,5,2, 1, 3 }},
#define WBREMOTEAPINDEXWL2G             122
{WBREMOTEAPINDEXWL2G,  ASN_INTEGER,  RONLY,
 var_wbWl2gRemoteAPTable, 5,  { 1,3,6, 1, 1 }},
#define WBREMOTEAPMACADDRWL2G           123
{WBREMOTEAPMACADDRWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wbWl2gRemoteAPTable, 5,  { 1,3,6, 1, 2 }},
#define WBREMOTEAPDELENTRYWL2G          124
{WBREMOTEAPDELENTRYWL2G,  ASN_INTEGER,  RWRITE,
 var_wbWl2gRemoteAPTable, 5,  { 1,3,6, 1, 3 }},
#define MACFILTERINDEXWL2G              125
{MACFILTERINDEXWL2G,  ASN_INTEGER,  RONLY,
 var_wl2gMacFilterTable, 5,  { 1,4,2, 1, 1 }},
#define MACFILTERMACADDRWL2G            126
{MACFILTERMACADDRWL2G,  ASN_OCTET_STR,  RWRITE,
 var_wl2gMacFilterTable, 5,  { 1,4,2, 1, 2 }},
#define MACFILTERDELENTRYWL2G           127
{MACFILTERDELENTRYWL2G,  ASN_INTEGER,  RWRITE,
 var_wl2gMacFilterTable, 5,  { 1,4,2, 1, 3 }},
#define WEPKEYINDEXWL5G         128
{WEPKEYINDEXWL5G,  ASN_INTEGER,  RONLY,
 var_wl5gWepKeyTable, 5,  { 2,1,11, 1, 1 }},
#define WEPKEYVALUEWL5G         129
{WEPKEYVALUEWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wl5gWepKeyTable, 5,  { 2,1,11, 1, 2 }},
#define WBAPRESULTINDEXWL5G             130
{WBAPRESULTINDEXWL5G,  ASN_INTEGER,  RONLY,
 var_wbWl5gBridgeAPScanTable, 6,  { 2,3,5,2, 1, 1 }},
#define WBAPRESULTBSSIDWL5G             131
{WBAPRESULTBSSIDWL5G,  ASN_OCTET_STR,  RONLY,
 var_wbWl5gBridgeAPScanTable, 6,  { 2,3,5,2, 1, 2 }},
#define WBAPRESULTSSIDWL5G              132
{WBAPRESULTSSIDWL5G,  ASN_OCTET_STR,  RONLY,
 var_wbWl5gBridgeAPScanTable, 6,  { 2,3,5,2, 1, 3 }},
#define WBREMOTEAPINDEXWL5G             133
{WBREMOTEAPINDEXWL5G,  ASN_INTEGER,  RONLY,
 var_wbWl5gRemoteAPTable, 5,  { 2,3,6, 1, 1 }},
#define WBREMOTEAPMACADDRWL5G           134
{WBREMOTEAPMACADDRWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wbWl5gRemoteAPTable, 5,  { 2,3,6, 1, 2 }},
#define WBREMOTEAPDELENTRYWL5G          135
{WBREMOTEAPDELENTRYWL5G,  ASN_INTEGER,  RWRITE,
 var_wbWl5gRemoteAPTable, 5,  { 2,3,6, 1, 3 }},
#define MACFILTERINDEXWL5G              136
{MACFILTERINDEXWL5G,  ASN_INTEGER,  RONLY,
 var_wl5gMacFilterTable, 5,  { 2,4,2, 1, 1 }},
#define MACFILTERMACADDRWL5G            137
{MACFILTERMACADDRWL5G,  ASN_OCTET_STR,  RWRITE,
 var_wl5gMacFilterTable, 5,  { 2,4,2, 1, 2 }},
#define MACFILTERDELENTRYWL5G           138
{MACFILTERDELENTRYWL5G,  ASN_INTEGER,  RWRITE,
 var_wl5gMacFilterTable, 5,  { 2,4,2, 1, 3 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the wireless module */
void
init_wireless(void)
{

    DEBUGMSGTL(("wireless", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("wireless", wireless_variables, variable7,
               wireless_variables_oid);

    /* place any other initialization junk you need here */
    sw_mode = nmp_get_int("sw_mode");
}

/*
 * var_wireless():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_wireless(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{

    if(sw_mode == SW_MODE_REPEATER &&  vp->magic != ROAMINGASSISTANTWL2G && vp->magic != ROAMINGASSISTANTWL5G)	//Doesn't support in repeater mode
	return NULL;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    /* 
     * this is where we do the value assignments for the mib results.
     */
    switch(vp->magic) {
    case SSIDWL2G:
        *write_method = write_ssidWl2g;
        if(nmp_safe_get("wl0_ssid")!=NULL)
		{
			strcpy(tmpstr, nmp_get("wl0_ssid"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case HIDESSIDWL2G:
        *write_method = write_hideSSIDWl2g;
        if(nmp_safe_get("wl0_closed") != NULL)
      	{
			tmpval = nmp_get_int("wl0_closed"); /* 0: No   1: Yes*/
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WIRELESSMODEWL2G:
        *write_method = write_wirelessModeWl2g;
        if(nmp_safe_get("wl0_nmode_x") != NULL)
      	{
			tmpval = nmp_get_int("wl0_nmode_x");/* 0: Auto 1: N Only  2: Legacy*/
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case OPTIMIZEDFORXBOXWL2G:
        *write_method = write_optimizedforXboxWl2g;
        if(nmp_safe_get("wl0_optimizexbox") != NULL)
      	{
			tmpval = nmp_get_int("wl0_optimizexbox"); /* 0: No   1: Yes*/
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
		return NULL;
    case PROTECTIONWL2G:
        *write_method = write_protectionWl2g;
        if(nmp_safe_get("wl0_gmode_protection") != NULL)
        {
			if(!strcmp(nmp_get("wl0_gmode_protection"), "off")) /* Disable */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl0_gmode_protection"), "auto")) /* Enable */
				tmpval = 1;	
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case CHANNELBANDWIDTHWL2G:
        *write_method = write_channelBandwidthWl2g;
        if(nmp_safe_get("wl0_bw") != NULL)
      	{
			tmpval = nmp_get_int("wl0_bw"); /* 0: 20/40Mhz 1: 20Mhz 2: 40Mhz */
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case CONTROLCHANNELWL2G:
        *write_method = write_controlChannelWl2g;
        if(nmp_safe_get("wl0_chanspec") != NULL)
      	{
			char *p;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("wl0_chanspec"));
			p = strpbrk(tmpstr, "ul/");
			if(p != 0)
			 	p = '\0';
			tmpval = atol(tmpstr);
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
        }
        return NULL;
    case EXTENSIONCHANNELWL2G:
        *write_method = write_extensionChannelWl2g;
		if((nmp_get_int("wl0_bw") != 1) && (nmp_safe_get("wl0_chanspec") != NULL))
      	{
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("wl0_chanspec"));
			if(strchr(tmpstr, 'u'))//Below
				tmpval = 2;
			else if(strchr(tmpstr, 'l'))//Above
				tmpval = 3;
			else//Auto
				tmpval = 1;

			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
        }        
        return NULL;
    case AUTHENTICATIONWL2G:
        *write_method = write_authenticationWl2g;
        if(nmp_safe_get("wl0_auth_mode_x") != NULL)
        {
			if(!strcmp(nmp_get("wl0_auth_mode_x"), "open")) /* open system */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "shared")) /* shared key */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "psk")) /* wpa personal */
				tmpval = 3;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "psk2")) /* wpa2 personal */
				tmpval = 4;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "pskpsk2")) /* wpa auto personal */
				tmpval = 5;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "wpa")) /* wpa enterprise */
				tmpval = 6;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "wpa2")) /* wpa2 enterprise */
				tmpval = 7;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "wpawpa2")) /* wpa auto enterprise */
				tmpval = 8;
			else if(!strcmp(nmp_get("wl0_auth_mode_x"), "radius")) /* radius with 802.1x */
				tmpval = 9;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEPENCRYPTIONWL2G:
        *write_method = write_wepEncryptionWl2g;
        if(nmp_safe_get("wl0_wep_x") != NULL)
      	{
			tmpval = nmp_get_int("wl0_wep_x");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case KEYINDEXWL2G:
        *write_method = write_keyIndexWl2g;
        if(strlen(nmp_safe_get("wl0_key")))
      	{
			tmpval = nmp_get_int("wl0_key");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case PASSPHRASEWL2G:
        *write_method = write_passphraseWl2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl0_phrase_x") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl0_phrase_x"));
			tmpstr[strlen(tmpstr)] = '\0';
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;	
        }
        return NULL;
    case WPAENCRYPTIONWL2G:
        *write_method = write_wpaEncryptionWl2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;
        if(nmp_safe_get("wl0_crypto") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl0_crypto"));	
			if(!strcmp(tmpstr, "tkip")) /* TKIP */
				tmpval = 1;
			else if(!strcmp(tmpstr, "aes")) /* AES */
				tmpval = 2;
			else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
				tmpval = 3;
			
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;	
        }
		return NULL;
    case WPAPRESHAREDKEYWL2G:
        *write_method = write_wpaPreSharedKeyWl2g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl0_wpa_psk") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl0_wpa_psk"));
			tmpstr[strlen(tmpstr)] = '\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
        }
        return NULL;
#if 0/*For Protected Management Frames, only enable for WPA2-Personal and WPA2-Enterprise, ARM platform.*/
    case PROTECTEDMANAGEMENTFRAMEWL2G:
        *write_method = write_protectedManagementFrameWl2g;

        return NULL;
#endif
    case KEYROTATIONINTERVALWL2G:
        *write_method = write_keyRotationIntervalWl2g;
		if(nmp_safe_get("wl0_wpa_gtk_rekey") != NULL)
		{
	      		tmpval = strtol(nmp_safe_get("wl0_wpa_gtk_rekey"), NULL, 10);
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case ENABLEWPSWL2G:
        *write_method = write_enableWPSWl2g;
        if(nmp_safe_get("wl0_wps_mode") != NULL)
		{
			if(!strcmp(nmp_get("wl0_wps_mode"), "enabled")) /* enable */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_wps_mode"), "disabled")) /* disable */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case SWITCHFREQUENCYTO5G:
        *write_method = write_switchFrequencyTo5g;
		if(nmp_get_int("wps_multiband") == 0)
		{
			tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
        return NULL;
    case CONNECTIONSTATUSWL2G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
        strcpy(tmpstr, getWscStatusStr());
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
    case CONFIGUREDWL2G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if(!strcmp(nmp_safe_get("lan_wps_oob"), "disabled"))
	        	strcpy(tmpstr, "Yes");
		else
			strcpy(tmpstr, "No");
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
    case APPINCODEWL2G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wps_device_pin") != NULL)
		{
			strcpy(tmpstr, nmp_get("wps_device_pin"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}
        return NULL;
    case CLIENTPINCODEWL2G:
        *write_method = write_clientPinCodeWl2g;
	memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wps_sta_pin") != NULL)
		{
			if(strcmp(nmp_safe_get("wps_sta_pin"), "00000000"))
				strcpy(tmpstr, nmp_get("wps_sta_pin"));
			else
				strcpy(tmpstr, "");
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}
        return NULL;
    case WPSMETHODWL2G:
        *write_method = write_wpsMethodWl2g;
        tmpval = 3; /* nothing */
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
    case WBMACADDRWL2G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if(nmp_safe_get("wl0_hwaddr") != NULL)
		{
			ether_atoe(nmp_safe_get("wl0_hwaddr"), tmpstr);	
			*var_len = 6;
	     		return ( u_char * )tmpstr;	
		}
		return NULL;
    case WBAPMODEWL2G:
        *write_method = write_wbApModeWl2g;
        if(nmp_safe_get("wl0_mode_x") != NULL)
      	{
			tmpval = nmp_get_int("wl0_mode_x");
			if(tmpval == 0) /* ap only */
				tmpval = 1;
			else if(tmpval == 1) /* wds only */
				tmpval = 2;
			else if(tmpval == 2)	/* hybrid */
				tmpval = 3;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case WBCONNECTREMOTEBRIDEGEAPWL2G:
        *write_method = write_wbConnectRemoteBridegeAPWl2g;
        if(nmp_safe_get("wl0_wdsapply_x") != NULL)
		{
			tmpval = nmp_get_int("wl0_wdsapply_x");
			if(tmpval == 0) /* no */
				tmpval = 2;
			else if(tmpval == 1) /* yes */
				tmpval = 1;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case WBBRIDGEAPSCANACTWL2G:
        *write_method = write_wbBridgeAPScanActWl2g;
        *var_len = sizeof( long );
        tmpval = 2; /* 1: scan	2: nothing */
		return ( u_char * ) &tmpval;
    case MACFILTERMODEWL2G:
        *write_method = write_macFilterModeWl2g;
        if(nmp_safe_get("wl0_macmode") != NULL)
		{
			if(!strcmp(nmp_get("wl0_macmode"), "disabled")) /* disabled */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_macmode"), "allow")) /* accept */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl0_macmode"), "deny")) /* reject */
				tmpval = 3;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case RADIUSSERVERIPADDRWL2G:
        *write_method = write_radiusServerIPAddrWl2g;
        if(nmp_safe_get("wl0_radius_ipaddr") != NULL)
		{
			strcpy(tmpstr, nmp_get("wl0_radius_ipaddr"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case RADIUSPORTWL2G:
        *write_method = write_radiusPortWl2g;
        if(nmp_safe_get("wl0_radius_port") != NULL)
      	{
			tmpval = atoi(nmp_get("wl0_radius_port"));
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case RADIUSCONNECTIONSECRETWL2G:
        *write_method = write_radiusConnectionSecretWl2g;
        if(nmp_safe_get("wl0_radius_key") != NULL)
		{
			strcpy(tmpstr, nmp_get("wl0_radius_key"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case RADIOWL2G:
        *write_method = write_radioWl2g;
        if(nmp_safe_get("wl0_radio") != NULL)
      	{
			tmpval = nmp_get_int("wl0_radio");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case ENABLESCHEDWL2G:
        *write_method = write_enableSchedWl2g;
        if(nmp_safe_get("wl0_timesched") != NULL)
      	{
			tmpval = nmp_get_int("wl0_timesched");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case WEEKDAYSENABLERADIOWL2G:
        *write_method = write_weekDaysEnableRadioWl2g;
        if(nmp_safe_get("wl0_radio_date_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_date_x"));
			if(tmpstr[1]-'0') tmpval += (1 << 7);
			if(tmpstr[2]-'0') tmpval += (1 << 6);
			if(tmpstr[3]-'0') tmpval += (1 << 5);
			if(tmpstr[4]-'0') tmpval += (1 << 4);
			if(tmpstr[5]-'0') tmpval += (1 << 3);
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOSTARTTIMEHWL2G:
        *write_method = write_weekDaysRadioStartTimeHWl2g;
        if(nmp_safe_get("wl0_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
			tmpval += (tmpstr[0]-'0') * 10;
			tmpval += (tmpstr[1]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOSTARTTIMEMWL2G:
        *write_method = write_weekDaysRadioStartTimeMWl2g;
        if(nmp_safe_get("wl0_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
			tmpval += (tmpstr[2]-'0') * 10;
			tmpval += (tmpstr[3]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOENDTIMEHWL2G:
        *write_method = write_weekDaysRadioEndTimeHWl2g;
        if(nmp_safe_get("wl0_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
			tmpval += (tmpstr[4]-'0') * 10;
			tmpval += (tmpstr[5]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOENDTIMEMWL2G:
        *write_method = write_weekDaysRadioEndTimeMWl2g;
        if(nmp_safe_get("wl0_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
			tmpval += (tmpstr[6]-'0') * 10;
			tmpval += (tmpstr[7]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDENABLERADIOWL2G:
        *write_method = write_weekendEnableRadioWl2g;
        if(nmp_safe_get("wl0_radio_date_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_date_x"));
			if(tmpstr[7]-'0') tmpval += (1 << 7);	//saturday
			if(tmpstr[0]-'0') tmpval += (1 << 6);	//sunday
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOSTARTTIMEHWL2G:
        *write_method = write_weekendRadioStartTimeHWl2g;
        if(nmp_safe_get("wl0_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
			tmpval += (tmpstr[0]-'0') * 10;
			tmpval += (tmpstr[1]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOSTARTTIMEMWL2G:
        *write_method = write_weekendRadioStartTimeMWl2g;
        if(nmp_safe_get("wl0_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
			tmpval += (tmpstr[2]-'0') * 10;
			tmpval += (tmpstr[3]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOENDTIMEHWL2G:
        *write_method = write_weekendRadioEndTimeHWl2g;
        if(nmp_safe_get("wl0_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
			tmpval += (tmpstr[4]-'0') * 10;
			tmpval += (tmpstr[5]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOENDTIMEMWL2G:
        *write_method = write_weekendRadioEndTimeMWl2g;
        if(nmp_safe_get("wl0_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
			tmpval += (tmpstr[6]-'0') * 10;
			tmpval += (tmpstr[7]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case APISOLATEDWL2G:
        *write_method = write_apIsolatedWl2g;
        if(nmp_safe_get("wl0_ap_isolate") != NULL)
      	{
			tmpval = nmp_get_int("wl0_ap_isolate");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case ROAMINGASSISTANTWL2G:
        *write_method = write_roamingAssistantWl2g;
        if(nmp_safe_get("wl0_user_rssi") != NULL)
      	{
			tmpval = nmp_get_int("wl0_user_rssi");
			if(tmpval != 0)
				tmpval = 1;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case DISCONNECTCLIENTRSSIWL2G:
        *write_method = write_disconnectClientRSSIWl2g;
        if(nmp_safe_get("wl0_user_rssi") != NULL)
      	{
			tmpval = nmp_get_int("wl0_user_rssi");
			if(tmpval == 0)
				tmpval = -70;//Default RSSI
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case IGMPSNOOPINGWL2G:
        *write_method = write_igmpSnoopingWl2g;
        if(nmp_safe_get("wl0_igs") != NULL)
      	{
			tmpval = nmp_get_int("wl0_igs");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case MULTICASTRATEWL2G:
        *write_method = write_multicastRateWl2g;
        if(nmp_safe_get("wl0_mrate_x") != NULL)
      	{
			tmpval = nmp_get_int("wl0_mrate_x");
			switch(tmpval) {
				case 0:	tmpval = 1; break;	//auto
				case 1: tmpval = 10; break;	//CCK-1
				case 2: tmpval = 11; break;	//CCK-2
				case 3: tmpval = 12; break;	//CCK-5.5
				case 4: tmpval = 2; break;	//OFDM-6
				case 5: tmpval = 3; break;	//OFDM-9
				case 6: tmpval = 13; break;	//CCK-11
				case 7: tmpval = 4; break;	//OFDM-12
				case 8: tmpval = 5; break;	//OFDM-18
				case 9: tmpval = 6; break;	//OFDM-24
				case 10: tmpval = 7; break;	//OFDM-36
				case 11: tmpval = 8; break;	//OFDM-48
				case 12: tmpval = 9; break;	//OFDM-54
			}
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case PREAMBLETYPEWL2G:
        *write_method = write_preambleTypeWl2g;
        if(nmp_safe_get("wl0_plcphdr") != NULL)
		{
			if(!strcmp(nmp_get("wl0_plcphdr"), "long")) /* long */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_plcphdr"), "short")) /* short */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl0_plcphdr"), "auto")) /* auto */
				tmpval = 3;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case AMPDURTSWL2G:
        *write_method = write_aMPDURTSWl2g;
        if(nmp_safe_get("wl0_ampdu_rts") != NULL)
      	{
			tmpval = nmp_get_int("wl0_ampdu_rts");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case RTSTHRESHOLDWL2G:
        *write_method = write_rtsThresholdWl2g;
        if(nmp_safe_get("wl0_rts") != NULL)
      	{
			tmpval = nmp_get_int("wl0_rts");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case DTIMINTERVALWL2G:
        *write_method = write_dtimIntervalWl2g;
        if(nmp_safe_get("wl0_dtim") != NULL)
      	{
			tmpval = nmp_get_int("wl0_dtim");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case BEACONINTERVALWL2G:
        *write_method = write_beaconIntervalWl2g;
        if(nmp_safe_get("wl0_bcn") != NULL)
      	{
			tmpval = nmp_get_int("wl0_bcn");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case TXBURSTINGWL2G:
        *write_method = write_txBurstingWl2g;
        if(nmp_safe_get("wl0_frameburst") != NULL)
		{
			if(!strcmp(nmp_get("wl0_frameburst"), "on")) /* on */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_frameburst"), "off")) /* off */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case WMMAPSDWL2G:
        *write_method = write_wmmAPSDWl2g;
        if(nmp_safe_get("wl0_wme_apsd") != NULL)
		{
			if(!strcmp(nmp_get("wl0_wme_apsd"), "on")) /* Enable */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl0_wme_apsd"), "off")) /* Disable */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case OPTIMIZEAMPDUAGGREGWL2G:
        *write_method = write_optimizeAMPDUAggregWl2g;
        if(nmp_safe_get("wl0_ampdu_mpdu") != NULL)
		{
			tmpval = nmp_get_int("wl0_ampdu_mpdu");/* 0: Disable  1: Enable */
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
        return NULL;
    case OPTIMIZEACKSUPPRESSIONWL2G:
        *write_method = write_optimizeAckSuppressionWl2g;
        if(nmp_safe_get("wl0_ack_ratio") != NULL)
		{
			tmpval = nmp_get_int("wl0_ack_ratio");/* 0: Disable  1: Enable */
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
        return NULL;
    case TXPOWERADJUSTMENTWL2G:
        *write_method = write_txPowerAdjustmentWl2g;
        if(nmp_safe_get("wl0_txpower") != NULL)
      	{
			tmpval = nmp_get_int("wl0_txpower");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;

#ifdef DUAL_BAND
    case SSIDWL5G:
        *write_method = write_ssidWl5g;
        if(nmp_safe_get("wl1_ssid")!=NULL)
		{
			strcpy(tmpstr, nmp_get("wl1_ssid"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case HIDESSIDWL5G:
        *write_method = write_hideSSIDWl5g;
        if(nmp_safe_get("wl1_closed") != NULL)
      	{
			tmpval = nmp_get_int("wl1_closed");/* 0: No 1: Yes*/
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WIRELESSMODEWL5G:
        *write_method = write_wirelessModeWl5g;
        if(nmp_safe_get("wl1_nmode_x") != NULL)
      	{
			tmpval = nmp_get_int("wl1_nmode_x");/* 0: Auto  1: N Only  2: Legacy  8:N/AC mixed */
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case OPTIMIZEDFORXBOXWL5G:
        *write_method = write_optimizedforXboxWl5g;
        if(nmp_safe_get("wl1_optimizexbox") != NULL)
      	{
			tmpval = nmp_get_int("wl1_optimizexbox"); /* 0: No   1: Yes*/
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
	return NULL;
    case CHANNELBANDWIDTHWL5G:
        *write_method = write_channelBandwidthWl5g;
        if(nmp_safe_get("wl1_bw") != NULL)
      	{
			tmpval = nmp_get_int("wl1_bw"); /* 0: 20/40/80 MHz  1: 20 MHz  2: 40MHz  3: 80MHz */
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case CONTROLCHANNELWL5G:
        *write_method = write_controlChannelWl5g;
        if(nmp_safe_get("wl1_chanspec") != NULL)
      	{
			char *p;
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("wl1_chanspec"));
			p = strpbrk(tmpstr, "ul/");
			if(p != 0)
			 	p = '\0';
			fprintf(stderr, "CONTROLCHANNELWL5G: tmpstr = %s\n", tmpstr);//cherry test
			tmpval = atol(tmpstr);
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
        }
        return NULL;
    case EXTENSIONCHANNELWL5G:
        if((nmp_get_int("wl1_bw") != 1) && (nmp_safe_get("wl1_chanspec") != NULL))
      	{
			memset(tmpstr, 0, SPRINT_MAX_LEN);
			strcpy(tmpstr, nmp_safe_get("wl1_chanspec"));
			if(strchr(tmpstr, 'u'))//Below
				tmpval = 2;
			else if(strchr(tmpstr, 'l'))//Above
				tmpval = 3;
			else//Auto
				tmpval = 1;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
        } 
        return NULL;
    case AUTHENTICATIONWL5G:
        *write_method = write_authenticationWl5g;
        if(nmp_safe_get("wl1_auth_mode_x") != NULL)
        {
			if(!strcmp(nmp_get("wl1_auth_mode_x"), "open")) /* open system */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "shared")) /* shared key */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "psk")) /* wpa personal */
				tmpval = 3;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "psk2")) /* wpa2 personal */
				tmpval = 4;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "pskpsk2")) /* wpa auto personal */
				tmpval = 5;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "wpa")) /* wpa enterprise */
				tmpval = 6;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "wpa2")) /* wpa2 enterprise */
				tmpval = 7;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "wpawpa2")) /* wpa auto enterprise */
				tmpval = 8;
			else if(!strcmp(nmp_get("wl1_auth_mode_x"), "radius")) /* radius with 802.1x */
				tmpval = 9;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEPENCRYPTIONWL5G:
        *write_method = write_wepEncryptionWl5g;
        if(nmp_safe_get("wl1_wep_x") != NULL)
      	{
			tmpval = nmp_get_int("wl1_wep_x");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case KEYINDEXWL5G:
        *write_method = write_keyIndexWl5g;
        if(strlen(nmp_safe_get("wl1_key")))
      	{
			tmpval = nmp_get_int("wl1_key");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case PASSPHRASEWL5G:
        *write_method = write_passphraseWl5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl1_phrase_x") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl1_phrase_x"));
			tmpstr[strlen(tmpstr)] = '\0';
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
        }
        return NULL;
    case WPAENCRYPTIONWL5G:
        *write_method = write_wpaEncryptionWl5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        tmpval = 0;
        if(nmp_safe_get("wl1_crypto") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl1_crypto"));	
			if(!strcmp(tmpstr, "tkip")) /* TKIP */
				tmpval = 1;
			else if(!strcmp(tmpstr, "aes")) /* AES */
				tmpval = 2;
			else if(!strcmp(tmpstr,"tkip+aes")) /* TKIP+AES */ 
				tmpval = 3;
			
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;	
        }
		return NULL;
    case WPAPRESHAREDKEYWL5G:
        *write_method = write_wpaPreSharedKeyWl5g;
        memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wl1_wpa_psk") != NULL)
        {
			strcpy(tmpstr, nmp_safe_get("wl1_wpa_psk"));
			tmpstr[strlen(tmpstr)] = '\0';
			*var_len = strlen( tmpstr );
			return ( u_char * ) tmpstr;	
        }
        return NULL;
#if 0 /*For Protected Management Frames, only enable for WPA2-Personal and WPA2-Enterprise, ARM platform.*/
    case PROTECTEDMANAGEMENTFRAMEWL5G:
        *write_method = write_protectedManagementFrameWl5g;

        return NULL;
#endif
    case KEYROTATIONINTERVALWL5G:
        *write_method = write_keyRotationIntervalWl5g;
		if(nmp_safe_get("wl1_wpa_gtk_rekey") != NULL)
		{
	      		tmpval = strtol(nmp_safe_get("wl1_wpa_gtk_rekey"), NULL, 10);
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case ENABLEWPSWL5G:
        *write_method = write_enableWPSWl5g;
        if(nmp_safe_get("wl1_wps_mode") != NULL)
		{
			if(!strcmp(nmp_get("wl1_wps_mode"), "enabled")) /* enable */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl1_wps_mode"), "disabled")) /* disable */
				tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case SWITCHFREQUENCYTO2G:
        *write_method = write_switchFrequencyTo2g;
		if(nmp_get_int("wps_multiband") == 0)
		{
			tmpval = 2;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
	        return NULL;
	    case CONNECTIONSTATUSWL5G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
	        strcpy(tmpstr, getWscStatusStr());
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
    case CONFIGUREDWL5G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if(!strcmp(nmp_safe_get("lan_wps_oob"), "disabled"))
	        	strcpy(tmpstr, "Yes");
		else
			strcpy(tmpstr, "No");
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
    case APPINCODEWL5G:
	memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wps_device_pin") != NULL)
		{
			strcpy(tmpstr, nmp_get("wps_device_pin"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}
        return NULL;
    case WPSMETHODWL5G:
        *write_method = write_wpsMethodWl5g;
        tmpval = 3; /* nothing */
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
    case CLIENTPINCODEWL5G:
        *write_method = write_clientPinCodeWl5g;
	memset(tmpstr, 0, SPRINT_MAX_LEN);
        if(nmp_safe_get("wps_sta_pin") != NULL)
                {
                        if(strcmp(nmp_safe_get("wps_sta_pin"), "00000000"))
                                strcpy(tmpstr, nmp_get("wps_sta_pin"));
                        else
                                strcpy(tmpstr, "");
                        *var_len = strlen(tmpstr);
                        return ( u_char * ) tmpstr;
                }
        return NULL;
    case WBMACADDRWL5G:
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if(nmp_safe_get("wl1_hwaddr") != NULL)
		{
			ether_atoe(nmp_safe_get("wl1_hwaddr"), tmpstr);	
			*var_len = 6;
	     		return ( u_char * )tmpstr;	
		}
        return NULL;
    case WBAPMODEWL5G:
        *write_method = write_wbApModeWl5g;
        if(nmp_safe_get("wl1_mode_x") != NULL)
      	{
			tmpval = nmp_get_int("wl1_mode_x");
			if(tmpval == 0) /* ap only */
				tmpval = 1;
			else if(tmpval == 1) /* wds only */
				tmpval = 2;
			else if(tmpval == 2)	/* hybrid */
				tmpval = 3;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case WBCONNECTREMOTEBRIDEGEAPWL5G:
        *write_method = write_wbConnectRemoteBridegeAPWl5g;
        if(nmp_safe_get("wl1_wdsapply_x") != NULL)
		{
			tmpval = nmp_get_int("wl1_wdsapply_x");
			if(tmpval == 0) /* no */
				tmpval = 2;
			else if(tmpval == 1) /* yes */
				tmpval = 1;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
	return NULL;
    case WBBRIDGEAPSCANACTWL5G:
        *write_method = write_wbBridgeAPScanActWl5g;
        *var_len = sizeof( long );
        tmpval = 2; /* 1: scan	2: nothing */
	return ( u_char * ) &tmpval;
    case MACFILTERMODEWL5G:
        *write_method = write_macFilterModeWl5g;
        if(nmp_safe_get("wl0_macmode") != NULL)
		{
			if(!strcmp(nmp_get("wl1_macmode"), "disabled")) /* disabled */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl1_macmode"), "allow")) /* accept */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl1_macmode"), "deny")) /* reject */
				tmpval = 3;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
	return NULL;
    case RADIUSSERVERIPADDRWL5G:
        *write_method = write_radiusServerIPAddrWl5g;
        if(nmp_safe_get("wl1_radius_ipaddr") != NULL)
		{
			strcpy(tmpstr, nmp_get("wl1_radius_ipaddr"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case RADIUSPORTWL5G:
        *write_method = write_radiusPortWl5g;
        if(nmp_safe_get("wl1_radius_port") != NULL)
      	{
			tmpval = atoi(nmp_get("wl1_radius_port"));
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case RADIUSCONNECTIONSECRETWL5G:
        *write_method = write_radiusConnectionSecretWl5g;
        if(nmp_safe_get("wl1_radius_key") != NULL)
		{
			strcpy(tmpstr, nmp_get("wl1_radius_key"));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}    
        return NULL;
    case RADIOWL5G:
        *write_method = write_radioWl5g;
        if(nmp_safe_get("wl1_radio") != NULL)
      	{
			tmpval = nmp_get_int("wl1_radio");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case ENABLESCHEDWL5G:
        *write_method = write_enableSchedWl5g;
         if(nmp_safe_get("wl1_timesched") != NULL)
      	{
			tmpval = nmp_get_int("wl1_timesched");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case WEEKDAYSENABLERADIOWL5G:
        *write_method = write_weekDaysEnableRadioWl5g;
        if(nmp_safe_get("wl1_radio_date_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_date_x"));
			if(tmpstr[1]-'0') tmpval += (1 << 7);
			if(tmpstr[2]-'0') tmpval += (1 << 6);
			if(tmpstr[3]-'0') tmpval += (1 << 5);
			if(tmpstr[4]-'0') tmpval += (1 << 4);
			if(tmpstr[5]-'0') tmpval += (1 << 3);
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOSTARTTIMEHWL5G:
        *write_method = write_weekDaysRadioStartTimeHWl5g;
        if(nmp_safe_get("wl1_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
			tmpval += (tmpstr[0]-'0') * 10;
			tmpval += (tmpstr[1]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOSTARTTIMEMWL5G:
        *write_method = write_weekDaysRadioStartTimeMWl5g;
        if(nmp_safe_get("wl1_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
			tmpval += (tmpstr[2]-'0') * 10;
			tmpval += (tmpstr[3]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOENDTIMEHWL5G:
        *write_method = write_weekDaysRadioEndTimeHWl5g;
        if(nmp_safe_get("wl1_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
			tmpval += (tmpstr[4]-'0') * 10;
			tmpval += (tmpstr[5]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKDAYSRADIOENDTIMEMWL5G:
        *write_method = write_weekDaysRadioEndTimeMWl5g;
        if(nmp_safe_get("wl1_radio_time_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
			tmpval += (tmpstr[6]-'0') * 10;
			tmpval += (tmpstr[7]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDENABLERADIOWL5G:
        *write_method = write_weekendEnableRadioWl5g;
        if(nmp_safe_get("wl1_radio_date_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_date_x"));
			if(tmpstr[7]-'0') tmpval += (1 << 7);	//saturday
			if(tmpstr[0]-'0') tmpval += (1 << 6);	//sunday
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOSTARTTIMEHWL5G:
        *write_method = write_weekendRadioStartTimeHWl5g;
        if(nmp_safe_get("wl1_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
			tmpval += (tmpstr[0]-'0') * 10;
			tmpval += (tmpstr[1]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOSTARTTIMEMWL5G:
        *write_method = write_weekendRadioStartTimeMWl5g;
        if(nmp_safe_get("wl1_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
			tmpval += (tmpstr[2]-'0') * 10;
			tmpval += (tmpstr[3]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOENDTIMEHWL5G:
        *write_method = write_weekendRadioEndTimeHWl5g;
        if(nmp_safe_get("wl1_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
			tmpval += (tmpstr[4]-'0') * 10;
			tmpval += (tmpstr[5]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case WEEKENDRADIOENDTIMEMWL5G:
        *write_method = write_weekendRadioEndTimeMWl5g;
        if(nmp_safe_get("wl1_radio_time2_x") != NULL)
      	{
			tmpval = 0;
			strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
			tmpval += (tmpstr[6]-'0') * 10;
			tmpval += (tmpstr[7]-'0');
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case APISOLATEDWL5G:
        *write_method = write_apIsolatedWl5g;
        if(nmp_safe_get("wl1_ap_isolate") != NULL)
      	{
			tmpval = nmp_get_int("wl1_ap_isolate");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}	
        return NULL;
    case ROAMINGASSISTANTWL5G:
        *write_method = write_roamingAssistantWl5g;
        if(nmp_safe_get("wl1_user_rssi") != NULL)
      	{
			tmpval = nmp_get_int("wl1_user_rssi");
			if(tmpval != 0)
				tmpval = 1;
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case DISCONNECTCLIENTRSSIWL5G:
        *write_method = write_disconnectClientRSSIWl5g;
        if(nmp_safe_get("wl1_user_rssi") != NULL)
      	{
			tmpval = nmp_get_int("wl1_user_rssi");
			if(tmpval == 0)
				tmpval = -70;//Default RSSI
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case IGMPSNOOPINGWL5G:
        *write_method = write_igmpSnoopingWl5g;
        if(nmp_safe_get("wl1_igs") != NULL)
      	{
			tmpval = nmp_get_int("wl1_igs");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case MULTICASTRATEWL5G:
        *write_method = write_multicastRateWl5g;
        if(nmp_safe_get("wl1_mrate_x") != NULL)
      	{
			tmpval = nmp_get_int("wl1_mrate_x");
			switch(tmpval) {
				case 0:	tmpval = 1; break;	//disable
				//case 1: tmpval = 10; break;	//CCK-1
				//case 2: tmpval = 11; break;	//CCK-2
				//case 3: tmpval = 12; break;	//CCK-5.5
				case 4: tmpval = 2; break;	//OFDM-6
				case 5: tmpval = 3; break;	//OFDM-9
				//case 6: tmpval = 13; break;	//CCK-11
				case 7: tmpval = 4; break;	//OFDM-12
				case 8: tmpval = 5; break;	//OFDM-18
				case 9: tmpval = 6; break;	//OFDM-24
				case 10: tmpval = 7; break;	//OFDM-36
				case 11: tmpval = 8; break;	//OFDM-48
				case 12: tmpval = 9; break;	//OFDM-54
			}
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case PREAMBLETYPEWL5G:
        *write_method = write_preambleTypeWl5g;
        if(nmp_safe_get("wl1_plcphdr") != NULL)
		{
			if(!strcmp(nmp_get("wl1_plcphdr"), "long")) /* long */
				tmpval = 1;
			else if(!strcmp(nmp_get("wl1_plcphdr"), "short")) /* short */
				tmpval = 2;
			else if(!strcmp(nmp_get("wl1_plcphdr"), "auto")) /* auto */
				tmpval = 3;
	      		*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
		}
		return NULL;
    case FRAGTHRESHOLDWL5G:
        *write_method = write_fragThresholdWl5g;
        if(nmp_safe_get("wl1_frag") != NULL)
      	{
			tmpval = nmp_get_int("wl1_frag");
			*var_len = sizeof( long );
			return ( u_char * ) &tmpval;
      	}
        return NULL;
    case RTSTHRESHOLDWL5G:
        *write_method = write_rtsThresholdWl5g;
        if(nmp_safe_get("wl1_rts") != NULL)
      	{
		tmpval = nmp_get_int("wl1_rts");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case DTIMINTERVALWL5G:
        *write_method = write_dtimIntervalWl5g;
        if(nmp_safe_get("wl1_dtim") != NULL)
      	{
		tmpval = nmp_get_int("wl1_dtim");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case BEACONINTERVALWL5G:
        *write_method = write_beaconIntervalWl5g;
        if(nmp_safe_get("wl1_bcn") != NULL)
      	{
		tmpval = nmp_get_int("wl1_bcn");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
    case TXBURSTINGWL5G:
        *write_method = write_txBurstingWl5g;
        if(nmp_safe_get("wl1_frameburst") != NULL)
	{
		if(!strcmp(nmp_get("wl1_frameburst"), "on")) /* on */
			tmpval = 1;
		else if(!strcmp(nmp_get("wl1_frameburst"), "off")) /* off */
			tmpval = 2;
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
	return NULL;
    case WMMWL5G:
        *write_method = write_wmmWl5g;
        if(nmp_safe_get("wl1_wme") != NULL)
	{
		if(!strcmp(nmp_get("wl1_wme"), "auto"))
			tmpval = 1;
		else if(!strcmp(nmp_get("wl1_wme"), "on")) /* Enable */
			tmpval = 2;
		else if(!strcmp(nmp_get("wl1_wme"), "off")) /* Disable */
			tmpval = 3;
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
        return NULL;
    case WMMNOACKNOWLEDGEMENTWL5G:
        *write_method = write_wmmNoAcknowledgementWl5g;
        if(nmp_safe_get("wl1_wme") != NULL)
	{
		if(!strcmp(nmp_get("wl1_wme_no_ack"), "on")) /* Enable */
			tmpval = 1;
		else if(!strcmp(nmp_get("wl1_wme_no_ack"), "off")) /* Disable */
			tmpval = 2;
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
        return NULL;
    case WMMAPSDWL5G:
        *write_method = write_wmmAPSDWl5g;
        if(nmp_safe_get("wl1_wme_apsd") != NULL)
	{
		if(!strcmp(nmp_get("wl1_wme_apsd"), "on")) /* on */
			tmpval = 1;
		else if(!strcmp(nmp_get("wl1_wme_apsd"), "off")) /* off */
			tmpval = 2;
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
	return NULL;
    case OPTIMIZEAMPDUAGGREGWL5G:
        *write_method = write_optimizeAMPDUAggregWl5g;
        if(nmp_safe_get("wl1_ampdu_mpdu") != NULL)
	{
		tmpval = nmp_get_int("wl1_ampdu_mpdu");/* 0: Disable  1: Enable */
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
        return NULL;
    case OPTIMIZEACKSUPPRESSIONWL5G:
        *write_method = write_optimizeAckSuppressionWl5g;
        if(nmp_safe_get("wl1_ack_ratio") != NULL)
	{
		tmpval = nmp_get_int("wl1_ack_ratio");/* 0: Disable  1: Enable */
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
        return NULL;
    case EXPLICITBEAMFORMINGWL5G:
        *write_method = write_explicitBeamformingWl5g;
        if(nmp_safe_get("wl1_txbf") != NULL)
	{
		tmpval = nmp_get_int("wl1_txbf");/* 0: Disable  1: Enable */
      		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
	}
        return NULL;
    case TXPOWERADJUSTMENTWL5G:
        *write_method = write_txPowerAdjustmentWl5g;
        if(nmp_safe_get("wl1_txpower") != NULL)
      	{
		tmpval = nmp_get_int("wl1_txpower");
		*var_len = sizeof( long );
		return ( u_char * ) &tmpval;
      	}
        return NULL;
#endif	//#ifdef DUAL_BAND
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_wl2gWepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wl2gWepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static unsigned char string[SPRINT_MAX_LEN];
    static long keyIndex;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    memset(string, 0, SPRINT_MAX_LEN);

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXWEPKEY /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WEPKEYINDEXWL2G:
        return NULL;
    case WEPKEYVALUEWL2G:
        *write_method = write_wepKeyValueWl2g;
        keyIndex = name[*length-1];
		sprintf(string, "wl0_key%d", keyIndex);
		string[strlen(string)] = '\0';
		if(nmp_safe_get(string) != NULL) {
			strcpy(tmpstr, nmp_safe_get(string));
			*var_len = strlen(tmpstr);
			return ( u_char * ) tmpstr;
		}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_wbWl2gBridgeAPScanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wbWl2gBridgeAPScanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 32/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WBAPRESULTINDEXWL2G:
        return NULL;
    case WBAPRESULTBSSIDWL2G:
    	index = name[*length-1]-1;
    	if(index < ap_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%02X:%02X:%02X:%02X:%02X:%02X", ap_list[index].BSSID[0],
								ap_list[index].BSSID[1],
								ap_list[index].BSSID[2],
								ap_list[index].BSSID[3],
								ap_list[index].BSSID[4],
								ap_list[index].BSSID[5]);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    case WBAPRESULTSSIDWL2G:
	index = name[*length-1]-1;
    	if(index < ap_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr,"%s", ap_list[index].ssid);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_wbWl2gRemoteAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wbWl2gRemoteAPTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int i, wdslist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXRBRIDGE; i++)
    	memset(wdslist[i], 0x0, MACSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of wds list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;		
	}
	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXRBRIDGE/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WBREMOTEAPINDEXWL2G:
        return NULL;
    case WBREMOTEAPMACADDRWL2G:
        *write_method = write_wbRemoteAPMACAddrWl2g;
        index = name[*length-1]-1;
        if(index <= wdslist_count-1) {
        	memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		ether_atoe(wdslist[index], tmpstr);
    	}
	*var_len = 6;
     	return ( u_char * )tmpstr;
    case WBREMOTEAPDELENTRYWL2G:
        *write_method = write_wbRemoteAPDelEntryWl2g;
    	tmpval = 2; /* no */
 	*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }

    for(i = 0; i < MAXRBRIDGE; i++)
    	free(wdslist[i]);

    return NULL;
}

/*
 * var_wl2gMacFilterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wl2gMacFilterTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int i, maclist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of mac list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXMACFILTER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case MACFILTERINDEXWL2G:
        return NULL;
    case MACFILTERMACADDRWL2G:
        *write_method = write_macFilterMACAddrWl2g;
        index = name[*length-1]-1;
        if(index <= maclist_count-1) {
        	memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		ether_atoe(maclist[index], tmpstr);
    	}
	*var_len = 6;
     	return ( u_char * )tmpstr;
    case MACFILTERDELENTRYWL2G:
        *write_method = write_macFilterDelEntryWl2g;
        tmpval = 2; /* no */
 	*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }

    return NULL;
}

#ifdef DUAL_BAND
/*
 * var_wl5gWepKeyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wl5gWepKeyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static unsigned char string[SPRINT_MAX_LEN];
    static long keyIndex;

    memset(tmpstr, 0, SPRINT_MAX_LEN);
    memset(string, 0, SPRINT_MAX_LEN);

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXWEPKEY /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WEPKEYINDEXWL5G:
        return NULL;
    case WEPKEYVALUEWL5G:
        *write_method = write_wepKeyValueWl5g;
        keyIndex = name[*length-1];
	sprintf(string, "wl1_key%d", keyIndex);
	string[strlen(string)] = '\0';
	if(nmp_safe_get(string) != NULL) {
		strcpy(tmpstr, nmp_safe_get(string));
		*var_len = strlen(tmpstr);
		return ( u_char * ) tmpstr;
	}
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_wbWl5gBridgeAPScanTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wbWl5gBridgeAPScanTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index = 0;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, 32/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WBAPRESULTINDEXWL5G:
        return NULL;
    case WBAPRESULTBSSIDWL5G:
    	index = name[*length-1]-1;
    	if(index < ap_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr, "%02X:%02X:%02X:%02X:%02X:%02X", ap_list[index].BSSID[0],
								ap_list[index].BSSID[1],
								ap_list[index].BSSID[2],
								ap_list[index].BSSID[3],
								ap_list[index].BSSID[4],
								ap_list[index].BSSID[5]);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    case WBAPRESULTSSIDWL5G:
	index = name[*length-1]-1;
    	if(index < ap_count)
    	{
    		memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    		sprintf(tmpstr,"%s", ap_list[index].ssid);
    		*var_len = strlen(tmpstr);
      		return ( u_char * )tmpstr;			
    	}	
        return NULL;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_wbWl5gRemoteAPTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wbWl5gRemoteAPTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int i, wdslist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXRBRIDGE; i++)
    	memset(wdslist[i], 0x0, MACSTRNUM);
    
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of wds list for 5G
    nv = nvp = strdup(nmp_safe_get("wl1_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;		
	}
	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXRBRIDGE/*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case WBREMOTEAPINDEXWL5G:
        return NULL;
    case WBREMOTEAPMACADDRWL5G:
        *write_method = write_wbRemoteAPMACAddrWl5g;
        index = name[*length-1]-1;
        if(index <= wdslist_count-1) {
        	memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		ether_atoe(wdslist[index], tmpstr);
    	}
	*var_len = 6;
     	return ( u_char * )tmpstr;
    case WBREMOTEAPDELENTRYWL5G:
        *write_method = write_wbRemoteAPDelEntryWl5g;
    	tmpval = 2; /* no */
 	*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_wl5gMacFilterTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wireless above.
 */
unsigned char *
var_wl5gMacFilterTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long index;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int i, maclist_count = 0;
    char *nv, *nvp, *b;

    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);

    //Compute the number of mac list for 5G
    nv = nvp = strdup(nmp_safe_get("wl1_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, MAXMACFILTER /*TABLE_SIZE*/)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case MACFILTERINDEXWL5G:
        return NULL;
    case MACFILTERMACADDRWL5G:
        *write_method = write_macFilterMACAddrWl5g;
        index = name[*length-1]-1;
        if(index <= maclist_count-1) {
        	memset(tmpstr, 0x0, SPRINT_MAX_LEN);
		ether_atoe(maclist[index], tmpstr);
    	}
	*var_len = 6;
     	return ( u_char * )tmpstr;
    case MACFILTERDELENTRYWL5G:
        *write_method = write_macFilterDelEntryWl5g;
        tmpval = 2; /* no */
 	*var_len = sizeof(unsigned long);
      	return ( u_char * )&tmpval;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
#endif	//#ifdef DUAL_BAND


int
write_ssidWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ssidWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to ssidWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
		strncpy(string, (u_char *)var_val, var_val_len); 
		string[var_val_len] = '\0';
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		nmp_set("wl0_ssid", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_hideSSIDWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to hideSSIDWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr, "write to hideSSIDWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to hideSSIDWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 0 || value == 1){
		nmp_set_int("wl0_closed", value);	
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wirelessModeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wirelessModeWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wirelessModeWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 2) {
              fprintf(stderr, "write to wirelessModeWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
           break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= 2) {
		nmp_set_int("wl0_nmode_x", value);
	     }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizedforXboxWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to optimizedforXboxWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to optimizedforXboxWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to optimizedforXboxWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
		/* 0: Disable the function of optimized for Xbox. 
  	           1: Enable the function of optimized for Xbox. */
             if(value == 0 || value == 1){
		nmp_set_int("wl0_optimizexbox", value);		
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_protectionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to protectionWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to protectionWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to protectionWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 || value == 2) {
		switch(value)
      		{
      			case 1:/* Enable protection */
				nmp_set("wl0_gmode_protection", "auto");
				break;		
      			case 2:/* Disable protection */	
				nmp_set("wl0_gmode_protection", "off");
				break;     					
      		}		
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_channelBandwidthWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to channelBandwidthWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to channelBandwidthWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to channelBandwidthWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	     /* 0: 20/40Mhz  1: 20Mhz  2: 40Mhz*/
             if(value >= 0 && value <= 2) {
		if( !strcmp(nmp_safe_get("wl0_nmode_x"), "2") && value != 1 ) {//Legacy. Only support 20MHz.
			return SNMP_ERR_WRONGVALUE;			
		}
		nmp_set_int("wl0_bw", value);
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_controlChannelWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size, num, channels[32];
    char *country_code = nvram_safe_get("country_code");

    size  = var_val_len;
    value = * (long *) var_val;
    num = channels_in_country(0, channels);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to controlChannelWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to controlChannelWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value < 0 || value > channels[num]){
              fprintf(stderr, "write to controlChannelWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= channels[num])
             {
		int bw = nmp_get_int("wl0_bw");
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if( bw == 1 ){//20MHz
			sprintf(tmpstr, "%d", value);
		}	
		else if( bw == 0 || bw == 2 ){// 20/40MHz or 40MHz
			if( value >= 1 && value <=7 )
				sprintf(tmpstr, "%dl", value);
			else if( value >= 10 && value <= 14)
				sprintf(tmpstr, "%du", value);
			else if( value == 8 || value == 9 ){
				if(!strcmp(country_code, "Q2") || !strcmp(country_code, "TW") || !strcmp(country_code, "US"))
					sprintf(tmpstr, "%du", value);	
				else
					sprintf(tmpstr, "%dl", value);						
			}
			else
				sprintf(tmpstr, "%d", value);
		}

		nmp_set("wl0_chanspec", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_extensionChannelWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size, channel;
    char *p;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to extensionChannelWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to extensionChannelWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3) {
              fprintf(stderr, "write to extensionChannelWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		strcpy(tmpstr, nmp_safe_get("wl0_chanspec"));
		p = strpbrk(tmpstr, "ul/");
		if(p != 0)
		 	p = '\0';
		channel = atol(tmpstr);

      		switch(value)
      		{
      			case 1:/* Auto */
				if(nmp_get_int("wl0_bw") == 1){//20MHz
					fprintf(stderr, "In 20MHz, user can't set extension channel.\n");
					return SNMP_ERR_NOSUCHNAME;
				}
				nmp_set("wl0_chanspec", tmpstr);
				break;
      			case 2:/* Above */
				if(nmp_get_int("wl0_bw") == 1){//20MHz
					fprintf(stderr, "In 20MHz, user can't set extension channel.\n");
					return SNMP_ERR_NOSUCHNAME;
				}
				nmp_set("wl0_chanspec", tmpstr);
				break;
      			case 3:	/* Below */
				if(nmp_get_int("wl0_bw") == 1){//20MHz
					fprintf(stderr, "In 20MHz, user can't set extension channel.\n");
					return SNMP_ERR_NOSUCHNAME;
				}
				nmp_set("wl0_chanspec", tmpstr);
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authenticationWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to authenticationWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to authenticationWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to authenticationWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 9) {
      		switch(value)
      		{
      			case 1:/* open system */
				nmp_set("wl0_auth_mode_x", "open");
				break;
      			case 2:/* shared key */
				nmp_set("wl0_auth_mode_x", "shared");
				break;
      			case 3:	/* wpa personal */
				nmp_set("wl0_auth_mode_x", "psk");
				break;
			case 4:/* wpa2 personal */
				nmp_set("wl0_auth_mode_x", "psk2");
				break;
      			case 5:/* wpa auto personal */
				nmp_set("wl0_auth_mode_x", "pskpsk2");
				break;
      			case 6:	/* wpa enterprise */
				nmp_set("wl0_auth_mode_x", "wpa");
				break;
			case 7:/* wpa2 enterprise */
				nmp_set("wl0_auth_mode_x", "wpa2");
				break;
      			case 8:/* wpa auto enterprise */
				nmp_set("wl0_auth_mode_x", "wpawpa2");
				break;
      			case 9:	/* radius with 802.1x */
				nmp_set("wl0_auth_mode_x", "radius");
				break;
		}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wepEncryptionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wepEncryptionWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wepEncryptionWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wepEncryptionWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			nmp_set_int("wl0_wep_x", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_keyIndexWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;         

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to keyIndexWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to keyIndexWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to keyIndexWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4)
		nmp_set_int("wl0_key", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_passphraseWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to passphraseWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(string, (u_char *)var_val, var_val_len); 
             string[var_val_len] = '\0';
             nmp_set("wl0_phrase_x", string);
             generateWepKey("0", string);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaEncryptionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wpaEncryptionWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wpaEncryptionWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write wpaEncryptionWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3)
             {
	      		switch(value)
	      		{
	      			case 1:/* TKIP */
					if( strstr(nmp_get("wl0_auth_mode_x"), "psk2") || strstr(nmp_get("wl0_auth_mode_x"), "wpa2") )
						return SNMP_ERR_WRONGVALUE;	
	      				nmp_set("wl0_crypto", "tkip");
	      				break;
	      			case 2:/* AES */
					if( !strcmp(nmp_get("wl0_auth_mode_x"), "psk") || !strcmp(nmp_get("wl0_auth_mode_x"), "wpa") )
						return SNMP_ERR_WRONGVALUE;
	      				nmp_set("wl0_crypto", "aes");
	      				break;
					case 3:/* TKIP+AES */
					if( !strcmp(nmp_get("wl0_auth_mode_x"), "psk") || !strcmp(nmp_get("wl0_auth_mode_x"), "wpa") )
						return SNMP_ERR_WRONGVALUE;
	      				nmp_set("wl0_crypto", "tkip+aes");
	      				break;
				}
			}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaPreSharedKeyWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wpaPreSharedKeyWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to wpaPreSharedKeyWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 8 && var_val_len <= 63)
             {
				strncpy(string, (u_char *)var_val, var_val_len);
				string[var_val_len] = '\0';
	        	nmp_set("wl0_wpa_psk", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /*For Protected Management Frames, only enable for WPA2-Personal and WPA2-Enterprise, ARM platform.*/
int
write_protectedManagementFrameWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif


int
write_keyRotationIntervalWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to keyRotationIntervalWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to keyRotationIntervalWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             sprintf(tmpstr, "%d", value);
             tmpstr[var_val_len] = '\0';
             nmp_set("wl0_wpa_gtk_rekey", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableWPSWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to enableWPSWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to enableWPSWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enableWPSWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("wl0_wps_mode", "enabled");
             	else if(value == 2)
			nmp_set("wl0_wps_mode", "disabled");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_switchFrequencyTo5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to switchFrequencyTo5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to switchFrequencyTo5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to switchFrequencyTo5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(nmp_get_int("wps_multiband") == 0)
			{
				if(!strcmp(nmp_safe_get("wl_wps_mode"), "disabled"))
				{
					if(value == 1)
						nmp_set("wps_band_x", "1"); /* 0: 2.4g  1: 5g */			
				}
				else
					return SNMP_ERR_WRONGVALUE; /* Frequency can't be switched when wps is enabled. */
		  	}
		  	else
				return SNMP_ERR_NOSUCHNAME;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpsMethodWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wpsMethodWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wpsMethodWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write to wpsMethodWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(value == 1 || value == 2)
				nmp_notify_rc("start_wps_method");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_clientPinCodeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    strncpy(tmpstr, (u_char *)var_val, var_val_len); 
    tmpstr[var_val_len] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wireless not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (!wl_wpsPincheck(tmpstr)) {
              fprintf ( stderr,"write to clientPinCodeWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("wps_sta_pin", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbApModeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbApModeWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbApModeWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to wbApModeWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value >= 1 && value <= 3) {
	      		switch(value)
	      		{
	      			case 1:/* ap only */
					nmp_set("wl0_mode_x", "0");
					break;
	      			case 2:/* wds only */
					nmp_set("wl0_mode_x", "1");
					break;
	      			case 3:	/* hybrid */
					nmp_set("wl0_mode_x", "2");
					break;
				}
            } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbConnectRemoteBridegeAPWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbConnectRemoteBridegeAPWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbConnectRemoteBridegeAPWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wbConnectRemoteBridegeAPWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
				if(value == 1)
					nmp_set("wl0_wdsapply_x", "1");
				else if(value == 2)
					nmp_set("wl0_wdsapply_x", "0"); 
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbBridgeAPScanActWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbBridgeAPScanActWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbBridgeAPScanActWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to wbBridgeAPScanActWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
            if(value == 1) {
      			ap_count = wl_scan(&ap_list, 0);
		//nmp_set_int("ap_count", ap_count);
            }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_macFilterModeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to macFilterModeWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to macFilterModeWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 3 ){
              fprintf ( stderr,"write to macFilterModeWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(value >= 1 && value <= 3) {
				if(value == 1)
					nmp_set("wl0_macmode", "disabled");
				else if(value == 2)
					nmp_set("wl0_macmode", "allow"); 
				else if(value == 3)
					nmp_set("wl0_macmode", "deny"); 
			}
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusServerIPAddrWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to radiusServerIPAddrWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 39) {
              fprintf(stderr, "write to radiusServerIPAddrWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 39) {
				strncpy(tmpstr, (u_char *)var_val, var_val_len); 
				tmpstr[var_val_len] = '\0';
				nmp_set("wl0_radius_ipaddr", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusPortWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to radiusPortWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 65535 ){
              fprintf(stderr, "write to radiusPortWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value <= 65535)
				nmp_set_int("wl0_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusConnectionSecretWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to radiusConnectionSecretWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(tmpstr, (u_char *)var_val, var_val_len); 
             tmpstr[var_val_len] = '\0';
             nmp_set("wl0_radius_key", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radioWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to radioWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to radioWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to radioWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
  	     nmp_set_int("wl0_radio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableSchedWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to enableSchedWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wl0_timesched", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysEnableRadioWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;
    char dateStr[16];

    size  = var_val_len;
    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to weekDaysEnableRadioWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to weekDaysEnableRadioWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_date_x"));
             (tmpstr[0]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 5)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 4)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 3)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[7]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("wl0_radio_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioStartTimeHWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioStartTimeHWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioStartTimeHWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekDaysRadioStartTimeHWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("wl0_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioStartTimeMWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioStartTimeMWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioStartTimeMWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekDaysRadioStartTimeMWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("wl0_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioEndTimeHWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioEndTimeHWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("wl0_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioEndTimeMWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("wl0_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendEnableRadioWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;
    char dateStr[16];

    size  = var_val_len;
    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to weekendEnableRadioWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to weekendEnableRadioWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_date_x"));
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[1]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[2]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[3]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[4]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[5]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("wl0_radio_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioStartTimeHWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioStartTimeHWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioStartTimeHWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekendRadioStartTimeHWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("wl0_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioStartTimeMWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioStartTimeMWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioStartTimeMWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekendRadioStartTimeMWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("wl0_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioEndTimeHWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioEndTimeHWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioEndTimeHWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekendRadioEndTimeHWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("wl0_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioEndTimeMWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioEndTimeMWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioEndTimeMWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekendRadioEndTimeMWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl0_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("wl0_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apIsolatedWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apIsolatedWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apIsolatedWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to apIsolatedWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	      	nmp_set_int("wl0_ap_isolate", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_roamingAssistantWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to roamingAssistantWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to roamingAssistantWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to roamingAssistantWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if( value == 0 )
				nmp_set_int("wl0_user_rssi", value);
			else if( value == 1 )
				nmp_set("wl0_user_rssi", "-70");//-70 is default RSSI
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_disconnectClientRSSIWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to disconnectClientRSSIWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to disconnectClientRSSIWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < -90 || *(long *)var_val > -70 ){
              fprintf(stderr, "write to disconnectClientRSSIWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		nmp_set_int("wl0_user_rssi", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_igmpSnoopingWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to igmpSnoopingWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to igmpSnoopingWl2g(: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to igmpSnoopingWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		nmp_set_int("wl0_igs", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_multicastRateWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to multicastRateWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to multicastRateWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 13 ){
              fprintf(stderr, "write to multicastRateWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             switch(value) {
				case 1: tmpval = 0; break;	//auto
				case 2: tmpval = 4; break;	//OFDM-6
				case 3: tmpval = 5; break;	//OFDM-9
				case 4: tmpval = 7; break;	//OFDM-12
				case 5: tmpval = 8; break;	//OFDM-18
				case 6: tmpval = 9; break;	//OFDM-24
				case 7: tmpval = 10; break;	//OFDM-36
				case 8: tmpval = 11; break;	//OFDM-48
				case 9: tmpval = 12; break;	//OFDM-54
				case 10: tmpval = 1; break;	//CCK-1
				case 11: tmpval = 2; break;	//CCK-2
				case 12: tmpval = 3; break;	//CCK-5.5
				case 13: tmpval = 6; break;	//CCK-11
             }
             nmp_set_int("wl0_mrate_x", tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_preambleTypeWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to preambleTypeWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to preambleTypeWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 3 ){
              fprintf ( stderr,"write to preambleTypeWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
				if(value == 1)
					nmp_set("wl0_plcphdr", "long");
				else if(value == 2)
					nmp_set("wl0_plcphdr", "short");
				else if(value == 3)
					nmp_set("wl0_plcphdr", "auto");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fragmentationThresholdWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to fragmentationThresholdWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to fragmentationThresholdWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 256 || *(long *)var_val > 2346 ) {
              fprintf(stderr, "write to fragmentationThresholdWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl0_frag", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_aMPDURTSWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to aMPDURTSWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to aMPDURTSWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to aMPDURTSWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          	nmp_set_int("wl0_ampdu_rts", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rtsThresholdWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to rtsThresholdWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to rtsThresholdWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2347 ) {
              fprintf(stderr, "write to rtsThresholdWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl0_rts", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dtimIntervalWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dtimIntervalWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dtimIntervalWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 255 ) {
              fprintf(stderr, "write to dtimIntervalWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl0_dtim", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_beaconIntervalWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to beaconIntervalWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to beaconIntervalWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 20 || *(long *)var_val > 1000 ) {
              fprintf(stderr, "write to beaconIntervalWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl0_bcn", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_txBurstingWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to txBurstingWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to txBurstingWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to txBurstingWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1)
		nmp_set("wl0_frameburst", "on");
             else if(value == 2)
		nmp_set("wl0_frameburst", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmmAPSDWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmmAPSDWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmmAPSDWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wmmAPSDWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1)
		nmp_set("wl0_wme_apsd", "on");
             else if(value == 2)
		nmp_set("wl0_wme_apsd", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizeAMPDUAggregWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to optimizeAMPDUAggregWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to optimizeAMPDUAggregWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to optimizeAMPDUAggregWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  nmp_set_int("wl0_ampdu_mpdu", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizeAckSuppressionWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to optimizeAckSuppressionWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          	nmp_set_int("wl0_ack_ratio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_txPowerAdjustmentWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to txPowerAdjustmentWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to txPowerAdjustmentWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 100 ) {
              fprintf(stderr, "write to txPowerAdjustmentWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl0_txpower", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


#ifdef DUAL_BAND
int
write_ssidWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to ssidWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32){/* The maximum length of SSID is 32. */
              fprintf(stderr, "write to ssidWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 32) {
				strncpy(string, (u_char *)var_val, var_val_len); 
				string[var_val_len] = '\0';
				nmp_set("wl1_ssid", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_hideSSIDWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to hideSSIDWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to hideSSIDWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to hideSSIDWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 0 || value == 1){
				nmp_set_int("wl1_closed", value);   					
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wirelessModeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wirelessModeWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wirelessModeWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ){
              fprintf(stderr, "write to wirelessModeWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= 2 || value == 8){
				nmp_set_int("wl1_nmode_x", value);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizedforXboxWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to optimizedforXboxWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to optimizedforXboxWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
      	  if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to optimizedforXboxWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 0 || value == 1){
				nmp_set_int("wl1_optimizexbox", value);					
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_channelBandwidthWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to channelBandwidthWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to channelBandwidthWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to channelBandwidthWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	      	/* 0: 20/40/80Mhz  1: 20MHz  2: 40MHz  3: 80MHz */
			if(value >= 0 && value <= 3) {
				if( !strcmp(nmp_safe_get("wl1_nmode_x"), "2") && value != 1 ) {//Legacy. Only support 20MHz.
					return SNMP_ERR_WRONGVALUE;
				}
				nmp_set_int("wl1_bw", value);
            } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_controlChannelWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size, num, channels[32];
    char *country_code = nvram_safe_get("country_code");

    size  = var_val_len;
    value = * (long *) var_val;
    num = channels_in_country(1, channels);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to controlChannelWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to controlChannelWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (value < 0 || value > channels[num]){
              fprintf(stderr, "write to controlChannelWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= channels[num]){
		int bw = nmp_get_int("wl1_bw");
		memset(tmpstr, 0, SPRINT_MAX_LEN);
		if( bw == 1){//20MHz
			sprintf(tmpstr, "%d", value);
		}
		else if( (bw == 0 && !strcmp(nvram_safe_get("preferred_lang"), "UK")) || bw == 2 ){// Auto for UK, 40MHz
			if( value == 36 || value == 44 || value == 52 || value == 60 || value == 100
				|| value == 108 || value == 116 || value == 124 || value == 132 || value == 140
				|| value == 149 || value == 157)
				sprintf(tmpstr, "%dl", value);
			else if( value == 40 || value == 48 || value == 56 || value == 64 || value == 104
				|| value == 112 || value == 120 || value == 128 || value == 136 || value == 144
				|| value == 153 || value == 161)
				sprintf(tmpstr, "%du", value);
			else
				sprintf(tmpstr, "%d", value);						
		}
		else if( bw == 3 ){// 80MHz
			if( value == 0 )
				sprintf(tmpstr, "%d", value);
			else
				sprintf(tmpstr, "%d/80", value);
		}
		else if ( bw == 0 && strcmp(nvram_safe_get("preferred_lang"), "UK")){ //Auto not for UK
			if( value == 0 || value == 165 )
				sprintf(tmpstr, "%d", value);
			else if( (value == 116 || value == 132 || value == 140) && !strcmp(country_code, "EU") )
				sprintf(tmpstr, "%dl", value);
			else if( (value == 136) && !strcmp(country_code, "EU") )
				sprintf(tmpstr, "%du", value);
			else
				sprintf(tmpstr, "%d/80", value);
		}
		else
			sprintf(tmpstr, "%d", value);
	
		nmp_set("wl1_chanspec", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_authenticationWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to authenticationWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to authenticationWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 9) {
              fprintf(stderr, "write to authenticationWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
      		switch(value)
      		{
      			case 1:/* open system */
					nmp_set("wl1_auth_mode_x", "open");
					break;
      			case 2:/* shared key */
					nmp_set("wl1_auth_mode_x", "shared");
					break;
      			case 3:	/* wpa personal */
					nmp_set("wl1_auth_mode_x", "psk");
					break;
				case 4:/* wpa2 personal */
					nmp_set("wl1_auth_mode_x", "psk2");
					break;
      			case 5:/* wpa auto personal */
					nmp_set("wl1_auth_mode_x", "pskpsk2");
					break;
      			case 6:	/* wpa enterprise */
					nmp_set("wl1_auth_mode_x", "wpa");
					break;
				case 7:/* wpa2 enterprise */
					nmp_set("wl1_auth_mode_x", "wpa2");
					break;
      			case 8:/* wpa auto enterprise */
					nmp_set("wl1_auth_mode_x", "wpawpa2");
					break;
      			case 9:	/* radius with 802.1x */
					nmp_set("wl1_auth_mode_x", "radius");
					break;
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wepEncryptionWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wepEncryptionWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wepEncryptionWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wepEncryptionWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 0 && value <= 2) {
		nmp_set_int("wl1_wep_x", value);
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_keyIndexWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val; 

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to keyIndexWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to keyIndexWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 4 ) {
              fprintf(stderr, "write to keyIndexWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 4)
		nmp_set_int("wl1_key", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_passphraseWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wireless not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(string, (u_char *)var_val, var_val_len); 
             string[var_val_len] = '\0';
             nmp_set("wl1_phrase_x", string);
             generateWepKey("1", string);	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaEncryptionWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wpaEncryptionWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wpaEncryptionWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 0 || *(long *)var_val > 3){
              fprintf ( stderr,"write wpaEncryptionWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3)
             {
	      		switch(value)
	      		{
	      			case 1:/* TKIP */
					if( strstr(nmp_get("wl1_auth_mode_x"), "psk2") || strstr(nmp_get("wl1_auth_mode_x"), "wpa2") )
						return SNMP_ERR_WRONGVALUE;	
	      				nmp_set("wl1_crypto", "tkip");
	      				break;
	      			case 2:/* AES */
					if( !strcmp(nmp_get("wl1_auth_mode_x"), "psk") || !strcmp(nmp_get("wl1_auth_mode_x"), "wpa") )
						return SNMP_ERR_WRONGVALUE;
	      				nmp_set("wl1_crypto", "aes");
	      				break;
					case 3:/* TKIP+AES */
					if( !strcmp(nmp_get("wl1_auth_mode_x"), "psk") || !strcmp(nmp_get("wl1_auth_mode_x"), "wpa") )
						return SNMP_ERR_WRONGVALUE;
	      				nmp_set("wl1_crypto", "tkip+aes");
	      				break;
				}
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpaPreSharedKeyWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];
    memset(string, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wpaPreSharedKeyWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( var_val_len < 8 || var_val_len > 63 ) {
              fprintf(stderr, "write to wpaPreSharedKeyWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len >= 8 && var_val_len <= 63)
             {
		strncpy(string, (u_char *)var_val, var_val_len);
		string[var_val_len] = '\0';
        	nmp_set("wl1_wpa_psk", string);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#if 0 /*For Protected Management Frames, only enable for WPA2-Personal and WPA2-Enterprise, ARM platform.*/
int
write_protectedManagementFrameWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif


int
write_keyRotationIntervalWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to keyRotationIntervalWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to keyRotationIntervalWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             memset(tmpstr, 0, SPRINT_MAX_LEN);
             sprintf(tmpstr, "%d", value);
             tmpstr[var_val_len] = '\0';
             nmp_set("wl1_wpa_gtk_rekey", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableWPSWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to enableWPSWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to enableWPSWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to enableWPSWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
             	if(value == 1)
			nmp_set("wl1_wps_mode", "enabled");
             	else if(value == 2)
			nmp_set("wl1_wps_mode", "disabled");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_switchFrequencyTo2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to switchFrequencyTo2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to switchFrequencyTo2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if (*(long *)var_val < 1 || *(long *)var_val > 2){
              fprintf ( stderr,"write to switchFrequencyTo2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(nmp_get_int("wps_multiband") == 0)
	  		{
				if(!strcmp(nmp_safe_get("wl_wps_mode"), "disabled"))
				{
					if(value == 1)
						nmp_set("wps_band_x", "0"); /* 0: 2.4g  1: 5g */			
				}
				else
					return SNMP_ERR_WRONGVALUE; /* Frequency can't be switched when wps is enabled. */
	  		}
	  		else
				return SNMP_ERR_NOSUCHNAME;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wpsMethodWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wpsMethodWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wpsMethodWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
         if (*(long *)var_val < 1 || *(long *)var_val > 3){
              fprintf ( stderr,"write to wpsMethodWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		if(value == 1 || value == 2)
	  			nmp_notify_rc("start_wps_method");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_clientPinCodeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    strncpy(tmpstr, (u_char *)var_val, var_val_len); 
    tmpstr[var_val_len] = '\0';

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to clientPinCodeWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to clientPinCodeWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set("wps_sta_pin", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbApModeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbApModeWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbApModeWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to wbApModeWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
	      		switch(value)
	      		{
	      			case 1:/* ap only */
					nmp_set("wl1_mode_x", "0");
					break;
	      			case 2:/* wds only */
					nmp_set("wl1_mode_x", "1");
					break;
	      			case 3:	/* hybrid */
					nmp_set("wl1_mode_x", "2");
					break;
				}
             } 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbConnectRemoteBridegeAPWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbConnectRemoteBridegeAPWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbConnectRemoteBridegeAPWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wbConnectRemoteBridegeAPWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 2) {
		if(value == 1)
			nmp_set("wl1_wdsapply_x", "1");
		else if(value == 2)
			nmp_set("wl1_wdsapply_x", "0"); 
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wbBridgeAPScanActWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbBridgeAPScanActWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbBridgeAPScanActWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 2 ){
              fprintf ( stderr,"write to wbBridgeAPScanActWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1) {
      		ap_count = wl_scan(&ap_list, 1);
		//nmp_set_int("ap_count", ap_count);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_macFilterModeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to macFilterModeWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to macFilterModeWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 3 ){
              fprintf ( stderr,"write to macFilterModeWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
		if(value == 1)
			nmp_set("wl1_macmode", "disabled");
		else if(value == 2)
			nmp_set("wl1_macmode", "allow"); 
		else if(value == 3)
			nmp_set("wl1_macmode", "deny"); 
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusServerIPAddrWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to radiusServerIPAddrWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 39) {
              fprintf(stderr, "write to radiusServerIPAddrWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(var_val_len <= 39) {
		strncpy(tmpstr, (u_char *)var_val, var_val_len); 
		tmpstr[var_val_len] = '\0';
		nmp_set("wl1_radius_ipaddr", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusPortWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to radiusPortWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 65535 ){
              fprintf(stderr, "write to radiusPortWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value <= 65535)
		nmp_set_int("wl1_radius_port", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radiusConnectionSecretWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wireless not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          /*if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }*/
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strncpy(tmpstr, (u_char *)var_val, var_val_len); 
             tmpstr[var_val_len] = '\0';
             nmp_set("wl1_radius_key", tmpstr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_radioWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to radioWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to radioWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to radioWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	     nmp_set_int("wl1_radio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_enableSchedWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to enableSchedWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		nmp_set_int("wl1_timesched", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysEnableRadioWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;
    char dateStr[16];

    size  = var_val_len;
    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to weekDaysEnableRadioWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to weekDaysEnableRadioWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_date_x"));
             (tmpstr[0]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 5)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 4)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 3)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[7]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("wl1_radio_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioStartTimeHWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioStartTimeHWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioStartTimeHWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekDaysRadioStartTimeHWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("wl1_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioStartTimeMWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioStartTimeMWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioStartTimeMWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekDaysRadioStartTimeMWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("wl1_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioEndTimeHWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioEndTimeHWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("wl1_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekDaysRadioEndTimeMWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekDaysRadioEndTimeMWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekDaysRadioEndTimeMWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekDaysRadioEndTimeHWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("wl1_radio_time_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendEnableRadioWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;
    char dateStr[16];

    size  = var_val_len;
    value = * (char *) var_val;

    memset(dateStr, 0, sizeof(dateStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to weekendEnableRadioWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to weekendEnableRadioWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_date_x"));
             (value & (1 << 6)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[1]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[2]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[3]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[4]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (tmpstr[5]-'0') ? strcat(dateStr, "1") : strcat(dateStr, "0");
             (value & (1 << 7)) ? strcat(dateStr, "1") : strcat(dateStr, "0");
             nmp_set("wl1_radio_date_x", dateStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioStartTimeHWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startM = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioStartTimeHWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioStartTimeHWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekendRadioStartTimeHWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", value, startM, endH, endM);
             nmp_set("wl1_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioStartTimeMWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, endH = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioStartTimeMWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioStartTimeMWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekendRadioStartTimeMWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, value, endH, endM);
             nmp_set("wl1_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioEndTimeHWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endM = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioEndTimeHWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioEndTimeHWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 23 ){
              fprintf(stderr, "write to weekendRadioEndTimeHWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endM += (tmpstr[6]-'0') * 10;
             endM += (tmpstr[7]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, value, endM);
             nmp_set("wl1_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_weekendRadioEndTimeMWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char timeStr[16];
    int startH = 0, startM = 0, endH = 0;

    size  = var_val_len;
    value = * (char *) var_val;

    memset(timeStr, 0, sizeof(timeStr));
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to weekendRadioEndTimeMWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to weekendRadioEndTimeMWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 59 ){
              fprintf(stderr, "write to weekendRadioEndTimeMWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             strcpy(tmpstr, nmp_safe_get("wl1_radio_time2_x"));
             startH += (tmpstr[0]-'0') * 10;
             startH += (tmpstr[1]-'0');
             startM += (tmpstr[2]-'0') * 10;
             startM += (tmpstr[3]-'0');
             endH += (tmpstr[4]-'0') * 10;
             endH += (tmpstr[5]-'0');
             sprintf(timeStr, "%02d%02d%02d%02d", startH, startM, endH, value);
             nmp_set("wl1_radio_time2_x", timeStr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apIsolatedWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size = var_val_len;
    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apIsolatedWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apIsolatedWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to apIsolatedWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	      nmp_set_int("wl1_ap_isolate", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_roamingAssistantWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to roamingAssistantWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to roamingAssistantWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to roamingAssistantWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			  if( value == 0 )
			    nmp_set_int("wl1_user_rssi", value);
			  else if( value == 1 )
				nmp_set("wl1_user_rssi", "-70");//-70 is default RSSI
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_disconnectClientRSSIWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to disconnectClientRSSIWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to disconnectClientRSSIWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < -90 || *(long *)var_val > -70 ){
              fprintf(stderr, "write to disconnectClientRSSIWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		nmp_set_int("wl1_user_rssi", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_igmpSnoopingWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to igmpSnoopingWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to igmpSnoopingWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ){
              fprintf(stderr, "write to igmpSnoopingWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	  		nmp_set_int("wl1_igs", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_multicastRateWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to multicastRateWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to multicastRateWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 9 ){
              fprintf(stderr, "write to multicastRateWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             switch(value) {
				case 1: tmpval = 0; break;	//disable
				case 2: tmpval = 4; break;	//OFDM-6
				case 3: tmpval = 5; break;	//OFDM-9
				case 4: tmpval = 7; break;	//OFDM-12
				case 5: tmpval = 8; break;	//OFDM-18
				case 6: tmpval = 9; break;	//OFDM-24
				case 7: tmpval = 10; break;	//OFDM-36
				case 8: tmpval = 11; break;	//OFDM-48
				case 9: tmpval = 12; break;	//OFDM-54
				//case 10: tmpval = 1; break;	//CCK-1
				//case 11: tmpval = 2; break;	//CCK-2
				//case 12: tmpval = 3; break;	//CCK-5.5
				//case 13: tmpval = 6; break;	//CCK-11
             }
             nmp_set_int("wl1_mrate_x", tmpval);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_preambleTypeWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = *(long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to preambleTypeWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to preambleTypeWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val> 3 ){
              fprintf ( stderr,"write to preambleTypeWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value >= 1 && value <= 3) {
		if(value == 1)
			nmp_set("wl1_plcphdr", "long");
		else if(value == 2)
			nmp_set("wl1_plcphdr", "short");
		else if(value == 3)
			nmp_set("wl1_plcphdr", "auto");
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_fragThresholdWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to fragThresholdWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to fragThresholdWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 256 || *(long *)var_val > 2346 ) {
              fprintf(stderr, "write to fragThresholdWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          	nmp_set_int("wl1_frag", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_rtsThresholdWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to rtsThresholdWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to rtsThresholdWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 2347 ) {
              fprintf(stderr, "write to rtsThresholdWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl1_rts", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_dtimIntervalWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to dtimIntervalWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to dtimIntervalWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 255 ) {
              fprintf(stderr, "write to dtimIntervalWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl1_dtim", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_beaconIntervalWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to beaconIntervalWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to beaconIntervalWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 20 || *(long *)var_val > 1000 ) {
              fprintf(stderr, "write to beaconIntervalWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl1_bcn", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_txBurstingWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to txBurstingWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to txBurstingWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to txBurstingWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1)
		nmp_set("wl1_frameburst", "on");
             else if(value == 2)
		nmp_set("wl1_frameburst", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmmWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmmWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmmWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 3 ) {
              fprintf(stderr, "write to wmmWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if(value == 1)
				nmp_set("wl1_wme", "auto");
			else if(value == 2)
				nmp_set("wl1_wme", "on");
			else if(value == 3)
				nmp_set("wl1_wme", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmmNoAcknowledgementWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmmNoAcknowledgementWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmmNoAcknowledgementWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wmmNoAcknowledgementWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			if( value == 1 )
				nmp_set("wl1_wme_no_ack", "on");
			else if( value == 2 )
				nmp_set("wl1_wme_no_ack", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wmmAPSDWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wmmAPSDWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wmmAPSDWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ) {
              fprintf(stderr, "write to wmmAPSDWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1)
		nmp_set("wl1_wme_apsd", "on");
             else if(value == 2)
		nmp_set("wl1_wme_apsd", "off");
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizeAMPDUAggregWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    size  = var_val_len;
    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to optimizeAMPDUAggregWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to optimizeAMPDUAggregWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to optimizeAMPDUAggregWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
   	  nmp_set_int("wl1_ampdu_mpdu", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_optimizeAckSuppressionWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;    

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wireless not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wireless: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to optimizeAckSuppressionWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          	nmp_set_int("wl1_ack_ratio", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_explicitBeamformingWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

	value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to explicitBeamformingWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to explicitBeamformingWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 1 ) {
              fprintf(stderr, "write to explicitBeamformingWl5g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
			nmp_set_int("wl1_txbf", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_txPowerAdjustmentWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;

    value = * (long *) var_val;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to txPowerAdjustmentWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to txPowerAdjustmentWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 0 || *(long *)var_val > 200 ) {
              fprintf(stderr, "write to txPowerAdjustmentWl2g: value out of range\n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             nmp_set_int("wl1_txpower", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif	//#ifdef DUAL_BAND

int
write_wepKeyValueWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long keyIndex;
    static unsigned char string[SPRINT_MAX_LEN];
    static int i = 0;

    keyIndex = name[name_len - 1];
    memset(string, 0, SPRINT_MAX_LEN);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wepKeyValueWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 && var_val_len != 26) {
              fprintf(stderr,"write to wepKeyValueWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
    	    sprintf(string, "wl0_key%d", keyIndex);
		    string[strlen(string)] = '\0';
		    strncpy(tmpstr, (u_char *)var_val, var_val_len);
            if(var_val_len == 10 || var_val_len == 26)
            {
				for(i = 0; i < var_val_len; i++)
				{
					if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
					|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
						return SNMP_ERR_WRONGVALUE;
				}
            }
	     	nmp_set(string, tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wbRemoteAPMACAddrWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, i, j;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int wdslist_count = 0;
    char *nv, *nvp, *b;
    char macaddr[MACSTRNUM];

    for(i = 0; i < MAXRBRIDGE; i++)
	memset(wdslist[i], 0x0, MACSTRNUM);

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of wds list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;
	}
	free(nv);
    }
    
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wbRemoteAPMACAddrWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to wbRemoteAPMACAddrWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
             {
		if((index+1) > wdslist_count)
			strcpy(wdslist[wdslist_count], macaddr);
		else
			strcpy(wdslist[index], macaddr);

		//Re-generate wl0_wdslist
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(wdslist[i][0]) {
				sprintf(macaddr_str, "<%s", wdslist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl0_wdslist", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wbRemoteAPDelEntryWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int i, j, index, num;
    int wdslist_count = 0;
    char *nv, *nvp, *b;
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;
    for(i = 0; i < MAXRBRIDGE; i++)
	memset(wdslist[i], 0x0, MACSTRNUM);

    //Compute the number of wds list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbRemoteAPDelEntryWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbRemoteAPDelEntryWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to wbRemoteAPDelEntryWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < wdslist_count)
             {
        	memset(wdslist[index], 0x0, MACSTRNUM);

		//Re-generate wl0_wdslist
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(wdslist[i][0]) {
				sprintf(macaddr_str, "<%s", wdslist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl0_wdslist", tmpstr);
             }   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }

    for(i = 0; i < MAXRBRIDGE; i++)
    	free(wdslist[i]);

    return SNMP_ERR_NOERROR;
}
int
write_macFilterMACAddrWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, i, j;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int maclist_count = 0;
    char *nv, *nvp, *b;
    char macaddr[MACSTRNUM];

    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of wds list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to macFilterMACAddrWl2g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to macFilterMACAddrWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
             {
		if((index+1) > maclist_count)
			strcpy(maclist[maclist_count], macaddr);
		else
			strcpy(maclist[index], macaddr);

		//Re-generate wl0_maclist_x
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(maclist[i][0]) {
				sprintf(macaddr_str, "<%s", maclist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl0_maclist_x", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_macFilterDelEntryWl2g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int i, j, index, num;
    int maclist_count = 0;
    char *nv, *nvp, *b;
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;
    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    
    //Compute the number of mac list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl0_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to macFilterDelEntryWl2g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to macFilterDelEntryWl2g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to macFilterDelEntryWl2g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < maclist_count)
             {
        	memset(maclist[index], 0x0, MACSTRNUM);

		//Re-generate wl0_maclist_x
		for(i = 0; i < MAXMACFILTER; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(maclist[i][0]) {
				sprintf(macaddr_str, "<%s", maclist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl0_maclist_x", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

#ifdef DUAL_BAND
int
write_wepKeyValueWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long keyIndex;
    static unsigned char string[SPRINT_MAX_LEN];
    static int i = 0;

    keyIndex = name[name_len - 1];
    memset(string, 0, SPRINT_MAX_LEN);
    memset(tmpstr, 0, SPRINT_MAX_LEN);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wepKeyValueWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 5 && var_val_len != 10 && var_val_len != 13 &&var_val_len != 26) {
              fprintf(stderr,"write to wepKeyValueWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
	     sprintf(string, "wl1_key%d", keyIndex);
	     string[strlen(string)] = '\0';
	     strncpy(tmpstr, (u_char *)var_val, var_val_len);
             if(var_val_len == 10 || var_val_len == 26)
             {
		for(i = 0; i < var_val_len; i++)
		{
			if(tmpstr[i] < '0' || (tmpstr[i] > '9' && tmpstr[i] < 'A')
			|| (tmpstr[i] > 'F' && tmpstr[i] < 'a') || tmpstr[i] > 'f')
				return SNMP_ERR_WRONGVALUE;
		}
             }
  	     nmp_set(string, tmpstr);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wbRemoteAPMACAddrWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, i, j;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int wdslist_count = 0;
    char *nv, *nvp, *b;
    char macaddr[MACSTRNUM];

    for(i = 0; i < MAXRBRIDGE; i++)
	memset(wdslist[i], 0x0, MACSTRNUM);

    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of wds list for 5G
    nv = nvp = strdup(nmp_safe_get("wl1_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wbRemoteAPMACAddrWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to wbRemoteAPMACAddrWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
             {
		if((index+1) > wdslist_count)
			strcpy(wdslist[wdslist_count], macaddr);
		else
			strcpy(wdslist[index], macaddr);

		//Re-generate wl0_wdslist
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(wdslist[i][0]) {
				sprintf(macaddr_str, "<%s", wdslist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl1_wdslist", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wbRemoteAPDelEntryWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char wdslist[MAXRBRIDGE][MACSTRNUM];
    int i, j, index, num;
    int wdslist_count = 0;
    char *nv, *nvp, *b;
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;
    for(i = 0; i < MAXRBRIDGE; i++)
	memset(wdslist[i], 0x0, MACSTRNUM);

    //Compute the number of wds list for 2.4G
    nv = nvp = strdup(nmp_safe_get("wl1_wdslist"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(wdslist[wdslist_count], b);
		wdslist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wbRemoteAPDelEntryWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wbRemoteAPDelEntryWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to wbRemoteAPDelEntryWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < wdslist_count)
             {
        	memset(wdslist[index], 0x0, MACSTRNUM);

		//Re-generate wl0_wdslist
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(wdslist[i][0]) {
				sprintf(macaddr_str, "<%s", wdslist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl1_wdslist", tmpstr);
             }  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_macFilterMACAddrWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long index, i, j;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int maclist_count = 0;
    char *nv, *nvp, *b;
    char macaddr[MACSTRNUM];

    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    memset(tmpstr, 0x0, SPRINT_MAX_LEN);
    index = name[name_len-1] -1;

    //Compute the number of wds list for 5G
    nv = nvp = strdup(nmp_safe_get("wl1_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to macFilterMACAddrWl5g not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 6) {
              fprintf(stderr,"write to macFilterMACAddrWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             ether_etoa(var_val, macaddr);
             if(strcmp("00:00:00:00:00:00", macaddr))
             {
		if((index+1) > maclist_count)
			strcpy(maclist[maclist_count], macaddr);
		else
			strcpy(maclist[index], macaddr);

		//Re-generate wl0_maclist_x
		for(i = 0; i < MAXRBRIDGE; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(maclist[i][0]) {
				sprintf(macaddr_str, "<%s", maclist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl1_maclist_x", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_macFilterDelEntryWl5g(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char maclist[MAXMACFILTER][MACSTRNUM];
    int i, j, index, num;
    int maclist_count = 0;
    char *nv, *nvp, *b;
    
    value = *(long *) var_val;
    index = name[name_len-1] - 1;
    for(i = 0; i < MAXMACFILTER; i++)
    	memset(maclist[i], 0x0, MACSTRNUM);
    
    //Compute the number of mac list for 5G
    nv = nvp = strdup(nmp_safe_get("wl1_maclist_x"));
    if (nv) {
	while ((b = strsep(&nvp, "<")) != NULL) {
		if (strlen(b)==0) continue;
		strcpy(maclist[maclist_count], b);
		maclist_count++;
	}
	free(nv);
    }

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to macFilterDelEntryWl5g not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to macFilterDelEntryWl5g: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          if ( *(long *)var_val < 1 || *(long *)var_val > 2 ){
              fprintf ( stderr,"write to macFilterDelEntryWl5g: value out of range\n" );
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             if(value == 1 && index < maclist_count)
             {
        	memset(maclist[index], 0x0, MACSTRNUM);

		//Re-generate wl0_maclist_x
		for(i = 0; i < MAXMACFILTER; i++)
		{
			char macaddr_str[32];
			memset(macaddr_str, 0x0, sizeof(macaddr_str));
			if(maclist[i][0]) {
				sprintf(macaddr_str, "<%s", maclist[i]);
				strcat(tmpstr, macaddr_str);
			}
		}

		nmp_set("wl1_maclist_x", tmpstr);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
#endif	//#ifdef DUAL_BAND
