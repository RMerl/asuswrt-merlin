@run mib2c.check_values_local.conf@
## -*- c -*-
######################################################################
## Do the .h file
######################################################################
@open ${name}_checkfns.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
 */

/***********************************************************************
 *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
 *   Modify the ${name}_checkfns_local.[ch] files insead.
 *   (so that you can regenerate this one as mib2c improvements are made)
 ***********************************************************************/
#ifndef $name.uc_CHECKFNS_H
#define $name.uc_CHECKFNS_H

/** make sure we load the functions that you can modify */
config_require(${name}_checkfns_local)

@foreach $t table@
/* these functions are designed to check incoming values for 
columns in the $t table for legality with respect to 
datatype and value.
 */

  @foreach $i column@
    @if $i.access =~ /(Write|Create)/@
      int check_${i}(int type, $i.decl *val, size_t val_len, $i.decl *old_val, size_t old_val_len);
    @end@
  @end@
@end@

#endif /* $name.uc_CHECKFNS_H */

######################################################################
## Do the .c file
######################################################################
@open ${name}_checkfns.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *        $Id$
 */

/********************************************************************
 *                       NOTE   NOTE   NOTE
 *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
 *   Modify the ${name}_checkfns_local.[ch] files insead so that you
 *   can regenerate this one as mib2c improvements are made.
 ********************************************************************/

/* standard headers */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include "${name}_checkfns.h"
#include "${name}_checkfns_local.h"
#include "${name}_enums.h"
@run mib2c.column_enums.conf@

@foreach $t table@
  @foreach $i column@
    @if $i.access =~ /(Write|Create)/@
/** Decides if an incoming value for the $i mib node is legal.
 *  @param type    The incoming data type.
 *  @param val     The value to be checked.
 *  @param val_len The length of data stored in val (in bytes).
 *  @return 0 if the incoming value is legal, an SNMP error code otherwise.
 */
    int
    check_${i}(int type, $i.decl *val, size_t val_len,
             $i.decl *old_val, size_t old_val_len) {

    int ret;

    /** Check to see that we were called legally */
      if (!val)
        return SNMP_ERR_GENERR;

    /** Check the incoming type for correctness */
      if (type != $i.type)
        return SNMP_ERR_WRONGTYPE;

      @if $i.type =~ /int/i@
        @eval $x = 0@
      	@foreach $l, $v enum@
           @if $x == 0@
    /** Check the enums.  Legal values will continue, others return error. */
           switch (*val) {
	       @eval $x = 1@
	   @end@
      	  case $i.uc_$l.uc:
      	@end@
        @if $x == 1@
      	    break;

    /** not a legal enum value.  return an error */
      	  default:
      	    return SNMP_ERR_INCONSISTENTVALUE;
      	}
        @end@
	ret = SNMP_ERR_NOERROR;
        @eval $x = 0@
        @foreach $min $max range $i@
          @if $x == 0@
    /** Check the ranges of the passed value for legality */
            @eval $x = 1@
	    if (
	  @else@
	        &&
          @end@
	       !(*val >= $min && *val <= $max)
        @end@
        @if $x != 0@
            ) {
            return SNMP_ERR_WRONGVALUE;
            }
        @end@
      @end@
      @if $i.type =~ /str/i@
        @eval $x = 0@
        @foreach $min $max range $i@
          @if $x == 0@
    /** Check the ranges of the passed value for legality */
            @eval $x = 1@
	    if (
	  @else@
	        &&
          @end@
	       !(val_len >= $min && val_len <= $max)
        @end@
        @if $x == 1@
            ) {
            return SNMP_ERR_WRONGVALUE;
            }
        @end@
      @end@

      @if "$i.syntax" eq "RowStatus"@
      if (ret = check_rowstatus_transition((old_val) ? *old_val : RS_NONEXISTENT, *val))
          return ret;
      @end@
      @if "$i.syntax" eq "StorageType"@
      if (ret = check_storage_transition((old_val) ? *old_val : SNMP_STORAGE_NONE, *val))
          return ret;
      @end@

    /** looks ok, call the local version of the same function. */
      return check_${i}_local(type, val, val_len, old_val, old_val_len);
    }
    @end@
  @end@
@end@
