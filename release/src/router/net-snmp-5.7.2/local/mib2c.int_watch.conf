## -*- c -*-
######################################################################
## Do the .h file
######################################################################
@open -@
*** Warning: only generating code for nodes of MIB type INTEGER
@open ${name}.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *        $Id$
 */
#ifndef $name.uc_H
#define $name.uc_H

/* function declarations */
void init_$name(void);

#endif /* $name.uc_H */
######################################################################
## Do the .c file
######################################################################
@open ${name}.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *        $Id$
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "${name}.h"

/*
 * The variables we want to tie the relevant OIDs to.
 * The agent will handle all GET and (if applicable) SET requests
 * to these variables automatically, changing the values as needed.
 */

@foreach $i scalar@
    @if !$i.needlength@
$i.decl    $i = 0;  /* XXX: set default value */
    @end@
@end@

/*
 * Our initialization routine, called automatically by the agent 
 * (Note that the function name must match init_FILENAME()) 
 */
void
init_${name}(void)
{
  netsnmp_handler_registration *reg;

  @foreach $i scalar@
    @if !$i.needlength@
    const oid ${i}_oid[] = { $i.commaoid };
    @end@
  static netsnmp_watcher_info ${i}_winfo;
  @end@

  /*
   * a debugging statement.  Run the agent with -D$name to see
   * the output of this debugging statement. 
   */
  DEBUGMSGTL(("$name", "Initializing the $name module\n"));


    /*
     * Register scalar watchers for each of the MIB objects.
     * The ASN type and RO/RW status are taken from the MIB definition,
     * but can be adjusted if needed.
     *
     * In most circumstances, the scalar watcher will handle all
     * of the necessary processing.  But the NULL parameter in the
     * netsnmp_create_handler_registration() call can be used to
     * supply a user-provided handler if necessary.
     *
     * This approach can also be used to handle Counter64, string-
     * and OID-based watched scalars (although variable-sized writeable
     * objects will need some more specialised initialisation).
     */
  @foreach $i scalar@
    @if !$i.needlength@
    DEBUGMSGTL(("$name",
                "Initializing $i scalar integer.  Default value = %d\n",
                $i));
    reg = netsnmp_create_handler_registration(
             "$i", NULL,
              ${i}_oid, OID_LENGTH(${i}_oid),
    @if $i.settable@
              HANDLER_CAN_RWRITE);
    @else@
              HANDLER_CAN_RONLY);
    @end@
    netsnmp_init_watcher_info(&${i}_winfo, &$i, sizeof($i.decl),
			      $i.type, WATCHER_FIXED_SIZE);
if (netsnmp_register_watched_scalar( reg, &${i}_winfo ) < 0 ) {
        snmp_log( LOG_ERR, "Failed to register watched $i" );
    }

    @end@
  @end@

  DEBUGMSGTL(("$name",
              "Done initalizing $name module\n"));
}
