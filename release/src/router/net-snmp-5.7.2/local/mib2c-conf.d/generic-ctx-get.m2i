#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##/*
## This include will generate the code needed to assign data from
## a generated data context to a parameter reference.
##
## EXAMPLE (prototype generated elsewhere)
## int
## ifName_get(ifXTable_ctx * ctx, char **ifName_ptr_ptr,
##            size_t * ifName_len_ptr) {
##
## 
## m2c_node_lh :   temp_ifName / (*ifName_ptr_ptr)
## m2c_node_lhs:   temp_ifName_len / (*ifName_len_ptr);
## m2c_ctx_rh  :   ctx->data.
## node        :  ifName
##
##    if (temp_ifName_len < ctx->data.ifName_len) {
##        temp_ifName = malloc(ctx->data.ifName_len);
##    }
##    temp_ifName_len = ctx->data.ifName_len;
##    memcpy(temp_ifName, ctx->data.ifName, temp_ifName_len);
##*/
@if "$m2c_data_context" ne "generated"@
    /** WARNING: this code might not work for $m2c_data_context */
@end@
##/* set up for length/copy conversions for various cases.
##   length mod applies to left hand side. copy mod applies to right hand side
##
##*/
@if ("$m2c_ctx_rhu" ne "elements") && ("$m2c_ctx_rhu" ne "bytes")@
@   print Invalid rh units '$m2c_ctx_rhu'@
@   exit@
@end@
@if ("$m2c_ctx_lhu" ne "elements") && ("$m2c_ctx_lhu" ne "bytes")@
@   print Invalid lh units '$m2c_ctx_lhu'@
@   exit@
@end@
@if "$m2c_ctx_rhu" ne "$m2c_ctx_lhu"@
##/*   elements = bytes,    length mod="/sizeof", copy mult="" */
@   if "$m2c_ctx_lhu" eq "elements"@
@      eval $m2c_ctx_lm = "/ sizeof($m2c_ctx_rh[0])"@
@      eval $m2c_ctx_cm = ""@
@   else@
##/*   bytes    = elements, length mod="*sizeof", copy mult="sizeof" */
@      eval $m2c_ctx_lm = "* sizeof($m2c_ctx_rh[0])"@
@      eval $m2c_ctx_cm = "* sizeof($m2c_ctx_rh[0])"@
@   end@
@else@
##/*     elements = elements, length mod="",        copy mult="sizeof" */
@   if "$m2c_ctx_lhu" eq "elements"@
@      eval $m2c_ctx_lm = ""@
@      eval $m2c_ctx_cm = "* sizeof($m2c_ctx_rh[0])"@
@   else@
##/*     bytes    = bytes,    length mod="",        copy mult="" */
@      eval $m2c_ctx_lm = ""@
@      eval $m2c_ctx_cm = ""@
@   end@
@end@
@if $m2c_node_needlength == 1@
    /*
     * make sure there is enough space for $node data
     */
    if ((NULL == $m2c_ctx_lh) ||
        ($m2c_ctx_lhs <
         ($m2c_ctx_rhs$m2c_ctx_lm))) {
@   if $m2c_node_realloc == 0@
        snmp_log(LOG_ERR,"not enough space for value ($m2c_ctx_rh)\n");
        return MFD_ERROR;
@   else@
        /*
         * allocate space for $node data
         */
@      if $m2c_node_realloc == 1@
        $m2c_ctx_lh = realloc($m2c_ctx_lh, $m2c_ctx_rhs$m2c_ctx_cm );
@      else@
        $m2c_ctx_lh = malloc($m2c_ctx_rhs$m2c_ctx_cm);
@      end@
        if(NULL == $m2c_ctx_lh) {
            snmp_log(LOG_ERR,"could not allocate memory ($m2c_ctx_rh)\n");
            return MFD_ERROR;
        }
@   end@
    }
    $m2c_ctx_lhs = $m2c_ctx_rhs$m2c_ctx_lm;
    memcpy( $m2c_ctx_lh, $m2c_ctx_rh, $m2c_ctx_rhs$m2c_ctx_cm );
@else@
@   if $node.decl =~ /U64/i@ #              ASN_COUNTER64
    ${m2c_ctx_lh}.high = ${m2c_ctx_rh}.high;
    ${m2c_ctx_lh}.low = ${m2c_ctx_rh}.low;
@   else@
    $m2c_ctx_lh = $m2c_ctx_rh;
@   end@
@end@ # length
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
