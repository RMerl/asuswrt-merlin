##//#########################################################  -*- c -*-
##//generic include for XXX. Do not use directly.
##
##//$Id$
##//####################################################################
##//####################################################################
##
## lower conf files get confused with multiple processing types, so
## set single options
@eval $mfd_data_access_processing_type = "$m2c_processing_type"@
@eval $m2c_processing_type = 'h'@
@open ${name}_data_access.h@
@eval $hack = "Id"@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$
 *
 * $$hack:$
 */
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
@eval $m2c_save = "$name"@
@eval $name = "${name}_DATA_ACCESS"@
@include generic-header-top.m2i@
@eval $name = "$m2c_save"@

/* *********************************************************************
 * function declarations
 */

/* *********************************************************************
 * Table declarations
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@

##@    eval $m2c_tmp=""@
##@    foreach $node index@
##@      include m2c_setup_node.m2i@
##@      eval $m2c_tmp="$m2c_tmp, $m2c_node_param_val"@
##@    end@ // for each index

    int ${context}_init_data(${context}_registration * ${context}_reg);

@    include mfd-access-${m2c_table_access}-defines.m2i@
    int ${context}_row_prep( ${context}_rowreq_ctx *rowreq_ctx);

@  if ($m2c_table_row_creation == 1) || ($m2c_table_persistent == 1)@
int ${context}_validate_index( ${context}_registration * ${context}_reg,
                               ${context}_rowreq_ctx *rowreq_ctx);
@    foreach $node externalindex@
@        include m2c_setup_node.m2i@
    int ${context}_${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx ); /* external */
@    end@ # foreach externalindex
@    foreach $node internalindex@
@        include m2c_setup_node.m2i@
int ${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx ); /* internal */
@    end@ # foreach internalindex
@  end@ # row creation/persistent
@end@

@eval $m2c_save = "$name"@
@eval $name = "${name}_DATA_ACCESS"@
@include generic-header-bottom.m2i@
@eval $name = "$m2c_save"@
##//##################################################################
##//Do the .c file
##//##################################################################
@eval $m2c_processing_type = 'c'@
@open ${name}_data_access.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$ 
 *
 * $$hack:$
 */
@include generic-source-includes.m2i@

#include "${name}_data_access.h"

/** @ingroup interface
 * @addtogroup data_access data_access: Routines to access data
 *
 * These routines are used to locate the data used to satisfy
 * requests.
 * 
 * @{
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@

/**
 * initialization for ${context} data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param ${context}_reg
 *        Pointer to ${context}_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
int
${context}_init_data(${context}_registration * ${context}_reg)
{
    DEBUGMSGTL(("verbose:${context}:${context}_init_data","called\n"));

    /*
     * TODO:303:o: Initialize $context data.
     */
@ifconf ${table}_init_data.m2i@
@   include ${table}_init_data.m2i@
@else@
@   if $m2c_include_examples == 1@
$example_start
    /*
     * if you are the sole writer for the file, you could
     * open it here. However, as stated earlier, we are assuming
     * the worst case, which in this case means that the file is
     * written to by someone else, and might not even exist when
     * we start up. So we can't do anything here.
     */
$example_end
@   end@

    return MFD_SUCCESS;
@end@ #ifconf
} /* ${context}_init_data */

@    include mfd-access-${m2c_table_access}-defines.m2i@
/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
${context}_row_prep( ${context}_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:${context}:${context}_row_prep","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:390:o: Prepare row for request.
     * If populating row data was delayed, this is the place to
     * fill in the row for this request.
     */

    return MFD_SUCCESS;
} /* ${context}_row_prep */

##//####################################################################
@  if ($m2c_table_row_creation == 1) || ($m2c_table_persistent == 1)@
/*
 * TODO:420:r: Implement $context index validation.
 */
@    foreach $node externalindex@
@        include m2c_setup_node.m2i@
@        if $m2c_report_progress == 1@
@           print | |   +-> Processing index $node@
@        end@
@        include details-node.m2i@
/**
 * check validity of ${node} external index portion
 *
 * NOTE: this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ${context}_validate_index() function.
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 */
int
${context}_${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx )
{
    DEBUGMSGTL(("verbose:${context}:${context}_${node}_check_index","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:424:M: |-> Check $context external index $node.
     * check that index value in the table context (rowreq_ctx)
     * for the external index $node is legal.
     */

    return MFD_SUCCESS; /*  external index $node ok */
} /* ${context}_${node}_check_index */

@    end@ # foreach externalindex
@    foreach $node internalindex@
@        include m2c_setup_node.m2i@
@        if $m2c_report_progress == 1@
@           print | |   +-> Processing index $node@
@        end@
@        include details-node.m2i@
/**
 * check validity of ${node} index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_ERROR     : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ${context}_validate_index() function.
 *
 * @note Also keep in mind that if the index refers to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 * The following checks have already been done for you:
@if $node.enums == 1@
 *    The value is one of $m2c_evals
@elsif $node.ranges == 1@
@    if ("$node.decl" eq "long") || ("$node.decl" eq "u_long")@
@        eval $m2c_tmp_ns = "value"@
@    else@
@        eval $m2c_tmp_ns = "length"@
@    end@
 *    The $m2c_tmp_ns is in (one of) the range set(s): $m2c_evals
@end@
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 */
int
${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx )
{
    DEBUGMSGTL(("verbose:${context}:${node}_check_index","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:426:M: |-> Check $context index $node.
     * check that index value in the table context is legal.
     * (rowreq_ctx->tbl_index.$node)
     */

    return MFD_SUCCESS; /* $node index ok */
} /* ${node}_check_index */

@    end@ # foreach internalindex
/**
 * verify specified index is valid.
 *
 * This check is independent of whether or not the values specified for
 * the columns of the new row are valid. Column values and row consistency
 * will be checked later. At this point, only the index values should be
 * checked.
 *
 * All of the individual index validation functions have been called, so this
 * is the place to make sure they are valid as a whole when combined. If
 * you only have one index, then you probably don't need to do anything else
 * here.
 * 
 * @note Keep in mind that if the indexes refer to a row in this or
 *       some other table, you can't check for that row here to make
 *       decisions, since that row might not be created yet, but may
 *       be created during the processing this request. If you have
 *       such checks, they should be done in the check_dependencies
 *       function, because any new/deleted/changed rows should be
 *       available then.
 *
 *
 * @param ${context}_reg
 *        Pointer to the user registration data
 * @param ${context}_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS            : success
 * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
 * @retval MFD_CANNOT_CREATE_EVER : index never valid
 */
int
${context}_validate_index( ${context}_registration * ${context}_reg,
                           ${context}_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:${context}:${context}_validate_index","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:430:M: |-> Validate potential $context index.
     */
    if(1) {
        snmp_log(LOG_WARNING,"invalid index for a new row in the "
                 "${context} table.\n");
        /*
         * determine failure type.
         *
         * If the index could not ever be created, return MFD_NOT_EVER
         * If the index can not be created under the present circumstances
         * (even though it could be created under other circumstances),
         * return MFD_NOT_NOW.
         */
        if(0) {
            return MFD_CANNOT_CREATE_EVER;
        }
        else {
            return MFD_CANNOT_CREATE_NOW;
        }
    }

    return rc;
} /* ${context}_validate_index */

@  end@ # persistent/row creation
@end@
##
/** @} */
##//####################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
@eval $m2c_processing_type = "$mfd_data_access_processing_type"@
