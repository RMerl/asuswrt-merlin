#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
## }
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * ${m2c_defaults_dir}node-${node}.m2d :
 *   @eval $@m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
${node}_map($m2c_node_map_param)
{
@if $m2c_node_needlength == 1@
    int converted_len;

    netsnmp_assert(NULL != raw_$m2c_node_param_val_name);
    netsnmp_assert((NULL != mib_$m2c_node_param_ref_name) && (NULL != mib_$m2c_node_param_ref_lname));
@else@
    netsnmp_assert(NULL != mib_$m2c_node_param_ref_name);
@end@
    
    DEBUGMSGTL(("verbose:${context}:${node}_map","called\n"));
    
@if $m2c_node_needlength == 1@
    /*
     * TODO:241:r: |-> Implement $node non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_$m2c_node_param_val_lname; /* assume equal */
    if((NULL == *mib_$m2c_node_param_ref_name) || (*mib_$m2c_node_param_ref_lname < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_$m2c_node_param_ref_name = realloc( *mib_$m2c_node_param_ref_name, converted_len * sizeof(**mib_$m2c_node_param_ref_name));
        if(NULL == *mib_$m2c_node_param_ref_name) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_$m2c_node_param_ref_lname = converted_len;
    memcpy( *mib_$m2c_node_param_ref_name, raw_$m2c_node_param_val_name, converted_len );
##
@elsif ($node.enums == 1) && ("$node.perltype" eq "INTEGER")@
    /*
     * TODO:241:o: |-> Implement $node enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_$m2c_node_param_val_name) {
@    foreach $e $v enum@
@        include m2c_setup_enum.m2i@
        case INTERNAL_$context.uc_$m2c_iname:
             *mib_$m2c_node_param_ref_name = $m2c_ename;
             break;

@    end@ # foreach
             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for $node\n", raw_$m2c_node_param_val_name );
                 return MFD_ERROR;
    }
##
@else@
    /*
     * TODO:241:o: |-> Implement $node mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_$m2c_node_param_ref_name) = raw_$m2c_node_param_val_name;
@end@

    return MFD_SUCCESS;
} /* ${node}_map */

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
