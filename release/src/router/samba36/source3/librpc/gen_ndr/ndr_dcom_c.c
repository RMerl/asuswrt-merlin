/* client functions auto-generated by pidl */

#include "includes.h"
#include <tevent.h>
#include "lib/util/tevent_ntstatus.h"
#include "librpc/gen_ndr/ndr_dcom.h"
#include "librpc/gen_ndr/ndr_dcom_c.h"

/* dcom_Unknown - client functions generated by pidl */

struct dcerpc_UseProtSeq_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UseProtSeq_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UseProtSeq_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct UseProtSeq *r)
{
	struct tevent_req *req;
	struct dcerpc_UseProtSeq_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UseProtSeq_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_USEPROTSEQ, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UseProtSeq_r_done, req);

	return req;
}

static void dcerpc_UseProtSeq_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_UseProtSeq_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_UseProtSeq_r_state *state =
		tevent_req_data(req,
		struct dcerpc_UseProtSeq_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UseProtSeq_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct UseProtSeq *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_USEPROTSEQ, mem_ctx, r);

	return status;
}

struct dcerpc_UseProtSeq_state {
	struct UseProtSeq orig;
	struct UseProtSeq tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UseProtSeq_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UseProtSeq_send(TALLOC_CTX *mem_ctx,
					  struct tevent_context *ev,
					  struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_UseProtSeq_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UseProtSeq_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_UseProtSeq_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UseProtSeq_done, req);
	return req;
}

static void dcerpc_UseProtSeq_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_UseProtSeq_state *state = tevent_req_data(
		req, struct dcerpc_UseProtSeq_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_UseProtSeq_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_UseProtSeq_recv(struct tevent_req *req,
				TALLOC_CTX *mem_ctx)
{
	struct dcerpc_UseProtSeq_state *state = tevent_req_data(
		req, struct dcerpc_UseProtSeq_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UseProtSeq(struct dcerpc_binding_handle *h,
			   TALLOC_CTX *mem_ctx)
{
	struct UseProtSeq r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_UseProtSeq_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_GetCustomProtseqInfo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetCustomProtseqInfo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetCustomProtseqInfo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct GetCustomProtseqInfo *r)
{
	struct tevent_req *req;
	struct dcerpc_GetCustomProtseqInfo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetCustomProtseqInfo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_GETCUSTOMPROTSEQINFO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetCustomProtseqInfo_r_done, req);

	return req;
}

static void dcerpc_GetCustomProtseqInfo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetCustomProtseqInfo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetCustomProtseqInfo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_GetCustomProtseqInfo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetCustomProtseqInfo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct GetCustomProtseqInfo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_GETCUSTOMPROTSEQINFO, mem_ctx, r);

	return status;
}

struct dcerpc_GetCustomProtseqInfo_state {
	struct GetCustomProtseqInfo orig;
	struct GetCustomProtseqInfo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetCustomProtseqInfo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetCustomProtseqInfo_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_GetCustomProtseqInfo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetCustomProtseqInfo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_GetCustomProtseqInfo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetCustomProtseqInfo_done, req);
	return req;
}

static void dcerpc_GetCustomProtseqInfo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_GetCustomProtseqInfo_state *state = tevent_req_data(
		req, struct dcerpc_GetCustomProtseqInfo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_GetCustomProtseqInfo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetCustomProtseqInfo_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetCustomProtseqInfo_state *state = tevent_req_data(
		req, struct dcerpc_GetCustomProtseqInfo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetCustomProtseqInfo(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx)
{
	struct GetCustomProtseqInfo r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_GetCustomProtseqInfo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

struct dcerpc_UpdateResolverBindings_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UpdateResolverBindings_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UpdateResolverBindings_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct UpdateResolverBindings *r)
{
	struct tevent_req *req;
	struct dcerpc_UpdateResolverBindings_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UpdateResolverBindings_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_UPDATERESOLVERBINDINGS, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UpdateResolverBindings_r_done, req);

	return req;
}

static void dcerpc_UpdateResolverBindings_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_UpdateResolverBindings_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_UpdateResolverBindings_r_state *state =
		tevent_req_data(req,
		struct dcerpc_UpdateResolverBindings_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UpdateResolverBindings_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct UpdateResolverBindings *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_dcom_Unknown,
			NDR_UPDATERESOLVERBINDINGS, mem_ctx, r);

	return status;
}

struct dcerpc_UpdateResolverBindings_state {
	struct UpdateResolverBindings orig;
	struct UpdateResolverBindings tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UpdateResolverBindings_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UpdateResolverBindings_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_UpdateResolverBindings_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UpdateResolverBindings_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_UpdateResolverBindings_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UpdateResolverBindings_done, req);
	return req;
}

static void dcerpc_UpdateResolverBindings_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_UpdateResolverBindings_state *state = tevent_req_data(
		req, struct dcerpc_UpdateResolverBindings_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_UpdateResolverBindings_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_UpdateResolverBindings_recv(struct tevent_req *req,
					    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_UpdateResolverBindings_state *state = tevent_req_data(
		req, struct dcerpc_UpdateResolverBindings_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UpdateResolverBindings(struct dcerpc_binding_handle *h,
				       TALLOC_CTX *mem_ctx)
{
	struct UpdateResolverBindings r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_UpdateResolverBindings_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */

	return NT_STATUS_OK;
}

/* IUnknown - client functions generated by pidl */

struct dcerpc_QueryInterface_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_QueryInterface_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_QueryInterface_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct QueryInterface *r)
{
	struct tevent_req *req;
	struct dcerpc_QueryInterface_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_QueryInterface_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IUnknown,
			NDR_QUERYINTERFACE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_QueryInterface_r_done, req);

	return req;
}

static void dcerpc_QueryInterface_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_QueryInterface_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_QueryInterface_r_state *state =
		tevent_req_data(req,
		struct dcerpc_QueryInterface_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_QueryInterface_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct QueryInterface *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IUnknown,
			NDR_QUERYINTERFACE, mem_ctx, r);

	return status;
}

struct dcerpc_QueryInterface_state {
	struct QueryInterface orig;
	struct QueryInterface tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_QueryInterface_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_QueryInterface_send(TALLOC_CTX *mem_ctx,
					      struct tevent_context *ev,
					      struct dcerpc_binding_handle *h,
					      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					      struct ORPCTHIS _ORPCthis /* [in]  */,
					      struct GUID *_iid /* [in] [unique] */,
					      struct MInterfacePointer **_data /* [out] [ref,iid_is(riid)] */)
{
	struct tevent_req *req;
	struct dcerpc_QueryInterface_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_QueryInterface_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.iid = _iid;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.data = _data;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_QueryInterface_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_QueryInterface_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_QueryInterface_done, req);
	return req;
}

static void dcerpc_QueryInterface_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_QueryInterface_state *state = tevent_req_data(
		req, struct dcerpc_QueryInterface_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_QueryInterface_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	*state->orig.out.data = *state->tmp.out.data;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_QueryInterface_recv(struct tevent_req *req,
				    TALLOC_CTX *mem_ctx,
				    WERROR *result)
{
	struct dcerpc_QueryInterface_state *state = tevent_req_data(
		req, struct dcerpc_QueryInterface_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_QueryInterface(struct dcerpc_binding_handle *h,
			       TALLOC_CTX *mem_ctx,
			       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			       struct ORPCTHIS _ORPCthis /* [in]  */,
			       struct GUID *_iid /* [in] [unique] */,
			       struct MInterfacePointer **_data /* [out] [ref,iid_is(riid)] */,
			       WERROR *result)
{
	struct QueryInterface r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.iid = _iid;

	status = dcerpc_QueryInterface_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	*_data = *r.out.data;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_AddRef_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_AddRef_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_AddRef_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct AddRef *r)
{
	struct tevent_req *req;
	struct dcerpc_AddRef_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_AddRef_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IUnknown,
			NDR_ADDREF, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_AddRef_r_done, req);

	return req;
}

static void dcerpc_AddRef_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_AddRef_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_AddRef_r_state *state =
		tevent_req_data(req,
		struct dcerpc_AddRef_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_AddRef_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct AddRef *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IUnknown,
			NDR_ADDREF, mem_ctx, r);

	return status;
}

struct dcerpc_AddRef_state {
	struct AddRef orig;
	struct AddRef tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_AddRef_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_AddRef_send(TALLOC_CTX *mem_ctx,
				      struct tevent_context *ev,
				      struct dcerpc_binding_handle *h,
				      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				      struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_AddRef_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_AddRef_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_AddRef_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_AddRef_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_AddRef_done, req);
	return req;
}

static void dcerpc_AddRef_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_AddRef_state *state = tevent_req_data(
		req, struct dcerpc_AddRef_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_AddRef_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_AddRef_recv(struct tevent_req *req,
			    TALLOC_CTX *mem_ctx,
			    uint32_t *result)
{
	struct dcerpc_AddRef_state *state = tevent_req_data(
		req, struct dcerpc_AddRef_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_AddRef(struct dcerpc_binding_handle *h,
		       TALLOC_CTX *mem_ctx,
		       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
		       struct ORPCTHIS _ORPCthis /* [in]  */,
		       uint32_t *result)
{
	struct AddRef r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_AddRef_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_Release_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Release_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Release_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct Release *r)
{
	struct tevent_req *req;
	struct dcerpc_Release_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Release_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IUnknown,
			NDR_RELEASE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Release_r_done, req);

	return req;
}

static void dcerpc_Release_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_Release_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_Release_r_state *state =
		tevent_req_data(req,
		struct dcerpc_Release_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Release_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct Release *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IUnknown,
			NDR_RELEASE, mem_ctx, r);

	return status;
}

struct dcerpc_Release_state {
	struct Release orig;
	struct Release tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Release_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Release_send(TALLOC_CTX *mem_ctx,
				       struct tevent_context *ev,
				       struct dcerpc_binding_handle *h,
				       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				       struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_Release_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Release_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_Release_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_Release_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Release_done, req);
	return req;
}

static void dcerpc_Release_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_Release_state *state = tevent_req_data(
		req, struct dcerpc_Release_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_Release_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_Release_recv(struct tevent_req *req,
			     TALLOC_CTX *mem_ctx,
			     uint32_t *result)
{
	struct dcerpc_Release_state *state = tevent_req_data(
		req, struct dcerpc_Release_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Release(struct dcerpc_binding_handle *h,
			TALLOC_CTX *mem_ctx,
			struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			struct ORPCTHIS _ORPCthis /* [in]  */,
			uint32_t *result)
{
	struct Release r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_Release_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IClassFactory - client functions generated by pidl */

struct dcerpc_CreateInstance_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_CreateInstance_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_CreateInstance_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct CreateInstance *r)
{
	struct tevent_req *req;
	struct dcerpc_CreateInstance_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_CreateInstance_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IClassFactory,
			NDR_CREATEINSTANCE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_CreateInstance_r_done, req);

	return req;
}

static void dcerpc_CreateInstance_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_CreateInstance_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_CreateInstance_r_state *state =
		tevent_req_data(req,
		struct dcerpc_CreateInstance_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_CreateInstance_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct CreateInstance *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IClassFactory,
			NDR_CREATEINSTANCE, mem_ctx, r);

	return status;
}

struct dcerpc_CreateInstance_state {
	struct CreateInstance orig;
	struct CreateInstance tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_CreateInstance_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_CreateInstance_send(TALLOC_CTX *mem_ctx,
					      struct tevent_context *ev,
					      struct dcerpc_binding_handle *h,
					      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					      struct ORPCTHIS _ORPCthis /* [in]  */,
					      struct MInterfacePointer *_pUnknown /* [in] [unique] */,
					      struct GUID *_iid /* [in] [unique] */,
					      struct MInterfacePointer *_ppv /* [out] [iid_is(riid),unique] */)
{
	struct tevent_req *req;
	struct dcerpc_CreateInstance_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_CreateInstance_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.pUnknown = _pUnknown;
	state->orig.in.iid = _iid;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.ppv = _ppv;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_CreateInstance_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_CreateInstance_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_CreateInstance_done, req);
	return req;
}

static void dcerpc_CreateInstance_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_CreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_CreateInstance_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_CreateInstance_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.ppv && state->tmp.out.ppv) {
		*state->orig.out.ppv = *state->tmp.out.ppv;
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_CreateInstance_recv(struct tevent_req *req,
				    TALLOC_CTX *mem_ctx,
				    WERROR *result)
{
	struct dcerpc_CreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_CreateInstance_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_CreateInstance(struct dcerpc_binding_handle *h,
			       TALLOC_CTX *mem_ctx,
			       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			       struct ORPCTHIS _ORPCthis /* [in]  */,
			       struct MInterfacePointer *_pUnknown /* [in] [unique] */,
			       struct GUID *_iid /* [in] [unique] */,
			       struct MInterfacePointer *_ppv /* [out] [iid_is(riid),unique] */,
			       WERROR *result)
{
	struct CreateInstance r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.pUnknown = _pUnknown;
	r.in.iid = _iid;

	status = dcerpc_CreateInstance_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_ppv && r.out.ppv) {
		*_ppv = *r.out.ppv;
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_RemoteCreateInstance_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemoteCreateInstance_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemoteCreateInstance_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemoteCreateInstance *r)
{
	struct tevent_req *req;
	struct dcerpc_RemoteCreateInstance_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemoteCreateInstance_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IClassFactory,
			NDR_REMOTECREATEINSTANCE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemoteCreateInstance_r_done, req);

	return req;
}

static void dcerpc_RemoteCreateInstance_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemoteCreateInstance_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemoteCreateInstance_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemoteCreateInstance_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemoteCreateInstance_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemoteCreateInstance *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IClassFactory,
			NDR_REMOTECREATEINSTANCE, mem_ctx, r);

	return status;
}

struct dcerpc_RemoteCreateInstance_state {
	struct RemoteCreateInstance orig;
	struct RemoteCreateInstance tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemoteCreateInstance_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemoteCreateInstance_send(TALLOC_CTX *mem_ctx,
						    struct tevent_context *ev,
						    struct dcerpc_binding_handle *h,
						    struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						    struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_RemoteCreateInstance_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemoteCreateInstance_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemoteCreateInstance_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemoteCreateInstance_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemoteCreateInstance_done, req);
	return req;
}

static void dcerpc_RemoteCreateInstance_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemoteCreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_RemoteCreateInstance_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemoteCreateInstance_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemoteCreateInstance_recv(struct tevent_req *req,
					  TALLOC_CTX *mem_ctx,
					  WERROR *result)
{
	struct dcerpc_RemoteCreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_RemoteCreateInstance_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemoteCreateInstance(struct dcerpc_binding_handle *h,
				     TALLOC_CTX *mem_ctx,
				     struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				     struct ORPCTHIS _ORPCthis /* [in]  */,
				     WERROR *result)
{
	struct RemoteCreateInstance r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_RemoteCreateInstance_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_LockServer_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_LockServer_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_LockServer_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct LockServer *r)
{
	struct tevent_req *req;
	struct dcerpc_LockServer_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_LockServer_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IClassFactory,
			NDR_LOCKSERVER, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_LockServer_r_done, req);

	return req;
}

static void dcerpc_LockServer_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_LockServer_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_LockServer_r_state *state =
		tevent_req_data(req,
		struct dcerpc_LockServer_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_LockServer_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct LockServer *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IClassFactory,
			NDR_LOCKSERVER, mem_ctx, r);

	return status;
}

struct dcerpc_LockServer_state {
	struct LockServer orig;
	struct LockServer tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_LockServer_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_LockServer_send(TALLOC_CTX *mem_ctx,
					  struct tevent_context *ev,
					  struct dcerpc_binding_handle *h,
					  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					  struct ORPCTHIS _ORPCthis /* [in]  */,
					  uint8_t _lock /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_LockServer_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_LockServer_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.lock = _lock;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_LockServer_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_LockServer_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_LockServer_done, req);
	return req;
}

static void dcerpc_LockServer_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_LockServer_state *state = tevent_req_data(
		req, struct dcerpc_LockServer_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_LockServer_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_LockServer_recv(struct tevent_req *req,
				TALLOC_CTX *mem_ctx,
				WERROR *result)
{
	struct dcerpc_LockServer_state *state = tevent_req_data(
		req, struct dcerpc_LockServer_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_LockServer(struct dcerpc_binding_handle *h,
			   TALLOC_CTX *mem_ctx,
			   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			   struct ORPCTHIS _ORPCthis /* [in]  */,
			   uint8_t _lock /* [in]  */,
			   WERROR *result)
{
	struct LockServer r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.lock = _lock;

	status = dcerpc_LockServer_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_RemoteLockServer_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemoteLockServer_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemoteLockServer_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemoteLockServer *r)
{
	struct tevent_req *req;
	struct dcerpc_RemoteLockServer_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemoteLockServer_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IClassFactory,
			NDR_REMOTELOCKSERVER, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemoteLockServer_r_done, req);

	return req;
}

static void dcerpc_RemoteLockServer_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemoteLockServer_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemoteLockServer_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemoteLockServer_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemoteLockServer_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemoteLockServer *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IClassFactory,
			NDR_REMOTELOCKSERVER, mem_ctx, r);

	return status;
}

struct dcerpc_RemoteLockServer_state {
	struct RemoteLockServer orig;
	struct RemoteLockServer tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemoteLockServer_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemoteLockServer_send(TALLOC_CTX *mem_ctx,
						struct tevent_context *ev,
						struct dcerpc_binding_handle *h,
						struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_RemoteLockServer_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemoteLockServer_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemoteLockServer_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemoteLockServer_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemoteLockServer_done, req);
	return req;
}

static void dcerpc_RemoteLockServer_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemoteLockServer_state *state = tevent_req_data(
		req, struct dcerpc_RemoteLockServer_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemoteLockServer_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemoteLockServer_recv(struct tevent_req *req,
				      TALLOC_CTX *mem_ctx,
				      WERROR *result)
{
	struct dcerpc_RemoteLockServer_state *state = tevent_req_data(
		req, struct dcerpc_RemoteLockServer_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemoteLockServer(struct dcerpc_binding_handle *h,
				 TALLOC_CTX *mem_ctx,
				 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				 struct ORPCTHIS _ORPCthis /* [in]  */,
				 WERROR *result)
{
	struct RemoteLockServer r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_RemoteLockServer_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IRemUnknown - client functions generated by pidl */

struct dcerpc_RemQueryInterface_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemQueryInterface_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemQueryInterface_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemQueryInterface *r)
{
	struct tevent_req *req;
	struct dcerpc_RemQueryInterface_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemQueryInterface_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMQUERYINTERFACE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemQueryInterface_r_done, req);

	return req;
}

static void dcerpc_RemQueryInterface_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemQueryInterface_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemQueryInterface_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemQueryInterface_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemQueryInterface_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemQueryInterface *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMQUERYINTERFACE, mem_ctx, r);

	return status;
}

struct dcerpc_RemQueryInterface_state {
	struct RemQueryInterface orig;
	struct RemQueryInterface tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemQueryInterface_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemQueryInterface_send(TALLOC_CTX *mem_ctx,
						 struct tevent_context *ev,
						 struct dcerpc_binding_handle *h,
						 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						 struct ORPCTHIS _ORPCthis /* [in]  */,
						 struct GUID *_ripid /* [in] [unique] */,
						 uint32_t _cRefs /* [in]  */,
						 uint16_t _cIids /* [in]  */,
						 struct GUID *_iids /* [in] [size_is(cIids),unique] */,
						 struct MInterfacePointer *_ip /* [out] [unique,size_is(cIids)] */)
{
	struct tevent_req *req;
	struct dcerpc_RemQueryInterface_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemQueryInterface_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.ripid = _ripid;
	state->orig.in.cRefs = _cRefs;
	state->orig.in.cIids = _cIids;
	state->orig.in.iids = _iids;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.ip = _ip;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemQueryInterface_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemQueryInterface_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemQueryInterface_done, req);
	return req;
}

static void dcerpc_RemQueryInterface_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemQueryInterface_state *state = tevent_req_data(
		req, struct dcerpc_RemQueryInterface_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemQueryInterface_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.ip && state->tmp.out.ip) {
		{
			size_t _copy_len_ip;
			_copy_len_ip = state->tmp.in.cIids;
			memcpy(state->orig.out.ip, state->tmp.out.ip, _copy_len_ip * sizeof(*state->orig.out.ip));
		}
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemQueryInterface_recv(struct tevent_req *req,
				       TALLOC_CTX *mem_ctx,
				       WERROR *result)
{
	struct dcerpc_RemQueryInterface_state *state = tevent_req_data(
		req, struct dcerpc_RemQueryInterface_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemQueryInterface(struct dcerpc_binding_handle *h,
				  TALLOC_CTX *mem_ctx,
				  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				  struct ORPCTHIS _ORPCthis /* [in]  */,
				  struct GUID *_ripid /* [in] [unique] */,
				  uint32_t _cRefs /* [in]  */,
				  uint16_t _cIids /* [in]  */,
				  struct GUID *_iids /* [in] [size_is(cIids),unique] */,
				  struct MInterfacePointer *_ip /* [out] [unique,size_is(cIids)] */,
				  WERROR *result)
{
	struct RemQueryInterface r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.ripid = _ripid;
	r.in.cRefs = _cRefs;
	r.in.cIids = _cIids;
	r.in.iids = _iids;

	status = dcerpc_RemQueryInterface_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_ip && r.out.ip) {
		{
			size_t _copy_len_ip;
			_copy_len_ip = r.in.cIids;
			memcpy(_ip, r.out.ip, _copy_len_ip * sizeof(*_ip));
		}
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_RemAddRef_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemAddRef_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemAddRef_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemAddRef *r)
{
	struct tevent_req *req;
	struct dcerpc_RemAddRef_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemAddRef_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMADDREF, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemAddRef_r_done, req);

	return req;
}

static void dcerpc_RemAddRef_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemAddRef_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemAddRef_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemAddRef_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemAddRef_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemAddRef *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMADDREF, mem_ctx, r);

	return status;
}

struct dcerpc_RemAddRef_state {
	struct RemAddRef orig;
	struct RemAddRef tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemAddRef_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemAddRef_send(TALLOC_CTX *mem_ctx,
					 struct tevent_context *ev,
					 struct dcerpc_binding_handle *h,
					 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					 struct ORPCTHIS _ORPCthis /* [in]  */,
					 uint16_t _cInterfaceRefs /* [in]  */,
					 struct REMINTERFACEREF *_InterfaceRefs /* [in] [size_is(cInterfaceRefs)] */,
					 WERROR *_pResults /* [out] [size_is(cInterfaceRefs),unique] */)
{
	struct tevent_req *req;
	struct dcerpc_RemAddRef_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemAddRef_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.cInterfaceRefs = _cInterfaceRefs;
	state->orig.in.InterfaceRefs = _InterfaceRefs;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.pResults = _pResults;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemAddRef_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemAddRef_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemAddRef_done, req);
	return req;
}

static void dcerpc_RemAddRef_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemAddRef_state *state = tevent_req_data(
		req, struct dcerpc_RemAddRef_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemAddRef_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.pResults && state->tmp.out.pResults) {
		{
			size_t _copy_len_pResults;
			_copy_len_pResults = state->tmp.in.cInterfaceRefs;
			memcpy(state->orig.out.pResults, state->tmp.out.pResults, _copy_len_pResults * sizeof(*state->orig.out.pResults));
		}
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemAddRef_recv(struct tevent_req *req,
			       TALLOC_CTX *mem_ctx,
			       WERROR *result)
{
	struct dcerpc_RemAddRef_state *state = tevent_req_data(
		req, struct dcerpc_RemAddRef_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemAddRef(struct dcerpc_binding_handle *h,
			  TALLOC_CTX *mem_ctx,
			  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			  struct ORPCTHIS _ORPCthis /* [in]  */,
			  uint16_t _cInterfaceRefs /* [in]  */,
			  struct REMINTERFACEREF *_InterfaceRefs /* [in] [size_is(cInterfaceRefs)] */,
			  WERROR *_pResults /* [out] [size_is(cInterfaceRefs),unique] */,
			  WERROR *result)
{
	struct RemAddRef r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.cInterfaceRefs = _cInterfaceRefs;
	r.in.InterfaceRefs = _InterfaceRefs;

	status = dcerpc_RemAddRef_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_pResults && r.out.pResults) {
		{
			size_t _copy_len_pResults;
			_copy_len_pResults = r.in.cInterfaceRefs;
			memcpy(_pResults, r.out.pResults, _copy_len_pResults * sizeof(*_pResults));
		}
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_RemRelease_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemRelease_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemRelease_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemRelease *r)
{
	struct tevent_req *req;
	struct dcerpc_RemRelease_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemRelease_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMRELEASE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemRelease_r_done, req);

	return req;
}

static void dcerpc_RemRelease_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemRelease_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemRelease_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemRelease_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemRelease_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemRelease *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IRemUnknown,
			NDR_REMRELEASE, mem_ctx, r);

	return status;
}

struct dcerpc_RemRelease_state {
	struct RemRelease orig;
	struct RemRelease tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemRelease_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemRelease_send(TALLOC_CTX *mem_ctx,
					  struct tevent_context *ev,
					  struct dcerpc_binding_handle *h,
					  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					  struct ORPCTHIS _ORPCthis /* [in]  */,
					  uint16_t _cInterfaceRefs /* [in]  */,
					  struct REMINTERFACEREF *_InterfaceRefs /* [in] [size_is(cInterfaceRefs)] */)
{
	struct tevent_req *req;
	struct dcerpc_RemRelease_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemRelease_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.cInterfaceRefs = _cInterfaceRefs;
	state->orig.in.InterfaceRefs = _InterfaceRefs;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemRelease_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemRelease_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemRelease_done, req);
	return req;
}

static void dcerpc_RemRelease_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemRelease_state *state = tevent_req_data(
		req, struct dcerpc_RemRelease_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemRelease_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemRelease_recv(struct tevent_req *req,
				TALLOC_CTX *mem_ctx,
				WERROR *result)
{
	struct dcerpc_RemRelease_state *state = tevent_req_data(
		req, struct dcerpc_RemRelease_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemRelease(struct dcerpc_binding_handle *h,
			   TALLOC_CTX *mem_ctx,
			   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			   struct ORPCTHIS _ORPCthis /* [in]  */,
			   uint16_t _cInterfaceRefs /* [in]  */,
			   struct REMINTERFACEREF *_InterfaceRefs /* [in] [size_is(cInterfaceRefs)] */,
			   WERROR *result)
{
	struct RemRelease r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.cInterfaceRefs = _cInterfaceRefs;
	r.in.InterfaceRefs = _InterfaceRefs;

	status = dcerpc_RemRelease_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IClassActivator - client functions generated by pidl */

struct dcerpc_GetClassObject_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetClassObject_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetClassObject_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct GetClassObject *r)
{
	struct tevent_req *req;
	struct dcerpc_GetClassObject_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetClassObject_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IClassActivator,
			NDR_GETCLASSOBJECT, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetClassObject_r_done, req);

	return req;
}

static void dcerpc_GetClassObject_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetClassObject_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetClassObject_r_state *state =
		tevent_req_data(req,
		struct dcerpc_GetClassObject_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetClassObject_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct GetClassObject *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IClassActivator,
			NDR_GETCLASSOBJECT, mem_ctx, r);

	return status;
}

struct dcerpc_GetClassObject_state {
	struct GetClassObject orig;
	struct GetClassObject tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetClassObject_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetClassObject_send(TALLOC_CTX *mem_ctx,
					      struct tevent_context *ev,
					      struct dcerpc_binding_handle *h,
					      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					      struct ORPCTHIS _ORPCthis /* [in]  */,
					      struct GUID _clsid /* [in]  */,
					      uint32_t _context /* [in]  */,
					      uint32_t _locale /* [in]  */,
					      struct GUID _iid /* [in]  */,
					      struct MInterfacePointer *_data /* [out] [ref,iid_is(iid)] */)
{
	struct tevent_req *req;
	struct dcerpc_GetClassObject_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetClassObject_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.clsid = _clsid;
	state->orig.in.context = _context;
	state->orig.in.locale = _locale;
	state->orig.in.iid = _iid;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.data = _data;

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_GetClassObject_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_GetClassObject_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetClassObject_done, req);
	return req;
}

static void dcerpc_GetClassObject_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_GetClassObject_state *state = tevent_req_data(
		req, struct dcerpc_GetClassObject_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_GetClassObject_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	*state->orig.out.data = *state->tmp.out.data;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetClassObject_recv(struct tevent_req *req,
				    TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetClassObject_state *state = tevent_req_data(
		req, struct dcerpc_GetClassObject_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetClassObject(struct dcerpc_binding_handle *h,
			       TALLOC_CTX *mem_ctx,
			       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			       struct ORPCTHIS _ORPCthis /* [in]  */,
			       struct GUID _clsid /* [in]  */,
			       uint32_t _context /* [in]  */,
			       uint32_t _locale /* [in]  */,
			       struct GUID _iid /* [in]  */,
			       struct MInterfacePointer *_data /* [out] [ref,iid_is(iid)] */)
{
	struct GetClassObject r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.clsid = _clsid;
	r.in.context = _context;
	r.in.locale = _locale;
	r.in.iid = _iid;

	status = dcerpc_GetClassObject_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	*_data = *r.out.data;

	/* Return result */

	return NT_STATUS_OK;
}

/* ISCMLocalActivator - client functions generated by pidl */

struct dcerpc_ISCMLocalActivator_CreateInstance_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ISCMLocalActivator_CreateInstance_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ISCMLocalActivator_CreateInstance_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct ISCMLocalActivator_CreateInstance *r)
{
	struct tevent_req *req;
	struct dcerpc_ISCMLocalActivator_CreateInstance_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ISCMLocalActivator_CreateInstance_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_ISCMLocalActivator,
			NDR_ISCMLOCALACTIVATOR_CREATEINSTANCE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ISCMLocalActivator_CreateInstance_r_done, req);

	return req;
}

static void dcerpc_ISCMLocalActivator_CreateInstance_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_ISCMLocalActivator_CreateInstance_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_ISCMLocalActivator_CreateInstance_r_state *state =
		tevent_req_data(req,
		struct dcerpc_ISCMLocalActivator_CreateInstance_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ISCMLocalActivator_CreateInstance_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct ISCMLocalActivator_CreateInstance *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_ISCMLocalActivator,
			NDR_ISCMLOCALACTIVATOR_CREATEINSTANCE, mem_ctx, r);

	return status;
}

struct dcerpc_ISCMLocalActivator_CreateInstance_state {
	struct ISCMLocalActivator_CreateInstance orig;
	struct ISCMLocalActivator_CreateInstance tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ISCMLocalActivator_CreateInstance_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ISCMLocalActivator_CreateInstance_send(TALLOC_CTX *mem_ctx,
								 struct tevent_context *ev,
								 struct dcerpc_binding_handle *h,
								 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
								 struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_ISCMLocalActivator_CreateInstance_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ISCMLocalActivator_CreateInstance_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_ISCMLocalActivator_CreateInstance_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_ISCMLocalActivator_CreateInstance_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ISCMLocalActivator_CreateInstance_done, req);
	return req;
}

static void dcerpc_ISCMLocalActivator_CreateInstance_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_ISCMLocalActivator_CreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_ISCMLocalActivator_CreateInstance_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_ISCMLocalActivator_CreateInstance_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_ISCMLocalActivator_CreateInstance_recv(struct tevent_req *req,
						       TALLOC_CTX *mem_ctx,
						       WERROR *result)
{
	struct dcerpc_ISCMLocalActivator_CreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_ISCMLocalActivator_CreateInstance_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ISCMLocalActivator_CreateInstance(struct dcerpc_binding_handle *h,
						  TALLOC_CTX *mem_ctx,
						  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						  struct ORPCTHIS _ORPCthis /* [in]  */,
						  WERROR *result)
{
	struct ISCMLocalActivator_CreateInstance r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_ISCMLocalActivator_CreateInstance_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IMachineLocalActivator - client functions generated by pidl */

struct dcerpc_IMachineLocalActivator_foo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_IMachineLocalActivator_foo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_IMachineLocalActivator_foo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct IMachineLocalActivator_foo *r)
{
	struct tevent_req *req;
	struct dcerpc_IMachineLocalActivator_foo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_IMachineLocalActivator_foo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IMachineLocalActivator,
			NDR_IMACHINELOCALACTIVATOR_FOO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_IMachineLocalActivator_foo_r_done, req);

	return req;
}

static void dcerpc_IMachineLocalActivator_foo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_IMachineLocalActivator_foo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_IMachineLocalActivator_foo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_IMachineLocalActivator_foo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_IMachineLocalActivator_foo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct IMachineLocalActivator_foo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IMachineLocalActivator,
			NDR_IMACHINELOCALACTIVATOR_FOO, mem_ctx, r);

	return status;
}

struct dcerpc_IMachineLocalActivator_foo_state {
	struct IMachineLocalActivator_foo orig;
	struct IMachineLocalActivator_foo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_IMachineLocalActivator_foo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_IMachineLocalActivator_foo_send(TALLOC_CTX *mem_ctx,
							  struct tevent_context *ev,
							  struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_IMachineLocalActivator_foo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_IMachineLocalActivator_foo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_IMachineLocalActivator_foo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_IMachineLocalActivator_foo_done, req);
	return req;
}

static void dcerpc_IMachineLocalActivator_foo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_IMachineLocalActivator_foo_state *state = tevent_req_data(
		req, struct dcerpc_IMachineLocalActivator_foo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_IMachineLocalActivator_foo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_IMachineLocalActivator_foo_recv(struct tevent_req *req,
						TALLOC_CTX *mem_ctx,
						WERROR *result)
{
	struct dcerpc_IMachineLocalActivator_foo_state *state = tevent_req_data(
		req, struct dcerpc_IMachineLocalActivator_foo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_IMachineLocalActivator_foo(struct dcerpc_binding_handle *h,
					   TALLOC_CTX *mem_ctx,
					   WERROR *result)
{
	struct IMachineLocalActivator_foo r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_IMachineLocalActivator_foo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* ILocalObjectExporter - client functions generated by pidl */

struct dcerpc_ILocalObjectExporter_Foo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ILocalObjectExporter_Foo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ILocalObjectExporter_Foo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct ILocalObjectExporter_Foo *r)
{
	struct tevent_req *req;
	struct dcerpc_ILocalObjectExporter_Foo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ILocalObjectExporter_Foo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = NULL;

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_ILocalObjectExporter,
			NDR_ILOCALOBJECTEXPORTER_FOO, state, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ILocalObjectExporter_Foo_r_done, req);

	return req;
}

static void dcerpc_ILocalObjectExporter_Foo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_ILocalObjectExporter_Foo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_ILocalObjectExporter_Foo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_ILocalObjectExporter_Foo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ILocalObjectExporter_Foo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct ILocalObjectExporter_Foo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_ILocalObjectExporter,
			NDR_ILOCALOBJECTEXPORTER_FOO, mem_ctx, r);

	return status;
}

struct dcerpc_ILocalObjectExporter_Foo_state {
	struct ILocalObjectExporter_Foo orig;
	struct ILocalObjectExporter_Foo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ILocalObjectExporter_Foo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ILocalObjectExporter_Foo_send(TALLOC_CTX *mem_ctx,
							struct tevent_context *ev,
							struct dcerpc_binding_handle *h)
{
	struct tevent_req *req;
	struct dcerpc_ILocalObjectExporter_Foo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ILocalObjectExporter_Foo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */

	/* Out parameters */

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_ILocalObjectExporter_Foo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ILocalObjectExporter_Foo_done, req);
	return req;
}

static void dcerpc_ILocalObjectExporter_Foo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_ILocalObjectExporter_Foo_state *state = tevent_req_data(
		req, struct dcerpc_ILocalObjectExporter_Foo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_ILocalObjectExporter_Foo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_ILocalObjectExporter_Foo_recv(struct tevent_req *req,
					      TALLOC_CTX *mem_ctx,
					      WERROR *result)
{
	struct dcerpc_ILocalObjectExporter_Foo_state *state = tevent_req_data(
		req, struct dcerpc_ILocalObjectExporter_Foo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ILocalObjectExporter_Foo(struct dcerpc_binding_handle *h,
					 TALLOC_CTX *mem_ctx,
					 WERROR *result)
{
	struct ILocalObjectExporter_Foo r;
	NTSTATUS status;

	/* In parameters */

	status = dcerpc_ILocalObjectExporter_Foo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* ISystemActivator - client functions generated by pidl */

struct dcerpc_ISystemActivatorRemoteCreateInstance_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ISystemActivatorRemoteCreateInstance_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ISystemActivatorRemoteCreateInstance_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct ISystemActivatorRemoteCreateInstance *r)
{
	struct tevent_req *req;
	struct dcerpc_ISystemActivatorRemoteCreateInstance_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ISystemActivatorRemoteCreateInstance_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_ISystemActivator,
			NDR_ISYSTEMACTIVATORREMOTECREATEINSTANCE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ISystemActivatorRemoteCreateInstance_r_done, req);

	return req;
}

static void dcerpc_ISystemActivatorRemoteCreateInstance_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_ISystemActivatorRemoteCreateInstance_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_ISystemActivatorRemoteCreateInstance_r_state *state =
		tevent_req_data(req,
		struct dcerpc_ISystemActivatorRemoteCreateInstance_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ISystemActivatorRemoteCreateInstance_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct ISystemActivatorRemoteCreateInstance *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_ISystemActivator,
			NDR_ISYSTEMACTIVATORREMOTECREATEINSTANCE, mem_ctx, r);

	return status;
}

struct dcerpc_ISystemActivatorRemoteCreateInstance_state {
	struct ISystemActivatorRemoteCreateInstance orig;
	struct ISystemActivatorRemoteCreateInstance tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_ISystemActivatorRemoteCreateInstance_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_ISystemActivatorRemoteCreateInstance_send(TALLOC_CTX *mem_ctx,
								    struct tevent_context *ev,
								    struct dcerpc_binding_handle *h,
								    struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
								    struct ORPCTHIS _ORPCthis /* [in]  */,
								    uint64_t _unknown1 /* [in]  */,
								    struct MInterfacePointer _iface1 /* [in]  */,
								    uint64_t _unknown2 /* [in]  */,
								    uint32_t *_unknown3 /* [out] [ref] */,
								    struct MInterfacePointer *_iface2 /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_ISystemActivatorRemoteCreateInstance_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_ISystemActivatorRemoteCreateInstance_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.unknown1 = _unknown1;
	state->orig.in.iface1 = _iface1;
	state->orig.in.unknown2 = _unknown2;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.unknown3 = _unknown3;
	state->orig.out.iface2 = _iface2;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_ISystemActivatorRemoteCreateInstance_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_ISystemActivatorRemoteCreateInstance_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_ISystemActivatorRemoteCreateInstance_done, req);
	return req;
}

static void dcerpc_ISystemActivatorRemoteCreateInstance_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_ISystemActivatorRemoteCreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_ISystemActivatorRemoteCreateInstance_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_ISystemActivatorRemoteCreateInstance_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	*state->orig.out.unknown3 = *state->tmp.out.unknown3;
	*state->orig.out.iface2 = *state->tmp.out.iface2;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_ISystemActivatorRemoteCreateInstance_recv(struct tevent_req *req,
							  TALLOC_CTX *mem_ctx,
							  WERROR *result)
{
	struct dcerpc_ISystemActivatorRemoteCreateInstance_state *state = tevent_req_data(
		req, struct dcerpc_ISystemActivatorRemoteCreateInstance_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_ISystemActivatorRemoteCreateInstance(struct dcerpc_binding_handle *h,
						     TALLOC_CTX *mem_ctx,
						     struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						     struct ORPCTHIS _ORPCthis /* [in]  */,
						     uint64_t _unknown1 /* [in]  */,
						     struct MInterfacePointer _iface1 /* [in]  */,
						     uint64_t _unknown2 /* [in]  */,
						     uint32_t *_unknown3 /* [out] [ref] */,
						     struct MInterfacePointer *_iface2 /* [out] [ref] */,
						     WERROR *result)
{
	struct ISystemActivatorRemoteCreateInstance r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.unknown1 = _unknown1;
	r.in.iface1 = _iface1;
	r.in.unknown2 = _unknown2;

	status = dcerpc_ISystemActivatorRemoteCreateInstance_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	*_unknown3 = *r.out.unknown3;
	*_iface2 = *r.out.iface2;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IRemUnknown2 - client functions generated by pidl */

struct dcerpc_RemQueryInterface2_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemQueryInterface2_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemQueryInterface2_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct RemQueryInterface2 *r)
{
	struct tevent_req *req;
	struct dcerpc_RemQueryInterface2_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemQueryInterface2_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IRemUnknown2,
			NDR_REMQUERYINTERFACE2, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemQueryInterface2_r_done, req);

	return req;
}

static void dcerpc_RemQueryInterface2_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemQueryInterface2_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_RemQueryInterface2_r_state *state =
		tevent_req_data(req,
		struct dcerpc_RemQueryInterface2_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemQueryInterface2_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct RemQueryInterface2 *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IRemUnknown2,
			NDR_REMQUERYINTERFACE2, mem_ctx, r);

	return status;
}

struct dcerpc_RemQueryInterface2_state {
	struct RemQueryInterface2 orig;
	struct RemQueryInterface2 tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_RemQueryInterface2_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_RemQueryInterface2_send(TALLOC_CTX *mem_ctx,
						  struct tevent_context *ev,
						  struct dcerpc_binding_handle *h,
						  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						  struct ORPCTHIS _ORPCthis /* [in]  */,
						  struct GUID *_ripid /* [in] [unique] */,
						  uint16_t _cIids /* [in]  */,
						  struct GUID *_iids /* [in] [size_is(cIids),unique] */,
						  WERROR *_phr /* [out] [size_is(cIids),unique] */,
						  struct MInterfacePointer *_ppMIF /* [out] [size_is(cIids),unique] */)
{
	struct tevent_req *req;
	struct dcerpc_RemQueryInterface2_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_RemQueryInterface2_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.ripid = _ripid;
	state->orig.in.cIids = _cIids;
	state->orig.in.iids = _iids;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.phr = _phr;
	state->orig.out.ppMIF = _ppMIF;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_RemQueryInterface2_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_RemQueryInterface2_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_RemQueryInterface2_done, req);
	return req;
}

static void dcerpc_RemQueryInterface2_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_RemQueryInterface2_state *state = tevent_req_data(
		req, struct dcerpc_RemQueryInterface2_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_RemQueryInterface2_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.phr && state->tmp.out.phr) {
		{
			size_t _copy_len_phr;
			_copy_len_phr = state->tmp.in.cIids;
			memcpy(state->orig.out.phr, state->tmp.out.phr, _copy_len_phr * sizeof(*state->orig.out.phr));
		}
	}
	if (state->orig.out.ppMIF && state->tmp.out.ppMIF) {
		{
			size_t _copy_len_ppMIF;
			_copy_len_ppMIF = state->tmp.in.cIids;
			memcpy(state->orig.out.ppMIF, state->tmp.out.ppMIF, _copy_len_ppMIF * sizeof(*state->orig.out.ppMIF));
		}
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_RemQueryInterface2_recv(struct tevent_req *req,
					TALLOC_CTX *mem_ctx,
					WERROR *result)
{
	struct dcerpc_RemQueryInterface2_state *state = tevent_req_data(
		req, struct dcerpc_RemQueryInterface2_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_RemQueryInterface2(struct dcerpc_binding_handle *h,
				   TALLOC_CTX *mem_ctx,
				   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				   struct ORPCTHIS _ORPCthis /* [in]  */,
				   struct GUID *_ripid /* [in] [unique] */,
				   uint16_t _cIids /* [in]  */,
				   struct GUID *_iids /* [in] [size_is(cIids),unique] */,
				   WERROR *_phr /* [out] [size_is(cIids),unique] */,
				   struct MInterfacePointer *_ppMIF /* [out] [size_is(cIids),unique] */,
				   WERROR *result)
{
	struct RemQueryInterface2 r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.ripid = _ripid;
	r.in.cIids = _cIids;
	r.in.iids = _iids;

	status = dcerpc_RemQueryInterface2_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_phr && r.out.phr) {
		{
			size_t _copy_len_phr;
			_copy_len_phr = r.in.cIids;
			memcpy(_phr, r.out.phr, _copy_len_phr * sizeof(*_phr));
		}
	}
	if (_ppMIF && r.out.ppMIF) {
		{
			size_t _copy_len_ppMIF;
			_copy_len_ppMIF = r.in.cIids;
			memcpy(_ppMIF, r.out.ppMIF, _copy_len_ppMIF * sizeof(*_ppMIF));
		}
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IDispatch - client functions generated by pidl */

struct dcerpc_GetTypeInfoCount_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetTypeInfoCount_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetTypeInfoCount_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct GetTypeInfoCount *r)
{
	struct tevent_req *req;
	struct dcerpc_GetTypeInfoCount_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetTypeInfoCount_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IDispatch,
			NDR_GETTYPEINFOCOUNT, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetTypeInfoCount_r_done, req);

	return req;
}

static void dcerpc_GetTypeInfoCount_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetTypeInfoCount_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetTypeInfoCount_r_state *state =
		tevent_req_data(req,
		struct dcerpc_GetTypeInfoCount_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetTypeInfoCount_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct GetTypeInfoCount *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IDispatch,
			NDR_GETTYPEINFOCOUNT, mem_ctx, r);

	return status;
}

struct dcerpc_GetTypeInfoCount_state {
	struct GetTypeInfoCount orig;
	struct GetTypeInfoCount tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetTypeInfoCount_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetTypeInfoCount_send(TALLOC_CTX *mem_ctx,
						struct tevent_context *ev,
						struct dcerpc_binding_handle *h,
						struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						struct ORPCTHIS _ORPCthis /* [in]  */,
						uint16_t *_pctinfo /* [out] [unique] */)
{
	struct tevent_req *req;
	struct dcerpc_GetTypeInfoCount_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetTypeInfoCount_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.pctinfo = _pctinfo;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_GetTypeInfoCount_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_GetTypeInfoCount_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetTypeInfoCount_done, req);
	return req;
}

static void dcerpc_GetTypeInfoCount_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_GetTypeInfoCount_state *state = tevent_req_data(
		req, struct dcerpc_GetTypeInfoCount_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_GetTypeInfoCount_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.pctinfo && state->tmp.out.pctinfo) {
		*state->orig.out.pctinfo = *state->tmp.out.pctinfo;
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetTypeInfoCount_recv(struct tevent_req *req,
				      TALLOC_CTX *mem_ctx,
				      WERROR *result)
{
	struct dcerpc_GetTypeInfoCount_state *state = tevent_req_data(
		req, struct dcerpc_GetTypeInfoCount_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetTypeInfoCount(struct dcerpc_binding_handle *h,
				 TALLOC_CTX *mem_ctx,
				 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				 struct ORPCTHIS _ORPCthis /* [in]  */,
				 uint16_t *_pctinfo /* [out] [unique] */,
				 WERROR *result)
{
	struct GetTypeInfoCount r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_GetTypeInfoCount_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_pctinfo && r.out.pctinfo) {
		*_pctinfo = *r.out.pctinfo;
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_GetTypeInfo_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetTypeInfo_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetTypeInfo_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct GetTypeInfo *r)
{
	struct tevent_req *req;
	struct dcerpc_GetTypeInfo_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetTypeInfo_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IDispatch,
			NDR_GETTYPEINFO, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetTypeInfo_r_done, req);

	return req;
}

static void dcerpc_GetTypeInfo_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetTypeInfo_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetTypeInfo_r_state *state =
		tevent_req_data(req,
		struct dcerpc_GetTypeInfo_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetTypeInfo_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct GetTypeInfo *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IDispatch,
			NDR_GETTYPEINFO, mem_ctx, r);

	return status;
}

struct dcerpc_GetTypeInfo_state {
	struct GetTypeInfo orig;
	struct GetTypeInfo tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetTypeInfo_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetTypeInfo_send(TALLOC_CTX *mem_ctx,
					   struct tevent_context *ev,
					   struct dcerpc_binding_handle *h,
					   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					   struct ORPCTHIS _ORPCthis /* [in]  */,
					   uint16_t _iTInfo /* [in]  */,
					   uint32_t _lcid /* [in]  */,
					   struct REF_ITypeInfo *_ppTInfo /* [out] [unique] */)
{
	struct tevent_req *req;
	struct dcerpc_GetTypeInfo_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetTypeInfo_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.iTInfo = _iTInfo;
	state->orig.in.lcid = _lcid;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.ppTInfo = _ppTInfo;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_GetTypeInfo_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_GetTypeInfo_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetTypeInfo_done, req);
	return req;
}

static void dcerpc_GetTypeInfo_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_GetTypeInfo_state *state = tevent_req_data(
		req, struct dcerpc_GetTypeInfo_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_GetTypeInfo_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.ppTInfo && state->tmp.out.ppTInfo) {
		*state->orig.out.ppTInfo = *state->tmp.out.ppTInfo;
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetTypeInfo_recv(struct tevent_req *req,
				 TALLOC_CTX *mem_ctx,
				 WERROR *result)
{
	struct dcerpc_GetTypeInfo_state *state = tevent_req_data(
		req, struct dcerpc_GetTypeInfo_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetTypeInfo(struct dcerpc_binding_handle *h,
			    TALLOC_CTX *mem_ctx,
			    struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			    struct ORPCTHIS _ORPCthis /* [in]  */,
			    uint16_t _iTInfo /* [in]  */,
			    uint32_t _lcid /* [in]  */,
			    struct REF_ITypeInfo *_ppTInfo /* [out] [unique] */,
			    WERROR *result)
{
	struct GetTypeInfo r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.iTInfo = _iTInfo;
	r.in.lcid = _lcid;

	status = dcerpc_GetTypeInfo_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_ppTInfo && r.out.ppTInfo) {
		*_ppTInfo = *r.out.ppTInfo;
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_GetIDsOfNames_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetIDsOfNames_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetIDsOfNames_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct GetIDsOfNames *r)
{
	struct tevent_req *req;
	struct dcerpc_GetIDsOfNames_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetIDsOfNames_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IDispatch,
			NDR_GETIDSOFNAMES, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetIDsOfNames_r_done, req);

	return req;
}

static void dcerpc_GetIDsOfNames_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetIDsOfNames_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_GetIDsOfNames_r_state *state =
		tevent_req_data(req,
		struct dcerpc_GetIDsOfNames_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetIDsOfNames_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct GetIDsOfNames *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IDispatch,
			NDR_GETIDSOFNAMES, mem_ctx, r);

	return status;
}

struct dcerpc_GetIDsOfNames_state {
	struct GetIDsOfNames orig;
	struct GetIDsOfNames tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_GetIDsOfNames_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_GetIDsOfNames_send(TALLOC_CTX *mem_ctx,
					     struct tevent_context *ev,
					     struct dcerpc_binding_handle *h,
					     struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					     struct ORPCTHIS _ORPCthis /* [in]  */,
					     struct GUID *_riid /* [in] [unique] */,
					     uint16_t _cNames /* [in]  */,
					     uint32_t _lcid /* [in]  */,
					     uint32_t *_rgDispId /* [out] [size_is(cNames),unique] */)
{
	struct tevent_req *req;
	struct dcerpc_GetIDsOfNames_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_GetIDsOfNames_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.riid = _riid;
	state->orig.in.cNames = _cNames;
	state->orig.in.lcid = _lcid;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.rgDispId = _rgDispId;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_GetIDsOfNames_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_GetIDsOfNames_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_GetIDsOfNames_done, req);
	return req;
}

static void dcerpc_GetIDsOfNames_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_GetIDsOfNames_state *state = tevent_req_data(
		req, struct dcerpc_GetIDsOfNames_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_GetIDsOfNames_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.rgDispId && state->tmp.out.rgDispId) {
		{
			size_t _copy_len_rgDispId;
			_copy_len_rgDispId = state->tmp.in.cNames;
			memcpy(state->orig.out.rgDispId, state->tmp.out.rgDispId, _copy_len_rgDispId * sizeof(*state->orig.out.rgDispId));
		}
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_GetIDsOfNames_recv(struct tevent_req *req,
				   TALLOC_CTX *mem_ctx,
				   WERROR *result)
{
	struct dcerpc_GetIDsOfNames_state *state = tevent_req_data(
		req, struct dcerpc_GetIDsOfNames_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_GetIDsOfNames(struct dcerpc_binding_handle *h,
			      TALLOC_CTX *mem_ctx,
			      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			      struct ORPCTHIS _ORPCthis /* [in]  */,
			      struct GUID *_riid /* [in] [unique] */,
			      uint16_t _cNames /* [in]  */,
			      uint32_t _lcid /* [in]  */,
			      uint32_t *_rgDispId /* [out] [size_is(cNames),unique] */,
			      WERROR *result)
{
	struct GetIDsOfNames r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.riid = _riid;
	r.in.cNames = _cNames;
	r.in.lcid = _lcid;

	status = dcerpc_GetIDsOfNames_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_rgDispId && r.out.rgDispId) {
		{
			size_t _copy_len_rgDispId;
			_copy_len_rgDispId = r.in.cNames;
			memcpy(_rgDispId, r.out.rgDispId, _copy_len_rgDispId * sizeof(*_rgDispId));
		}
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_Invoke_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Invoke_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Invoke_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct Invoke *r)
{
	struct tevent_req *req;
	struct dcerpc_Invoke_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Invoke_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IDispatch,
			NDR_INVOKE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Invoke_r_done, req);

	return req;
}

static void dcerpc_Invoke_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_Invoke_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_Invoke_r_state *state =
		tevent_req_data(req,
		struct dcerpc_Invoke_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Invoke_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct Invoke *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IDispatch,
			NDR_INVOKE, mem_ctx, r);

	return status;
}

struct dcerpc_Invoke_state {
	struct Invoke orig;
	struct Invoke tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Invoke_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Invoke_send(TALLOC_CTX *mem_ctx,
				      struct tevent_context *ev,
				      struct dcerpc_binding_handle *h,
				      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				      struct ORPCTHIS _ORPCthis /* [in]  */,
				      uint32_t _dispIdMember /* [in]  */,
				      struct GUID *_riid /* [in] [unique] */,
				      uint32_t _lcid /* [in]  */,
				      uint16_t _wFlags /* [in]  */,
				      struct DISPPARAMS *_pDispParams /* [in,out] [unique] */,
				      struct VARIANT *_pVarResult /* [out] [unique] */,
				      struct EXCEPINFO *_pExcepInfo /* [out] [unique] */,
				      uint16_t *_puArgErr /* [out] [unique] */)
{
	struct tevent_req *req;
	struct dcerpc_Invoke_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Invoke_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.dispIdMember = _dispIdMember;
	state->orig.in.riid = _riid;
	state->orig.in.lcid = _lcid;
	state->orig.in.wFlags = _wFlags;
	state->orig.in.pDispParams = _pDispParams;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.pDispParams = _pDispParams;
	state->orig.out.pVarResult = _pVarResult;
	state->orig.out.pExcepInfo = _pExcepInfo;
	state->orig.out.puArgErr = _puArgErr;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_Invoke_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_Invoke_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Invoke_done, req);
	return req;
}

static void dcerpc_Invoke_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_Invoke_state *state = tevent_req_data(
		req, struct dcerpc_Invoke_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_Invoke_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	if (state->orig.out.pDispParams && state->tmp.out.pDispParams) {
		*state->orig.out.pDispParams = *state->tmp.out.pDispParams;
	}
	if (state->orig.out.pVarResult && state->tmp.out.pVarResult) {
		*state->orig.out.pVarResult = *state->tmp.out.pVarResult;
	}
	if (state->orig.out.pExcepInfo && state->tmp.out.pExcepInfo) {
		*state->orig.out.pExcepInfo = *state->tmp.out.pExcepInfo;
	}
	if (state->orig.out.puArgErr && state->tmp.out.puArgErr) {
		*state->orig.out.puArgErr = *state->tmp.out.puArgErr;
	}

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_Invoke_recv(struct tevent_req *req,
			    TALLOC_CTX *mem_ctx,
			    WERROR *result)
{
	struct dcerpc_Invoke_state *state = tevent_req_data(
		req, struct dcerpc_Invoke_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Invoke(struct dcerpc_binding_handle *h,
		       TALLOC_CTX *mem_ctx,
		       struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
		       struct ORPCTHIS _ORPCthis /* [in]  */,
		       uint32_t _dispIdMember /* [in]  */,
		       struct GUID *_riid /* [in] [unique] */,
		       uint32_t _lcid /* [in]  */,
		       uint16_t _wFlags /* [in]  */,
		       struct DISPPARAMS *_pDispParams /* [in,out] [unique] */,
		       struct VARIANT *_pVarResult /* [out] [unique] */,
		       struct EXCEPINFO *_pExcepInfo /* [out] [unique] */,
		       uint16_t *_puArgErr /* [out] [unique] */,
		       WERROR *result)
{
	struct Invoke r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.dispIdMember = _dispIdMember;
	r.in.riid = _riid;
	r.in.lcid = _lcid;
	r.in.wFlags = _wFlags;
	r.in.pDispParams = _pDispParams;

	status = dcerpc_Invoke_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	if (_pDispParams && r.out.pDispParams) {
		*_pDispParams = *r.out.pDispParams;
	}
	if (_pVarResult && r.out.pVarResult) {
		*_pVarResult = *r.out.pVarResult;
	}
	if (_pExcepInfo && r.out.pExcepInfo) {
		*_pExcepInfo = *r.out.pExcepInfo;
	}
	if (_puArgErr && r.out.puArgErr) {
		*_puArgErr = *r.out.puArgErr;
	}

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IMarshal - client functions generated by pidl */

struct dcerpc_MarshalInterface_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_MarshalInterface_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_MarshalInterface_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct MarshalInterface *r)
{
	struct tevent_req *req;
	struct dcerpc_MarshalInterface_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_MarshalInterface_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IMarshal,
			NDR_MARSHALINTERFACE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_MarshalInterface_r_done, req);

	return req;
}

static void dcerpc_MarshalInterface_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_MarshalInterface_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_MarshalInterface_r_state *state =
		tevent_req_data(req,
		struct dcerpc_MarshalInterface_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_MarshalInterface_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct MarshalInterface *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IMarshal,
			NDR_MARSHALINTERFACE, mem_ctx, r);

	return status;
}

struct dcerpc_MarshalInterface_state {
	struct MarshalInterface orig;
	struct MarshalInterface tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_MarshalInterface_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_MarshalInterface_send(TALLOC_CTX *mem_ctx,
						struct tevent_context *ev,
						struct dcerpc_binding_handle *h,
						struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_MarshalInterface_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_MarshalInterface_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_MarshalInterface_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_MarshalInterface_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_MarshalInterface_done, req);
	return req;
}

static void dcerpc_MarshalInterface_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_MarshalInterface_state *state = tevent_req_data(
		req, struct dcerpc_MarshalInterface_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_MarshalInterface_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_MarshalInterface_recv(struct tevent_req *req,
				      TALLOC_CTX *mem_ctx,
				      WERROR *result)
{
	struct dcerpc_MarshalInterface_state *state = tevent_req_data(
		req, struct dcerpc_MarshalInterface_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_MarshalInterface(struct dcerpc_binding_handle *h,
				 TALLOC_CTX *mem_ctx,
				 struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				 struct ORPCTHIS _ORPCthis /* [in]  */,
				 WERROR *result)
{
	struct MarshalInterface r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_MarshalInterface_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_UnMarshalInterface_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UnMarshalInterface_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UnMarshalInterface_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct UnMarshalInterface *r)
{
	struct tevent_req *req;
	struct dcerpc_UnMarshalInterface_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UnMarshalInterface_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IMarshal,
			NDR_UNMARSHALINTERFACE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UnMarshalInterface_r_done, req);

	return req;
}

static void dcerpc_UnMarshalInterface_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_UnMarshalInterface_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_UnMarshalInterface_r_state *state =
		tevent_req_data(req,
		struct dcerpc_UnMarshalInterface_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UnMarshalInterface_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct UnMarshalInterface *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IMarshal,
			NDR_UNMARSHALINTERFACE, mem_ctx, r);

	return status;
}

struct dcerpc_UnMarshalInterface_state {
	struct UnMarshalInterface orig;
	struct UnMarshalInterface tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_UnMarshalInterface_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_UnMarshalInterface_send(TALLOC_CTX *mem_ctx,
						  struct tevent_context *ev,
						  struct dcerpc_binding_handle *h,
						  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
						  struct ORPCTHIS _ORPCthis /* [in]  */)
{
	struct tevent_req *req;
	struct dcerpc_UnMarshalInterface_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_UnMarshalInterface_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_UnMarshalInterface_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_UnMarshalInterface_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_UnMarshalInterface_done, req);
	return req;
}

static void dcerpc_UnMarshalInterface_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_UnMarshalInterface_state *state = tevent_req_data(
		req, struct dcerpc_UnMarshalInterface_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_UnMarshalInterface_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_UnMarshalInterface_recv(struct tevent_req *req,
					TALLOC_CTX *mem_ctx,
					WERROR *result)
{
	struct dcerpc_UnMarshalInterface_state *state = tevent_req_data(
		req, struct dcerpc_UnMarshalInterface_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_UnMarshalInterface(struct dcerpc_binding_handle *h,
				   TALLOC_CTX *mem_ctx,
				   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				   struct ORPCTHIS _ORPCthis /* [in]  */,
				   WERROR *result)
{
	struct UnMarshalInterface r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;

	status = dcerpc_UnMarshalInterface_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* ICoffeeMachine - client functions generated by pidl */

struct dcerpc_MakeCoffee_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_MakeCoffee_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_MakeCoffee_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct MakeCoffee *r)
{
	struct tevent_req *req;
	struct dcerpc_MakeCoffee_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_MakeCoffee_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_ICoffeeMachine,
			NDR_MAKECOFFEE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_MakeCoffee_r_done, req);

	return req;
}

static void dcerpc_MakeCoffee_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_MakeCoffee_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_MakeCoffee_r_state *state =
		tevent_req_data(req,
		struct dcerpc_MakeCoffee_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_MakeCoffee_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct MakeCoffee *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_ICoffeeMachine,
			NDR_MAKECOFFEE, mem_ctx, r);

	return status;
}

struct dcerpc_MakeCoffee_state {
	struct MakeCoffee orig;
	struct MakeCoffee tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_MakeCoffee_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_MakeCoffee_send(TALLOC_CTX *mem_ctx,
					  struct tevent_context *ev,
					  struct dcerpc_binding_handle *h,
					  struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
					  struct ORPCTHIS _ORPCthis /* [in]  */,
					  const char *_flavor /* [in] [charset(UTF16),ref] */)
{
	struct tevent_req *req;
	struct dcerpc_MakeCoffee_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_MakeCoffee_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.flavor = _flavor;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_MakeCoffee_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_MakeCoffee_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_MakeCoffee_done, req);
	return req;
}

static void dcerpc_MakeCoffee_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_MakeCoffee_state *state = tevent_req_data(
		req, struct dcerpc_MakeCoffee_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_MakeCoffee_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_MakeCoffee_recv(struct tevent_req *req,
				TALLOC_CTX *mem_ctx,
				WERROR *result)
{
	struct dcerpc_MakeCoffee_state *state = tevent_req_data(
		req, struct dcerpc_MakeCoffee_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_MakeCoffee(struct dcerpc_binding_handle *h,
			   TALLOC_CTX *mem_ctx,
			   struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
			   struct ORPCTHIS _ORPCthis /* [in]  */,
			   const char *_flavor /* [in] [charset(UTF16),ref] */,
			   WERROR *result)
{
	struct MakeCoffee r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.flavor = _flavor;

	status = dcerpc_MakeCoffee_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

/* IStream - client functions generated by pidl */

struct dcerpc_Read_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Read_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Read_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct Read *r)
{
	struct tevent_req *req;
	struct dcerpc_Read_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Read_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IStream,
			NDR_READ, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Read_r_done, req);

	return req;
}

static void dcerpc_Read_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_Read_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_Read_r_state *state =
		tevent_req_data(req,
		struct dcerpc_Read_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Read_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct Read *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IStream,
			NDR_READ, mem_ctx, r);

	return status;
}

struct dcerpc_Read_state {
	struct Read orig;
	struct Read tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Read_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Read_send(TALLOC_CTX *mem_ctx,
				    struct tevent_context *ev,
				    struct dcerpc_binding_handle *h,
				    struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				    struct ORPCTHIS _ORPCthis /* [in]  */,
				    uint8_t *_pv /* [out] [size_is(num_requested),length_is(*num_read)] */,
				    uint32_t _num_requested /* [in]  */,
				    uint32_t *_num_readx /* [in] [unique] */,
				    uint32_t *_num_read /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_Read_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Read_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.num_requested = _num_requested;
	state->orig.in.num_readx = _num_readx;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.pv = _pv;
	state->orig.out.num_read = _num_read;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_Read_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_Read_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Read_done, req);
	return req;
}

static void dcerpc_Read_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_Read_state *state = tevent_req_data(
		req, struct dcerpc_Read_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_Read_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	{
		size_t _copy_len_pv;
		if ((*state->tmp.out.num_read) > (state->tmp.in.num_requested)) {
			tevent_req_nterror(req, NT_STATUS_INVALID_NETWORK_RESPONSE);
			return;
		}
		_copy_len_pv = *state->tmp.out.num_read;
		memcpy(state->orig.out.pv, state->tmp.out.pv, _copy_len_pv * sizeof(*state->orig.out.pv));
	}
	*state->orig.out.num_read = *state->tmp.out.num_read;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_Read_recv(struct tevent_req *req,
			  TALLOC_CTX *mem_ctx,
			  WERROR *result)
{
	struct dcerpc_Read_state *state = tevent_req_data(
		req, struct dcerpc_Read_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Read(struct dcerpc_binding_handle *h,
		     TALLOC_CTX *mem_ctx,
		     struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
		     struct ORPCTHIS _ORPCthis /* [in]  */,
		     uint8_t *_pv /* [out] [size_is(num_requested),length_is(*num_read)] */,
		     uint32_t _num_requested /* [in]  */,
		     uint32_t *_num_readx /* [in] [unique] */,
		     uint32_t *_num_read /* [out] [ref] */,
		     WERROR *result)
{
	struct Read r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.num_requested = _num_requested;
	r.in.num_readx = _num_readx;

	status = dcerpc_Read_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	{
		size_t _copy_len_pv;
		if ((*r.out.num_read) > (r.in.num_requested)) {
			return NT_STATUS_INVALID_NETWORK_RESPONSE;
		}
		_copy_len_pv = *r.out.num_read;
		memcpy(_pv, r.out.pv, _copy_len_pv * sizeof(*_pv));
	}
	*_num_read = *r.out.num_read;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

struct dcerpc_Write_r_state {
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Write_r_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Write_r_send(TALLOC_CTX *mem_ctx,
	struct tevent_context *ev,
	struct dcerpc_binding_handle *h,
	struct Write *r)
{
	struct tevent_req *req;
	struct dcerpc_Write_r_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Write_r_state);
	if (req == NULL) {
		return NULL;
	}

	state->out_mem_ctx = talloc_new(state);
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	subreq = dcerpc_binding_handle_call_send(state, ev, h,
			NULL, &ndr_table_IStream,
			NDR_WRITE, state->out_mem_ctx, r);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Write_r_done, req);

	return req;
}

static void dcerpc_Write_r_done(struct tevent_req *subreq)
{
	struct tevent_req *req =
		tevent_req_callback_data(subreq,
		struct tevent_req);
	NTSTATUS status;

	status = dcerpc_binding_handle_call_recv(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	tevent_req_done(req);
}

NTSTATUS dcerpc_Write_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_Write_r_state *state =
		tevent_req_data(req,
		struct dcerpc_Write_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Write_r(struct dcerpc_binding_handle *h, TALLOC_CTX *mem_ctx, struct Write *r)
{
	NTSTATUS status;

	status = dcerpc_binding_handle_call(h,
			NULL, &ndr_table_IStream,
			NDR_WRITE, mem_ctx, r);

	return status;
}

struct dcerpc_Write_state {
	struct Write orig;
	struct Write tmp;
	TALLOC_CTX *out_mem_ctx;
};

static void dcerpc_Write_done(struct tevent_req *subreq);

struct tevent_req *dcerpc_Write_send(TALLOC_CTX *mem_ctx,
				     struct tevent_context *ev,
				     struct dcerpc_binding_handle *h,
				     struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
				     struct ORPCTHIS _ORPCthis /* [in]  */,
				     uint8_t *_data /* [in] [unique,size_is(num_requested)] */,
				     uint32_t _num_requested /* [in]  */,
				     uint32_t *_num_written /* [out] [ref] */)
{
	struct tevent_req *req;
	struct dcerpc_Write_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct dcerpc_Write_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;

	/* In parameters */
	state->orig.in.ORPCthis = _ORPCthis;
	state->orig.in.data = _data;
	state->orig.in.num_requested = _num_requested;

	/* Out parameters */
	state->orig.out.ORPCthat = _ORPCthat;
	state->orig.out.num_written = _num_written;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "dcerpc_Write_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = dcerpc_Write_r_send(state, ev, h, &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, dcerpc_Write_done, req);
	return req;
}

static void dcerpc_Write_done(struct tevent_req *subreq)
{
	struct tevent_req *req = tevent_req_callback_data(
		subreq, struct tevent_req);
	struct dcerpc_Write_state *state = tevent_req_data(
		req, struct dcerpc_Write_state);
	NTSTATUS status;
	TALLOC_CTX *mem_ctx;

	if (state->out_mem_ctx) {
		mem_ctx = state->out_mem_ctx;
	} else {
		mem_ctx = state;
	}

	status = dcerpc_Write_r_recv(subreq, mem_ctx);
	TALLOC_FREE(subreq);
	if (!NT_STATUS_IS_OK(status)) {
		tevent_req_nterror(req, status);
		return;
	}

	/* Copy out parameters */
	*state->orig.out.ORPCthat = *state->tmp.out.ORPCthat;
	*state->orig.out.num_written = *state->tmp.out.num_written;

	/* Copy result */
	state->orig.out.result = state->tmp.out.result;

	/* Reset temporary structure */
	ZERO_STRUCT(state->tmp);

	tevent_req_done(req);
}

NTSTATUS dcerpc_Write_recv(struct tevent_req *req,
			   TALLOC_CTX *mem_ctx,
			   WERROR *result)
{
	struct dcerpc_Write_state *state = tevent_req_data(
		req, struct dcerpc_Write_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	/* Steal possible out parameters to the callers context */
	talloc_steal(mem_ctx, state->out_mem_ctx);

	/* Return result */
	*result = state->orig.out.result;

	tevent_req_received(req);
	return NT_STATUS_OK;
}

NTSTATUS dcerpc_Write(struct dcerpc_binding_handle *h,
		      TALLOC_CTX *mem_ctx,
		      struct ORPCTHAT *_ORPCthat /* [out] [ref] */,
		      struct ORPCTHIS _ORPCthis /* [in]  */,
		      uint8_t *_data /* [in] [unique,size_is(num_requested)] */,
		      uint32_t _num_requested /* [in]  */,
		      uint32_t *_num_written /* [out] [ref] */,
		      WERROR *result)
{
	struct Write r;
	NTSTATUS status;

	/* In parameters */
	r.in.ORPCthis = _ORPCthis;
	r.in.data = _data;
	r.in.num_requested = _num_requested;

	status = dcerpc_Write_r(h, mem_ctx, &r);
	if (!NT_STATUS_IS_OK(status)) {
		return status;
	}

	/* Return variables */
	*_ORPCthat = *r.out.ORPCthat;
	*_num_written = *r.out.num_written;

	/* Return result */
	*result = r.out.result;

	return NT_STATUS_OK;
}

