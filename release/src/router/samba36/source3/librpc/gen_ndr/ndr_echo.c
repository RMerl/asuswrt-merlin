/* parser auto-generated by pidl */

#include "includes.h"
#include "librpc/gen_ndr/ndr_echo.h"

_PUBLIC_ enum ndr_err_code ndr_push_echo_info1(struct ndr_push *ndr, int ndr_flags, const struct echo_info1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 1));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->v));
		NDR_CHECK(ndr_push_trailer_align(ndr, 1));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ enum ndr_err_code ndr_pull_echo_info1(struct ndr_pull *ndr, int ndr_flags, struct echo_info1 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 1));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->v));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 1));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info1(struct ndr_print *ndr, const char *name, const struct echo_info1 *r)
{
	ndr_print_struct(ndr, name, "echo_info1");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint8(ndr, "v", r->v);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_info2(struct ndr_push *ndr, int ndr_flags, const struct echo_info2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 2));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->v));
		NDR_CHECK(ndr_push_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_info2(struct ndr_pull *ndr, int ndr_flags, struct echo_info2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 2));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->v));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 2));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info2(struct ndr_print *ndr, const char *name, const struct echo_info2 *r)
{
	ndr_print_struct(ndr, name, "echo_info2");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint16(ndr, "v", r->v);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_info3(struct ndr_push *ndr, int ndr_flags, const struct echo_info3 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->v));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_info3(struct ndr_pull *ndr, int ndr_flags, struct echo_info3 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->v));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info3(struct ndr_print *ndr, const char *name, const struct echo_info3 *r)
{
	ndr_print_struct(ndr, name, "echo_info3");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "v", r->v);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_STRUCT_echo_info4(struct ndr_push *ndr, int ndr_flags, const struct echo_info4 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->v));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_STRUCT_echo_info4(struct ndr_pull *ndr, int ndr_flags, struct echo_info4 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->v));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_STRUCT_echo_info4(struct ndr_print *ndr, const char *name, const struct echo_info4 *r)
{
	ndr_print_struct(ndr, name, "echo_info4");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_hyper(ndr, "v", r->v);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_info5(struct ndr_push *ndr, int ndr_flags, const struct echo_info5 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->v1));
		NDR_CHECK(ndr_push_hyper(ndr, NDR_SCALARS, r->v2));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_info5(struct ndr_pull *ndr, int ndr_flags, struct echo_info5 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->v1));
		NDR_CHECK(ndr_pull_hyper(ndr, NDR_SCALARS, &r->v2));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info5(struct ndr_print *ndr, const char *name, const struct echo_info5 *r)
{
	ndr_print_struct(ndr, name, "echo_info5");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint8(ndr, "v1", r->v1);
	ndr_print_hyper(ndr, "v2", r->v2);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_info6(struct ndr_push *ndr, int ndr_flags, const struct echo_info6 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 1));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->v1));
		NDR_CHECK(ndr_push_echo_info1(ndr, NDR_SCALARS, &r->info1));
		NDR_CHECK(ndr_push_trailer_align(ndr, 1));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_info6(struct ndr_pull *ndr, int ndr_flags, struct echo_info6 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 1));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->v1));
		NDR_CHECK(ndr_pull_echo_info1(ndr, NDR_SCALARS, &r->info1));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 1));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info6(struct ndr_print *ndr, const char *name, const struct echo_info6 *r)
{
	ndr_print_struct(ndr, name, "echo_info6");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint8(ndr, "v1", r->v1);
	ndr_print_echo_info1(ndr, "info1", &r->info1);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_info7(struct ndr_push *ndr, int ndr_flags, const struct echo_info7 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 8));
		NDR_CHECK(ndr_push_uint8(ndr, NDR_SCALARS, r->v1));
		NDR_CHECK(ndr_push_STRUCT_echo_info4(ndr, NDR_SCALARS, &r->info4));
		NDR_CHECK(ndr_push_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_info7(struct ndr_pull *ndr, int ndr_flags, struct echo_info7 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint8(ndr, NDR_SCALARS, &r->v1));
		NDR_CHECK(ndr_pull_STRUCT_echo_info4(ndr, NDR_SCALARS, &r->info4));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 8));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_info7(struct ndr_print *ndr, const char *name, const struct echo_info7 *r)
{
	ndr_print_struct(ndr, name, "echo_info7");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint8(ndr, "v1", r->v1);
	ndr_print_STRUCT_echo_info4(ndr, "info4", &r->info4);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_Info(struct ndr_push *ndr, int ndr_flags, const union echo_Info *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, level));
		NDR_CHECK(ndr_push_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_push_echo_info1(ndr, NDR_SCALARS, &r->info1));
			break; }

			case 2: {
				NDR_CHECK(ndr_push_echo_info2(ndr, NDR_SCALARS, &r->info2));
			break; }

			case 3: {
				NDR_CHECK(ndr_push_echo_info3(ndr, NDR_SCALARS, &r->info3));
			break; }

			case 4: {
				NDR_CHECK(ndr_push_STRUCT_echo_info4(ndr, NDR_SCALARS, &r->info4));
			break; }

			case 5: {
				NDR_CHECK(ndr_push_echo_info5(ndr, NDR_SCALARS, &r->info5));
			break; }

			case 6: {
				NDR_CHECK(ndr_push_echo_info6(ndr, NDR_SCALARS, &r->info6));
			break; }

			case 7: {
				NDR_CHECK(ndr_push_echo_info7(ndr, NDR_SCALARS, &r->info7));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			case 3:
			break;

			case 4:
			break;

			case 5:
			break;

			case 6:
			break;

			case 7:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Info(struct ndr_pull *ndr, int ndr_flags, union echo_Info *r)
{
	uint32_t level;
	uint16_t _level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &_level));
		if (_level != level) {
			return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u for r at %s", _level, __location__);
		}
		NDR_CHECK(ndr_pull_union_align(ndr, 8));
		switch (level) {
			case 1: {
				NDR_CHECK(ndr_pull_echo_info1(ndr, NDR_SCALARS, &r->info1));
			break; }

			case 2: {
				NDR_CHECK(ndr_pull_echo_info2(ndr, NDR_SCALARS, &r->info2));
			break; }

			case 3: {
				NDR_CHECK(ndr_pull_echo_info3(ndr, NDR_SCALARS, &r->info3));
			break; }

			case 4: {
				NDR_CHECK(ndr_pull_STRUCT_echo_info4(ndr, NDR_SCALARS, &r->info4));
			break; }

			case 5: {
				NDR_CHECK(ndr_pull_echo_info5(ndr, NDR_SCALARS, &r->info5));
			break; }

			case 6: {
				NDR_CHECK(ndr_pull_echo_info6(ndr, NDR_SCALARS, &r->info6));
			break; }

			case 7: {
				NDR_CHECK(ndr_pull_echo_info7(ndr, NDR_SCALARS, &r->info7));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case 1:
			break;

			case 2:
			break;

			case 3:
			break;

			case 4:
			break;

			case 5:
			break;

			case 6:
			break;

			case 7:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Info(struct ndr_print *ndr, const char *name, const union echo_Info *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "echo_Info");
	switch (level) {
		case 1:
			ndr_print_echo_info1(ndr, "info1", &r->info1);
		break;

		case 2:
			ndr_print_echo_info2(ndr, "info2", &r->info2);
		break;

		case 3:
			ndr_print_echo_info3(ndr, "info3", &r->info3);
		break;

		case 4:
			ndr_print_STRUCT_echo_info4(ndr, "info4", &r->info4);
		break;

		case 5:
			ndr_print_echo_info5(ndr, "info5", &r->info5);
		break;

		case 6:
			ndr_print_echo_info6(ndr, "info6", &r->info6);
		break;

		case 7:
			ndr_print_echo_info7(ndr, "info7", &r->info7);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

static enum ndr_err_code ndr_push_echo_Enum1(struct ndr_push *ndr, int ndr_flags, enum echo_Enum1 r)
{
	NDR_CHECK(ndr_push_enum_uint1632(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Enum1(struct ndr_pull *ndr, int ndr_flags, enum echo_Enum1 *r)
{
	uint16_t v;
	NDR_CHECK(ndr_pull_enum_uint1632(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Enum1(struct ndr_print *ndr, const char *name, enum echo_Enum1 r)
{
	const char *val = NULL;

	switch (r) {
		case ECHO_ENUM1: val = "ECHO_ENUM1"; break;
		case ECHO_ENUM2: val = "ECHO_ENUM2"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_echo_Enum1_32(struct ndr_push *ndr, int ndr_flags, enum echo_Enum1_32 r)
{
	NDR_CHECK(ndr_push_enum_uint32(ndr, NDR_SCALARS, r));
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Enum1_32(struct ndr_pull *ndr, int ndr_flags, enum echo_Enum1_32 *r)
{
	uint32_t v;
	NDR_CHECK(ndr_pull_enum_uint32(ndr, NDR_SCALARS, &v));
	*r = v;
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Enum1_32(struct ndr_print *ndr, const char *name, enum echo_Enum1_32 r)
{
	const char *val = NULL;

	switch (r) {
		case ECHO_ENUM1_32: val = "ECHO_ENUM1_32"; break;
		case ECHO_ENUM2_32: val = "ECHO_ENUM2_32"; break;
	}
	ndr_print_enum(ndr, name, "ENUM", val, r);
}

static enum ndr_err_code ndr_push_echo_Enum2(struct ndr_push *ndr, int ndr_flags, const struct echo_Enum2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_echo_Enum1(ndr, NDR_SCALARS, r->e1));
		NDR_CHECK(ndr_push_echo_Enum1_32(ndr, NDR_SCALARS, r->e2));
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Enum2(struct ndr_pull *ndr, int ndr_flags, struct echo_Enum2 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_echo_Enum1(ndr, NDR_SCALARS, &r->e1));
		NDR_CHECK(ndr_pull_echo_Enum1_32(ndr, NDR_SCALARS, &r->e2));
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Enum2(struct ndr_print *ndr, const char *name, const struct echo_Enum2 *r)
{
	ndr_print_struct(ndr, name, "echo_Enum2");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_echo_Enum1(ndr, "e1", r->e1);
	ndr_print_echo_Enum1_32(ndr, "e2", r->e2);
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_Enum3(struct ndr_push *ndr, int ndr_flags, const union echo_Enum3 *r)
{
	if (ndr_flags & NDR_SCALARS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		NDR_CHECK(ndr_push_union_align(ndr, 4));
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, level));
		NDR_CHECK(ndr_push_union_align(ndr, 4));
		switch (level) {
			case ECHO_ENUM1: {
				NDR_CHECK(ndr_push_echo_Enum1(ndr, NDR_SCALARS, r->e1));
			break; }

			case ECHO_ENUM2: {
				NDR_CHECK(ndr_push_echo_Enum2(ndr, NDR_SCALARS, &r->e2));
			break; }

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		uint32_t level = ndr_push_get_switch_value(ndr, r);
		switch (level) {
			case ECHO_ENUM1:
			break;

			case ECHO_ENUM2:
			break;

			default:
				return ndr_push_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Enum3(struct ndr_pull *ndr, int ndr_flags, union echo_Enum3 *r)
{
	uint32_t level;
	uint16_t _level;
	level = ndr_pull_get_switch_value(ndr, r);
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_union_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &_level));
		if (_level != level) {
			return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u for r at %s", _level, __location__);
		}
		NDR_CHECK(ndr_pull_union_align(ndr, 4));
		switch (level) {
			case ECHO_ENUM1: {
				NDR_CHECK(ndr_pull_echo_Enum1(ndr, NDR_SCALARS, &r->e1));
			break; }

			case ECHO_ENUM2: {
				NDR_CHECK(ndr_pull_echo_Enum2(ndr, NDR_SCALARS, &r->e2));
			break; }

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	if (ndr_flags & NDR_BUFFERS) {
		switch (level) {
			case ECHO_ENUM1:
			break;

			case ECHO_ENUM2:
			break;

			default:
				return ndr_pull_error(ndr, NDR_ERR_BAD_SWITCH, "Bad switch value %u at %s", level, __location__);
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Enum3(struct ndr_print *ndr, const char *name, const union echo_Enum3 *r)
{
	uint32_t level;
	level = ndr_print_get_switch_value(ndr, r);
	ndr_print_union(ndr, name, level, "echo_Enum3");
	switch (level) {
		case ECHO_ENUM1:
			ndr_print_echo_Enum1(ndr, "e1", r->e1);
		break;

		case ECHO_ENUM2:
			ndr_print_echo_Enum2(ndr, "e2", &r->e2);
		break;

		default:
			ndr_print_bad_level(ndr, name, level);
	}
}

static enum ndr_err_code ndr_push_echo_Surrounding(struct ndr_push *ndr, int ndr_flags, const struct echo_Surrounding *r)
{
	uint32_t cntr_surrounding_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->x));
		NDR_CHECK(ndr_push_align(ndr, 4));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->x));
		for (cntr_surrounding_0 = 0; cntr_surrounding_0 < r->x; cntr_surrounding_0++) {
			NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->surrounding[cntr_surrounding_0]));
		}
		NDR_CHECK(ndr_push_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_Surrounding(struct ndr_pull *ndr, int ndr_flags, struct echo_Surrounding *r)
{
	uint32_t size_surrounding_0 = 0;
	uint32_t cntr_surrounding_0;
	TALLOC_CTX *_mem_save_surrounding_0;
	if (ndr_flags & NDR_SCALARS) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->surrounding));
		NDR_CHECK(ndr_pull_align(ndr, 4));
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->x));
		size_surrounding_0 = ndr_get_array_size(ndr, &r->surrounding);
		NDR_PULL_ALLOC_N(ndr, r->surrounding, size_surrounding_0);
		_mem_save_surrounding_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->surrounding, 0);
		for (cntr_surrounding_0 = 0; cntr_surrounding_0 < size_surrounding_0; cntr_surrounding_0++) {
			NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->surrounding[cntr_surrounding_0]));
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_surrounding_0, 0);
		if (r->surrounding) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->surrounding, r->x));
		}
		NDR_CHECK(ndr_pull_trailer_align(ndr, 4));
	}
	if (ndr_flags & NDR_BUFFERS) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_Surrounding(struct ndr_print *ndr, const char *name, const struct echo_Surrounding *r)
{
	uint32_t cntr_surrounding_0;
	ndr_print_struct(ndr, name, "echo_Surrounding");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	ndr_print_uint32(ndr, "x", r->x);
	ndr->print(ndr, "%s: ARRAY(%d)", "surrounding", (int)r->x);
	ndr->depth++;
	for (cntr_surrounding_0=0;cntr_surrounding_0<r->x;cntr_surrounding_0++) {
		ndr_print_uint16(ndr, "surrounding", r->surrounding[cntr_surrounding_0]);
	}
	ndr->depth--;
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_AddOne(struct ndr_push *ndr, int flags, const struct echo_AddOne *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.in_data));
	}
	if (flags & NDR_OUT) {
		if (r->out.out_data == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.out_data));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_AddOne(struct ndr_pull *ndr, int flags, struct echo_AddOne *r)
{
	TALLOC_CTX *_mem_save_out_data_0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.in_data));
		NDR_PULL_ALLOC(ndr, r->out.out_data);
		ZERO_STRUCTP(r->out.out_data);
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.out_data);
		}
		_mem_save_out_data_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.out_data, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, r->out.out_data));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_out_data_0, LIBNDR_FLAG_REF_ALLOC);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_AddOne(struct ndr_print *ndr, const char *name, int flags, const struct echo_AddOne *r)
{
	ndr_print_struct(ndr, name, "echo_AddOne");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_AddOne");
		ndr->depth++;
		ndr_print_uint32(ndr, "in_data", r->in.in_data);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_AddOne");
		ndr->depth++;
		ndr_print_ptr(ndr, "out_data", r->out.out_data);
		ndr->depth++;
		ndr_print_uint32(ndr, "out_data", *r->out.out_data);
		ndr->depth--;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_EchoData(struct ndr_push *ndr, int flags, const struct echo_EchoData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->in.in_data, r->in.len));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.out_data, r->in.len));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_EchoData(struct ndr_pull *ndr, int flags, struct echo_EchoData *r)
{
	uint32_t size_in_data_0 = 0;
	uint32_t size_out_data_0 = 0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.len));
		NDR_CHECK(ndr_pull_array_size(ndr, &r->in.in_data));
		size_in_data_0 = ndr_get_array_size(ndr, &r->in.in_data);
		NDR_PULL_ALLOC_N(ndr, r->in.in_data, size_in_data_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->in.in_data, size_in_data_0));
		if (r->in.in_data) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->in.in_data, r->in.len));
		}
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->out.out_data));
		size_out_data_0 = ndr_get_array_size(ndr, &r->out.out_data);
		NDR_PULL_ALLOC_N(ndr, r->out.out_data, size_out_data_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->out.out_data, size_out_data_0));
		if (r->out.out_data) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->out.out_data, r->in.len));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_EchoData(struct ndr_print *ndr, const char *name, int flags, const struct echo_EchoData *r)
{
	ndr_print_struct(ndr, name, "echo_EchoData");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_EchoData");
		ndr->depth++;
		ndr_print_uint32(ndr, "len", r->in.len);
		ndr_print_array_uint8(ndr, "in_data", r->in.in_data, r->in.len);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_EchoData");
		ndr->depth++;
		ndr_print_array_uint8(ndr, "out_data", r->out.out_data, r->in.len);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_SinkData(struct ndr_push *ndr, int flags, const struct echo_SinkData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->in.data, r->in.len));
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_SinkData(struct ndr_pull *ndr, int flags, struct echo_SinkData *r)
{
	uint32_t size_data_0 = 0;
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.len));
		NDR_CHECK(ndr_pull_array_size(ndr, &r->in.data));
		size_data_0 = ndr_get_array_size(ndr, &r->in.data);
		NDR_PULL_ALLOC_N(ndr, r->in.data, size_data_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->in.data, size_data_0));
		if (r->in.data) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->in.data, r->in.len));
		}
	}
	if (flags & NDR_OUT) {
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_SinkData(struct ndr_print *ndr, const char *name, int flags, const struct echo_SinkData *r)
{
	ndr_print_struct(ndr, name, "echo_SinkData");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_SinkData");
		ndr->depth++;
		ndr_print_uint32(ndr, "len", r->in.len);
		ndr_print_array_uint8(ndr, "data", r->in.data, r->in.len);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_SinkData");
		ndr->depth++;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_SourceData(struct ndr_push *ndr, int flags, const struct echo_SourceData *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.len));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.len));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.data, r->in.len));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_SourceData(struct ndr_pull *ndr, int flags, struct echo_SourceData *r)
{
	uint32_t size_data_0 = 0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.len));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_array_size(ndr, &r->out.data));
		size_data_0 = ndr_get_array_size(ndr, &r->out.data);
		NDR_PULL_ALLOC_N(ndr, r->out.data, size_data_0);
		NDR_CHECK(ndr_pull_array_uint8(ndr, NDR_SCALARS, r->out.data, size_data_0));
		if (r->out.data) {
			NDR_CHECK(ndr_check_array_size(ndr, (void*)&r->out.data, r->in.len));
		}
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_SourceData(struct ndr_print *ndr, const char *name, int flags, const struct echo_SourceData *r)
{
	ndr_print_struct(ndr, name, "echo_SourceData");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_SourceData");
		ndr->depth++;
		ndr_print_uint32(ndr, "len", r->in.len);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_SourceData");
		ndr->depth++;
		ndr_print_array_uint8(ndr, "data", r->out.data, r->in.len);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestCall(struct ndr_push *ndr, int flags, const struct echo_TestCall *r)
{
	if (flags & NDR_IN) {
		if (r->in.s1 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->in.s1, CH_UTF16)));
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(r->in.s1, CH_UTF16)));
		NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, r->in.s1, ndr_charset_length(r->in.s1, CH_UTF16), sizeof(uint16_t), CH_UTF16));
	}
	if (flags & NDR_OUT) {
		if (r->out.s2 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_unique_ptr(ndr, *r->out.s2));
		if (*r->out.s2) {
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(*r->out.s2, CH_UTF16)));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, 0));
			NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, ndr_charset_length(*r->out.s2, CH_UTF16)));
			NDR_CHECK(ndr_push_charset(ndr, NDR_SCALARS, *r->out.s2, ndr_charset_length(*r->out.s2, CH_UTF16), sizeof(uint16_t), CH_UTF16));
		}
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestCall(struct ndr_pull *ndr, int flags, struct echo_TestCall *r)
{
	uint32_t size_s1_1 = 0;
	uint32_t length_s1_1 = 0;
	uint32_t _ptr_s2;
	uint32_t size_s2_2 = 0;
	uint32_t length_s2_2 = 0;
	TALLOC_CTX *_mem_save_s2_0;
	TALLOC_CTX *_mem_save_s2_1;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_array_size(ndr, &r->in.s1));
		NDR_CHECK(ndr_pull_array_length(ndr, &r->in.s1));
		size_s1_1 = ndr_get_array_size(ndr, &r->in.s1);
		length_s1_1 = ndr_get_array_length(ndr, &r->in.s1);
		if (length_s1_1 > size_s1_1) {
			return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_s1_1, length_s1_1);
		}
		NDR_CHECK(ndr_check_string_terminator(ndr, length_s1_1, sizeof(uint16_t)));
		NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, &r->in.s1, length_s1_1, sizeof(uint16_t), CH_UTF16));
		NDR_PULL_ALLOC(ndr, r->out.s2);
		ZERO_STRUCTP(r->out.s2);
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.s2);
		}
		_mem_save_s2_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.s2, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_s2));
		if (_ptr_s2) {
			NDR_PULL_ALLOC(ndr, *r->out.s2);
		} else {
			*r->out.s2 = NULL;
		}
		if (*r->out.s2) {
			_mem_save_s2_1 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, *r->out.s2, 0);
			NDR_CHECK(ndr_pull_array_size(ndr, r->out.s2));
			NDR_CHECK(ndr_pull_array_length(ndr, r->out.s2));
			size_s2_2 = ndr_get_array_size(ndr, r->out.s2);
			length_s2_2 = ndr_get_array_length(ndr, r->out.s2);
			if (length_s2_2 > size_s2_2) {
				return ndr_pull_error(ndr, NDR_ERR_ARRAY_SIZE, "Bad array size %u should exceed array length %u", size_s2_2, length_s2_2);
			}
			NDR_CHECK(ndr_check_string_terminator(ndr, length_s2_2, sizeof(uint16_t)));
			NDR_CHECK(ndr_pull_charset(ndr, NDR_SCALARS, r->out.s2, length_s2_2, sizeof(uint16_t), CH_UTF16));
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_s2_1, 0);
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_s2_0, LIBNDR_FLAG_REF_ALLOC);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestCall(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestCall *r)
{
	ndr_print_struct(ndr, name, "echo_TestCall");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestCall");
		ndr->depth++;
		ndr_print_ptr(ndr, "s1", r->in.s1);
		ndr->depth++;
		ndr_print_string(ndr, "s1", r->in.s1);
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestCall");
		ndr->depth++;
		ndr_print_ptr(ndr, "s2", r->out.s2);
		ndr->depth++;
		ndr_print_ptr(ndr, "s2", *r->out.s2);
		ndr->depth++;
		if (*r->out.s2) {
			ndr_print_string(ndr, "s2", *r->out.s2);
		}
		ndr->depth--;
		ndr->depth--;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestCall2(struct ndr_push *ndr, int flags, const struct echo_TestCall2 *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->in.level));
	}
	if (flags & NDR_OUT) {
		if (r->out.info == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_set_switch_value(ndr, r->out.info, r->in.level));
		NDR_CHECK(ndr_push_echo_Info(ndr, NDR_SCALARS, r->out.info));
		NDR_CHECK(ndr_push_NTSTATUS(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestCall2(struct ndr_pull *ndr, int flags, struct echo_TestCall2 *r)
{
	TALLOC_CTX *_mem_save_info_0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->in.level));
		NDR_PULL_ALLOC(ndr, r->out.info);
		ZERO_STRUCTP(r->out.info);
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.info);
		}
		_mem_save_info_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.info, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_set_switch_value(ndr, r->out.info, r->in.level));
		NDR_CHECK(ndr_pull_echo_Info(ndr, NDR_SCALARS, r->out.info));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_info_0, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_NTSTATUS(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestCall2(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestCall2 *r)
{
	ndr_print_struct(ndr, name, "echo_TestCall2");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestCall2");
		ndr->depth++;
		ndr_print_uint16(ndr, "level", r->in.level);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestCall2");
		ndr->depth++;
		ndr_print_ptr(ndr, "info", r->out.info);
		ndr->depth++;
		ndr_print_set_switch_value(ndr, r->out.info, r->in.level);
		ndr_print_echo_Info(ndr, "info", r->out.info);
		ndr->depth--;
		ndr_print_NTSTATUS(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestSleep(struct ndr_push *ndr, int flags, const struct echo_TestSleep *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.seconds));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestSleep(struct ndr_pull *ndr, int flags, struct echo_TestSleep *r)
{
	if (flags & NDR_IN) {
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->in.seconds));
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_uint32(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestSleep(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestSleep *r)
{
	ndr_print_struct(ndr, name, "echo_TestSleep");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestSleep");
		ndr->depth++;
		ndr_print_uint32(ndr, "seconds", r->in.seconds);
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestSleep");
		ndr->depth++;
		ndr_print_uint32(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestEnum(struct ndr_push *ndr, int flags, const struct echo_TestEnum *r)
{
	if (flags & NDR_IN) {
		if (r->in.foo1 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Enum1(ndr, NDR_SCALARS, *r->in.foo1));
		if (r->in.foo2 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Enum2(ndr, NDR_SCALARS, r->in.foo2));
		if (r->in.foo3 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_set_switch_value(ndr, r->in.foo3, *r->in.foo1));
		NDR_CHECK(ndr_push_echo_Enum3(ndr, NDR_SCALARS, r->in.foo3));
	}
	if (flags & NDR_OUT) {
		if (r->out.foo1 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Enum1(ndr, NDR_SCALARS, *r->out.foo1));
		if (r->out.foo2 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Enum2(ndr, NDR_SCALARS, r->out.foo2));
		if (r->out.foo3 == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_set_switch_value(ndr, r->out.foo3, *r->out.foo1));
		NDR_CHECK(ndr_push_echo_Enum3(ndr, NDR_SCALARS, r->out.foo3));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestEnum(struct ndr_pull *ndr, int flags, struct echo_TestEnum *r)
{
	TALLOC_CTX *_mem_save_foo1_0;
	TALLOC_CTX *_mem_save_foo2_0;
	TALLOC_CTX *_mem_save_foo3_0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.foo1);
		}
		_mem_save_foo1_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.foo1, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Enum1(ndr, NDR_SCALARS, r->in.foo1));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo1_0, LIBNDR_FLAG_REF_ALLOC);
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.foo2);
		}
		_mem_save_foo2_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.foo2, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Enum2(ndr, NDR_SCALARS, r->in.foo2));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo2_0, LIBNDR_FLAG_REF_ALLOC);
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.foo3);
		}
		_mem_save_foo3_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.foo3, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_set_switch_value(ndr, r->in.foo3, *r->in.foo1));
		NDR_CHECK(ndr_pull_echo_Enum3(ndr, NDR_SCALARS, r->in.foo3));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo3_0, LIBNDR_FLAG_REF_ALLOC);
		NDR_PULL_ALLOC(ndr, r->out.foo1);
		*r->out.foo1 = *r->in.foo1;
		NDR_PULL_ALLOC(ndr, r->out.foo2);
		*r->out.foo2 = *r->in.foo2;
		NDR_PULL_ALLOC(ndr, r->out.foo3);
		*r->out.foo3 = *r->in.foo3;
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.foo1);
		}
		_mem_save_foo1_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.foo1, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Enum1(ndr, NDR_SCALARS, r->out.foo1));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo1_0, LIBNDR_FLAG_REF_ALLOC);
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.foo2);
		}
		_mem_save_foo2_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.foo2, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Enum2(ndr, NDR_SCALARS, r->out.foo2));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo2_0, LIBNDR_FLAG_REF_ALLOC);
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.foo3);
		}
		_mem_save_foo3_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.foo3, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_set_switch_value(ndr, r->out.foo3, *r->out.foo1));
		NDR_CHECK(ndr_pull_echo_Enum3(ndr, NDR_SCALARS, r->out.foo3));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_foo3_0, LIBNDR_FLAG_REF_ALLOC);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestEnum(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestEnum *r)
{
	ndr_print_struct(ndr, name, "echo_TestEnum");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestEnum");
		ndr->depth++;
		ndr_print_ptr(ndr, "foo1", r->in.foo1);
		ndr->depth++;
		ndr_print_echo_Enum1(ndr, "foo1", *r->in.foo1);
		ndr->depth--;
		ndr_print_ptr(ndr, "foo2", r->in.foo2);
		ndr->depth++;
		ndr_print_echo_Enum2(ndr, "foo2", r->in.foo2);
		ndr->depth--;
		ndr_print_ptr(ndr, "foo3", r->in.foo3);
		ndr->depth++;
		ndr_print_set_switch_value(ndr, r->in.foo3, *r->in.foo1);
		ndr_print_echo_Enum3(ndr, "foo3", r->in.foo3);
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestEnum");
		ndr->depth++;
		ndr_print_ptr(ndr, "foo1", r->out.foo1);
		ndr->depth++;
		ndr_print_echo_Enum1(ndr, "foo1", *r->out.foo1);
		ndr->depth--;
		ndr_print_ptr(ndr, "foo2", r->out.foo2);
		ndr->depth++;
		ndr_print_echo_Enum2(ndr, "foo2", r->out.foo2);
		ndr->depth--;
		ndr_print_ptr(ndr, "foo3", r->out.foo3);
		ndr->depth++;
		ndr_print_set_switch_value(ndr, r->out.foo3, *r->out.foo1);
		ndr_print_echo_Enum3(ndr, "foo3", r->out.foo3);
		ndr->depth--;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestSurrounding(struct ndr_push *ndr, int flags, const struct echo_TestSurrounding *r)
{
	if (flags & NDR_IN) {
		if (r->in.data == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Surrounding(ndr, NDR_SCALARS, r->in.data));
	}
	if (flags & NDR_OUT) {
		if (r->out.data == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_echo_Surrounding(ndr, NDR_SCALARS, r->out.data));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestSurrounding(struct ndr_pull *ndr, int flags, struct echo_TestSurrounding *r)
{
	TALLOC_CTX *_mem_save_data_0;
	if (flags & NDR_IN) {
		ZERO_STRUCT(r->out);

		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.data);
		}
		_mem_save_data_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.data, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Surrounding(ndr, NDR_SCALARS, r->in.data));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_0, LIBNDR_FLAG_REF_ALLOC);
		NDR_PULL_ALLOC(ndr, r->out.data);
		*r->out.data = *r->in.data;
	}
	if (flags & NDR_OUT) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->out.data);
		}
		_mem_save_data_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->out.data, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_echo_Surrounding(ndr, NDR_SCALARS, r->out.data));
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_0, LIBNDR_FLAG_REF_ALLOC);
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestSurrounding(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestSurrounding *r)
{
	ndr_print_struct(ndr, name, "echo_TestSurrounding");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestSurrounding");
		ndr->depth++;
		ndr_print_ptr(ndr, "data", r->in.data);
		ndr->depth++;
		ndr_print_echo_Surrounding(ndr, "data", r->in.data);
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestSurrounding");
		ndr->depth++;
		ndr_print_ptr(ndr, "data", r->out.data);
		ndr->depth++;
		ndr_print_echo_Surrounding(ndr, "data", r->out.data);
		ndr->depth--;
		ndr->depth--;
	}
	ndr->depth--;
}

static enum ndr_err_code ndr_push_echo_TestDoublePointer(struct ndr_push *ndr, int flags, const struct echo_TestDoublePointer *r)
{
	if (flags & NDR_IN) {
		if (r->in.data == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_unique_ptr(ndr, *r->in.data));
		if (*r->in.data) {
			NDR_CHECK(ndr_push_unique_ptr(ndr, **r->in.data));
			if (**r->in.data) {
				NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, ***r->in.data));
			}
		}
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_push_uint16(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

static enum ndr_err_code ndr_pull_echo_TestDoublePointer(struct ndr_pull *ndr, int flags, struct echo_TestDoublePointer *r)
{
	uint32_t _ptr_data;
	TALLOC_CTX *_mem_save_data_0;
	TALLOC_CTX *_mem_save_data_1;
	TALLOC_CTX *_mem_save_data_2;
	if (flags & NDR_IN) {
		if (ndr->flags & LIBNDR_FLAG_REF_ALLOC) {
			NDR_PULL_ALLOC(ndr, r->in.data);
		}
		_mem_save_data_0 = NDR_PULL_GET_MEM_CTX(ndr);
		NDR_PULL_SET_MEM_CTX(ndr, r->in.data, LIBNDR_FLAG_REF_ALLOC);
		NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_data));
		if (_ptr_data) {
			NDR_PULL_ALLOC(ndr, *r->in.data);
		} else {
			*r->in.data = NULL;
		}
		if (*r->in.data) {
			_mem_save_data_1 = NDR_PULL_GET_MEM_CTX(ndr);
			NDR_PULL_SET_MEM_CTX(ndr, *r->in.data, 0);
			NDR_CHECK(ndr_pull_generic_ptr(ndr, &_ptr_data));
			if (_ptr_data) {
				NDR_PULL_ALLOC(ndr, **r->in.data);
			} else {
				**r->in.data = NULL;
			}
			if (**r->in.data) {
				_mem_save_data_2 = NDR_PULL_GET_MEM_CTX(ndr);
				NDR_PULL_SET_MEM_CTX(ndr, **r->in.data, 0);
				NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, **r->in.data));
				NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_2, 0);
			}
			NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_1, 0);
		}
		NDR_PULL_SET_MEM_CTX(ndr, _mem_save_data_0, LIBNDR_FLAG_REF_ALLOC);
	}
	if (flags & NDR_OUT) {
		NDR_CHECK(ndr_pull_uint16(ndr, NDR_SCALARS, &r->out.result));
	}
	return NDR_ERR_SUCCESS;
}

_PUBLIC_ void ndr_print_echo_TestDoublePointer(struct ndr_print *ndr, const char *name, int flags, const struct echo_TestDoublePointer *r)
{
	ndr_print_struct(ndr, name, "echo_TestDoublePointer");
	if (r == NULL) { ndr_print_null(ndr); return; }
	ndr->depth++;
	if (flags & NDR_SET_VALUES) {
		ndr->flags |= LIBNDR_PRINT_SET_VALUES;
	}
	if (flags & NDR_IN) {
		ndr_print_struct(ndr, "in", "echo_TestDoublePointer");
		ndr->depth++;
		ndr_print_ptr(ndr, "data", r->in.data);
		ndr->depth++;
		ndr_print_ptr(ndr, "data", *r->in.data);
		ndr->depth++;
		if (*r->in.data) {
			ndr_print_ptr(ndr, "data", **r->in.data);
			ndr->depth++;
			if (**r->in.data) {
				ndr_print_uint16(ndr, "data", ***r->in.data);
			}
			ndr->depth--;
		}
		ndr->depth--;
		ndr->depth--;
		ndr->depth--;
	}
	if (flags & NDR_OUT) {
		ndr_print_struct(ndr, "out", "echo_TestDoublePointer");
		ndr->depth++;
		ndr_print_uint16(ndr, "result", r->out.result);
		ndr->depth--;
	}
	ndr->depth--;
}

static const struct ndr_interface_call rpcecho_calls[] = {
	{
		"echo_AddOne",
		sizeof(struct echo_AddOne),
		(ndr_push_flags_fn_t) ndr_push_echo_AddOne,
		(ndr_pull_flags_fn_t) ndr_pull_echo_AddOne,
		(ndr_print_function_t) ndr_print_echo_AddOne,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_EchoData",
		sizeof(struct echo_EchoData),
		(ndr_push_flags_fn_t) ndr_push_echo_EchoData,
		(ndr_pull_flags_fn_t) ndr_pull_echo_EchoData,
		(ndr_print_function_t) ndr_print_echo_EchoData,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_SinkData",
		sizeof(struct echo_SinkData),
		(ndr_push_flags_fn_t) ndr_push_echo_SinkData,
		(ndr_pull_flags_fn_t) ndr_pull_echo_SinkData,
		(ndr_print_function_t) ndr_print_echo_SinkData,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_SourceData",
		sizeof(struct echo_SourceData),
		(ndr_push_flags_fn_t) ndr_push_echo_SourceData,
		(ndr_pull_flags_fn_t) ndr_pull_echo_SourceData,
		(ndr_print_function_t) ndr_print_echo_SourceData,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestCall",
		sizeof(struct echo_TestCall),
		(ndr_push_flags_fn_t) ndr_push_echo_TestCall,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestCall,
		(ndr_print_function_t) ndr_print_echo_TestCall,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestCall2",
		sizeof(struct echo_TestCall2),
		(ndr_push_flags_fn_t) ndr_push_echo_TestCall2,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestCall2,
		(ndr_print_function_t) ndr_print_echo_TestCall2,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestSleep",
		sizeof(struct echo_TestSleep),
		(ndr_push_flags_fn_t) ndr_push_echo_TestSleep,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestSleep,
		(ndr_print_function_t) ndr_print_echo_TestSleep,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestEnum",
		sizeof(struct echo_TestEnum),
		(ndr_push_flags_fn_t) ndr_push_echo_TestEnum,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestEnum,
		(ndr_print_function_t) ndr_print_echo_TestEnum,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestSurrounding",
		sizeof(struct echo_TestSurrounding),
		(ndr_push_flags_fn_t) ndr_push_echo_TestSurrounding,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestSurrounding,
		(ndr_print_function_t) ndr_print_echo_TestSurrounding,
		{ 0, NULL },
		{ 0, NULL },
	},
	{
		"echo_TestDoublePointer",
		sizeof(struct echo_TestDoublePointer),
		(ndr_push_flags_fn_t) ndr_push_echo_TestDoublePointer,
		(ndr_pull_flags_fn_t) ndr_pull_echo_TestDoublePointer,
		(ndr_print_function_t) ndr_print_echo_TestDoublePointer,
		{ 0, NULL },
		{ 0, NULL },
	},
	{ NULL, 0, NULL, NULL, NULL }
};

static const char * const rpcecho_endpoint_strings[] = {
	"ncacn_np:[\\pipe\\rpcecho]", 
	"ncacn_ip_tcp:", 
	"ncalrpc:", 
};

static const struct ndr_interface_string_array rpcecho_endpoints = {
	.count	= 3,
	.names	= rpcecho_endpoint_strings
};

static const char * const rpcecho_authservice_strings[] = {
	"host", 
};

static const struct ndr_interface_string_array rpcecho_authservices = {
	.count	= 1,
	.names	= rpcecho_authservice_strings
};


const struct ndr_interface_table ndr_table_rpcecho = {
	.name		= "rpcecho",
	.syntax_id	= {
		{0x60a15ec5,0x4de8,0x11d7,{0xa6,0x37},{0x00,0x50,0x56,0xa2,0x01,0x82}},
		NDR_RPCECHO_VERSION
	},
	.helpstring	= NDR_RPCECHO_HELPSTRING,
	.num_calls	= 10,
	.calls		= rpcecho_calls,
	.endpoints	= &rpcecho_endpoints,
	.authservices	= &rpcecho_authservices
};

