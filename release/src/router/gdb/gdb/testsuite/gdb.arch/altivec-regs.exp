# Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu
#

# Tests for Powerpc AltiVec register setting and fetching

if $tracelevel then {
    strace $tracelevel
}

#
# Test the use of registers, especially AltiVec registers, for Powerpc.
# This file uses altivec-regs.c for input.
#

set prms_id 0
set bug_id 0

if {![istarget "powerpc*"] || [skip_altivec_tests]} then {
    verbose "Skipping altivec register tests."
    verbose -log "Skipping altivec register tests."
    return
}

set testfile "altivec-regs"
set binfile ${objdir}/${subdir}/${testfile}
set srcfile ${testfile}.c

set compile_flags {debug nowarnings}
if [get_compiler_info $binfile] {
    warning "get_compiler failed"
    return -1
}

if [test_compiler_info gcc*] {
    set compile_flags "$compile_flags additional_flags=-maltivec"
} elseif [test_compiler_info xlc*] {
    set compile_flags "$compile_flags additional_flags=-qaltivec"
} else {
    warning "unknown compiler"
    return -1
}

if  { [gdb_compile ${srcdir}/${subdir}/${srcfile} ${binfile} executable $compile_flags] != "" } {
     untested altivec-regs.exp
     return -1
}

gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load ${binfile}

#
# Run to `main' where we begin our tests.
#

if ![runto_main] then {
    gdb_suppress_tests
}

# set all the registers integer portions to 1
for {set i 0} {$i < 32} {incr i 1} {
        for {set j 0} {$j < 4} {incr j 1} {
           gdb_test "set \$vr$i.v4_int32\[$j\] = 1" "" "set reg vr$i.v4si.f\[$j\]"
        }
}

gdb_test "set \$vscr = 1" "" ""
gdb_test "set \$vrsave = 1" "" ""

# Now execute some target code, so that GDB's register cache is flushed.

gdb_test "next" "" ""

send_gdb "show endian\n"
set endianness ""
gdb_expect {
    -re "(The target endianness is set automatically .currently )(big|little)( endian.*)$gdb_prompt $" {
        pass "endianness"
	set endianness $expect_out(2,string)
    }
    -re ".*$gdb_prompt $" {
	fail "couldn't get endianness"
    }
    timeout		{ fail "(timeout) endianness" }
}

# And then read the AltiVec registers back, to see that
# a) the register write above worked, and
# b) the register read (below) also works.

if {$endianness == "big"} {
set vector_register ".uint128 = 0x00000001000000010000000100000001, v4_float = .0x0, 0x0, 0x0, 0x0., v4_int32 = .0x1, 0x1, 0x1, 0x1., v8_int16 = .0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1., v16_int8 = .0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1.."
} else {
set vector_register ".uint128 = 0x00000001000000010000000100000001, v4_float = .0x0, 0x0, 0x0, 0x0., v4_int32 = .0x1, 0x1, 0x1, 0x1., v8_int16 = .0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0., v16_int8 = .0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0.."
}

for {set i 0} {$i < 32} {incr i 1} {
        gdb_test "info reg vr$i" "vr$i.*$vector_register" "info reg vr$i"
}

gdb_test "info reg vrsave" "vrsave.*0x1\t1" "info reg vrsave"
gdb_test "info reg vscr" "vscr.*0x1\t1" "info reg vscr"

# Now redo the same tests, but using the print command.
# Note: in LE case, the char array is printed WITHOUT the last character.
# Gdb treats the terminating null char in the array like the terminating
# null char in a string and doesn't print it. This is not a failure, but
# the way gdb works.

if {$endianness == "big"} {
     set decimal_vector ".uint128 = 0x00000001000000010000000100000001, v4_float = .1.*e-45, 1.*e-45, 1.*e-45, 1.*e-45., v4_int32 = .1, 1, 1, 1., v8_int16 = .0, 1, 0, 1, 0, 1, 0, 1., v16_int8 = .0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001'.."
} else {
     set decimal_vector ".uint128 = 0x00000001000000010000000100000001, v4_float = .1.*e-45, 1.*e-45, 1.*e-45, 1.*e-45., v4_int32 = .1, 1, 1, 1., v8_int16 = .1, 0, 1, 0, 1, 0, 1, 0., v16_int8 = .1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0', 0 '.0', 1 '.001', 0 '.0', 0 '.0'.."
}

for {set i 0} {$i < 32} {incr i 1} {
        gdb_test "print \$vr$i" ".* = $decimal_vector" "print vr$i"
}

gdb_test "print \$vrsave" ".* = 1" "print vrsave"
gdb_test "print \$vscr" ".* = 1" "print vscr"

for {set i 0} {$i < 32} {incr i 1} {
         set pattern$i ".*vr$i.*"
         append pattern$i $vector_register
}

send_gdb "info vector\n"
gdb_expect_list "info vector" ".*$gdb_prompt $" {
[$pattern0]
[$pattern1]
[$pattern2]
[$pattern3]
[$pattern4]
[$pattern5]
[$pattern6]
[$pattern7]
[$pattern8]
[$pattern9]
[$pattern10]
[$pattern11]
[$pattern12]
[$pattern13]
[$pattern14]
[$pattern15]
[$pattern16]
[$pattern17]
[$pattern18]
[$pattern19]
[$pattern20]
[$pattern21]
[$pattern22]
[$pattern23]
[$pattern24]
[$pattern25]
[$pattern26]
[$pattern27]
[$pattern28]
[$pattern29]
[$pattern30]
[$pattern31]
"\[ \t\n\r\]+vscr\[ \t\]+0x1"
"\[ \t\n\r\]+vrsave\[ \t\]+0x1"
}

gdb_test "break vector_fun" \
 "Breakpoint 2 at.*altivec-regs.c, line \[0-9\]+\\." \
 "Set breakpoint at vector_fun"

# Actually it is nuch easier to see these results printed in hex.
gdb_test "set output-radix 16" \
  "Output radix now set to decimal 16, hex 10, octal 20." \
  "Set output radix to hex"

gdb_test "continue" \
  "Breakpoint 2, vector_fun .a=.0xfefefefe, 0xfefefefe, 0xfefefefe, 0xfefefefe., b=.0x1010101, 0x1010101, 0x1010101, 0x1010101.*altivec-regs.c.*vec_splat_u8.2..;" \
  "continue to vector_fun"

# Do a next over the assignment to vector 'a'. 
gdb_test "next" ".*b = \\(\\(vector unsigned int\\) vec_splat_u8\\(3\\)\\);" \
  "next (1)"

# Do a next over the assignment to vector 'b'. 
gdb_test "next" "c = vec_add \\(a, b\\);" \
  "next (2)"

# Now 'a' should be '0x02020202...' and 'b' should be '0x03030303...'
gdb_test "print/x a" \
  ".*= .0x2020202, 0x2020202, 0x2020202, 0x2020202." \
  "print vector parameter a"

gdb_test "print/x b" \
  ".*= .0x3030303, 0x3030303, 0x3030303, 0x3030303." \
  "print vector parameter b"

# If we do an 'up' now, and print 'x' and 'y' we should see the values they
# have in main, not the values they have in vector_fun.
gdb_test "up" ".1.*main \\(\\) at.*altivec-regs.c.*z = vector_fun \\(x, y\\);" \
  "up to main"

gdb_test "print/x x" \
  ".*= .0xfefefefe, 0xfefefefe, 0xfefefefe, 0xfefefefe." \
  "print vector x"

gdb_test "print/x y" \
  ".*= .0x1010101, 0x1010101, 0x1010101, 0x1010101." \
  "print vector y"

# now go back to vector_func and do a finish, to see if we can print the return
# value correctly.

gdb_test "down" \
  ".0  vector_fun \\(a=.0x2020202, 0x2020202, 0x2020202, 0x2020202., b=.0x3030303, 0x3030303, 0x3030303, 0x3030303.\\) at.*altivec-regs.c.*c = vec_add \\(a, b\\);" \
  "down to vector_fun"

gdb_test "finish" \
  "Run till exit from .0  vector_fun \\(a=.0x2020202, 0x2020202, 0x2020202, 0x2020202., b=.0x3030303, 0x3030303, 0x3030303, 0x3030303.\\) at.*altivec-regs.c.*in main \\(\\) at.*altivec-regs.c.*z = vector_fun \\(x, y\\);.*Value returned is.*= .0x5050505, 0x5050505, 0x5050505, 0x5050505." \
  "finish returned correct value"



