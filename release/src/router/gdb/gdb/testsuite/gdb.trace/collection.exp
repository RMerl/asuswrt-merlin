# Copyright 1998, 2005, 2007 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Please email any bugs, comments, and/or additions to this file to:
# bug-gdb@prep.ai.mit.edu

if [istarget "m68k-*-elf"] then {
    pass "Test not supported on this target"
    return;
}

load_lib "trace-support.exp"

if $tracelevel then {
	strace $tracelevel
}

set prms_id 0
set bug_id 0

set testfile "collection"
set srcfile ${testfile}.c
set binfile $objdir/$subdir/$testfile

if { [gdb_compile "$srcdir/$subdir/$srcfile" $binfile \
	executable {debug nowarnings}] != "" } {
    untested collection.exp
    return -1
}

# Tests: 
# 1) $args
# 2) function args by name
# 3) $locs
# 4) function locals by name
# 5) $regs
# 6) registers by name ($sp, $fp?)
# 7) globals by name
# 8) expressions (lots of different kinds: local and global)

set ws "\[\r\n\t \]+"
set cr "\[\r\n\]+"

#
# Utility procs
#

proc test_register { reg test_id } {
    global cr
    global gdb_prompt

    send_gdb "print $reg\n"
    gdb_expect {
	-re "\\$\[0-9\]+ = \[x0\]+$cr$gdb_prompt " {
	    fail "collect $test_id: collected $reg (zero)"
	}
	-re "\\$\[0-9\]+ = \[x0-9a-fA-F\]+$cr$gdb_prompt " {
	    pass "collect $test_id: collected $reg"
	}
	-re "\[Ee\]rror.*$gdb_prompt " {
	    fail "collect $test_id: collected $reg (error)"
	}
	timeout {
	    fail "collect $test_id: collected $reg (timeout)"
	}
    }
}

proc run_trace_experiment { msg test_func } {
    global gdb_prompt
    gdb_run_cmd
    gdb_expect {
	-re ".*Breakpoint \[0-9\]+, begin .*$gdb_prompt $" { 
	}
	-re ".*$gdb_prompt $" { 
	    fail "collect $msg: advance to go"
	}
	timeout { 
	    fail "collect $msg: advance to go (timeout)"
	}
    }
    gdb_test "tstart" \
	    "\[\r\n\]+" \
	    "collect $msg: start trace experiment"
    gdb_test "continue" \
	    "Continuing.*Breakpoint \[0-9\]+, end.*" \
	    "collect $msg: run trace experiment"
    gdb_test "tstop" \
	    "\[\r\n\]+" \
	    "collect $msg: stop trace experiment"
    gdb_test "tfind start" \
	    "#0  $test_func .*" \
	    "collect $msg: tfind test frame"
}


#
# Test procs
#

proc gdb_collect_args_test { myargs msg } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    gdb_test "trace args_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $msg: set tracepoint"
    gdb_trace_setactions "collect $msg: define actions" \
	    "" \
	    "collect $myargs" "^$"

    # Begin the test.
    run_trace_experiment $msg args_test_func

    gdb_test "print argc" \
	    "\\$\[0-9\]+ = 1 '.001'$cr" \
	    "collect $msg: collected arg char"
    gdb_test "print argi" \
	    "\\$\[0-9\]+ = 2$cr" \
	    "collect $msg: collected arg int"
    gdb_test "print argf" \
	    "\\$\[0-9\]+ = 3.\[23\]\[0-9\]*$cr" \
	    "collect $msg: collected arg float"
    gdb_test "print argd" \
	    "\\$\[0-9\]+ = 4.\[34\]\[0-9\]*$cr" \
	    "collect $msg: collected arg double"

    # struct arg as one of several args (near end of list)
    gdb_test "print argstruct.memberc" \
	    "\\$\[0-9\]+ = 101 'e'$cr" \
	    "collect $msg: collected arg struct member char"
    gdb_test "print argstruct.memberi" \
	    "\\$\[0-9\]+ = 102$cr" \
	    "collect $msg: collected arg struct member int"
    gdb_test "print argstruct.memberf" \
	    "\\$\[0-9\]+ = 103.\[23\]\[0-9\]*$cr" \
	    "collect $msg: collected arg struct member float"
    gdb_test "print argstruct.memberd" \
	    "\\$\[0-9\]+ = 104.\[34\]\[0-9\]*$cr" \
	    "collect $msg: collected arg struct member double"

    # array arg as one of several args (near end of list)
    gdb_test "print argarray\[0\]" \
	    "\\$\[0-9\]+ = 111$cr" \
	    "collect $msg: collected argarray #0"
    gdb_test "print argarray\[1\]" \
	    "\\$\[0-9\]+ = 112$cr" \
	    "collect $msg: collected argarray #1"
    gdb_test "print argarray\[2\]" \
	    "\\$\[0-9\]+ = 113$cr" \
	    "collect $msg: collected argarray #2"
    gdb_test "print argarray\[3\]" \
	    "\\$\[0-9\]+ = 114$cr" \
	    "collect $msg: collected argarray #3"

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $msg: cease trace debugging"
}

proc gdb_collect_argstruct_test { myargs msg } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    gdb_test "trace argstruct_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $msg: set tracepoint"
    gdb_trace_setactions "collect $msg: define actions" \
	    "" \
	    "collect $myargs" "^$"

    # Begin the test.
    run_trace_experiment $msg argstruct_test_func

    # struct argument as only argument
    gdb_test "print argstruct.memberc" \
	    "\\$\[0-9\]+ = 101 'e'$cr" \
	    "collect $msg: collected arg struct member char"
    gdb_test "print argstruct.memberi" \
	    "\\$\[0-9\]+ = 102$cr" \
	    "collect $msg: collected arg struct member int"
    gdb_test "print argstruct.memberf" \
	    "\\$\[0-9\]+ = 103.\[23\]\[0-9\]*$cr" \
	    "collect $msg: collected arg struct member float"
    gdb_test "print argstruct.memberd" \
	    "\\$\[0-9\]+ = 104.\[34\]\[0-9\]*$cr" \
	    "collect $msg: collected arg struct member double"

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $msg: cease trace debugging"
}


proc gdb_collect_argarray_test { myargs msg } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    gdb_test "trace argarray_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $msg: set tracepoint"
    gdb_trace_setactions "collect $msg: define actions" \
	    "" \
	    "collect $myargs" "^$"

    # Begin the test.
    run_trace_experiment $msg argarray_test_func

    # array arg as only argument
    gdb_test "print argarray\[0\]" \
	    "\\$\[0-9\]+ = 111$cr" \
	    "collect $msg: collected argarray #0"
    gdb_test "print argarray\[1\]" \
	    "\\$\[0-9\]+ = 112$cr" \
	    "collect $msg: collected argarray #1"
    gdb_test "print argarray\[2\]" \
	    "\\$\[0-9\]+ = 113$cr" \
	    "collect $msg: collected argarray #2"
    gdb_test "print argarray\[3\]" \
	    "\\$\[0-9\]+ = 114$cr" \
	    "collect $msg: collected argarray #3"

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $msg: cease trace debugging"
}


proc gdb_collect_locals_test { func mylocs msg } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    # Find the comment-identified line for setting this tracepoint.
    set testline 0
    send_gdb "list $func, +30\n"
    gdb_expect {
	-re "\[\r\n\](\[0-9\]+)\[^\r\n\]+ Set_Tracepoint_Here .*$gdb_prompt" {
	    set testline $expect_out(1,string)
	    pass "collect $msg: find tracepoint line"
	}
	-re ".*$gdb_prompt " {
	    fail "collect $msg: find tracepoint line (skipping locals test)"
	    return
	}
	timeout {
	    fail "collect $msg: find tracepoint line (skipping locals test)"
	    return
	}
    }

    gdb_test "trace $testline" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $msg: set tracepoint"
    gdb_trace_setactions "collect $msg: define actions" \
	    "" \
	    "collect $mylocs" "^$"

    # Begin the test.
    run_trace_experiment $msg $func

    gdb_test "print locc" \
	"\\$\[0-9\]+ = 11 '.\[a-z0-7\]+'$cr" \
	    "collect $msg: collected local char"
    gdb_test "print loci" \
	    "\\$\[0-9\]+ = 12$cr" \
	    "collect $msg: collected local int"
    gdb_test "print locf" \
	    "\\$\[0-9\]+ = 13.\[23\]\[0-9\]*$cr" \
	    "collect $msg: collected local float"
    gdb_test "print locd" \
	    "\\$\[0-9\]+ = 14.\[34\]\[0-9\]*$cr" \
	    "collect $msg: collected local double"

    gdb_test "print locst.memberc" \
	    "\\$\[0-9\]+ = 15 '.017'$cr" \
	    "collect $msg: collected local member char"
    gdb_test "print locst.memberi" \
	    "\\$\[0-9\]+ = 16$cr" \
	    "collect $msg: collected local member int"
    gdb_test "print locst.memberf" \
	    "\\$\[0-9\]+ = 17.\[67\]\[0-9\]*$cr" \
	    "collect $msg: collected local member float"
    gdb_test "print locst.memberd" \
	    "\\$\[0-9\]+ = 18.\[78\]\[0-9\]*$cr" \
	    "collect $msg: collected local member double"

    gdb_test "print locar\[0\]" \
	    "\\$\[0-9\]+ = 121$cr" \
	    "collect $msg: collected locarray #0"
    gdb_test "print locar\[1\]" \
	    "\\$\[0-9\]+ = 122$cr" \
	    "collect $msg: collected locarray #1"
    gdb_test "print locar\[2\]" \
	    "\\$\[0-9\]+ = 123$cr" \
	    "collect $msg: collected locarray #2"
    gdb_test "print locar\[3\]" \
	    "\\$\[0-9\]+ = 124$cr" \
	    "collect $msg: collected locarray #3"
	    

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $msg: cease trace debugging"
}

proc gdb_collect_registers_test { myregs } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    # We'll simply re-use the args_test_function for this test
    gdb_test "trace args_test_func" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $myregs: set tracepoint"
    gdb_trace_setactions "collect $myregs: define actions" \
	    "" \
	    "collect $myregs" "^$"

    # Begin the test.
    run_trace_experiment $myregs args_test_func

    test_register "\$fp" $myregs
    test_register "\$sp" $myregs
    test_register "\$pc" $myregs

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $myregs: cease trace debugging"
}

proc gdb_collect_expression_test { func expr val msg } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    # Find the comment-identified line for setting this tracepoint.
    set testline 0
    send_gdb "list $func, +30\n"
    gdb_expect {
	-re "\[\r\n\](\[0-9\]+)\[^\r\n\]+ Set_Tracepoint_Here .*$gdb_prompt" {
	    set testline $expect_out(1,string)
	    pass "collect $msg: find tracepoint line"
	}
	-re ".*$gdb_prompt " {
	    fail "collect $msg: find tracepoint line (skipping locals test)"
	    return
	}
	timeout {
	    fail "collect $msg: find tracepoint line (skipping locals test)"
	    return
	}
    }

    gdb_test "trace $testline" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect $msg: set tracepoint"
    gdb_trace_setactions "collect $msg: define actions" \
	    "" \
	    "collect $expr" "^$"

    # Begin the test.
    run_trace_experiment $msg $func

    gdb_test "print $expr" \
	    "\\$\[0-9\]+ = $val$cr" \
	    "collect $msg: got expected value '$val'"

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect $msg: cease trace debugging"
}

proc gdb_collect_globals_test { } {
    global cr
    global gdb_prompt

    # Make sure we're in a sane starting state.
    gdb_test "tstop" "" ""
    gdb_test "tfind none" "" ""
    gdb_delete_tracepoints

    # Find the comment-identified line for setting this tracepoint.
    set testline 0
    send_gdb "list globals_test_func, +30\n"
    gdb_expect {
	-re "\[\r\n\](\[0-9\]+)\[^\r\n\]+ Set_Tracepoint_Here .*$gdb_prompt" {
	    set testline $expect_out(1,string)
	    pass "collect globals: find tracepoint line"
	}
	-re ".*$gdb_prompt " {
	    fail "collect globals: find tracepoint line (skipping global test)"
	    return
	}
	timeout {
	    fail "collect globals: find tracepoint line (skipping global test)"
	    return
	}
    }

    gdb_test "trace $testline" \
	    "Tracepoint \[0-9\]+ at .*" \
	    "collect globals: set tracepoint"
    gdb_trace_setactions "collect globals: define actions" \
	    "" \
	    "collect globalc, globali, globalf, globald" "^$" \
	    "collect globalstruct, globalp, globalarr" "^$"

    # Begin the test.
    run_trace_experiment "globals" globals_test_func

    gdb_test "print globalc" \
	    "\\$\[0-9\]+ = 71 'G'$cr" \
	    "collect globals: collected global char"
    gdb_test "print globali" \
	    "\\$\[0-9\]+ = 72$cr" \
	    "collect globals: collected global int"
    gdb_test "print globalf" \
	    "\\$\[0-9\]+ = 73.\[23\]\[0-9\]*$cr" \
	    "collect globals: collected global float"
    gdb_test "print globald" \
	    "\\$\[0-9\]+ = 74.\[34\]\[0-9\]*$cr" \
	    "collect globals: collected global double"

    gdb_test "print globalstruct.memberc" \
	    "\\$\[0-9\]+ = 81 'Q'$cr" \
	    "collect globals: collected struct char member"
    gdb_test "print globalstruct.memberi" \
	    "\\$\[0-9\]+ = 82$cr" \
	    "collect globals: collected struct member int"
    gdb_test "print globalstruct.memberf" \
	    "\\$\[0-9\]+ = 83.\[23\]\[0-9\]*$cr" \
	    "collect globals: collected struct member float"
    gdb_test "print globalstruct.memberd" \
	    "\\$\[0-9\]+ = 84.\[34\]\[0-9\]*$cr" \
	    "collect globals: collected struct member double"

    gdb_test "print globalp == &globalstruct" \
	    "\\$\[0-9\]+ = 1$cr" \
	    "collect globals: collected global pointer"

    gdb_test "print globalarr\[1\]" \
	    "\\$\[0-9\]+ = 1$cr" \
	    "collect globals: collected global array element #1"
    gdb_test "print globalarr\[2\]" \
	    "\\$\[0-9\]+ = 2$cr" \
	    "collect globals: collected global array element #2"
    gdb_test "print globalarr\[3\]" \
	    "\\$\[0-9\]+ = 3$cr" \
	    "collect globals: collected global array element #3"

    gdb_test "tfind none" \
	    "#0  end .*" \
	    "collect globals: cease trace debugging"
}

proc gdb_trace_collection_test { } {
    global gdb_prompt;

    gdb_test "set width 0" "" ""
    delete_breakpoints

    # We generously give ourselves one "pass" if we successfully 
    # detect that this test cannot be run on this target!
    if { ![gdb_target_supports_trace] } then { 
	pass "Current target does not supporst trace"
	return 1;
    }

    gdb_test "break begin" "" ""
    gdb_test "break end"   "" ""
    gdb_collect_args_test "\$args" \
	    "args collectively"
    gdb_collect_args_test "argc, argi, argf, argd, argstruct, argarray" \
	    "args individually"
    gdb_collect_argstruct_test "\$args" \
	    "argstruct collectively"
    gdb_collect_argstruct_test "argstruct" \
	    "argstruct individually"
    gdb_collect_argarray_test "\$args" \
	    "argarray collectively"
    gdb_collect_argarray_test "argarray" \
	    "argarray individually"
    gdb_collect_locals_test local_test_func "\$locals" \
	    "auto locals collectively"
    gdb_collect_locals_test local_test_func \
	    "locc, loci, locf, locd, locst, locar" \
	    "auto locals individually"
    gdb_collect_locals_test reglocal_test_func "\$locals" \
	    "register locals collectively"
    gdb_collect_locals_test reglocal_test_func \
	    "locc, loci, locf, locd, locst, locar" \
	    "register locals individually"
    gdb_collect_locals_test statlocal_test_func "\$locals" \
	    "static locals collectively"
    gdb_collect_locals_test statlocal_test_func \
	    "locc, loci, locf, locd, locst, locar" \
	    "static locals individually"
    
    gdb_collect_registers_test "\$regs"
    gdb_collect_registers_test "\$fp, \$sp, \$pc"
    gdb_collect_globals_test
    
    #
    # Expression tests:
    #
    # *x	(**x, ...)
    # x.y	(x.y.z, ...)
    # x->y	(x->y->z, ...)
    # x[2]	(x[2][3], ...) (const index)
    # x[y]	(x[y][z], ...) (index to be char, short, long, float, double)
    #  NOTE:
    #  We test the following operators by using them in an array index
    #  expression -- because the naked result of an operator is not really
    #  collected.  To be sure the operator was evaluated correctly on the
    #  target, we have to actually use the result eg. in an array offset
    #  calculation.
    # x[y +  z] (tests addition: y and z various combos of types, sclasses)
    # x[y -  z] (tests subtraction) (ditto)
    # x[y *  z] (tests multiplication) (ditto)
    # x[y /  z] (tests division) (ditto)
    # x[y %  z] (tests modulo division) (ditto)
    # x[y == z] (tests equality relation) (ditto)              UNSUPPORTED
    # x[y != z] (tests inequality relation) (ditto)            UNSUPPORTED
    # x[y >  z] (tests greater-than relation) (ditto)          UNSUPPORTED
    # x[y <  z] (tests less-than relation) (ditto)             UNSUPPORTED
    # x[y >= z] (tests greater-than-or-equal relation) (ditto) UNSUPPORTED
    # x[y <= z] (tests less-than-or-equal relation) (ditto)    UNSUPPORTED
    # x[y && z] (tests logical and) (ditto)                    UNSUPPORTED
    # x[y || z] (tests logical or) (ditto)                     UNSUPPORTED
    # x[y &  z] (tests binary and) (ditto)                     UNSUPPORTED
    # x[y |  z] (tests binary or) (ditto)                      UNSUPPORTED
    # x[y ^  z] (tests binary xor) (ditto)                     UNSUPPORTED
    # x[y ? z1 : z2] (tests ternary operator) (ditto)          UNSUPPORTED
    # x[y << z] (tests shift-left) (ditto)                     UNSUPPORTED
    # x[y >> z] (tests shift-right) (ditto)                    UNSUPPORTED
    # x[y =  z] (tests assignment operator) (ditto)            UNSUPPORTED
    # x[++y]    (tests pre-increment operator) (ditto)         UNSUPPORTED
    # x[--y]    (tests pre-decrement operator) (ditto)         UNSUPPORTED
    # x[y++]    (tests post-increment operator) (ditto)        UNSUPPORTED
    # x[y--]    (tests post-decrement operator) (ditto)        UNSUPPORTED
    # x[+y]     (tests unary plus) (ditto)
    # x[-y]     (tests unary minus) (ditto)
    # x[!y]     (tests logical not) (ditto)                    UNSUPPORTED
    # x[~y]     (tests binary not) (ditto)                     UNSUPPORTED
    # x[(y, z)] (tests comma expression) (ditto)
    # cast expr
    # stack data
    
    gdb_collect_expression_test globals_test_func \
	    "globalstruct.memberi"  "82"     "a.b"
    gdb_collect_expression_test globals_test_func \
	    "globalp->memberc"      "81 'Q'" "a->b"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[2\]"        "2"      "a\[2\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l3\]"       "3"      "a\[b\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l3 + l2\]"  "5"      "a\[b + c\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l3 - l2\]"  "1"      "a\[b - c\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l3 * l2\]"  "6"      "a\[b * c\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l6 / l3\]"  "2"      "a\[b / c\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[l7 % l3\]"  "1"      "a\[b % c\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[+l1\]"      "1"      "a\[+b\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[-lminus\]"  "2"      "a\[-b\]"
    gdb_collect_expression_test globals_test_func \
	    "globalarr\[\(l6, l7\)\]" "7"    "a\[\(b, c\)\]"

}

# Start with a fresh gdb.
 
gdb_exit
gdb_start
gdb_reinitialize_dir $srcdir/$subdir
gdb_load $binfile
 
if [target_info exists gdb_stub] {
    gdb_step_for_stub;
}
 
# Body of test encased in a proc so we can return prematurely.
gdb_trace_collection_test

# Finished!
gdb_test "tfind none" "" ""



