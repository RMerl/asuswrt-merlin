#
# For a description of the syntax of this configuration file,
# see Documentation/kbuild/kconfig-language.txt.
#
# Note: ISA is disabled and will hopefully never be enabled.
# If you managed to buy an ISA x86-64 box you'll have to fix all the
# ISA drivers you need yourself.
#

mainmenu "Linux Kernel Configuration"

config X86_64
	bool
	default y
	help
	  Port to the x86-64 architecture. x86-64 is a 64-bit extension to the
	  classical 32-bit x86 architecture. For details see
	  <http://www.x86-64.org/>.

config 64BIT
	def_bool y

config X86
	bool
	default y

config GENERIC_TIME
	bool
	default y

config GENERIC_TIME_VSYSCALL
	bool
	default y

config ZONE_DMA32
	bool
	default y

config LOCKDEP_SUPPORT
	bool
	default y

config STACKTRACE_SUPPORT
	bool
	default y

config SEMAPHORE_SLEEPERS
	bool
	default y

config MMU
	bool
	default y

config ZONE_DMA
	bool
	default y

config ISA
	bool

config SBUS
	bool

config RWSEM_GENERIC_SPINLOCK
	bool
	default y

config RWSEM_XCHGADD_ALGORITHM
	bool

config GENERIC_HWEIGHT
	bool
	default y

config GENERIC_CALIBRATE_DELAY
	bool
	default y

config X86_CMPXCHG
	bool
	default y

config EARLY_PRINTK
	bool
	default y

config GENERIC_ISA_DMA
	bool
	default y

config GENERIC_IOMAP
	bool
	default y

config ARCH_MAY_HAVE_PC_FDC
	bool
	default y

config ARCH_POPULATES_NODE_MAP
	def_bool y

config DMI
	bool
	default y

config AUDIT_ARCH
	bool
	default y

config GENERIC_BUG
	bool
	default y
	depends on BUG

config ARCH_HAS_ILOG2_U32
	bool
	default n

config ARCH_HAS_ILOG2_U64
	bool
	default n

source "init/Kconfig"


menu "Processor type and features"

choice
	prompt "Subarchitecture Type"
	default X86_PC

config X86_PC
	bool "PC-compatible"
	help
	  Choose this option if your computer is a standard PC or compatible.

config X86_VSMP
	bool "Support for ScaleMP vSMP"
	depends on PCI
	 help
	  Support for ScaleMP vSMP systems.  Say 'Y' here if this kernel is
	  supposed to run on these EM64T-based machines.  Only choose this option
	  if you have one of these machines.

endchoice

choice
	prompt "Processor family"
	default GENERIC_CPU

config MK8
	bool "AMD-Opteron/Athlon64"
	help
	  Optimize for AMD Opteron/Athlon64/Hammer/K8 CPUs.

config MPSC
       bool "Intel P4 / older Netburst based Xeon"
       help
	  Optimize for Intel Pentium 4 and older Nocona/Dempsey Xeon CPUs
	  with Intel Extended Memory 64 Technology(EM64T). For details see
	  <http://www.intel.com/technology/64bitextensions/>.
	  Note that the latest Xeons (Xeon 51xx and 53xx) are not based on the
          Netburst core and shouldn't use this option. You can distinguish them
	  using the cpu family field
	  in /proc/cpuinfo. Family 15 is an older Xeon, Family 6 a newer one
	  (this rule only applies to systems that support EM64T)

config MCORE2
	bool "Intel Core2 / newer Xeon"
	help
	  Optimize for Intel Core2 and newer Xeons (51xx)
	  You can distinguish the newer Xeons from the older ones using
	  the cpu family field in /proc/cpuinfo. 15 is an older Xeon
	  (use CONFIG_MPSC then), 6 is a newer one. This rule only
	  applies to CPUs that support EM64T.

config GENERIC_CPU
	bool "Generic-x86-64"
	help
	  Generic x86-64 CPU.
	  Run equally well on all x86-64 CPUs.

endchoice

#
# Define implied options from the CPU selection here
#
config X86_L1_CACHE_BYTES
	int
	default "128" if GENERIC_CPU || MPSC
	default "64" if MK8 || MCORE2

config X86_L1_CACHE_SHIFT
	int
	default "7" if GENERIC_CPU || MPSC
	default "6" if MK8 || MCORE2

config X86_INTERNODE_CACHE_BYTES
	int
	default "4096" if X86_VSMP
	default X86_L1_CACHE_BYTES if !X86_VSMP

config X86_TSC
	bool
	default y

config X86_GOOD_APIC
	bool
	default y

config MICROCODE
	tristate "/dev/cpu/microcode - Intel CPU microcode support"
	select FW_LOADER
	---help---
	  If you say Y here the 'File systems' section, you will be
	  able to update the microcode on Intel processors. You will
	  obviously need the actual microcode binary data itself which is
	  not shipped with the Linux kernel.

	  For latest news and information on obtaining all the required
	  ingredients for this driver, check:
	  <http://www.urbanmyth.org/microcode/>.

	  To compile this driver as a module, choose M here: the
	  module will be called microcode.
	  If you use modprobe or kmod you may also want to add the line
	  'alias char-major-10-184 microcode' to your /etc/modules.conf file.

config MICROCODE_OLD_INTERFACE
	bool
	depends on MICROCODE
	default y

config X86_MSR
	tristate "/dev/cpu/*/msr - Model-specific register support"
	help
	  This device gives privileged processes access to the x86
	  Model-Specific Registers (MSRs).  It is a character device with
	  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
	  MSR accesses are directed to a specific CPU on multi-processor
	  systems.

config X86_CPUID
	tristate "/dev/cpu/*/cpuid - CPU information support"
	help
	  This device gives processes access to the x86 CPUID instruction to
	  be executed on a specific processor.  It is a character device
	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
	  /dev/cpu/31/cpuid.

config X86_HT
	bool
	depends on SMP && !MK8
	default y

config MATH_EMULATION
	bool

config MCA
	bool

config EISA
	bool

config X86_IO_APIC
	bool
	default y

config X86_LOCAL_APIC
	bool
	default y

config MTRR
	bool "MTRR (Memory Type Range Register) support"
	---help---
	  On Intel P6 family processors (Pentium Pro, Pentium II and later)
	  the Memory Type Range Registers (MTRRs) may be used to control
	  processor access to memory ranges. This is most useful if you have
	  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
	  allows bus write transfers to be combined into a larger transfer
	  before bursting over the PCI/AGP bus. This can increase performance
	  of image write operations 2.5 times or more. Saying Y here creates a
	  /proc/mtrr file which may be used to manipulate your processor's
	  MTRRs. Typically the X server should use this.

	  This code has a reasonably generic interface so that similar
	  control registers on other processors can be easily supported
	  as well.

	  Saying Y here also fixes a problem with buggy SMP BIOSes which only
	  set the MTRRs for the boot CPU and not for the secondary CPUs. This
	  can lead to all sorts of problems, so it's good to say Y here.

	  Just say Y here, all x86-64 machines support MTRRs.

	  See <file:Documentation/mtrr.txt> for more information.

config SMP
	bool "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, like most personal computers, say N. If
	  you have a system with more than one CPU, say Y.

	  If you say N here, the kernel will run on single and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  singleprocessor machines. On a singleprocessor machine, the kernel
	  will run faster if you say N here.

	  If you don't know what to do here, say N.

config SCHED_SMT
	bool "SMT (Hyperthreading) scheduler support"
	depends on SMP
	default n
	help
	  SMT scheduler support improves the CPU scheduler's decision making
	  when dealing with Intel Pentium 4 chips with HyperThreading at a
	  cost of slightly increased overhead in some places. If unsure say
	  N here.

config SCHED_MC
	bool "Multi-core scheduler support"
	depends on SMP
	default y
	help
	  Multi-core scheduler support improves the CPU scheduler's decision
	  making when dealing with multi-core CPU chips at a cost of slightly
	  increased overhead in some places. If unsure say N here.

source "kernel/Kconfig.preempt"

config NUMA
       bool "Non Uniform Memory Access (NUMA) Support"
       depends on SMP
       help
	 Enable NUMA (Non Uniform Memory Access) support. The kernel 
	 will try to allocate memory used by a CPU on the local memory 
	 controller of the CPU and add some more NUMA awareness to the kernel.
	 This code is recommended on all multiprocessor Opteron systems.
	 If the system is EM64T, you should say N unless your system is EM64T 
	 NUMA. 

config K8_NUMA
       bool "Old style AMD Opteron NUMA detection"
       depends on NUMA && PCI
       default y
       help
	 Enable K8 NUMA node topology detection.  You should say Y here if
	 you have a multi processor AMD K8 system. This uses an old
	 method to read the NUMA configuration directly from the builtin
	 Northbridge of Opteron. It is recommended to use X86_64_ACPI_NUMA
	 instead, which also takes priority if both are compiled in.   

config NODES_SHIFT
	int
	default "6"
	depends on NEED_MULTIPLE_NODES

# Dummy CONFIG option to select ACPI_NUMA from drivers/acpi/Kconfig.

config X86_64_ACPI_NUMA
       bool "ACPI NUMA detection"
       depends on NUMA
       select ACPI 
	select PCI
       select ACPI_NUMA
       default y
       help
	 Enable ACPI SRAT based node topology detection.

config NUMA_EMU
	bool "NUMA emulation"
	depends on NUMA
	help
	  Enable NUMA emulation. A flat machine will be split
	  into virtual nodes when booted with "numa=fake=N", where N is the
	  number of nodes. This is only useful for debugging.

config ARCH_DISCONTIGMEM_ENABLE
       bool
       depends on NUMA
       default y

config ARCH_DISCONTIGMEM_DEFAULT
	def_bool y
	depends on NUMA

config ARCH_SPARSEMEM_ENABLE
	def_bool y
	depends on (NUMA || EXPERIMENTAL)

config ARCH_MEMORY_PROBE
	def_bool y
	depends on MEMORY_HOTPLUG

config ARCH_FLATMEM_ENABLE
	def_bool y
	depends on !NUMA

source "mm/Kconfig"

config MEMORY_HOTPLUG_RESERVE
	def_bool y
	depends on (MEMORY_HOTPLUG && DISCONTIGMEM)

config HAVE_ARCH_EARLY_PFN_TO_NID
	def_bool y
	depends on NUMA

config OUT_OF_LINE_PFN_TO_PAGE
	def_bool y
	depends on DISCONTIGMEM

config NR_CPUS
	int "Maximum number of CPUs (2-255)"
	range 2 255
	depends on SMP
	default "8"
	help
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support. Current maximum is 255 CPUs due to
	  APIC addressing limits. Less depending on the hardware.

	  This is purely to save memory - each supported CPU requires
	  memory in the static kernel configuration.

config HOTPLUG_CPU
	bool "Support for suspend on SMP and hot-pluggable CPUs (EXPERIMENTAL)"
	depends on SMP && HOTPLUG && EXPERIMENTAL
	help
		Say Y here to experiment with turning CPUs off and on.  CPUs
		can be controlled through /sys/devices/system/cpu/cpu#.
		This is also required for suspend/hibernation on SMP systems.

		Say N if you want to disable CPU hotplug and don't need to
		suspend.

config ARCH_ENABLE_MEMORY_HOTPLUG
	def_bool y

config HPET_TIMER
	bool
	default y
	help
	  Use the IA-PC HPET (High Precision Event Timer) to manage
	  time in preference to the PIT and RTC, if a HPET is
	  present.  The HPET provides a stable time base on SMP
	  systems, unlike the TSC, but it is more expensive to access,
	  as it is off-chip.  You can find the HPET spec at
	  <http://www.intel.com/hardwaredesign/hpetspec.htm>.

config HPET_EMULATE_RTC
	bool "Provide RTC interrupt"
	depends on HPET_TIMER && RTC=y

# Mark as embedded because too many people got it wrong.
# The code disables itself when not needed.
config IOMMU
	bool "IOMMU support" if EMBEDDED
	default y
	select SWIOTLB
	select AGP
	depends on PCI
	help
	  Support for full DMA access of devices with 32bit memory access only
	  on systems with more than 3GB. This is usually needed for USB,
	  sound, many IDE/SATA chipsets and some other devices.
	  Provides a driver for the AMD Athlon64/Opteron/Turion/Sempron GART
	  based hardware IOMMU and a software bounce buffer based IOMMU used
	  on Intel systems and as fallback.
	  The code is only active when needed (enough memory and limited
	  device) unless CONFIG_IOMMU_DEBUG or iommu=force is specified
	  too.

config CALGARY_IOMMU
	bool "IBM Calgary IOMMU support"
	select SWIOTLB
	depends on PCI && EXPERIMENTAL
	help
	  Support for hardware IOMMUs in IBM's xSeries x366 and x460
	  systems. Needed to run systems with more than 3GB of memory
	  properly with 32-bit PCI devices that do not support DAC
	  (Double Address Cycle). Calgary also supports bus level
	  isolation, where all DMAs pass through the IOMMU.  This
	  prevents them from going anywhere except their intended
	  destination. This catches hard-to-find kernel bugs and
	  mis-behaving drivers and devices that do not use the DMA-API
	  properly to set up their DMA buffers.  The IOMMU can be
	  turned off at boot time with the iommu=off parameter.
	  Normally the kernel will make the right choice by itself.
	  If unsure, say Y.

config CALGARY_IOMMU_ENABLED_BY_DEFAULT
	bool "Should Calgary be enabled by default?"
	default y
	depends on CALGARY_IOMMU
	help
	  Should Calgary be enabled by default? if you choose 'y', Calgary
	  will be used (if it exists). If you choose 'n', Calgary will not be
	  used even if it exists. If you choose 'n' and would like to use
	  Calgary anyway, pass 'iommu=calgary' on the kernel command line.
	  If unsure, say Y.

# need this always selected by IOMMU for the VIA workaround
config SWIOTLB
	bool
	help
	  Support for software bounce buffers used on x86-64 systems
	  which don't have a hardware IOMMU (e.g. the current generation
	  of Intel's x86-64 CPUs). Using this PCI devices which can only
	  access 32-bits of memory can be used on systems with more than
	  3 GB of memory. If unsure, say Y.

config X86_MCE
	bool "Machine check support" if EMBEDDED
	default y
	help
	   Include a machine check error handler to report hardware errors.
	   This version will require the mcelog utility to decode some
	   machine check error logs. See
	   ftp://ftp.x86-64.org/pub/linux/tools/mcelog

config X86_MCE_INTEL
	bool "Intel MCE features"
	depends on X86_MCE && X86_LOCAL_APIC
	default y
	help
	   Additional support for intel specific MCE features such as
	   the thermal monitor.

config X86_MCE_AMD
	bool "AMD MCE features"
	depends on X86_MCE && X86_LOCAL_APIC
	default y
	help
	   Additional support for AMD specific MCE features such as
	   the DRAM Error Threshold.

config KEXEC
	bool "kexec system call"
	help
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is independent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  The name comes from the similarity to the exec system call.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.  It may help to enable device hotplugging
	  support.  As of this writing the exact hardware interface is
	  strongly in flux, so no good recommendation can be made.

config CRASH_DUMP
	bool "kernel crash dumps (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	help
          Generate crash dump after being started by kexec.
          This should be normally only set in special crash dump kernels
          which are loaded in the main kernel with kexec-tools into
          a specially reserved region and then later executed after
          a crash by kdump/kexec. The crash dump kernel must be compiled
	  to a memory address not used by the main kernel or BIOS using
	  PHYSICAL_START.
          For more details see Documentation/kdump/kdump.txt

config RELOCATABLE
	bool "Build a relocatable kernel(EXPERIMENTAL)"
	depends on EXPERIMENTAL
	help
	  Builds a relocatable kernel. This enables loading and running
	  a kernel binary from a different physical address than it has
	  been compiled for.

	  One use is for the kexec on panic case where the recovery kernel
	  must live at a different physical address than the primary
	  kernel.

	  Note: If CONFIG_RELOCATABLE=y, then kernel run from the address
	  it has been loaded at and compile time physical address
	  (CONFIG_PHYSICAL_START) is ignored.

config PHYSICAL_START
	hex "Physical address where the kernel is loaded" if (EMBEDDED || CRASH_DUMP)
	default "0x200000"
	help
	  This gives the physical address where the kernel is loaded. It
	  should be aligned to 2MB boundary.

	  If kernel is a not relocatable (CONFIG_RELOCATABLE=n) then
	  bzImage will decompress itself to above physical address and
	  run from there. Otherwise, bzImage will run from the address where
	  it has been loaded by the boot loader and will ignore above physical
	  address.

	  In normal kdump cases one does not have to set/change this option
	  as now bzImage can be compiled as a completely relocatable image
	  (CONFIG_RELOCATABLE=y) and be used to load and run from a different
	  address. This option is mainly useful for the folks who don't want
	  to use a bzImage for capturing the crash dump and want to use a
	  vmlinux instead.

	  So if you are using bzImage for capturing the crash dump, leave
	  the value here unchanged to 0x200000 and set CONFIG_RELOCATABLE=y.
	  Otherwise if you plan to use vmlinux for capturing the crash dump
	  change this value to start of the reserved region (Typically 16MB
	  0x1000000). In other words, it can be set based on the "X" value as
	  specified in the "crashkernel=YM@XM" command line boot parameter
	  passed to the panic-ed kernel. Typically this parameter is set as
	  crashkernel=64M@16M. Please take a look at
	  Documentation/kdump/kdump.txt for more details about crash dumps.

	  Usage of bzImage for capturing the crash dump is advantageous as
	  one does not have to build two kernels. Same kernel can be used
	  as production kernel and capture kernel.

	  Don't change this unless you know what you are doing.

config SECCOMP
	bool "Enable seccomp to safely compute untrusted bytecode"
	depends on PROC_FS
	default y
	help
	  This kernel feature is useful for number crunching applications
	  that may need to compute untrusted bytecode during their
	  execution. By using pipes or other transports made available to
	  the process as file descriptors supporting the read/write
	  syscalls, it's possible to isolate those applications in
	  their own address space using seccomp. Once seccomp is
	  enabled via /proc/<pid>/seccomp, it cannot be disabled
	  and the task is only allowed to execute a few safe syscalls
	  defined by each seccomp mode.

	  If unsure, say Y. Only embedded should say N here.

config CC_STACKPROTECTOR
	bool "Enable -fstack-protector buffer overflow detection (EXPERIMENTAL)"
	depends on EXPERIMENTAL
	help
         This option turns on the -fstack-protector GCC feature. This
	  feature puts, at the beginning of critical functions, a canary
	  value on the stack just before the return address, and validates
	  the value just before actually returning.  Stack based buffer
	  overflows (that need to overwrite this return address) now also
	  overwrite the canary, which gets detected and the attack is then
	  neutralized via a kernel panic.

	  This feature requires gcc version 4.2 or above, or a distribution
	  gcc with the feature backported. Older versions are automatically
	  detected and for those versions, this configuration option is ignored.

config CC_STACKPROTECTOR_ALL
	bool "Use stack-protector for all functions"
	depends on CC_STACKPROTECTOR
	help
	  Normally, GCC only inserts the canary value protection for
	  functions that use large-ish on-stack buffers. By enabling
	  this option, GCC will be asked to do this for ALL functions.

source kernel/Kconfig.hz

config K8_NB
	def_bool y
	depends on AGP_AMD64 || IOMMU || (PCI && NUMA)

endmenu

#
# Use the generic interrupt handling code in kernel/irq/:
#
config GENERIC_HARDIRQS
	bool
	default y

config GENERIC_IRQ_PROBE
	bool
	default y

# we have no ISA slots, but we do have ISA-style DMA.
config ISA_DMA_API
	bool
	default y

config GENERIC_PENDING_IRQ
	bool
	depends on GENERIC_HARDIRQS && SMP
	default y

menu "Power management options"

source kernel/power/Kconfig

source "drivers/acpi/Kconfig"

source "arch/x86_64/kernel/cpufreq/Kconfig"

endmenu

menu "Bus options (PCI etc.)"

config PCI
	bool "PCI support"
	select ARCH_SUPPORTS_MSI if (X86_LOCAL_APIC && X86_IO_APIC)

# x86-64 doesn't support PCI BIOS access from long mode so always go direct.
config PCI_DIRECT
	bool
	depends on PCI
	default y

config PCI_MMCONFIG
	bool "Support mmconfig PCI config space access"
	depends on PCI && ACPI

source "drivers/pci/pcie/Kconfig"

source "drivers/pci/Kconfig"

source "drivers/pcmcia/Kconfig"

source "drivers/pci/hotplug/Kconfig"

endmenu


menu "Executable file formats / Emulations"

source "fs/Kconfig.binfmt"

config IA32_EMULATION
	bool "IA32 Emulation"
	help
	  Include code to run 32-bit programs under a 64-bit kernel. You should likely
	  turn this on, unless you're 100% sure that you don't have any 32-bit programs
	  left.

config IA32_AOUT
       tristate "IA32 a.out support"
       depends on IA32_EMULATION
       help
         Support old a.out binaries in the 32bit emulation.

config COMPAT
	bool
	depends on IA32_EMULATION
	default y

config SYSVIPC_COMPAT
	bool
	depends on COMPAT && SYSVIPC
	default y

endmenu

source "net/Kconfig"

source drivers/Kconfig

source "drivers/firmware/Kconfig"

source fs/Kconfig

menu "Instrumentation Support"
        depends on EXPERIMENTAL

source "arch/x86_64/oprofile/Kconfig"

config KPROBES
	bool "Kprobes (EXPERIMENTAL)"
	depends on KALLSYMS && EXPERIMENTAL && MODULES
	help
	  Kprobes allows you to trap at almost any kernel address and
	  execute a callback function.  register_kprobe() establishes
	  a probepoint and specifies the callback.  Kprobes is useful
	  for kernel debugging, non-intrusive instrumentation and testing.
	  If in doubt, say "N".
endmenu

source "arch/x86_64/Kconfig.debug"

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"
