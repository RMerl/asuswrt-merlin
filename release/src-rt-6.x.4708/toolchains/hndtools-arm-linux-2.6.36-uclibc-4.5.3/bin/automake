#!/usr/bin/perl -w
# -*- perl -*-
# Generated from automake.in; do not edit by hand.

eval 'case $# in 0) exec /usr/bin/perl -S "$0";; *) exec /usr/bin/perl -S "$0" "$@";; esac'
    if 0;

# automake - create Makefile.in from Makefile.am
# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
# Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Originally written by David Mackenzie <djm@gnu.ai.mit.edu>.
# Perl reimplementation by Tom Tromey <tromey@redhat.com>, and
# Alexandre Duret-Lutz <adl@gnu.org>.

package Language;

BEGIN
{
  my $perllibdir = $ENV{'perllibdir'} || '/projects/hnd/tools/linux/hndtools-arm-linux-2.6.36-uclibc-4.5.3/share/automake-1.11';
  unshift @INC, (split ':', $perllibdir);

  # Override SHELL.  This is required on DJGPP so that system() uses
  # bash, not COMMAND.COM which doesn't quote arguments properly.
  # Other systems aren't expected to use $SHELL when Automake
  # runs, but it should be safe to drop the `if DJGPP' guard if
  # it turns up other systems need the same thing.  After all,
  # if SHELL is used, ./configure's SHELL is always better than
  # the user's SHELL (which may be something like tcsh).
  $ENV{'SHELL'} = '/bin/sh' if exists $ENV{'DJDIR'};
}

use Automake::Struct;
struct (# Short name of the language (c, f77...).
	'name' => "\$",
	# Nice name of the language (C, Fortran 77...).
	'Name' => "\$",

	# List of configure variables which must be defined.
	'config_vars' => '@',

	'ansi'    => "\$",
	# `pure' is `1' or `'.  A `pure' language is one where, if
	# all the files in a directory are of that language, then we
	# do not require the C compiler or any code to call it.
	'pure'   => "\$",

	'autodep' => "\$",

	# Name of the compiling variable (COMPILE).
	'compiler'  => "\$",
	# Content of the compiling variable.
	'compile'  => "\$",
	# Flag to require compilation without linking (-c).
	'compile_flag' => "\$",
	'extensions' => '@',
	# A subroutine to compute a list of possible extensions of
	# the product given the input extensions.
	# (defaults to a subroutine which returns ('.$(OBJEXT)', '.lo'))
	'output_extensions' => "\$",
	# A list of flag variables used in 'compile'.
	# (defaults to [])
	'flags' => "@",

	# Any tag to pass to libtool while compiling.
	'libtool_tag' => "\$",

	# The file to use when generating rules for this language.
	# The default is 'depend2'.
	'rule_file' => "\$",

	# Name of the linking variable (LINK).
	'linker' => "\$",
	# Content of the linking variable.
	'link' => "\$",

	# Name of the compiler variable (CC).
	'ccer' => "\$",

	# Name of the linker variable (LD).
	'lder' => "\$",
	# Content of the linker variable ($(CC)).
	'ld' => "\$",

	# Flag to specify the output file (-o).
	'output_flag' => "\$",
	'_finish' => "\$",

	# This is a subroutine which is called whenever we finally
	# determine the context in which a source file will be
	# compiled.
	'_target_hook' => "\$",

	# If TRUE, nodist_ sources will be compiled using specific rules
	# (i.e. not inference rules).  The default is FALSE.
	'nodist_specific' => "\$");


sub finish ($)
{
  my ($self) = @_;
  if (defined $self->_finish)
    {
      &{$self->_finish} (@_);
    }
}

sub target_hook ($$$$%)
{
    my ($self) = @_;
    if (defined $self->_target_hook)
    {
	&{$self->_target_hook} (@_);
    }
}

package Automake;

use strict;
use Automake::Config;
BEGIN
{
  if ($perl_threads)
    {
      require threads;
      import threads;
      require Thread::Queue;
      import Thread::Queue;
    }
}
use Automake::General;
use Automake::XFile;
use Automake::Channels;
use Automake::ChannelDefs;
use Automake::Configure_ac;
use Automake::FileUtils;
use Automake::Location;
use Automake::Condition qw/TRUE FALSE/;
use Automake::DisjConditions;
use Automake::Options;
use Automake::Version;
use Automake::Variable;
use Automake::VarDef;
use Automake::Rule;
use Automake::RuleDef;
use Automake::Wrap 'makefile_wrap';
use File::Basename;
use File::Spec;
use Carp;

## ----------- ##
## Constants.  ##
## ----------- ##

# Some regular expressions.  One reason to put them here is that it
# makes indentation work better in Emacs.

# Writing singled-quoted-$-terminated regexes is a pain because
# perl-mode thinks of $' as the ${'} variable (instead of a $ followed
# by a closing quote.  Letting perl-mode think the quote is not closed
# leads to all sort of misindentations.  On the other hand, defining
# regexes as double-quoted strings is far less readable.  So usually
# we will write:
#
#  $REGEX = '^regex_value' . "\$";

my $IGNORE_PATTERN = '^\s*##([^#\n].*)?\n';
my $WHITE_PATTERN = '^\s*' . "\$";
my $COMMENT_PATTERN = '^#';
my $TARGET_PATTERN='[$a-zA-Z0-9_.@%][-.a-zA-Z0-9_(){}/$+@%]*';
# A rule has three parts: a list of targets, a list of dependencies,
# and optionally actions.
my $RULE_PATTERN =
  "^($TARGET_PATTERN(?:(?:\\\\\n|\\s)+$TARGET_PATTERN)*) *:([^=].*|)\$";

# Only recognize leading spaces, not leading tabs.  If we recognize
# leading tabs here then we need to make the reader smarter, because
# otherwise it will think rules like `foo=bar; \' are errors.
my $ASSIGNMENT_PATTERN = '^ *([^ \t=:+]*)\s*([:+]?)=\s*(.*)' . "\$";
# This pattern recognizes a Gnits version id and sets $1 if the
# release is an alpha release.  We also allow a suffix which can be
# used to extend the version number with a "fork" identifier.
my $GNITS_VERSION_PATTERN = '\d+\.\d+([a-z]|\.\d+)?(-[A-Za-z0-9]+)?';

my $IF_PATTERN = '^if\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*)\s*(?:#.*)?' . "\$";
my $ELSE_PATTERN =
  '^else(?:\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*))?\s*(?:#.*)?' . "\$";
my $ENDIF_PATTERN =
  '^endif(?:\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*))?\s*(?:#.*)?' . "\$";
my $PATH_PATTERN = '(\w|[+/.-])+';
# This will pass through anything not of the prescribed form.
my $INCLUDE_PATTERN = ('^include\s+'
		       . '((\$\(top_srcdir\)/' . $PATH_PATTERN . ')'
		       . '|(\$\(srcdir\)/' . $PATH_PATTERN . ')'
		       . '|([^/\$]' . $PATH_PATTERN . '))\s*(#.*)?' . "\$");

# Match `-d' as a command-line argument in a string.
my $DASH_D_PATTERN = "(^|\\s)-d(\\s|\$)";
# Directories installed during 'install-exec' phase.
my $EXEC_DIR_PATTERN =
  '^(?:bin|sbin|libexec|sysconf|localstate|lib|pkglib|.*exec.*)' . "\$";

# Values for AC_CANONICAL_*
use constant AC_CANONICAL_BUILD  => 1;
use constant AC_CANONICAL_HOST   => 2;
use constant AC_CANONICAL_TARGET => 3;

# Values indicating when something should be cleaned.
use constant MOSTLY_CLEAN     => 0;
use constant CLEAN            => 1;
use constant DIST_CLEAN       => 2;
use constant MAINTAINER_CLEAN => 3;

# Libtool files.
my @libtool_files = qw(ltmain.sh config.guess config.sub);
# ltconfig appears here for compatibility with old versions of libtool.
my @libtool_sometimes = qw(ltconfig ltcf-c.sh ltcf-cxx.sh ltcf-gcj.sh);

# Commonly found files we look for and automatically include in
# DISTFILES.
my @common_files =
    (qw(ABOUT-GNU ABOUT-NLS AUTHORS BACKLOG COPYING COPYING.DOC COPYING.LIB
	COPYING.LESSER ChangeLog INSTALL NEWS README THANKS TODO
	ansi2knr.1 ansi2knr.c compile config.guess config.rpath config.sub
	depcomp elisp-comp install-sh libversion.in mdate-sh missing
	mkinstalldirs py-compile texinfo.tex ylwrap),
     @libtool_files, @libtool_sometimes);

# Commonly used files we auto-include, but only sometimes.  This list
# is used for the --help output only.
my @common_sometimes =
  qw(aclocal.m4 acconfig.h config.h.top config.h.bot configure
     configure.ac configure.in stamp-vti);

# Standard directories from the GNU Coding Standards, and additional
# pkg* directories from Automake.  Stored in a hash for fast member check.
my %standard_prefix =
    map { $_ => 1 } (qw(bin data dataroot dvi exec html include info
			lib libexec lisp localstate man man1 man2 man3
			man4 man5 man6 man7 man8 man9 oldinclude pdf
			pkgdatadir pkgincludedir pkglibdir pkglibexecdir
			ps sbin sharedstate sysconf));

# Copyright on generated Makefile.ins.
my $gen_copyright = "\
# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
# Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.
";

# These constants are returned by the lang_*_rewrite functions.
# LANG_SUBDIR means that the resulting object file should be in a
# subdir if the source file is.  In this case the file name cannot
# have `..' components.
use constant LANG_IGNORE  => 0;
use constant LANG_PROCESS => 1;
use constant LANG_SUBDIR  => 2;

# These are used when keeping track of whether an object can be built
# by two different paths.
use constant COMPILE_LIBTOOL  => 1;
use constant COMPILE_ORDINARY => 2;

# We can't always associate a location to a variable or a rule,
# when it's defined by Automake.  We use INTERNAL in this case.
use constant INTERNAL => new Automake::Location;

# Serialization keys for message queues.
use constant QUEUE_MESSAGE   => "msg";
use constant QUEUE_CONF_FILE => "conf file";
use constant QUEUE_LOCATION  => "location";
use constant QUEUE_STRING    => "string";


## ---------------------------------- ##
## Variables related to the options.  ##
## ---------------------------------- ##

# TRUE if we should always generate Makefile.in.
my $force_generation = 1;

# From the Perl manual.
my $symlink_exists = (eval 'symlink ("", "");', $@ eq '');

# TRUE if missing standard files should be installed.
my $add_missing = 0;

# TRUE if we should copy missing files; otherwise symlink if possible.
my $copy_missing = 0;

# TRUE if we should always update files that we know about.
my $force_missing = 0;


## ---------------------------------------- ##
## Variables filled during files scanning.  ##
## ---------------------------------------- ##

# Name of the configure.ac file.
my $configure_ac;

# Files found by scanning configure.ac for LIBOBJS.
my %libsources = ();

# Names used in AC_CONFIG_HEADER call.
my @config_headers = ();

# Names used in AC_CONFIG_LINKS call.
my @config_links = ();

# Directory where output files go.  Actually, output files are
# relative to this directory.
my $output_directory;

# List of Makefile.am's to process, and their corresponding outputs.
my @input_files = ();
my %output_files = ();

# Complete list of Makefile.am's that exist.
my @configure_input_files = ();

# List of files in AC_CONFIG_FILES/AC_OUTPUT without Makefile.am's,
# and their outputs.
my @other_input_files = ();
# Where each AC_CONFIG_FILES/AC_OUTPUT/AC_CONFIG_LINK/AC_CONFIG_HEADER appears.
# The keys are the files created by these macros.
my %ac_config_files_location = ();
# The condition under which AC_CONFIG_FOOS appears.
my %ac_config_files_condition = ();

# Directory to search for configure-required files.  This
# will be computed by &locate_aux_dir and can be set using
# AC_CONFIG_AUX_DIR in configure.ac.
# $CONFIG_AUX_DIR is the `raw' directory, valid only in the source-tree.
my $config_aux_dir = '';
my $config_aux_dir_set_in_configure_ac = 0;
# $AM_CONFIG_AUX_DIR is prefixed with $(top_srcdir), so it can be used
# in Makefiles.
my $am_config_aux_dir = '';

# Directory to search for AC_LIBSOURCE files, as set by AC_CONFIG_LIBOBJ_DIR
# in configure.ac.
my $config_libobj_dir = '';

# Whether AM_GNU_GETTEXT has been seen in configure.ac.
my $seen_gettext = 0;
# Whether AM_GNU_GETTEXT([external]) is used.
my $seen_gettext_external = 0;
# Where AM_GNU_GETTEXT appears.
my $ac_gettext_location;
# Whether AM_GNU_GETTEXT_INTL_SUBDIR has been seen.
my $seen_gettext_intl = 0;

# Lists of tags supported by Libtool.
my %libtool_tags = ();
# 1 if Libtool uses LT_SUPPORTED_TAG.  If it does, then it also
# uses AC_REQUIRE_AUX_FILE.
my $libtool_new_api = 0;

# Most important AC_CANONICAL_* macro seen so far.
my $seen_canonical = 0;
# Location of that macro.
my $canonical_location;

# Where AM_MAINTAINER_MODE appears.
my $seen_maint_mode;

# Actual version we've seen.
my $package_version = '';

# Where version is defined.
my $package_version_location;

# TRUE if we've seen AM_ENABLE_MULTILIB.
my $seen_multilib = 0;

# TRUE if we've seen AM_PROG_CC_C_O
my $seen_cc_c_o = 0;

# Location of AC_REQUIRE_AUX_FILE calls, indexed by their argument.
my %required_aux_file = ();

# Where AM_INIT_AUTOMAKE is called;
my $seen_init_automake = 0;

# TRUE if we've seen AM_AUTOMAKE_VERSION.
my $seen_automake_version = 0;

# Hash table of discovered configure substitutions.  Keys are names,
# values are `FILE:LINE' strings which are used by error message
# generation.
my %configure_vars = ();

# Ignored configure substitutions (i.e., variables not to be output in
# Makefile.in)
my %ignored_configure_vars = ();

# Files included by $configure_ac.
my @configure_deps = ();

# Greatest timestamp of configure's dependencies.
my $configure_deps_greatest_timestamp = 0;

# Hash table of AM_CONDITIONAL variables seen in configure.
my %configure_cond = ();

# This maps extensions onto language names.
my %extension_map = ();

# List of the DIST_COMMON files we discovered while reading
# configure.in
my $configure_dist_common = '';

# This maps languages names onto objects.
my %languages = ();
# Maps each linker variable onto a language object.
my %link_languages = ();

# maps extensions to needed source flags.
my %sourceflags = ();

# List of targets we must always output.
# FIXME: Complete, and remove falsely required targets.
my %required_targets =
  (
   'all'          => 1,
   'dvi'	  => 1,
   'pdf'	  => 1,
   'ps'		  => 1,
   'info'	  => 1,
   'install-info' => 1,
   'install'      => 1,
   'install-data' => 1,
   'install-exec' => 1,
   'uninstall'    => 1,

   # FIXME: Not required, temporary hacks.
   # Well, actually they are sort of required: the -recursive
   # targets will run them anyway...
   'html-am'         => 1,
   'dvi-am'          => 1,
   'pdf-am'          => 1,
   'ps-am'           => 1,
   'info-am'         => 1,
   'install-data-am' => 1,
   'install-exec-am' => 1,
   'install-html-am' => 1,
   'install-dvi-am'  => 1,
   'install-pdf-am'  => 1,
   'install-ps-am'   => 1,
   'install-info-am' => 1,
   'installcheck-am' => 1,
   'uninstall-am' => 1,

   'install-man' => 1,
  );

# Set to 1 if this run will create the Makefile.in that distributes
# the files in config_aux_dir.
my $automake_will_process_aux_dir = 0;

# The name of the Makefile currently being processed.
my $am_file = 'BUG';


################################################################

## ------------------------------------------ ##
## Variables reset by &initialize_per_input.  ##
## ------------------------------------------ ##

# Basename and relative dir of the input file.
my $am_file_name;
my $am_relative_dir;

# Same but wrt Makefile.in.
my $in_file_name;
my $relative_dir;

# Relative path to the top directory.
my $topsrcdir;

# Greatest timestamp of the output's dependencies (excluding
# configure's dependencies).
my $output_deps_greatest_timestamp;

# These variables are used when generating each Makefile.in.
# They hold the Makefile.in until it is ready to be printed.
my $output_vars;
my $output_all;
my $output_header;
my $output_rules;
my $output_trailer;

# This is the conditional stack, updated on if/else/endif, and
# used to build Condition objects.
my @cond_stack;

# This holds the set of included files.
my @include_stack;

# List of dependencies for the obvious targets.
my @all;
my @check;
my @check_tests;

# Keys in this hash table are files to delete.  The associated
# value tells when this should happen (MOSTLY_CLEAN, DIST_CLEAN, etc.)
my %clean_files;

# Keys in this hash table are object files or other files in
# subdirectories which need to be removed.  This only holds files
# which are created by compilations.  The value in the hash indicates
# when the file should be removed.
my %compile_clean_files;

# Keys in this hash table are directories where we expect to build a
# libtool object.  We use this information to decide what directories
# to delete.
my %libtool_clean_directories;

# Value of `$(SOURCES)', used by tags.am.
my @sources;
# Sources which go in the distribution.
my @dist_sources;

# This hash maps object file names onto their corresponding source
# file names.  This is used to ensure that each object is created
# by a single source file.
my %object_map;

# This hash maps object file names onto an integer value representing
# whether this object has been built via ordinary compilation or
# libtool compilation (the COMPILE_* constants).
my %object_compilation_map;


# This keeps track of the directories for which we've already
# created dirstamp code.  Keys are directories, values are stamp files.
# Several keys can share the same stamp files if they are equivalent
# (as are `.//foo' and `foo').
my %directory_map;

# All .P files.
my %dep_files;

# This is a list of all targets to run during "make dist".
my @dist_targets;

# Keep track of all programs declared in this Makefile, without
# $(EXEEXT).  @substitutions@ are not listed.
my %known_programs;
my %known_libraries;

# Keys in this hash are the basenames of files which must depend on
# ansi2knr.  Values are either the empty string, or the directory in
# which the ANSI source file appears; the directory must have a
# trailing `/'.
my %de_ansi_files;

# This keeps track of which extensions we've seen (that we care
# about).
my %extension_seen;

# This is random scratch space for the language finish functions.
# Don't randomly overwrite it; examine other uses of keys first.
my %language_scratch;

# We keep track of which objects need special (per-executable)
# handling on a per-language basis.
my %lang_specific_files;

# This is set when `handle_dist' has finished.  Once this happens,
# we should no longer push on dist_common.
my $handle_dist_run;

# Used to store a set of linkers needed to generate the sources currently
# under consideration.
my %linkers_used;

# True if we need `LINK' defined.  This is a hack.
my $need_link;

# Was get_object_extension run?
# FIXME: This is a hack. a better switch should be found.
my $get_object_extension_was_run;

# Record each file processed by make_paragraphs.
my %transformed_files;


################################################################

## ---------------------------------------------- ##
## Variables not reset by &initialize_per_input.  ##
## ---------------------------------------------- ##

# Cache each file processed by make_paragraphs.
# (This is different from %transformed_files because
# %transformed_files is reset for each file while %am_file_cache
# it global to the run.)
my %am_file_cache;

################################################################

# var_SUFFIXES_trigger ($TYPE, $VALUE)
# ------------------------------------
# This is called by Automake::Variable::define() when SUFFIXES
# is defined ($TYPE eq '') or appended ($TYPE eq '+').
# The work here needs to be performed as a side-effect of the
# macro_define() call because SUFFIXES definitions impact
# on $KNOWN_EXTENSIONS_PATTERN which is used used when parsing
# the input am file.
sub var_SUFFIXES_trigger ($$)
{
    my ($type, $value) = @_;
    accept_extensions (split (' ', $value));
}
Automake::Variable::hook ('SUFFIXES', \&var_SUFFIXES_trigger);

################################################################

## --------------------------------- ##
## Forward subroutine declarations.  ##
## --------------------------------- ##
sub register_language (%);
sub file_contents_internal ($$$%);
sub define_files_variable ($\@$$);


# &initialize_per_input ()
# ------------------------
# (Re)-Initialize per-Makefile.am variables.
sub initialize_per_input ()
{
    reset_local_duplicates ();

    $am_file_name = undef;
    $am_relative_dir = undef;

    $in_file_name = undef;
    $relative_dir = undef;
    $topsrcdir = undef;

    $output_deps_greatest_timestamp = 0;

    $output_vars = '';
    $output_all = '';
    $output_header = '';
    $output_rules = '';
    $output_trailer = '';

    Automake::Options::reset;
    Automake::Variable::reset;
    Automake::Rule::reset;

    @cond_stack = ();

    @include_stack = ();

    @all = ();
    @check = ();
    @check_tests = ();

    %clean_files = ();
    %compile_clean_files = ();

    # We always include `.'.  This isn't strictly correct.
    %libtool_clean_directories = ('.' => 1);

    @sources = ();
    @dist_sources = ();

    %object_map = ();
    %object_compilation_map = ();

    %directory_map = ();

    %dep_files = ();

    @dist_targets = ();

    %known_programs = ();
    %known_libraries= ();

    %de_ansi_files = ();

    %extension_seen = ();

    %language_scratch = ();

    %lang_specific_files = ();

    $handle_dist_run = 0;

    $need_link = 0;

    $get_object_extension_was_run = 0;

    %transformed_files = ();
}


################################################################

# Initialize our list of languages that are internally supported.

# C.
register_language ('name' => 'c',
		   'Name' => 'C',
		   'config_vars' => ['CC'],
		   'ansi' => 1,
		   'autodep' => '',
		   'flags' => ['CFLAGS', 'CPPFLAGS'],
		   'ccer' => 'CC',
		   'compiler' => 'COMPILE',
		   'compile' => '$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)',
		   'lder' => 'CCLD',
		   'ld' => '$(CC)',
		   'linker' => 'LINK',
		   'link' => '$(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'compile_flag' => '-c',
		   'libtool_tag' => 'CC',
		   'extensions' => ['.c'],
		   '_finish' => \&lang_c_finish);

# C++.
register_language ('name' => 'cxx',
		   'Name' => 'C++',
		   'config_vars' => ['CXX'],
		   'linker' => 'CXXLINK',
		   'link' => '$(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'CXX',
		   'flags' => ['CXXFLAGS', 'CPPFLAGS'],
		   'compile' => '$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)',
		   'ccer' => 'CXX',
		   'compiler' => 'CXXCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'CXX',
		   'lder' => 'CXXLD',
		   'ld' => '$(CXX)',
		   'pure' => 1,
		   'extensions' => ['.c++', '.cc', '.cpp', '.cxx', '.C']);

# Objective C.
register_language ('name' => 'objc',
		   'Name' => 'Objective C',
		   'config_vars' => ['OBJC'],
		   'linker' => 'OBJCLINK',
		   'link' => '$(OBJCLD) $(AM_OBJCFLAGS) $(OBJCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'OBJC',
		   'flags' => ['OBJCFLAGS', 'CPPFLAGS'],
		   'compile' => '$(OBJC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_OBJCFLAGS) $(OBJCFLAGS)',
		   'ccer' => 'OBJC',
		   'compiler' => 'OBJCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'lder' => 'OBJCLD',
		   'ld' => '$(OBJC)',
		   'pure' => 1,
		   'extensions' => ['.m']);

# Unified Parallel C.
register_language ('name' => 'upc',
		   'Name' => 'Unified Parallel C',
		   'config_vars' => ['UPC'],
		   'linker' => 'UPCLINK',
		   'link' => '$(UPCLD) $(AM_UPCFLAGS) $(UPCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'UPC',
		   'flags' => ['UPCFLAGS', 'CPPFLAGS'],
		   'compile' => '$(UPC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_UPCFLAGS) $(UPCFLAGS)',
		   'ccer' => 'UPC',
		   'compiler' => 'UPCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'lder' => 'UPCLD',
		   'ld' => '$(UPC)',
		   'pure' => 1,
		   'extensions' => ['.upc']);

# Headers.
register_language ('name' => 'header',
		   'Name' => 'Header',
		   'extensions' => ['.h', '.H', '.hxx', '.h++', '.hh',
				    '.hpp', '.inc'],
		   # No output.
		   'output_extensions' => sub { return () },
		   # Nothing to do.
		   '_finish' => sub { });

# Vala
register_language ('name' => 'vala',
		   'Name' => 'Vala',
		   'config_vars' => ['VALAC'],
		   'flags' => [],
		   'compile' => '$(VALAC) $(AM_VALAFLAGS) $(VALAFLAGS)',
		   'ccer' => 'VALAC',
		   'compiler' => 'VALACOMPILE',
		   'extensions' => ['.vala'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ s/vala$/c/;
						return ($ext,) },
		   'rule_file' => 'vala',
		   '_finish' => \&lang_vala_finish,
		   '_target_hook' => \&lang_vala_target_hook,
		   'nodist_specific' => 1);

# Yacc (C & C++).
register_language ('name' => 'yacc',
		   'Name' => 'Yacc',
		   'config_vars' => ['YACC'],
		   'flags' => ['YFLAGS'],
		   'compile' => '$(YACC) $(YFLAGS) $(AM_YFLAGS)',
		   'ccer' => 'YACC',
		   'compiler' => 'YACCCOMPILE',
		   'extensions' => ['.y'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/y/c/;
						return ($ext,) },
		   'rule_file' => 'yacc',
		   '_finish' => \&lang_yacc_finish,
		   '_target_hook' => \&lang_yacc_target_hook,
		   'nodist_specific' => 1);
register_language ('name' => 'yaccxx',
		   'Name' => 'Yacc (C++)',
		   'config_vars' => ['YACC'],
		   'rule_file' => 'yacc',
		   'flags' => ['YFLAGS'],
		   'ccer' => 'YACC',
		   'compiler' => 'YACCCOMPILE',
		   'compile' => '$(YACC) $(YFLAGS) $(AM_YFLAGS)',
		   'extensions' => ['.y++', '.yy', '.yxx', '.ypp'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/y/c/;
						return ($ext,) },
		   '_finish' => \&lang_yacc_finish,
		   '_target_hook' => \&lang_yacc_target_hook,
		   'nodist_specific' => 1);

# Lex (C & C++).
register_language ('name' => 'lex',
		   'Name' => 'Lex',
		   'config_vars' => ['LEX'],
		   'rule_file' => 'lex',
		   'flags' => ['LFLAGS'],
		   'compile' => '$(LEX) $(LFLAGS) $(AM_LFLAGS)',
		   'ccer' => 'LEX',
		   'compiler' => 'LEXCOMPILE',
		   'extensions' => ['.l'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/l/c/;
						return ($ext,) },
		   '_finish' => \&lang_lex_finish,
		   '_target_hook' => \&lang_lex_target_hook,
		   'nodist_specific' => 1);
register_language ('name' => 'lexxx',
		   'Name' => 'Lex (C++)',
		   'config_vars' => ['LEX'],
		   'rule_file' => 'lex',
		   'flags' => ['LFLAGS'],
		   'compile' => '$(LEX) $(LFLAGS) $(AM_LFLAGS)',
		   'ccer' => 'LEX',
		   'compiler' => 'LEXCOMPILE',
		   'extensions' => ['.l++', '.ll', '.lxx', '.lpp'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/l/c/;
						return ($ext,) },
		   '_finish' => \&lang_lex_finish,
		   '_target_hook' => \&lang_lex_target_hook,
		   'nodist_specific' => 1);

# Assembler.
register_language ('name' => 'asm',
		   'Name' => 'Assembler',
		   'config_vars' => ['CCAS', 'CCASFLAGS'],

		   'flags' => ['CCASFLAGS'],
		   # Users can set AM_CCASFLAGS to include DEFS, INCLUDES,
		   # or anything else required.  They can also set CCAS.
		   # Or simply use Preprocessed Assembler.
		   'compile' => '$(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)',
		   'ccer' => 'CCAS',
		   'compiler' => 'CCASCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'extensions' => ['.s'],

		   # With assembly we still use the C linker.
		   '_finish' => \&lang_c_finish);

# Preprocessed Assembler.
register_language ('name' => 'cppasm',
		   'Name' => 'Preprocessed Assembler',
		   'config_vars' => ['CCAS', 'CCASFLAGS'],

		   'autodep' => 'CCAS',
		   'flags' => ['CCASFLAGS', 'CPPFLAGS'],
		   'compile' => '$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)',
		   'ccer' => 'CPPAS',
		   'compiler' => 'CPPASCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'extensions' => ['.S', '.sx'],

		   # With assembly we still use the C linker.
		   '_finish' => \&lang_c_finish);

# Fortran 77
register_language ('name' => 'f77',
		   'Name' => 'Fortran 77',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'flags' => ['FFLAGS'],
		   'compile' => '$(F77) $(AM_FFLAGS) $(FFLAGS)',
		   'ccer' => 'F77',
		   'compiler' => 'F77COMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'pure' => 1,
		   'extensions' => ['.f', '.for']);

# Fortran
register_language ('name' => 'fc',
		   'Name' => 'Fortran',
		   'config_vars' => ['FC'],
		   'linker' => 'FCLINK',
		   'link' => '$(FCLD) $(AM_FCFLAGS) $(FCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'flags' => ['FCFLAGS'],
		   'compile' => '$(FC) $(AM_FCFLAGS) $(FCFLAGS)',
		   'ccer' => 'FC',
		   'compiler' => 'FCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'FC',
		   'lder' => 'FCLD',
		   'ld' => '$(FC)',
		   'pure' => 1,
		   'extensions' => ['.f90', '.f95', '.f03', '.f08']);

# Preprocessed Fortran
register_language ('name' => 'ppfc',
		   'Name' => 'Preprocessed Fortran',
		   'config_vars' => ['FC'],
		   'linker' => 'FCLINK',
		   'link' => '$(FCLD) $(AM_FCFLAGS) $(FCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'FCLD',
		   'ld' => '$(FC)',
		   'flags' => ['FCFLAGS', 'CPPFLAGS'],
		   'ccer' => 'PPFC',
		   'compiler' => 'PPFCCOMPILE',
		   'compile' => '$(FC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FCFLAGS) $(FCFLAGS)',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'FC',
		   'pure' => 1,
		   'extensions' => ['.F90','.F95', '.F03', '.F08']);

# Preprocessed Fortran 77
#
# The current support for preprocessing Fortran 77 just involves
# passing `$(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS)
# $(CPPFLAGS)' as additional flags to the Fortran 77 compiler, since
# this is how GNU Make does it; see the `GNU Make Manual, Edition 0.51
# for `make' Version 3.76 Beta' (specifically, from info file
# `(make)Catalogue of Rules').
#
# A better approach would be to write an Autoconf test
# (i.e. AC_PROG_FPP) for a Fortran 77 preprocessor, because not all
# Fortran 77 compilers know how to do preprocessing.  The Autoconf
# macro AC_PROG_FPP should test the Fortran 77 compiler first for
# preprocessing capabilities, and then fall back on cpp (if cpp were
# available).
register_language ('name' => 'ppf77',
		   'Name' => 'Preprocessed Fortran 77',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'flags' => ['FFLAGS', 'CPPFLAGS'],
		   'ccer' => 'PPF77',
		   'compiler' => 'PPF77COMPILE',
		   'compile' => '$(F77) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FFLAGS) $(FFLAGS)',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'pure' => 1,
		   'extensions' => ['.F']);

# Ratfor.
register_language ('name' => 'ratfor',
		   'Name' => 'Ratfor',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'flags' => ['RFLAGS', 'FFLAGS'],
		   # FIXME also FFLAGS.
		   'compile' => '$(F77) $(AM_FFLAGS) $(FFLAGS) $(AM_RFLAGS) $(RFLAGS)',
		   'ccer' => 'F77',
		   'compiler' => 'RCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'pure' => 1,
		   'extensions' => ['.r']);

# Java via gcj.
register_language ('name' => 'java',
		   'Name' => 'Java',
		   'config_vars' => ['GCJ'],
		   'linker' => 'GCJLINK',
		   'link' => '$(GCJLD) $(AM_GCJFLAGS) $(GCJFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'GCJ',
		   'flags' => ['GCJFLAGS'],
		   'compile' => '$(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)',
		   'ccer' => 'GCJ',
		   'compiler' => 'GCJCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'GCJ',
		   'lder' => 'GCJLD',
		   'ld' => '$(GCJ)',
		   'pure' => 1,
		   'extensions' => ['.java', '.class', '.zip', '.jar']);

################################################################

# Error reporting functions.

# err_am ($MESSAGE, [%OPTIONS])
# -----------------------------
# Uncategorized errors about the current Makefile.am.
sub err_am ($;%)
{
  msg_am ('error', @_);
}

# err_ac ($MESSAGE, [%OPTIONS])
# -----------------------------
# Uncategorized errors about configure.ac.
sub err_ac ($;%)
{
  msg_ac ('error', @_);
}

# msg_am ($CHANNEL, $MESSAGE, [%OPTIONS])
# ---------------------------------------
# Messages about about the current Makefile.am.
sub msg_am ($$;%)
{
  my ($channel, $msg, %opts) = @_;
  msg $channel, "${am_file}.am", $msg, %opts;
}

# msg_ac ($CHANNEL, $MESSAGE, [%OPTIONS])
# ---------------------------------------
# Messages about about configure.ac.
sub msg_ac ($$;%)
{
  my ($channel, $msg, %opts) = @_;
  msg $channel, $configure_ac, $msg, %opts;
}

################################################################

# subst ($TEXT)
# -------------
# Return a configure-style substitution using the indicated text.
# We do this to avoid having the substitutions directly in automake.in;
# when we do that they are sometimes removed and this causes confusion
# and bugs.
sub subst ($)
{
    my ($text) = @_;
    return '@' . $text . '@';
}

################################################################


# $BACKPATH
# &backname ($REL-DIR)
# --------------------
# If I `cd $REL-DIR', then to come back, I should `cd $BACKPATH'.
# For instance `src/foo' => `../..'.
# Works with non strictly increasing paths, i.e., `src/../lib' => `..'.
sub backname ($)
{
    my ($file) = @_;
    my @res;
    foreach (split (/\//, $file))
    {
	next if $_ eq '.' || $_ eq '';
	if ($_ eq '..')
	{
	    pop @res
	      or prog_error ("trying to reverse path `$file' pointing outside tree");
	}
	else
	{
	    push (@res, '..');
	}
    }
    return join ('/', @res) || '.';
}

################################################################

# `silent-rules' mode handling functions.

# verbose_var (NAME)
# ------------------
# The public variable stem used to implement `silent-rules'.
sub verbose_var ($)
{
    my ($name) = @_;
    return 'AM_V_' . $name;
}

# verbose_private_var (NAME)
# --------------------------
# The naming policy for the private variables for `silent-rules'.
sub verbose_private_var ($)
{
    my ($name) = @_;
    return 'am__v_' . $name;
}

# define_verbose_var (NAME, VAL)
# ------------------------------
# For `silent-rules' mode, setup VAR and dispatcher, to expand to VAL if silent.
sub define_verbose_var ($$)
{
    my ($name, $val) = @_;
    my $var = verbose_var ($name);
    my $pvar = verbose_private_var ($name);
    my $silent_var = $pvar . '_0';
    if (option 'silent-rules')
      {
	# Using `$V' instead of `$(V)' breaks IRIX make.
	define_variable ($var, '$(' . $pvar . '_$(V))', INTERNAL);
	define_variable ($pvar . '_', '$(' . $pvar . '_$(AM_DEFAULT_VERBOSITY))', INTERNAL);
	Automake::Variable::define ($silent_var, VAR_AUTOMAKE, '', TRUE, $val,
				    '', INTERNAL, VAR_ASIS)
	  if (! vardef ($silent_var, TRUE));
      }
}

# Above should not be needed in the general automake code.

# verbose_flag (NAME)
# -------------------
# Contents of %VERBOSE%: variable to expand before rule command.
sub verbose_flag ($)
{
    my ($name) = @_;
    return '$(' . verbose_var ($name) . ')'
      if (option 'silent-rules');
    return '';
}

# silent_flag
# -----------
# Contents of %SILENT%: variable to expand to `@' when silent.
sub silent_flag ()
{
    return verbose_flag ('at');
}

# define_verbose_tagvar (NAME)
# ----------------------------
# Engage the needed `silent-rules' machinery for tag NAME.
sub define_verbose_tagvar ($)
{
    my ($name) = @_;
    if (option 'silent-rules')
      {
	define_verbose_var ($name, '@echo "  '. $name . ' ' x (6 - length ($name)) . '" $@;');
	define_verbose_var ('at', '@');
      }
}

# define_verbose_libtool
# ----------------------
# Engage the needed `silent-rules' machinery for `libtool --silent'.
sub define_verbose_libtool ()
{
    define_verbose_var ('lt', '--silent');
    return verbose_flag ('lt');
}


################################################################


# Handle AUTOMAKE_OPTIONS variable.  Return 1 on error, 0 otherwise.
sub handle_options
{
  my $var = var ('AUTOMAKE_OPTIONS');
  if ($var)
    {
      if ($var->has_conditional_contents)
	{
	  msg_var ('unsupported', $var,
		   "`AUTOMAKE_OPTIONS' cannot have conditional contents");
	}
      foreach my $locvals ($var->value_as_list_recursive (cond_filter => TRUE,
							  location => 1))
	{
	  my ($loc, $value) = @$locvals;
	  return 1 if (process_option_list ($loc, $value))
	}
    }

  # Override portability-recursive warning.
  switch_warning ('no-portability-recursive')
    if option 'silent-rules';

  if ($strictness == GNITS)
    {
      set_option ('readme-alpha', INTERNAL);
      set_option ('std-options', INTERNAL);
      set_option ('check-news', INTERNAL);
    }

  return 0;
}

# shadow_unconditionally ($varname, $where)
# -----------------------------------------
# Return a $(variable) that contains all possible values
# $varname can take.
# If the VAR wasn't defined conditionally, return $(VAR).
# Otherwise we create an am__VAR_DIST variable which contains
# all possible values, and return $(am__VAR_DIST).
sub shadow_unconditionally ($$)
{
  my ($varname, $where) = @_;
  my $var = var $varname;
  if ($var->has_conditional_contents)
    {
      $varname = "am__${varname}_DIST";
      my @files = uniq ($var->value_as_list_recursive);
      define_pretty_variable ($varname, TRUE, $where, @files);
    }
  return "\$($varname)"
}

# get_object_extension ($EXTENSION)
# ---------------------------------
# Prefix $EXTENSION with $U if ansi2knr is in use.
sub get_object_extension ($)
{
    my ($extension) = @_;

    # Check for automatic de-ANSI-fication.
    $extension = '$U' . $extension
      if option 'ansi2knr';

    $get_object_extension_was_run = 1;

    return $extension;
}

# check_user_variables (@LIST)
# ----------------------------
# Make sure each variable VAR in @LIST does not exist, suggest using AM_VAR
# otherwise.
sub check_user_variables (@)
{
  my @dont_override = @_;
  foreach my $flag (@dont_override)
    {
      my $var = var $flag;
      if ($var)
	{
	  for my $cond ($var->conditions->conds)
	    {
	      if ($var->rdef ($cond)->owner == VAR_MAKEFILE)
		{
		  msg_cond_var ('gnu', $cond, $flag,
				"`$flag' is a user variable, "
				. "you should not override it;\n"
				. "use `AM_$flag' instead.");
		}
	    }
	}
    }
}

# Call finish function for each language that was used.
sub handle_languages
{
    if (! option 'no-dependencies')
    {
	# Include auto-dep code.  Don't include it if DEP_FILES would
	# be empty.
	if (&saw_sources_p (0) && keys %dep_files)
	{
	    # Set location of depcomp.
	    &define_variable ('depcomp',
			      "\$(SHELL) $am_config_aux_dir/depcomp",
			      INTERNAL);
	    &define_variable ('am__depfiles_maybe', 'depfiles', INTERNAL);

	    require_conf_file ("$am_file.am", FOREIGN, 'depcomp');

	    my @deplist = sort keys %dep_files;
	    # Generate each `include' individually.  Irix 6 make will
	    # not properly include several files resulting from a
	    # variable expansion; generating many separate includes
	    # seems safest.
	    $output_rules .= "\n";
	    foreach my $iter (@deplist)
	    {
		$output_rules .= (subst ('AMDEP_TRUE')
				  . subst ('am__include')
				  . ' '
				  . subst ('am__quote')
				  . $iter
				  . subst ('am__quote')
				  . "\n");
	    }

	    # Compute the set of directories to remove in distclean-depend.
	    my @depdirs = uniq (map { dirname ($_) } @deplist);
	    $output_rules .= &file_contents ('depend',
					     new Automake::Location,
					     DEPDIRS => "@depdirs");
	}
    }
    else
    {
	&define_variable ('depcomp', '', INTERNAL);
	&define_variable ('am__depfiles_maybe', '', INTERNAL);
    }

    my %done;

    # Is the c linker needed?
    my $needs_c = 0;
    foreach my $ext (sort keys %extension_seen)
    {
	next unless $extension_map{$ext};

	my $lang = $languages{$extension_map{$ext}};

	my $rule_file = $lang->rule_file || 'depend2';

	# Get information on $LANG.
	my $pfx = $lang->autodep;
	my $fpfx = ($pfx eq '') ? 'CC' : $pfx;

	my ($AMDEP, $FASTDEP) =
	  (option 'no-dependencies' || $lang->autodep eq 'no')
	  ? ('FALSE', 'FALSE') : ('AMDEP', "am__fastdep$fpfx");

	my $verbose = verbose_flag ($lang->ccer || 'GEN');
	my $silent = silent_flag ();

	my %transform = ('EXT'     => $ext,
			 'PFX'     => $pfx,
			 'FPFX'    => $fpfx,
			 'AMDEP'   => $AMDEP,
			 'FASTDEP' => $FASTDEP,
			 '-c'      => $lang->compile_flag || '',
			 # These are not used, but they need to be defined
			 # so &transform do not complain.
			 SUBDIROBJ     => 0,
			 'DERIVED-EXT' => 'BUG',
			 DIST_SOURCE   => 1,
			 VERBOSE   => $verbose,
			 SILENT    => $silent,
			);

	# Generate the appropriate rules for this extension.
	if (((! option 'no-dependencies') && $lang->autodep ne 'no')
	    || defined $lang->compile)
	{
	    # Some C compilers don't support -c -o.  Use it only if really
	    # needed.
	    my $output_flag = $lang->output_flag || '';
	    $output_flag = '-o'
	      if (! $output_flag
		  && $lang->name eq 'c'
		  && option 'subdir-objects');

	    # Compute a possible derived extension.
	    # This is not used by depend2.am.
	    my $der_ext = (&{$lang->output_extensions} ($ext))[0];

	    # When we output an inference rule like `.c.o:' we
	    # have two cases to consider: either subdir-objects
	    # is used, or it is not.
	    #
	    # In the latter case the rule is used to build objects
	    # in the current directory, and dependencies always
	    # go into `./$(DEPDIR)/'.  We can hard-code this value.
	    #
	    # In the former case the rule can be used to build
	    # objects in sub-directories too.  Dependencies should
	    # go into the appropriate sub-directories, e.g.,
	    # `sub/$(DEPDIR)/'.  The value of this directory
	    # needs to be computed on-the-fly.
	    #
	    # DEPBASE holds the name of this directory, plus the
	    # basename part of the object file (extensions Po, TPo,
	    # Plo, TPlo will be added later as appropriate).  It is
	    # either hardcoded, or a shell variable (`$depbase') that
	    # will be computed by the rule.
	    my $depbase =
	      option ('subdir-objects') ? '$$depbase' : '$(DEPDIR)/$*';
	    $output_rules .=
	      file_contents ($rule_file,
			     new Automake::Location,
			     %transform,
			     GENERIC   => 1,

			     'DERIVED-EXT' => $der_ext,

			     DEPBASE   => $depbase,
			     BASE      => '$*',
			     SOURCE    => '$<',
			     SOURCEFLAG => $sourceflags{$ext} || '',
			     OBJ       => '$@',
			     OBJOBJ    => '$@',
			     LTOBJ     => '$@',

			     COMPILE   => '$(' . $lang->compiler . ')',
			     LTCOMPILE => '$(LT' . $lang->compiler . ')',
			     -o        => $output_flag,
			     SUBDIROBJ => !! option 'subdir-objects');
	}

	# Now include code for each specially handled object with this
	# language.
	my %seen_files = ();
	foreach my $file (@{$lang_specific_files{$lang->name}})
	{
	    my ($derived, $source, $obj, $myext, $srcext, %file_transform) = @$file;

	    # We might see a given object twice, for instance if it is
	    # used under different conditions.
	    next if defined $seen_files{$obj};
	    $seen_files{$obj} = 1;

	    prog_error ("found " . $lang->name .
			" in handle_languages, but compiler not defined")
	      unless defined $lang->compile;

	    my $obj_compile = $lang->compile;

	    # Rewrite each occurrence of `AM_$flag' in the compile
	    # rule into `${derived}_$flag' if it exists.
	    for my $flag (@{$lang->flags})
	      {
		my $val = "${derived}_$flag";
		$obj_compile =~ s/\(AM_$flag\)/\($val\)/
		  if set_seen ($val);
	      }

	    my $libtool_tag = '';
	    if ($lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag})
	      {
		$libtool_tag = '--tag=' . $lang->libtool_tag . ' '
	      }

	    my $ptltflags = "${derived}_LIBTOOLFLAGS";
	    $ptltflags = 'AM_LIBTOOLFLAGS' unless set_seen $ptltflags;

	    my $ltverbose = define_verbose_libtool ();
	    my $obj_ltcompile =
	      "\$(LIBTOOL) $ltverbose $libtool_tag\$($ptltflags) \$(LIBTOOLFLAGS) "
	      . "--mode=compile $obj_compile";

	    # We _need_ `-o' for per object rules.
	    my $output_flag = $lang->output_flag || '-o';

	    my $depbase = dirname ($obj);
	    $depbase = ''
		if $depbase eq '.';
	    $depbase .= '/'
		unless $depbase eq '';
	    $depbase .= '$(DEPDIR)/' . basename ($obj);

	    # Support for deansified files in subdirectories is ugly
	    # enough to deserve an explanation.
	    #
	    # A Note about normal ansi2knr processing first.  On
	    #
	    #   AUTOMAKE_OPTIONS = ansi2knr
	    #   bin_PROGRAMS = foo
	    #   foo_SOURCES = foo.c
	    #
	    # we generate rules similar to:
	    #
	    #   foo: foo$U.o; link ...
	    #   foo$U.o: foo$U.c; compile ...
	    #   foo_.c: foo.c; ansi2knr ...
	    #
	    # this is fairly compact, and will call ansi2knr depending
	    # on the value of $U (`' or `_').
	    #
	    # It's harder with subdir sources. On
	    #
	    #   AUTOMAKE_OPTIONS = ansi2knr
	    #   bin_PROGRAMS = foo
	    #   foo_SOURCES = sub/foo.c
	    #
	    # we have to create foo_.c in the current directory.
	    # (Unless the user asks 'subdir-objects'.)  This is important
	    # in case the same file (`foo.c') is compiled from other
	    # directories with different cpp options: foo_.c would
	    # be preprocessed for only one set of options if it were
	    # put in the subdirectory.
	    #
	    # Because foo$U.o must be built from either foo_.c or
	    # sub/foo.c we can't be as concise as in the first example.
	    # Instead we output
	    #
	    #   foo: foo$U.o; link ...
	    #   foo_.o: foo_.c; compile ...
	    #   foo.o: sub/foo.c; compile ...
	    #   foo_.c: foo.c; ansi2knr ...
	    #
	    # This is why we'll now transform $rule_file twice
	    # if we detect this case.
	    # A first time we output the compile rule with `$U'
	    # replaced by `_' and the source directory removed,
	    # and another time we simply remove `$U'.
	    #
	    # Note that at this point $source (as computed by
	    # &handle_single_transform) is `sub/foo$U.c'.
	    # This can be confusing: it can be used as-is when
	    # subdir-objects is set, otherwise you have to know
	    # it really means `foo_.c' or `sub/foo.c'.
	    my $objdir = dirname ($obj);
	    my $srcdir = dirname ($source);
	    if ($lang->ansi && $obj =~ /\$U/)
	      {
		prog_error "`$obj' contains \$U, but `$source' doesn't."
		  if $source !~ /\$U/;

		(my $source_ = $source) =~ s/\$U/_/g;
		# Output an additional rule if _.c and .c are not in
		# the same directory.  (_.c is always in $objdir.)
		if ($objdir ne $srcdir)
		  {
		    (my $obj_ = $obj) =~ s/\$U/_/g;
		    (my $depbase_ = $depbase) =~ s/\$U/_/g;
		    $source_ = basename ($source_);

		    $output_rules .=
		      file_contents ($rule_file,
				     new Automake::Location,
				     %transform,
				     GENERIC   => 0,

				     DEPBASE   => $depbase_,
				     BASE      => $obj_,
				     SOURCE    => $source_,
				     SOURCEFLAG => $sourceflags{$srcext} || '',
				     OBJ       => "$obj_$myext",
				     OBJOBJ    => "$obj_.obj",
				     LTOBJ     => "$obj_.lo",

				     COMPILE   => $obj_compile,
				     LTCOMPILE => $obj_ltcompile,
				     -o        => $output_flag,
				     %file_transform);
		    $obj =~ s/\$U//g;
		    $depbase =~ s/\$U//g;
		    $source =~ s/\$U//g;
		  }
	      }

	    $output_rules .=
	      file_contents ($rule_file,
			     new Automake::Location,
			     %transform,
			     GENERIC   => 0,

			     DEPBASE   => $depbase,
			     BASE      => $obj,
			     SOURCE    => $source,
			     SOURCEFLAG => $sourceflags{$srcext} || '',
			     # Use $myext and not `.o' here, in case
			     # we are actually building a new source
			     # file -- e.g. via yacc.
			     OBJ       => "$obj$myext",
			     OBJOBJ    => "$obj.obj",
			     LTOBJ     => "$obj.lo",

			     VERBOSE   => $verbose,
			     SILENT    => $silent,
			     COMPILE   => $obj_compile,
			     LTCOMPILE => $obj_ltcompile,
			     -o        => $output_flag,
			     %file_transform);
	}

	# The rest of the loop is done once per language.
	next if defined $done{$lang};
	$done{$lang} = 1;

	# Load the language dependent Makefile chunks.
	my %lang = map { uc ($_) => 0 } keys %languages;
	$lang{uc ($lang->name)} = 1;
	$output_rules .= file_contents ('lang-compile',
					new Automake::Location,
					%transform, %lang);

	# If the source to a program consists entirely of code from a
	# `pure' language, for instance C++ or Fortran 77, then we
	# don't need the C compiler code.  However if we run into
	# something unusual then we do generate the C code.  There are
	# probably corner cases here that do not work properly.
	# People linking Java code to Fortran code deserve pain.
	$needs_c ||= ! $lang->pure;

	define_compiler_variable ($lang)
	  if ($lang->compile);

	define_linker_variable ($lang)
	  if ($lang->link);

	require_variables ("$am_file.am", $lang->Name . " source seen",
			   TRUE, @{$lang->config_vars});

	# Call the finisher.
	$lang->finish;

	# Flags listed in `->flags' are user variables (per GNU Standards),
	# they should not be overridden in the Makefile...
	my @dont_override = @{$lang->flags};
	# ... and so is LDFLAGS.
	push @dont_override, 'LDFLAGS' if $lang->link;

	check_user_variables @dont_override;
    }

    # If the project is entirely C++ or entirely Fortran 77 (i.e., 1
    # suffix rule was learned), don't bother with the C stuff.  But if
    # anything else creeps in, then use it.
    $needs_c = 1
      if $need_link || suffix_rules_count > 1;

    if ($needs_c)
      {
	&define_compiler_variable ($languages{'c'})
	  unless defined $done{$languages{'c'}};
	define_linker_variable ($languages{'c'});
      }

    # Always provide the user with `AM_V_GEN' for `silent-rules' mode.
    define_verbose_tagvar ('GEN');
}


# append_exeext { PREDICATE } $MACRO
# ----------------------------------
# Append $(EXEEXT) to each filename in $F appearing in the Makefile
# variable $MACRO if &PREDICATE($F) is true.  @substitutions@ are
# ignored.
#
# This is typically used on all filenames of *_PROGRAMS, and filenames
# of TESTS that are programs.
sub append_exeext (&$)
{
  my ($pred, $macro) = @_;

  transform_variable_recursively
    ($macro, $macro, 'am__EXEEXT', 0, INTERNAL,
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;
       # Append $(EXEEXT) unless the user did it already, or it's a
       # @substitution@.
       $val .= '$(EXEEXT)'
	 if $val !~ /(?:\$\(EXEEXT\)$|^[@]\w+[@]$)/ && &$pred ($val);
       return $val;
     });
}


# Check to make sure a source defined in LIBOBJS is not explicitly
# mentioned.  This is a separate function (as opposed to being inlined
# in handle_source_transform) because it isn't always appropriate to
# do this check.
sub check_libobjs_sources
{
  my ($one_file, $unxformed) = @_;

  foreach my $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
		      'dist_EXTRA_', 'nodist_EXTRA_')
    {
      my @files;
      my $varname = $prefix . $one_file . '_SOURCES';
      my $var = var ($varname);
      if ($var)
	{
	  @files = $var->value_as_list_recursive;
	}
      elsif ($prefix eq '')
	{
	  @files = ($unxformed . '.c');
	}
      else
	{
	  next;
	}

      foreach my $file (@files)
	{
	  err_var ($prefix . $one_file . '_SOURCES',
		   "automatically discovered file `$file' should not" .
		   " be explicitly mentioned")
	    if defined $libsources{$file};
	}
    }
}


# @OBJECTS
# handle_single_transform ($VAR, $TOPPARENT, $DERIVED, $OBJ, $FILE, %TRANSFORM)
# -----------------------------------------------------------------------------
# Does much of the actual work for handle_source_transform.
# Arguments are:
#   $VAR is the name of the variable that the source filenames come from
#   $TOPPARENT is the name of the _SOURCES variable which is being processed
#   $DERIVED is the name of resulting executable or library
#   $OBJ is the object extension (e.g., `$U.lo')
#   $FILE the source file to transform
#   %TRANSFORM contains extras arguments to pass to file_contents
#     when producing explicit rules
# Result is a list of the names of objects
# %linkers_used will be updated with any linkers needed
sub handle_single_transform ($$$$$%)
{
    my ($var, $topparent, $derived, $obj, $_file, %transform) = @_;
    my @files = ($_file);
    my @result = ();
    my $nonansi_obj = $obj;
    $nonansi_obj =~ s/\$U//g;

    # Turn sources into objects.  We use a while loop like this
    # because we might add to @files in the loop.
    while (scalar @files > 0)
    {
	$_ = shift @files;

	# Configure substitutions in _SOURCES variables are errors.
	if (/^\@.*\@$/)
	{
	  my $parent_msg = '';
	  $parent_msg = "\nand is referred to from `$topparent'"
	    if $topparent ne $var->name;
	  err_var ($var,
		   "`" . $var->name . "' includes configure substitution `$_'"
		   . $parent_msg . ";\nconfigure " .
		   "substitutions are not allowed in _SOURCES variables");
	  next;
	}

	# If the source file is in a subdirectory then the `.o' is put
	# into the current directory, unless the subdir-objects option
	# is in effect.

	# Split file name into base and extension.
	next if ! /^(?:(.*)\/)?([^\/]*)($KNOWN_EXTENSIONS_PATTERN)$/;
	my $full = $_;
	my $directory = $1 || '';
	my $base = $2;
	my $extension = $3;

	# We must generate a rule for the object if it requires its own flags.
	my $renamed = 0;
	my ($linker, $object);

	# This records whether we've seen a derived source file (e.g.
	# yacc output).
	my $derived_source = 0;

	# This holds the `aggregate context' of the file we are
	# currently examining.  If the file is compiled with
	# per-object flags, then it will be the name of the object.
	# Otherwise it will be `AM'.  This is used by the target hook
	# language function.
	my $aggregate = 'AM';

	$extension = &derive_suffix ($extension, $nonansi_obj);
	my $lang;
	if ($extension_map{$extension} &&
	    ($lang = $languages{$extension_map{$extension}}))
	{
	    # Found the language, so see what it says.
	    &saw_extension ($extension);

	    # Do we have per-executable flags for this executable?
	    my $have_per_exec_flags = 0;
	    my @peflags = @{$lang->flags};
	    push @peflags, 'LIBTOOLFLAGS' if $nonansi_obj eq '.lo';
	    foreach my $flag (@peflags)
	      {
		if (set_seen ("${derived}_$flag"))
		  {
		    $have_per_exec_flags = 1;
		    last;
		  }
	      }

	    # Note: computed subr call.  The language rewrite function
	    # should return one of the LANG_* constants.  It could
	    # also return a list whose first value is such a constant
	    # and whose second value is a new source extension which
	    # should be applied.  This means this particular language
	    # generates another source file which we must then process
	    # further.
	    my $subr = \&{'lang_' . $lang->name . '_rewrite'};
	    my ($r, $source_extension)
		= &$subr ($directory, $base, $extension,
			  $nonansi_obj, $have_per_exec_flags, $var);
	    # Skip this entry if we were asked not to process it.
	    next if $r == LANG_IGNORE;

	    # Now extract linker and other info.
	    $linker = $lang->linker;

	    my $this_obj_ext;
	    if (defined $source_extension)
	    {
		$this_obj_ext = $source_extension;
		$derived_source = 1;
	    }
	    elsif ($lang->ansi)
	    {
		$this_obj_ext = $obj;
	    }
	    else
	    {
		$this_obj_ext = $nonansi_obj;
	    }
	    $object = $base . $this_obj_ext;

	    if ($have_per_exec_flags)
	    {
		# We have a per-executable flag in effect for this
		# object.  In this case we rewrite the object's
		# name to ensure it is unique.

		# We choose the name `DERIVED_OBJECT' to ensure
		# (1) uniqueness, and (2) continuity between
		# invocations.  However, this will result in a
		# name that is too long for losing systems, in
		# some situations.  So we provide _SHORTNAME to
		# override.

		my $dname = $derived;
		my $var = var ($derived . '_SHORTNAME');
		if ($var)
		{
		    # FIXME: should use the same Condition as
		    # the _SOURCES variable.  But this is really
		    # silly overkill -- nobody should have
		    # conditional shortnames.
		    $dname = $var->variable_value;
		}
		$object = $dname . '-' . $object;

		prog_error ($lang->name . " flags defined without compiler")
		  if ! defined $lang->compile;

		$renamed = 1;
	    }

	    # If rewrite said it was ok, put the object into a
	    # subdir.
	    if ($r == LANG_SUBDIR && $directory ne '')
	    {
		$object = $directory . '/' . $object;
	    }

	    # If the object file has been renamed (because per-target
	    # flags are used) we cannot compile the file with an
	    # inference rule: we need an explicit rule.
	    #
	    # If the source is in a subdirectory and the object is in
	    # the current directory, we also need an explicit rule.
	    #
	    # If both source and object files are in a subdirectory
	    # (this happens when the subdir-objects option is used),
	    # then the inference will work.
	    #
	    # The latter case deserves a historical note.  When the
	    # subdir-objects option was added on 1999-04-11 it was
	    # thought that inferences rules would work for
	    # subdirectory objects too.  Later, on 1999-11-22,
	    # automake was changed to output explicit rules even for
	    # subdir-objects.  Nobody remembers why, but this occurred
	    # soon after the merge of the user-dep-gen-branch so it
	    # might be related.  In late 2003 people complained about
	    # the size of the generated Makefile.ins (libgcj, with
	    # 2200+ subdir objects was reported to have a 9MB
	    # Makefile), so we now rely on inference rules again.
	    # Maybe we'll run across the same issue as in the past,
	    # but at least this time we can document it.  However since
	    # dependency tracking has evolved it is possible that
	    # our old problem no longer exists.
	    # Using inference rules for subdir-objects has been tested
	    # with GNU make, Solaris make, Ultrix make, BSD make,
	    # HP-UX make, and OSF1 make successfully.
	    if ($renamed
		|| ($directory ne '' && ! option 'subdir-objects')
		# We must also use specific rules for a nodist_ source
		# if its language requests it.
		|| ($lang->nodist_specific && ! $transform{'DIST_SOURCE'}))
	    {
		my $obj_sans_ext = substr ($object, 0,
					   - length ($this_obj_ext));
		my $full_ansi;
		if ($directory ne '')
	          {
			$full_ansi = $directory . '/' . $base . $extension;
	          }
		else
	          {
			$full_ansi = $base . $extension;
	          }

		if ($lang->ansi && option 'ansi2knr')
		  {
		    $full_ansi =~ s/$KNOWN_EXTENSIONS_PATTERN$/\$U$&/;
		    $obj_sans_ext .= '$U';
		  }

		my @specifics = ($full_ansi, $obj_sans_ext,
				 # Only use $this_obj_ext in the derived
				 # source case because in the other case we
				 # *don't* want $(OBJEXT) to appear here.
				 ($derived_source ? $this_obj_ext : '.o'),
				 $extension);

		# If we renamed the object then we want to use the
		# per-executable flag name.  But if this is simply a
		# subdir build then we still want to use the AM_ flag
		# name.
		if ($renamed)
		  {
		    unshift @specifics, $derived;
		    $aggregate = $derived;
		  }
		else
		  {
		    unshift @specifics, 'AM';
		  }

		# Each item on this list is a reference to a list consisting
		# of four values followed by additional transform flags for
		# file_contents.   The four values are the derived flag prefix
		# (e.g. for `foo_CFLAGS', it is `foo'), the name of the
		# source file, the base name of the output file, and
		# the extension for the object file.
		push (@{$lang_specific_files{$lang->name}},
		      [@specifics, %transform]);
	    }
	}
	elsif ($extension eq $nonansi_obj)
	{
	    # This is probably the result of a direct suffix rule.
	    # In this case we just accept the rewrite.
	    $object = "$base$extension";
	    $object = "$directory/$object" if $directory ne '';
	    $linker = '';
	}
	else
	{
	    # No error message here.  Used to have one, but it was
	    # very unpopular.
	    # FIXME: we could potentially do more processing here,
	    # perhaps treating the new extension as though it were a
	    # new source extension (as above).  This would require
	    # more restructuring than is appropriate right now.
	    next;
	}

	err_am "object `$object' created by `$full' and `$object_map{$object}'"
	  if (defined $object_map{$object}
	      && $object_map{$object} ne $full);

	my $comp_val = (($object =~ /\.lo$/)
			? COMPILE_LIBTOOL : COMPILE_ORDINARY);
	(my $comp_obj = $object) =~ s/\.lo$/.\$(OBJEXT)/;
	if (defined $object_compilation_map{$comp_obj}
	    && $object_compilation_map{$comp_obj} != 0
	    # Only see the error once.
	    && ($object_compilation_map{$comp_obj}
		!= (COMPILE_LIBTOOL | COMPILE_ORDINARY))
	    && $object_compilation_map{$comp_obj} != $comp_val)
	  {
	    err_am "object `$comp_obj' created both with libtool and without";
	  }
	$object_compilation_map{$comp_obj} |= $comp_val;

	if (defined $lang)
	{
	    # Let the language do some special magic if required.
	    $lang->target_hook ($aggregate, $object, $full, %transform);
	}

	if ($derived_source)
	  {
	    prog_error ($lang->name . " has automatic dependency tracking")
	      if $lang->autodep ne 'no';
	    # Make sure this new source file is handled next.  That will
	    # make it appear to be at the right place in the list.
	    unshift (@files, $object);
	    # Distribute derived sources unless the source they are
	    # derived from is not.
	    &push_dist_common ($object)
	      unless ($topparent =~ /^(?:nobase_)?nodist_/);
	    next;
	  }

	$linkers_used{$linker} = 1;

	push (@result, $object);

	if (! defined $object_map{$object})
	{
	    my @dep_list = ();
	    $object_map{$object} = $full;

	    # If resulting object is in subdir, we need to make
	    # sure the subdir exists at build time.
	    if ($object =~ /\//)
	    {
		# FIXME: check that $DIRECTORY is somewhere in the
		# project

		# For Java, the way we're handling it right now, a
		# `..' component doesn't make sense.
		if ($lang && $lang->name eq 'java' && $object =~ /(\/|^)\.\.\//)
		  {
		    err_am "`$full' should not contain a `..' component";
		  }

		# Make sure object is removed by `make mostlyclean'.
		$compile_clean_files{$object} = MOSTLY_CLEAN;
		# If we have a libtool object then we also must remove
		# the ordinary .o.
		if ($object =~ /\.lo$/)
		{
		    (my $xobj = $object) =~ s,lo$,\$(OBJEXT),;
		    $compile_clean_files{$xobj} = MOSTLY_CLEAN;

		    # Remove any libtool object in this directory.
		    $libtool_clean_directories{$directory} = 1;
		}

		push (@dep_list, require_build_directory ($directory));

		# If we're generating dependencies, we also want
		# to make sure that the appropriate subdir of the
		# .deps directory is created.
		push (@dep_list,
		      require_build_directory ($directory . '/$(DEPDIR)'))
		  unless option 'no-dependencies';
	    }

	    &pretty_print_rule ($object . ':', "\t", @dep_list)
		if scalar @dep_list > 0;
	}

	# Transform .o or $o file into .P file (for automatic
	# dependency code).
	if ($lang && $lang->autodep ne 'no')
	{
	    my $depfile = $object;
	    $depfile =~ s/\.([^.]*)$/.P$1/;
	    $depfile =~ s/\$\(OBJEXT\)$/o/;
	    $dep_files{dirname ($depfile) . '/$(DEPDIR)/'
			 . basename ($depfile)} = 1;
	}
    }

    return @result;
}


# $LINKER
# define_objects_from_sources ($VAR, $OBJVAR, $NODEFINE, $ONE_FILE,
#                              $OBJ, $PARENT, $TOPPARENT, $WHERE, %TRANSFORM)
# ---------------------------------------------------------------------------
# Define an _OBJECTS variable for a _SOURCES variable (or subvariable)
#
# Arguments are:
#   $VAR is the name of the _SOURCES variable
#   $OBJVAR is the name of the _OBJECTS variable if known (otherwise
#     it will be generated and returned).
#   $NODEFINE is a boolean: if true, $OBJVAR will not be defined (but
#     work done to determine the linker will be).
#   $ONE_FILE is the canonical (transformed) name of object to build
#   $OBJ is the object extension (i.e. either `.o' or `.lo').
#   $TOPPARENT is the _SOURCES variable being processed.
#   $WHERE context into which this definition is done
#   %TRANSFORM extra arguments to pass to file_contents when producing
#     rules
#
# Result is a pair ($LINKER, $OBJVAR):
#    $LINKER is a boolean, true if a linker is needed to deal with the objects
sub define_objects_from_sources ($$$$$$$%)
{
  my ($var, $objvar, $nodefine, $one_file,
      $obj, $topparent, $where, %transform) = @_;

  my $needlinker = "";

  transform_variable_recursively
    ($var, $objvar, 'am__objects', $nodefine, $where,
     # The transform code to run on each filename.
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;
       my @trans = handle_single_transform ($subvar, $topparent,
					    $one_file, $obj, $val,
					    %transform);
       $needlinker = "true" if @trans;
       return @trans;
     });

  return $needlinker;
}


# handle_source_transform ($CANON_TARGET, $TARGET, $OBJEXT, $WHERE, %TRANSFORM)
# -----------------------------------------------------------------------------
# Handle SOURCE->OBJECT transform for one program or library.
# Arguments are:
#   canonical (transformed) name of target to build
#   actual target of object to build
#   object extension (i.e., either `.o' or `$o')
#   location of the source variable
#   extra arguments to pass to file_contents when producing rules
# Return the name of the linker variable that must be used.
# Empty return means just use `LINK'.
sub handle_source_transform ($$$$%)
{
    # one_file is canonical name.  unxformed is given name.  obj is
    # object extension.
    my ($one_file, $unxformed, $obj, $where, %transform) = @_;

    my $linker = '';

    # No point in continuing if _OBJECTS is defined.
    return if reject_var ($one_file . '_OBJECTS',
			  $one_file . '_OBJECTS should not be defined');

    my %used_pfx = ();
    my $needlinker;
    %linkers_used = ();
    foreach my $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
			'dist_EXTRA_', 'nodist_EXTRA_')
    {
	my $varname = $prefix . $one_file . "_SOURCES";
	my $var = var $varname;
	next unless $var;

	# We are going to define _OBJECTS variables using the prefix.
	# Then we glom them all together.  So we can't use the null
	# prefix here as we need it later.
	my $xpfx = ($prefix eq '') ? 'am_' : $prefix;

	# Keep track of which prefixes we saw.
	$used_pfx{$xpfx} = 1
	  unless $prefix =~ /EXTRA_/;

	push @sources, "\$($varname)";
	push @dist_sources, shadow_unconditionally ($varname, $where)
	  unless (option ('no-dist') || $prefix =~ /^nodist_/);

	$needlinker |=
	    define_objects_from_sources ($varname,
					 $xpfx . $one_file . '_OBJECTS',
					 $prefix =~ /EXTRA_/,
					 $one_file, $obj, $varname, $where,
					 DIST_SOURCE => ($prefix !~ /^nodist_/),
					 %transform);
    }
    if ($needlinker)
    {
	$linker ||= &resolve_linker (%linkers_used);
    }

    my @keys = sort keys %used_pfx;
    if (scalar @keys == 0)
    {
	# The default source for libfoo.la is libfoo.c, but for
	# backward compatibility we first look at libfoo_la.c,
	# if no default source suffix is given.
	my $old_default_source = "$one_file.c";
	my $ext_var = var ('AM_DEFAULT_SOURCE_EXT');
	my $default_source_ext = $ext_var ? variable_value ($ext_var) : '.c';
	msg_var ('unsupported', $ext_var, $ext_var->name . " can assume at most one value")
	  if $default_source_ext =~ /[\t ]/;
	(my $default_source = $unxformed) =~ s,(\.[^./\\]*)?$,$default_source_ext,;
	if ($old_default_source ne $default_source
	    && !$ext_var
	    && (rule $old_default_source
		|| rule '$(srcdir)/' . $old_default_source
		|| rule '${srcdir}/' . $old_default_source
		|| -f $old_default_source))
	  {
	    my $loc = $where->clone;
	    $loc->pop_context;
	    msg ('obsolete', $loc,
		 "the default source for `$unxformed' has been changed "
		 . "to `$default_source'.\n(Using `$old_default_source' for "
		 . "backward compatibility.)");
	    $default_source = $old_default_source;
	  }
	# If a rule exists to build this source with a $(srcdir)
	# prefix, use that prefix in our variables too.  This is for
	# the sake of BSD Make.
	if (rule '$(srcdir)/' . $default_source
	    || rule '${srcdir}/' . $default_source)
	  {
	    $default_source = '$(srcdir)/' . $default_source;
	  }

	&define_variable ($one_file . "_SOURCES", $default_source, $where);
	push (@sources, $default_source);
	push (@dist_sources, $default_source);

	%linkers_used = ();
	my (@result) =
	  handle_single_transform ($one_file . '_SOURCES',
				   $one_file . '_SOURCES',
				   $one_file, $obj,
				   $default_source, %transform);
	$linker ||= &resolve_linker (%linkers_used);
	define_pretty_variable ($one_file . '_OBJECTS', TRUE, $where, @result);
    }
    else
    {
	@keys = map { '$(' . $_ . $one_file . '_OBJECTS)' } @keys;
	define_pretty_variable ($one_file . '_OBJECTS', TRUE, $where, @keys);
    }

    # If we want to use `LINK' we must make sure it is defined.
    if ($linker eq '')
    {
	$need_link = 1;
    }

    return $linker;
}


# handle_lib_objects ($XNAME, $VAR)
# ---------------------------------
# Special-case ALLOCA and LIBOBJS substitutions in _LDADD or _LIBADD variables.
# Also, generate _DEPENDENCIES variable if appropriate.
# Arguments are:
#   transformed name of object being built, or empty string if no object
#   name of _LDADD/_LIBADD-type variable to examine
# Returns 1 if LIBOBJS seen, 0 otherwise.
sub handle_lib_objects
{
  my ($xname, $varname) = @_;

  my $var = var ($varname);
  prog_error "handle_lib_objects: `$varname' undefined"
    unless $var;
  prog_error "handle_lib_objects: unexpected variable name `$varname'"
    unless $varname =~ /^(.*)(?:LIB|LD)ADD$/;
  my $prefix = $1 || 'AM_';

  my $seen_libobjs = 0;
  my $flagvar = 0;

  transform_variable_recursively
    ($varname, $xname . '_DEPENDENCIES', 'am__DEPENDENCIES',
     ! $xname, INTERNAL,
     # Transformation function, run on each filename.
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;

       if ($val =~ /^-/)
	 {
	   # Skip -lfoo and -Ldir silently; these are explicitly allowed.
	   if ($val !~ /^-[lL]/ &&
	       # Skip -dlopen and -dlpreopen; these are explicitly allowed
	       # for Libtool libraries or programs.  (Actually we are a bit
	       # laxe here since this code also applies to non-libtool
	       # libraries or programs, for which -dlopen and -dlopreopen
	       # are pure nonsense.  Diagnosing this doesn't seem very
	       # important: the developer will quickly get complaints from
	       # the linker.)
	       $val !~ /^-dl(?:pre)?open$/ &&
	       # Only get this error once.
	       ! $flagvar)
	     {
	       $flagvar = 1;
	       # FIXME: should display a stack of nested variables
	       # as context when $var != $subvar.
	       err_var ($var, "linker flags such as `$val' belong in "
			. "`${prefix}LDFLAGS");
	     }
	   return ();
	 }
       elsif ($val !~ /^\@.*\@$/)
	 {
	   # Assume we have a file of some sort, and output it into the
	   # dependency variable.  Autoconf substitutions are not output;
	   # rarely is a new dependency substituted into e.g. foo_LDADD
	   # -- but bad things (e.g. -lX11) are routinely substituted.
	   # Note that LIBOBJS and ALLOCA are exceptions to this rule,
	   # and handled specially below.
	   return $val;
	 }
       elsif ($val =~ /^\@(LT)?LIBOBJS\@$/)
	 {
	   handle_LIBOBJS ($subvar, $cond, $1);
	   $seen_libobjs = 1;
	   return $val;
	 }
       elsif ($val =~ /^\@(LT)?ALLOCA\@$/)
	 {
	   handle_ALLOCA ($subvar, $cond, $1);
	   return $val;
	 }
       else
	 {
	   return ();
	 }
     });

  return $seen_libobjs;
}

# handle_LIBOBJS_or_ALLOCA ($VAR)
# -------------------------------
# Definitions common to LIBOBJS and ALLOCA.
# VAR should be one of LIBOBJS, LTLIBOBJS, ALLOCA, or LTALLOCA.
sub handle_LIBOBJS_or_ALLOCA ($)
{
  my ($var) = @_;

  my $dir = '';

  # If LIBOBJS files must be built in another directory we have
  # to define LIBOBJDIR and ensure the files get cleaned.
  # Otherwise LIBOBJDIR can be left undefined, and the cleaning
  # is achieved by `rm -f *.$(OBJEXT)' in compile.am.
  if ($config_libobj_dir
      && $relative_dir ne $config_libobj_dir)
    {
      if (option 'subdir-objects')
	{
	  # In the top-level Makefile we do not use $(top_builddir), because
	  # we are already there, and since the targets are built without
	  # a $(top_builddir), it helps BSD Make to match them with
	  # dependencies.
	  $dir = "$config_libobj_dir/" if $config_libobj_dir ne '.';
	  $dir = "$topsrcdir/$dir" if $relative_dir ne '.';
	  define_variable ('LIBOBJDIR', "$dir", INTERNAL);
	  $clean_files{"\$($var)"} = MOSTLY_CLEAN;
	  # If LTLIBOBJS is used, we must also clear LIBOBJS (which might
	  # be created by libtool as a side-effect of creating LTLIBOBJS).
	  $clean_files{"\$($var)"} = MOSTLY_CLEAN if $var =~ s/^LT//;
	}
      else
	{
	  error ("`\$($var)' cannot be used outside `$config_libobj_dir' if"
		 . " `subdir-objects' is not set");
	}
    }

  return $dir;
}

sub handle_LIBOBJS ($$$)
{
  my ($var, $cond, $lt) = @_;
  my $myobjext = $lt ? 'lo' : 'o';
  $lt ||= '';

  $var->requires_variables ("\@${lt}LIBOBJS\@ used", $lt . 'LIBOBJS')
    if ! keys %libsources;

  my $dir = handle_LIBOBJS_or_ALLOCA "${lt}LIBOBJS";

  foreach my $iter (keys %libsources)
    {
      if ($iter =~ /\.[cly]$/)
	{
	  &saw_extension ($&);
	  &saw_extension ('.c');
	}

      if ($iter =~ /\.h$/)
	{
	  require_libsource_with_macro ($cond, $var, FOREIGN, $iter);
	}
      elsif ($iter ne 'alloca.c')
	{
	  my $rewrite = $iter;
	  $rewrite =~ s/\.c$/.P$myobjext/;
	  $dep_files{$dir . '$(DEPDIR)/' . $rewrite} = 1;
	  $rewrite = "^" . quotemeta ($iter) . "\$";
	  # Only require the file if it is not a built source.
	  my $bs = var ('BUILT_SOURCES');
	  if (! $bs || ! grep (/$rewrite/, $bs->value_as_list_recursive))
	    {
	      require_libsource_with_macro ($cond, $var, FOREIGN, $iter);
	    }
	}
    }
}

sub handle_ALLOCA ($$$)
{
  my ($var, $cond, $lt) = @_;
  my $myobjext = $lt ? 'lo' : 'o';
  $lt ||= '';
  my $dir = handle_LIBOBJS_or_ALLOCA "${lt}ALLOCA";

  $var->requires_variables ("\@${lt}ALLOCA\@ used", $lt . 'ALLOCA');
  $dep_files{$dir . '$(DEPDIR)/alloca.P' . $myobjext} = 1;
  require_libsource_with_macro ($cond, $var, FOREIGN, 'alloca.c');
  &saw_extension ('.c');
}

# Canonicalize the input parameter
sub canonicalize
{
    my ($string) = @_;
    $string =~ tr/A-Za-z0-9_\@/_/c;
    return $string;
}

# Canonicalize a name, and check to make sure the non-canonical name
# is never used.  Returns canonical name.  Arguments are name and a
# list of suffixes to check for.
sub check_canonical_spelling
{
  my ($name, @suffixes) = @_;

  my $xname = &canonicalize ($name);
  if ($xname ne $name)
    {
      foreach my $xt (@suffixes)
	{
	  reject_var ("$name$xt", "use `$xname$xt', not `$name$xt'");
	}
    }

  return $xname;
}


# handle_compile ()
# -----------------
# Set up the compile suite.
sub handle_compile ()
{
    return
      unless $get_object_extension_was_run;

    # Boilerplate.
    my $default_includes = '';
    if (! option 'nostdinc')
      {
	my @incs = ('-I.', subst ('am__isrc'));

	my $var = var 'CONFIG_HEADER';
	if ($var)
	  {
	    foreach my $hdr (split (' ', $var->variable_value))
	      {
		push @incs, '-I' . dirname ($hdr);
	      }
	  }
	# We want `-I. -I$(srcdir)', but the latter -I is redundant
	# and unaesthetic in non-VPATH builds.  We use `-I.@am__isrc@`
	# instead.  It will be replaced by '-I.' or '-I. -I$(srcdir)'.
	# Items in CONFIG_HEADER are never in $(srcdir) so it is safe
	# to just put @am__isrc@ right after `-I.', without a space.
	($default_includes = ' ' . uniq (@incs)) =~ s/ @/@/;
      }

    my (@mostly_rms, @dist_rms);
    foreach my $item (sort keys %compile_clean_files)
    {
	if ($compile_clean_files{$item} == MOSTLY_CLEAN)
	{
	    push (@mostly_rms, "\t-rm -f $item");
	}
	elsif ($compile_clean_files{$item} == DIST_CLEAN)
	{
	    push (@dist_rms, "\t-rm -f $item");
	}
	else
	{
	  prog_error 'invalid entry in %compile_clean_files';
	}
    }

    my ($coms, $vars, $rules) =
      &file_contents_internal (1, "$libdir/am/compile.am",
			       new Automake::Location,
			       ('DEFAULT_INCLUDES' => $default_includes,
				'MOSTLYRMS' => join ("\n", @mostly_rms),
				'DISTRMS' => join ("\n", @dist_rms)));
    $output_vars .= $vars;
    $output_rules .= "$coms$rules";

    # Check for automatic de-ANSI-fication.
    if (option 'ansi2knr')
      {
	my ($ansi2knr_filename, $ansi2knr_where) = @{option 'ansi2knr'};
	my $ansi2knr_dir = '';

	require_variables ($ansi2knr_where, "option `ansi2knr' is used",
			   TRUE, "ANSI2KNR", "U");

	# topdir is where ansi2knr should be.
	if ($ansi2knr_filename eq 'ansi2knr')
	  {
	    # Only require ansi2knr files if they should appear in
	    # this directory.
	    require_file ($ansi2knr_where, FOREIGN,
			  'ansi2knr.c', 'ansi2knr.1');

	    # ansi2knr needs to be built before subdirs, so unshift it.
	    unshift (@all, '$(ANSI2KNR)');
	  }
	else
	  {
	    $ansi2knr_dir = dirname ($ansi2knr_filename);
	  }

	$output_rules .= &file_contents ('ansi2knr',
					 new Automake::Location,
					 'ANSI2KNR-DIR' => $ansi2knr_dir);

    }
}

# handle_libtool ()
# -----------------
# Handle libtool rules.
sub handle_libtool
{
  return unless var ('LIBTOOL');

  # Libtool requires some files, but only at top level.
  # (Starting with Libtool 2.0 we do not have to bother.  These
  # requirements are done with AC_REQUIRE_AUX_FILE.)
  require_conf_file_with_macro (TRUE, 'LIBTOOL', FOREIGN, @libtool_files)
    if $relative_dir eq '.' && ! $libtool_new_api;

  my @libtool_rms;
  foreach my $item (sort keys %libtool_clean_directories)
    {
      my $dir = ($item eq '.') ? '' : "$item/";
      # .libs is for Unix, _libs for DOS.
      push (@libtool_rms, "\t-rm -rf ${dir}.libs ${dir}_libs");
    }

  check_user_variables 'LIBTOOLFLAGS';

  # Output the libtool compilation rules.
  $output_rules .= &file_contents ('libtool',
				   new Automake::Location,
				   LTRMS => join ("\n", @libtool_rms));
}

# handle_programs ()
# ------------------
# Handle C programs.
sub handle_programs
{
  my @proglist = &am_install_var ('progs', 'PROGRAMS',
				  'bin', 'sbin', 'libexec', 'pkglib',
				  'noinst', 'check');
  return if ! @proglist;

  my $seen_global_libobjs =
    var ('LDADD') && &handle_lib_objects ('', 'LDADD');

  foreach my $pair (@proglist)
    {
      my ($where, $one_file) = @$pair;

      my $seen_libobjs = 0;
      my $obj = get_object_extension '.$(OBJEXT)';

      $known_programs{$one_file} = $where;

      # Canonicalize names and check for misspellings.
      my $xname = &check_canonical_spelling ($one_file, '_LDADD', '_LDFLAGS',
					     '_SOURCES', '_OBJECTS',
					     '_DEPENDENCIES');

      $where->push_context ("while processing program `$one_file'");
      $where->set (INTERNAL->get);

      my $linker = &handle_source_transform ($xname, $one_file, $obj, $where,
					     NONLIBTOOL => 1, LIBTOOL => 0);

      if (var ($xname . "_LDADD"))
	{
	  $seen_libobjs = &handle_lib_objects ($xname, $xname . '_LDADD');
	}
      else
	{
	  # User didn't define prog_LDADD override.  So do it.
	  &define_variable ($xname . '_LDADD', '$(LDADD)', $where);

	  # This does a bit too much work.  But we need it to
	  # generate _DEPENDENCIES when appropriate.
	  if (var ('LDADD'))
	    {
	      $seen_libobjs = &handle_lib_objects ($xname, 'LDADD');
	    }
	}

      reject_var ($xname . '_LIBADD',
		  "use `${xname}_LDADD', not `${xname}_LIBADD'");

      set_seen ($xname . '_DEPENDENCIES');
      set_seen ($xname . '_LDFLAGS');

      # Determine program to use for link.
      my($xlink, $vlink) = &define_per_target_linker_variable ($linker, $xname);
      $vlink = verbose_flag ($vlink || 'GEN');

      # If the resulting program lies into a subdirectory,
      # make sure this directory will exist.
      my $dirstamp = require_build_directory_maybe ($one_file);

      $libtool_clean_directories{dirname ($one_file)} = 1;

      $output_rules .= &file_contents ('program',
				       $where,
				       PROGRAM  => $one_file,
				       XPROGRAM => $xname,
				       XLINK    => $xlink,
				       VERBOSE  => $vlink,
				       DIRSTAMP => $dirstamp,
				       EXEEXT   => '$(EXEEXT)');

      if ($seen_libobjs || $seen_global_libobjs)
	{
	  if (var ($xname . '_LDADD'))
	    {
	      &check_libobjs_sources ($xname, $xname . '_LDADD');
	    }
	  elsif (var ('LDADD'))
	    {
	      &check_libobjs_sources ($xname, 'LDADD');
	    }
	}
    }
}


# handle_libraries ()
# -------------------
# Handle libraries.
sub handle_libraries
{
  my @liblist = &am_install_var ('libs', 'LIBRARIES',
				 'lib', 'pkglib', 'noinst', 'check');
  return if ! @liblist;

  my @prefix = am_primary_prefixes ('LIBRARIES', 0, 'lib', 'pkglib',
				    'noinst', 'check');

  if (@prefix)
    {
      my $var = rvar ($prefix[0] . '_LIBRARIES');
      $var->requires_variables ('library used', 'RANLIB');
    }

  &define_variable ('AR', 'ar', INTERNAL);
  &define_variable ('ARFLAGS', 'cru', INTERNAL);
  &define_verbose_tagvar ('AR');

  foreach my $pair (@liblist)
    {
      my ($where, $onelib) = @$pair;

      my $seen_libobjs = 0;
      # Check that the library fits the standard naming convention.
      my $bn = basename ($onelib);
      if ($bn !~ /^lib.*\.a$/)
	{
	  $bn =~ s/^(?:lib)?(.*?)(?:\.[^.]*)?$/lib$1.a/;
	  my $suggestion = dirname ($onelib) . "/$bn";
	  $suggestion =~ s|^\./||g;
	  msg ('error-gnu/warn', $where,
	       "`$onelib' is not a standard library name\n"
	       . "did you mean `$suggestion'?")
	}

      ($known_libraries{$onelib} = $bn) =~ s/\.a$//;

      $where->push_context ("while processing library `$onelib'");
      $where->set (INTERNAL->get);

      my $obj = get_object_extension '.$(OBJEXT)';

      # Canonicalize names and check for misspellings.
      my $xlib = &check_canonical_spelling ($onelib, '_LIBADD', '_SOURCES',
					    '_OBJECTS', '_DEPENDENCIES',
					    '_AR');

      if (! var ($xlib . '_AR'))
	{
	  &define_variable ($xlib . '_AR', '$(AR) $(ARFLAGS)', $where);
	}

      # Generate support for conditional object inclusion in
      # libraries.
      if (var ($xlib . '_LIBADD'))
	{
	  if (&handle_lib_objects ($xlib, $xlib . '_LIBADD'))
	    {
	      $seen_libobjs = 1;
	    }
	}
      else
	{
	  &define_variable ($xlib . "_LIBADD", '', $where);
	}

      reject_var ($xlib . '_LDADD',
		  "use `${xlib}_LIBADD', not `${xlib}_LDADD'");

      # Make sure we at look at this.
      set_seen ($xlib . '_DEPENDENCIES');

      &handle_source_transform ($xlib, $onelib, $obj, $where,
				NONLIBTOOL => 1, LIBTOOL => 0);

      # If the resulting library lies into a subdirectory,
      # make sure this directory will exist.
      my $dirstamp = require_build_directory_maybe ($onelib);
      my $verbose = verbose_flag ('AR');
      my $silent = silent_flag ();

      $output_rules .= &file_contents ('library',
				       $where,
				       VERBOSE  => $verbose,
				       SILENT   => $silent,
				       LIBRARY  => $onelib,
				       XLIBRARY => $xlib,
				       DIRSTAMP => $dirstamp);

      if ($seen_libobjs)
	{
	  if (var ($xlib . '_LIBADD'))
	    {
	      &check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}
    }
}


# handle_ltlibraries ()
# ---------------------
# Handle shared libraries.
sub handle_ltlibraries
{
  my @liblist = &am_install_var ('ltlib', 'LTLIBRARIES',
				 'noinst', 'lib', 'pkglib', 'check');
  return if ! @liblist;

  my @prefix = am_primary_prefixes ('LTLIBRARIES', 0, 'lib', 'pkglib',
				    'noinst', 'check');

  if (@prefix)
    {
      my $var = rvar ($prefix[0] . '_LTLIBRARIES');
      $var->requires_variables ('Libtool library used', 'LIBTOOL');
    }

  my %instdirs = ();
  my %instsubdirs = ();
  my %instconds = ();
  my %liblocations = ();	# Location (in Makefile.am) of each library.

  foreach my $key (@prefix)
    {
      # Get the installation directory of each library.
      my $dir = $key;
      my $strip_subdir = 1;
      if ($dir =~ /^nobase_/)
        {
	  $dir =~ s/^nobase_//;
	  $strip_subdir = 0;
	}
      my $var = rvar ($key . '_LTLIBRARIES');

      # We reject libraries which are installed in several places
      # in the same condition, because we can only specify one
      # `-rpath' option.
      $var->traverse_recursively
	(sub
	 {
	   my ($var, $val, $cond, $full_cond) = @_;
	   my $hcond = $full_cond->human;
	   my $where = $var->rdef ($cond)->location;
	   my $ldir = '';
	   $ldir = '/' . dirname ($val)
	     if (!$strip_subdir);
	   # A library cannot be installed in different directories
	   # in overlapping conditions.
	   if (exists $instconds{$val})
	     {
	       my ($msg, $acond) =
		 $instconds{$val}->ambiguous_p ($val, $full_cond);

	       if ($msg)
		 {
		   error ($where, $msg, partial => 1);
		   my $dirtxt = "installed " . ($strip_subdir ? "in" : "below") . " `$dir'";
		   $dirtxt = "built for `$dir'"
		     if $dir eq 'EXTRA' || $dir eq 'noinst' || $dir eq 'check';
		   my $dircond =
		     $full_cond->true ? "" : " in condition $hcond";

		   error ($where, "`$val' should be $dirtxt$dircond ...",
			  partial => 1);

		   my $hacond = $acond->human;
		   my $adir = $instdirs{$val}{$acond};
		   my $adirtxt = "installed in `$adir'";
		   $adirtxt = "built for `$adir'"
		     if ($adir eq 'EXTRA' || $adir eq 'noinst'
			 || $adir eq 'check');
		   my $adircond = $acond->true ? "" : " in condition $hacond";

		   my $onlyone = ($dir ne $adir) ?
		     ("\nLibtool libraries can be built for only one "
		      . "destination.") : "";

		   error ($liblocations{$val}{$acond},
			  "... and should also be $adirtxt$adircond.$onlyone");
		   return;
		 }
	     }
	   else
	     {
	       $instconds{$val} = new Automake::DisjConditions;
	     }
	   $instdirs{$val}{$full_cond} = $dir;
	   $instsubdirs{$val}{$full_cond} = $ldir;
	   $liblocations{$val}{$full_cond} = $where;
	   $instconds{$val} = $instconds{$val}->merge ($full_cond);
	 },
	 sub
	 {
	   return ();
	 },
	 skip_ac_subst => 1);
    }

  foreach my $pair (@liblist)
    {
      my ($where, $onelib) = @$pair;

      my $seen_libobjs = 0;
      my $obj = get_object_extension '.lo';

      # Canonicalize names and check for misspellings.
      my $xlib = &check_canonical_spelling ($onelib, '_LIBADD', '_LDFLAGS',
					    '_SOURCES', '_OBJECTS',
					    '_DEPENDENCIES');

      # Check that the library fits the standard naming convention.
      my $libname_rx = '^lib.*\.la';
      my $ldvar = var ("${xlib}_LDFLAGS") || var ('AM_LDFLAGS');
      my $ldvar2 = var ('LDFLAGS');
      if (($ldvar && grep (/-module/, $ldvar->value_as_list_recursive))
	  || ($ldvar2 && grep (/-module/, $ldvar2->value_as_list_recursive)))
	{
	  # Relax name checking for libtool modules.
	  $libname_rx = '\.la';
	}

      my $bn = basename ($onelib);
      if ($bn !~ /$libname_rx$/)
	{
	  my $type = 'library';
	  if ($libname_rx eq '\.la')
	    {
	      $bn =~ s/^(lib|)(.*?)(?:\.[^.]*)?$/$1$2.la/;
	      $type = 'module';
	    }
	  else
	    {
	      $bn =~ s/^(?:lib)?(.*?)(?:\.[^.]*)?$/lib$1.la/;
	    }
	  my $suggestion = dirname ($onelib) . "/$bn";
	  $suggestion =~ s|^\./||g;
	  msg ('error-gnu/warn', $where,
	       "`$onelib' is not a standard libtool $type name\n"
	       . "did you mean `$suggestion'?")
	}

      ($known_libraries{$onelib} = $bn) =~ s/\.la$//;

      $where->push_context ("while processing Libtool library `$onelib'");
      $where->set (INTERNAL->get);

      # Make sure we look at these.
      set_seen ($xlib . '_LDFLAGS');
      set_seen ($xlib . '_DEPENDENCIES');

      # Generate support for conditional object inclusion in
      # libraries.
      if (var ($xlib . '_LIBADD'))
	{
	  if (&handle_lib_objects ($xlib, $xlib . '_LIBADD'))
	    {
	      $seen_libobjs = 1;
	    }
	}
      else
	{
	  &define_variable ($xlib . "_LIBADD", '', $where);
	}

      reject_var ("${xlib}_LDADD",
		  "use `${xlib}_LIBADD', not `${xlib}_LDADD'");


      my $linker = &handle_source_transform ($xlib, $onelib, $obj, $where,
					     NONLIBTOOL => 0, LIBTOOL => 1);

      # Determine program to use for link.
      my($xlink, $vlink) = &define_per_target_linker_variable ($linker, $xlib);
      $vlink = verbose_flag ($vlink || 'GEN');

      my $rpathvar = "am_${xlib}_rpath";
      my $rpath = "\$($rpathvar)";
      foreach my $rcond ($instconds{$onelib}->conds)
	{
	  my $val;
	  if ($instdirs{$onelib}{$rcond} eq 'EXTRA'
	      || $instdirs{$onelib}{$rcond} eq 'noinst'
	      || $instdirs{$onelib}{$rcond} eq 'check')
	    {
	      # It's an EXTRA_ library, so we can't specify -rpath,
	      # because we don't know where the library will end up.
	      # The user probably knows, but generally speaking automake
	      # doesn't -- and in fact configure could decide
	      # dynamically between two different locations.
	      $val = '';
	    }
	  else
	    {
	      $val = ('-rpath $(' . $instdirs{$onelib}{$rcond} . 'dir)');
	      $val .= $instsubdirs{$onelib}{$rcond}
	        if defined $instsubdirs{$onelib}{$rcond};
	    }
	  if ($rcond->true)
	    {
	      # If $rcond is true there is only one condition and
	      # there is no point defining an helper variable.
	      $rpath = $val;
	    }
	  else
	    {
	      define_pretty_variable ($rpathvar, $rcond, INTERNAL, $val);
	    }
	}

      # If the resulting library lies into a subdirectory,
      # make sure this directory will exist.
      my $dirstamp = require_build_directory_maybe ($onelib);

      # Remember to cleanup .libs/ in this directory.
      my $dirname = dirname $onelib;
      $libtool_clean_directories{$dirname} = 1;

      $output_rules .= &file_contents ('ltlibrary',
				       $where,
				       LTLIBRARY  => $onelib,
				       XLTLIBRARY => $xlib,
				       RPATH      => $rpath,
				       XLINK      => $xlink,
				       VERBOSE    => $vlink,
				       DIRSTAMP   => $dirstamp);
      if ($seen_libobjs)
	{
	  if (var ($xlib . '_LIBADD'))
	    {
	      &check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}
    }
}

# See if any _SOURCES variable were misspelled.
sub check_typos ()
{
  # It is ok if the user sets this particular variable.
  set_seen 'AM_LDFLAGS';

  foreach my $primary ('SOURCES', 'LIBADD', 'LDADD', 'LDFLAGS', 'DEPENDENCIES')
    {
      foreach my $var (variables $primary)
	{
	  my $varname = $var->name;
	  # A configure variable is always legitimate.
	  next if exists $configure_vars{$varname};

	  for my $cond ($var->conditions->conds)
	    {
	      $varname =~ /^(?:nobase_)?(?:dist_|nodist_)?(.*)_[[:alnum:]]+$/;
	      msg_var ('syntax', $var, "variable `$varname' is defined but no"
		       . " program or\nlibrary has `$1' as canonical name"
		       . " (possible typo)")
		unless $var->rdef ($cond)->seen;
	    }
	}
    }
}


# Handle scripts.
sub handle_scripts
{
    # NOTE we no longer automatically clean SCRIPTS, because it is
    # useful to sometimes distribute scripts verbatim.  This happens
    # e.g. in Automake itself.
    &am_install_var ('-candist', 'scripts', 'SCRIPTS',
		     'bin', 'sbin', 'libexec', 'pkgdata',
		     'noinst', 'check');
}




## ------------------------ ##
## Handling Texinfo files.  ##
## ------------------------ ##

# ($OUTFILE, $VFILE, @CLEAN_FILES)
# &scan_texinfo_file ($FILENAME)
# ------------------------------
# $OUTFILE     - name of the info file produced by $FILENAME.
# $VFILE       - name of the version.texi file used (undef if none).
# @CLEAN_FILES - list of byproducts (indexes etc.)
sub scan_texinfo_file ($)
{
  my ($filename) = @_;

  # Some of the following extensions are always created, no matter
  # whether indexes are used or not.  Other (like cps, fns, ... pgs)
  # are only created when they are used.  We used to scan $FILENAME
  # for their use, but that is not enough: they could be used in
  # included files.  We can't scan included files because we don't
  # know the include path.  Therefore we always erase these files, no
  # matter whether they are used or not.
  #
  # (tmp is only created if an @macro is used and a certain e-TeX
  # feature is not available.)
  my %clean_suffixes =
    map { $_ => 1 } (qw(aux log toc tmp
			cp cps
			fn fns
			ky kys
			vr vrs
			tp tps
			pg pgs)); # grep 'new.*index' texinfo.tex

  my $texi = new Automake::XFile "< $filename";
  verb "reading $filename";

  my ($outfile, $vfile);
  while ($_ = $texi->getline)
    {
      if (/^\@setfilename +(\S+)/)
	{
	  # Honor only the first @setfilename.  (It's possible to have
	  # more occurrences later if the manual shows examples of how
	  # to use @setfilename...)
	  next if $outfile;

	  $outfile = $1;
	  if ($outfile =~ /\.([^.]+)$/ && $1 ne 'info')
	    {
	      error ("$filename:$.",
		     "output `$outfile' has unrecognized extension");
	      return;
	    }
	}
      # A "version.texi" file is actually any file whose name matches
      # "vers*.texi".
      elsif (/^\@include\s+(vers[^.]*\.texi)\s*$/)
	{
	  $vfile = $1;
	}

      # Try to find new or unused indexes.

      # Creating a new category of index.
      elsif (/^\@def(code)?index (\w+)/)
	{
	  $clean_suffixes{$2} = 1;
	  $clean_suffixes{"$2s"} = 1;
	}

      # Merging an index into an another.
      elsif (/^\@syn(code)?index (\w+) (\w+)/)
	{
	  delete $clean_suffixes{"$2s"};
	  $clean_suffixes{"$3s"} = 1;
	}

    }

  if (! $outfile)
    {
      err_am "`$filename' missing \@setfilename";
      return;
    }

  my $infobase = basename ($filename);
  $infobase =~ s/\.te?xi(nfo)?$//;
  return ($outfile, $vfile,
	  map { "$infobase.$_" } (sort keys %clean_suffixes));
}


# ($DIRSTAMP, @CLEAN_FILES)
# output_texinfo_build_rules ($SOURCE, $DEST, $INSRC, @DEPENDENCIES)
# ------------------------------------------------------------------
# SOURCE - the source Texinfo file
# DEST - the destination Info file
# INSRC - wether DEST should be built in the source tree
# DEPENDENCIES - known dependencies
sub output_texinfo_build_rules ($$$@)
{
  my ($source, $dest, $insrc, @deps) = @_;

  # Split `a.texi' into `a' and `.texi'.
  my ($spfx, $ssfx) = ($source =~ /^(.*?)(\.[^.]*)?$/);
  my ($dpfx, $dsfx) = ($dest =~ /^(.*?)(\.[^.]*)?$/);

  $ssfx ||= "";
  $dsfx ||= "";

  # We can output two kinds of rules: the "generic" rules use Make
  # suffix rules and are appropriate when $source and $dest do not lie
  # in a sub-directory; the "specific" rules are needed in the other
  # case.
  #
  # The former are output only once (this is not really apparent here,
  # but just remember that some logic deeper in Automake will not
  # output the same rule twice); while the later need to be output for
  # each Texinfo source.
  my $generic;
  my $makeinfoflags;
  my $sdir = dirname $source;
  if ($sdir eq '.' && dirname ($dest) eq '.')
    {
      $generic = 1;
      $makeinfoflags = '-I $(srcdir)';
    }
  else
    {
      $generic = 0;
      $makeinfoflags = "-I $sdir -I \$(srcdir)/$sdir";
    }

  # A directory can contain two kinds of info files: some built in the
  # source tree, and some built in the build tree.  The rules are
  # different in each case.  However we cannot output two different
  # set of generic rules.  Because in-source builds are more usual, we
  # use generic rules in this case and fall back to "specific" rules
  # for build-dir builds.  (It should not be a problem to invert this
  # if needed.)
  $generic = 0 unless $insrc;

  # We cannot use a suffix rule to build info files with an empty
  # extension.  Otherwise we would output a single suffix inference
  # rule, with separate dependencies, as in
  #
  #    .texi:
  #             $(MAKEINFO) ...
  #    foo.info: foo.texi
  #
  # which confuse Solaris make.  (See the Autoconf manual for
  # details.)  Therefore we use a specific rule in this case.  This
  # applies to info files only (dvi and pdf files always have an
  # extension).
  my $generic_info = ($generic && $dsfx) ? 1 : 0;

  # If the resulting file lie into a subdirectory,
  # make sure this directory will exist.
  my $dirstamp = require_build_directory_maybe ($dest);

  my $dipfx = ($insrc ? '$(srcdir)/' : '') . $dpfx;

  $output_rules .= file_contents ('texibuild',
				  new Automake::Location,
				  DEPS             => "@deps",
				  DEST_PREFIX      => $dpfx,
				  DEST_INFO_PREFIX => $dipfx,
				  DEST_SUFFIX      => $dsfx,
				  DIRSTAMP         => $dirstamp,
				  GENERIC          => $generic,
				  GENERIC_INFO     => $generic_info,
				  INSRC		   => $insrc,
				  MAKEINFOFLAGS    => $makeinfoflags,
				  SOURCE           => ($generic
						       ? '$<' : $source),
				  SOURCE_INFO      => ($generic_info
						       ? '$<' : $source),
				  SOURCE_REAL      => $source,
				  SOURCE_SUFFIX    => $ssfx,
				  );
  return ($dirstamp, "$dpfx.dvi", "$dpfx.pdf", "$dpfx.ps", "$dpfx.html");
}


# ($MOSTLYCLEAN, $TEXICLEAN, $MAINTCLEAN)
# handle_texinfo_helper ($info_texinfos)
# --------------------------------------
# Handle all Texinfo source; helper for handle_texinfo.
sub handle_texinfo_helper ($)
{
  my ($info_texinfos) = @_;
  my (@infobase, @info_deps_list, @texi_deps);
  my %versions;
  my $done = 0;
  my (@mostly_cleans, @texi_cleans, @maint_cleans) = ('', '', '');

  # Build a regex matching user-cleaned files.
  my $d = var 'DISTCLEANFILES';
  my $c = var 'CLEANFILES';
  my @f = ();
  push @f, $d->value_as_list_recursive (inner_expand => 1) if $d;
  push @f, $c->value_as_list_recursive (inner_expand => 1) if $c;
  @f = map { s|[^A-Za-z_0-9*\[\]\-]|\\$&|g; s|\*|[^/]*|g; $_; } @f;
  my $user_cleaned_files = '^(?:' . join ('|', @f) . ')$';

  foreach my $texi
      ($info_texinfos->value_as_list_recursive (inner_expand => 1))
    {
      my $infobase = $texi;
      $infobase =~ s/\.(txi|texinfo|texi)$//;

      if ($infobase eq $texi)
	{
	  # FIXME: report line number.
	  err_am "texinfo file `$texi' has unrecognized extension";
	  next;
	}

      push @infobase, $infobase;

      # If 'version.texi' is referenced by input file, then include
      # automatic versioning capability.
      my ($out_file, $vtexi, @clean_files) =
	scan_texinfo_file ("$relative_dir/$texi")
	or next;
      push (@mostly_cleans, @clean_files);

      # If the Texinfo source is in a subdirectory, create the
      # resulting info in this subdirectory.  If it is in the current
      # directory, try hard to not prefix "./" because it breaks the
      # generic rules.
      my $outdir = dirname ($texi) . '/';
      $outdir = "" if $outdir eq './';
      $out_file =  $outdir . $out_file;

      # Until Automake 1.6.3, .info files were built in the
      # source tree.  This was an obstacle to the support of
      # non-distributed .info files, and non-distributed .texi
      # files.
      #
      # * Non-distributed .texi files is important in some packages
      #   where .texi files are built at make time, probably using
      #   other binaries built in the package itself, maybe using
      #   tools or information found on the build host.  Because
      #   these files are not distributed they are always rebuilt
      #   at make time; they should therefore not lie in the source
      #   directory.  One plan was to support this using
      #   nodist_info_TEXINFOS or something similar.  (Doing this
      #   requires some sanity checks.  For instance Automake should
      #   not allow:
      #      dist_info_TEXINFOS = foo.texi
      #      nodist_foo_TEXINFOS = included.texi
      #   because a distributed file should never depend on a
      #   non-distributed file.)
      #
      # * If .texi files are not distributed, then .info files should
      #   not be distributed either.  There are also cases where one
      #   wants to distribute .texi files, but does not want to
      #   distribute the .info files.  For instance the Texinfo package
      #   distributes the tool used to build these files; it would
      #   be a waste of space to distribute them.  It's not clear
      #   which syntax we should use to indicate that .info files should
      #   not be distributed.  Akim Demaille suggested that eventually
      #   we switch to a new syntax:
      #   |  Maybe we should take some inspiration from what's already
      #   |  done in the rest of Automake.  Maybe there is too much
      #   |  syntactic sugar here, and you want
      #   |     nodist_INFO = bar.info
      #   |     dist_bar_info_SOURCES = bar.texi
      #   |     bar_texi_DEPENDENCIES = foo.texi
      #   |  with a bit of magic to have bar.info represent the whole
      #   |  bar*info set.  That's a lot more verbose that the current
      #   |  situation, but it is # not new, hence the user has less
      #   |  to learn.
      #	  |
      #   |  But there is still too much room for meaningless specs:
      #   |     nodist_INFO = bar.info
      #   |     dist_bar_info_SOURCES = bar.texi
      #   |     dist_PS = bar.ps something-written-by-hand.ps
      #   |     nodist_bar_ps_SOURCES = bar.texi
      #   |     bar_texi_DEPENDENCIES = foo.texi
      #   |  here bar.texi is dist_ in line 2, and nodist_ in 4.
      #
      # Back to the point, it should be clear that in order to support
      # non-distributed .info files, we need to build them in the
      # build tree, not in the source tree (non-distributed .texi
      # files are less of a problem, because we do not output build
      # rules for them).  In Automake 1.7 .info build rules have been
      # largely cleaned up so that .info files get always build in the
      # build tree, even when distributed.  The idea was that
      #   (1) if during a VPATH build the .info file was found to be
      #       absent or out-of-date (in the source tree or in the
      #       build tree), Make would rebuild it in the build tree.
      #       If an up-to-date source-tree of the .info file existed,
      #       make would not rebuild it in the build tree.
      #   (2) having two copies of .info files, one in the source tree
      #       and one (newer) in the build tree is not a problem
      #       because `make dist' always pick files in the build tree
      #       first.
      # However it turned out the be a bad idea for several reasons:
      #   * Tru64, OpenBSD, and FreeBSD (not NetBSD) Make do not behave
      #     like GNU Make on point (1) above.  These implementations
      #     of Make would always rebuild .info files in the build
      #     tree, even if such files were up to date in the source
      #     tree.  Consequently, it was impossible to perform a VPATH
      #     build of a package containing Texinfo files using these
      #     Make implementations.
      #     (Refer to the Autoconf Manual, section "Limitation of
      #     Make", paragraph "VPATH", item "target lookup", for
      #     an account of the differences between these
      #     implementations.)
      #   * The GNU Coding Standards require these files to be built
      #     in the source-tree (when they are distributed, that is).
      #   * Keeping a fresher copy of distributed files in the
      #     build tree can be annoying during development because
      #     - if the files is kept under CVS, you really want it
      #       to be updated in the source tree
      #     - it is confusing that `make distclean' does not erase
      #       all files in the build tree.
      #
      # Consequently, starting with Automake 1.8, .info files are
      # built in the source tree again.  Because we still plan to
      # support non-distributed .info files at some point, we
      # have a single variable ($INSRC) that controls whether
      # the current .info file must be built in the source tree
      # or in the build tree.  Actually this variable is switched
      # off for .info files that appear to be cleaned; this is
      # for backward compatibility with package such as Texinfo,
      # which do things like
      #   info_TEXINFOS = texinfo.txi info-stnd.texi info.texi
      #   DISTCLEANFILES = texinfo texinfo-* info*.info*
      #   # Do not create info files for distribution.
      #   dist-info:
      # in order not to distribute .info files.
      my $insrc = ($out_file =~ $user_cleaned_files) ? 0 : 1;

      my $soutdir = '$(srcdir)/' . $outdir;
      $outdir = $soutdir if $insrc;

      # If user specified file_TEXINFOS, then use that as explicit
      # dependency list.
      @texi_deps = ();
      push (@texi_deps, "$soutdir$vtexi") if $vtexi;

      my $canonical = canonicalize ($infobase);
      if (var ($canonical . "_TEXINFOS"))
	{
	  push (@texi_deps, '$(' . $canonical . '_TEXINFOS)');
	  push_dist_common ('$(' . $canonical . '_TEXINFOS)');
	}

      my ($dirstamp, @cfiles) =
	output_texinfo_build_rules ($texi, $out_file, $insrc, @texi_deps);
      push (@texi_cleans, @cfiles);

      push (@info_deps_list, $out_file);

      # If a vers*.texi file is needed, emit the rule.
      if ($vtexi)
	{
	  err_am ("`$vtexi', included in `$texi', "
		  . "also included in `$versions{$vtexi}'")
	    if defined $versions{$vtexi};
	  $versions{$vtexi} = $texi;

	  # We number the stamp-vti files.  This is doable since the
	  # actual names don't matter much.  We only number starting
	  # with the second one, so that the common case looks nice.
	  my $vti = ($done ? $done : 'vti');
	  ++$done;

	  # This is ugly, but it is our historical practice.
	  if ($config_aux_dir_set_in_configure_ac)
	    {
	      require_conf_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
					    'mdate-sh');
	    }
	  else
	    {
	      require_file_with_macro (TRUE, 'info_TEXINFOS',
				       FOREIGN, 'mdate-sh');
	    }

	  my $conf_dir;
	  if ($config_aux_dir_set_in_configure_ac)
	    {
	      $conf_dir = "$am_config_aux_dir/";
	    }
	  else
	    {
	      $conf_dir = '$(srcdir)/';
	    }
	  $output_rules .= file_contents ('texi-vers',
					  new Automake::Location,
					  TEXI     => $texi,
					  VTI      => $vti,
					  STAMPVTI => "${soutdir}stamp-$vti",
					  VTEXI    => "$soutdir$vtexi",
					  MDDIR    => $conf_dir,
					  DIRSTAMP => $dirstamp);
	}
    }

  # Handle location of texinfo.tex.
  my $need_texi_file = 0;
  my $texinfodir;
  if (var ('TEXINFO_TEX'))
    {
      # The user defined TEXINFO_TEX so assume he knows what he is
      # doing.
      $texinfodir = ('$(srcdir)/'
		     . dirname (variable_value ('TEXINFO_TEX')));
    }
  elsif (option 'cygnus')
    {
      $texinfodir = '$(top_srcdir)/../texinfo';
      define_variable ('TEXINFO_TEX', "$texinfodir/texinfo.tex", INTERNAL);
    }
  elsif ($config_aux_dir_set_in_configure_ac)
    {
      $texinfodir = $am_config_aux_dir;
      define_variable ('TEXINFO_TEX', "$texinfodir/texinfo.tex", INTERNAL);
      $need_texi_file = 2; # so that we require_conf_file later
    }
  else
    {
      $texinfodir = '$(srcdir)';
      $need_texi_file = 1;
    }
  define_variable ('am__TEXINFO_TEX_DIR', $texinfodir, INTERNAL);

  push (@dist_targets, 'dist-info');

  if (! option 'no-installinfo')
    {
      # Make sure documentation is made and installed first.  Use
      # $(INFO_DEPS), not 'info', because otherwise recursive makes
      # get run twice during "make all".
      unshift (@all, '$(INFO_DEPS)');
    }

  define_files_variable ("DVIS", @infobase, 'dvi', INTERNAL);
  define_files_variable ("PDFS", @infobase, 'pdf', INTERNAL);
  define_files_variable ("PSS", @infobase, 'ps', INTERNAL);
  define_files_variable ("HTMLS", @infobase, 'html', INTERNAL);

  # This next isn't strictly needed now -- the places that look here
  # could easily be changed to look in info_TEXINFOS.  But this is
  # probably better, in case noinst_TEXINFOS is ever supported.
  define_variable ("TEXINFOS", variable_value ('info_TEXINFOS'), INTERNAL);

  # Do some error checking.  Note that this file is not required
  # when in Cygnus mode; instead we defined TEXINFO_TEX explicitly
  # up above.
  if ($need_texi_file && ! option 'no-texinfo.tex')
    {
      if ($need_texi_file > 1)
	{
	  require_conf_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
					'texinfo.tex');
	}
      else
	{
	  require_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
				   'texinfo.tex');
	}
    }

  return (makefile_wrap ("", "\t  ", @mostly_cleans),
	  makefile_wrap ("", "\t  ", @texi_cleans),
	  makefile_wrap ("", "\t  ", @maint_cleans));
}


# handle_texinfo ()
# -----------------
# Handle all Texinfo source.
sub handle_texinfo ()
{
  reject_var 'TEXINFOS', "`TEXINFOS' is an anachronism; use `info_TEXINFOS'";
  # FIXME: I think this is an obsolete future feature name.
  reject_var 'html_TEXINFOS', "HTML generation not yet supported";

  my $info_texinfos = var ('info_TEXINFOS');
  my ($mostlyclean, $clean, $maintclean) = ('', '', '');
  if ($info_texinfos)
    {
      ($mostlyclean, $clean, $maintclean) = handle_texinfo_helper ($info_texinfos);
      chomp $mostlyclean;
      chomp $clean;
      chomp $maintclean;
    }

  $output_rules .=  file_contents ('texinfos',
				   new Automake::Location,
				   MOSTLYCLEAN   => $mostlyclean,
				   TEXICLEAN     => $clean,
				   MAINTCLEAN    => $maintclean,
				   'LOCAL-TEXIS' => !!$info_texinfos);
}


# Handle any man pages.
sub handle_man_pages
{
  reject_var 'MANS', "`MANS' is an anachronism; use `man_MANS'";

  # Find all the sections in use.  We do this by first looking for
  # "standard" sections, and then looking for any additional
  # sections used in man_MANS.
  my (%sections, %notrans_sections, %trans_sections,
      %notrans_vars, %trans_vars, %notrans_sect_vars, %trans_sect_vars);
  # We handle nodist_ for uniformity.  man pages aren't distributed
  # by default so it isn't actually very important.
  foreach my $npfx ('', 'notrans_')
    {
      foreach my $pfx ('', 'dist_', 'nodist_')
	{
	  # Add more sections as needed.
	  foreach my $section ('0'..'9', 'n', 'l')
	    {
	      my $varname = $npfx . $pfx . 'man' . $section . '_MANS';
	      if (var ($varname))
		{
		  $sections{$section} = 1;
		  $varname = '$(' . $varname . ')';
		  if ($npfx eq 'notrans_')
		    {
		      $notrans_sections{$section} = 1;
		      $notrans_sect_vars{$varname} = 1;
		    }
		  else
		    {
		      $trans_sections{$section} = 1;
		      $trans_sect_vars{$varname} = 1;
		    }

		  &push_dist_common ($varname)
		    if $pfx eq 'dist_';
		}
	    }

	  my $varname = $npfx . $pfx . 'man_MANS';
	  my $var = var ($varname);
	  if ($var)
	    {
	      foreach ($var->value_as_list_recursive)
		{
		  # A page like `foo.1c' goes into man1dir.
		  if (/\.([0-9a-z])([a-z]*)$/)
		    {
		      $sections{$1} = 1;
		      if ($npfx eq 'notrans_')
			{
			  $notrans_sections{$1} = 1;
			}
		      else
			{
			  $trans_sections{$1} = 1;
			}
		    }
		}

	      $varname = '$(' . $varname . ')';
	      if ($npfx eq 'notrans_')
		{
		  $notrans_vars{$varname} = 1;
		}
	      else
		{
		  $trans_vars{$varname} = 1;
		}
	      &push_dist_common ($varname)
		if $pfx eq 'dist_';
	    }
	}
    }

  return unless %sections;

  my @unsorted_deps;

  # Build section independent variables.
  my $have_notrans = %notrans_vars;
  my @notrans_list = sort keys %notrans_vars;
  my $have_trans = %trans_vars;
  my @trans_list = sort keys %trans_vars;

  # Now for each section, generate an install and uninstall rule.
  # Sort sections so output is deterministic.
  foreach my $section (sort keys %sections)
    {
      # Build section dependent variables.
      my $notrans_mans = $have_notrans || exists $notrans_sections{$section};
      my $trans_mans = $have_trans || exists $trans_sections{$section};
      my (%notrans_this_sect, %trans_this_sect);
      my $expr = 'man' . $section . '_MANS';
      foreach my $varname (keys %notrans_sect_vars)
	{
	  if ($varname =~ /$expr/)
	    {
	      $notrans_this_sect{$varname} = 1;
	    }
	}
      foreach my $varname (keys %trans_sect_vars)
	{
	  if ($varname =~ /$expr/)
	    {
	      $trans_this_sect{$varname} = 1;
	    }
	}
      my @notrans_sect_list = sort keys %notrans_this_sect;
      my @trans_sect_list = sort keys %trans_this_sect;
      @unsorted_deps = (keys %notrans_vars, keys %trans_vars,
                        keys %notrans_this_sect, keys %trans_this_sect);
      my @deps = sort @unsorted_deps;
      $output_rules .= &file_contents ('mans',
				       new Automake::Location,
				       SECTION           => $section,
				       DEPS              => "@deps",
				       NOTRANS_MANS      => $notrans_mans,
				       NOTRANS_SECT_LIST => "@notrans_sect_list",
				       HAVE_NOTRANS      => $have_notrans,
				       NOTRANS_LIST      => "@notrans_list",
				       TRANS_MANS        => $trans_mans,
				       TRANS_SECT_LIST   => "@trans_sect_list",
				       HAVE_TRANS        => $have_trans,
				       TRANS_LIST        => "@trans_list");
    }

  @unsorted_deps  = (keys %notrans_vars, keys %trans_vars,
                     keys %notrans_sect_vars, keys %trans_sect_vars);
  my @mans = sort @unsorted_deps;
  $output_vars .= file_contents ('mans-vars',
				 new Automake::Location,
				 MANS => "@mans");

  push (@all, '$(MANS)')
    unless option 'no-installman';
}

# Handle DATA variables.
sub handle_data
{
    &am_install_var ('-noextra', '-candist', 'data', 'DATA',
		     'data', 'dataroot', 'dvi', 'html', 'pdf', 'ps',
		     'sysconf', 'sharedstate', 'localstate',
		     'pkgdata', 'lisp', 'noinst', 'check');
}

# Handle TAGS.
sub handle_tags
{
    my @tag_deps = ();
    my @ctag_deps = ();
    if (var ('SUBDIRS'))
    {
	$output_rules .= ("tags-recursive:\n"
			  . "\tlist=\'\$(SUBDIRS)\'; for subdir in \$\$list; do \\\n"
			  # Never fail here if a subdir fails; it
			  # isn't important.
			  . "\t  test \"\$\$subdir\" = . || (\$(am__cd) \$\$subdir"
			  . " && \$(MAKE) \$(AM_MAKEFLAGS) tags); \\\n"
			  . "\tdone\n");
	push (@tag_deps, 'tags-recursive');
	&depend ('.PHONY', 'tags-recursive');
	&depend ('.MAKE', 'tags-recursive');

	$output_rules .= ("ctags-recursive:\n"
			  . "\tlist=\'\$(SUBDIRS)\'; for subdir in \$\$list; do \\\n"
			  # Never fail here if a subdir fails; it
			  # isn't important.
			  . "\t  test \"\$\$subdir\" = . || (\$(am__cd) \$\$subdir"
			  . " && \$(MAKE) \$(AM_MAKEFLAGS) ctags); \\\n"
			  . "\tdone\n");
	push (@ctag_deps, 'ctags-recursive');
	&depend ('.PHONY', 'ctags-recursive');
	&depend ('.MAKE', 'ctags-recursive');
    }

    if (&saw_sources_p (1)
	|| var ('ETAGS_ARGS')
	|| @tag_deps)
    {
	my @config;
	foreach my $spec (@config_headers)
	{
	    my ($out, @ins) = split_config_file_spec ($spec);
	    foreach my $in (@ins)
	      {
		# If the config header source is in this directory,
		# require it.
		push @config, basename ($in)
		  if $relative_dir eq dirname ($in);
	      }
	}
	$output_rules .= &file_contents ('tags',
					 new Automake::Location,
					 CONFIG    => "@config",
					 TAGSDIRS  => "@tag_deps",
					 CTAGSDIRS => "@ctag_deps");

	set_seen 'TAGS_DEPENDENCIES';
    }
    elsif (reject_var ('TAGS_DEPENDENCIES',
		       "doesn't make sense to define `TAGS_DEPENDENCIES'"
		       . "without\nsources or `ETAGS_ARGS'"))
    {
    }
    else
    {
	# Every Makefile must define some sort of TAGS rule.
	# Otherwise, it would be possible for a top-level "make TAGS"
	# to fail because some subdirectory failed.
	$output_rules .= "tags: TAGS\nTAGS:\n\n";
	# Ditto ctags.
	$output_rules .= "ctags: CTAGS\nCTAGS:\n\n";
    }
}

# Handle multilib support.
sub handle_multilib
{
  if ($seen_multilib && $relative_dir eq '.')
    {
      $output_rules .= &file_contents ('multilib', new Automake::Location);
      push (@all, 'all-multi');
    }
}


# user_phony_rule ($NAME)
# -----------------------
# Return false if rule $NAME does not exist.  Otherwise,
# declare it as phony, complete its definition (in case it is
# conditional), and return its Automake::Rule instance.
sub user_phony_rule ($)
{
  my ($name) = @_;
  my $rule = rule $name;
  if ($rule)
    {
      depend ('.PHONY', $name);
      # Define $NAME in all condition where it is not already defined,
      # so that it is always OK to depend on $NAME.
      for my $c ($rule->not_always_defined_in_cond (TRUE)->conds)
	{
	  Automake::Rule::define ($name, 'internal', RULE_AUTOMAKE,
				  $c, INTERNAL);
	  $output_rules .= $c->subst_string . "$name:\n";
	}
    }
  return $rule;
}


# $BOOLEAN
# &for_dist_common ($A, $B)
# -------------------------
# Subroutine for &handle_dist: sort files to dist.
#
# We put README first because it then becomes easier to make a
# Usenet-compliant shar file (in these, README must be first).
#
# FIXME: do more ordering of files here.
sub for_dist_common
{
    return 0
	if $a eq $b;
    return -1
	if $a eq 'README';
    return 1
	if $b eq 'README';
    return $a cmp $b;
}

# handle_dist
# -----------
# Handle 'dist' target.
sub handle_dist ()
{
  # Substitutions for distdir.am
  my %transform;

  # Define DIST_SUBDIRS.  This must always be done, regardless of the
  # no-dist setting: target like `distclean' or `maintainer-clean' use it.
  my $subdirs = var ('SUBDIRS');
  if ($subdirs)
    {
      # If SUBDIRS is conditionally defined, then set DIST_SUBDIRS
      # to all possible directories, and use it.  If DIST_SUBDIRS is
      # defined, just use it.

      # Note that we check DIST_SUBDIRS first on purpose, so that
      # we don't call has_conditional_contents for now reason.
      # (In the past one project used so many conditional subdirectories
      # that calling has_conditional_contents on SUBDIRS caused
      # automake to grow to 150Mb -- this should not happen with
      # the current implementation of has_conditional_contents,
      # but it's more efficient to avoid the call anyway.)
      if (var ('DIST_SUBDIRS'))
	{
	}
      elsif ($subdirs->has_conditional_contents)
	{
	  define_pretty_variable
	    ('DIST_SUBDIRS', TRUE, INTERNAL,
	     uniq ($subdirs->value_as_list_recursive));
	}
      else
	{
	  # We always define this because that is what `distclean'
	  # wants.
	  define_pretty_variable ('DIST_SUBDIRS', TRUE, INTERNAL,
				  '$(SUBDIRS)');
	}
    }

  # The remaining definitions are only required when a dist target is used.
  return if option 'no-dist';

  # At least one of the archive formats must be enabled.
  if ($relative_dir eq '.')
    {
      my $archive_defined = option 'no-dist-gzip' ? 0 : 1;
      $archive_defined ||=
	grep { option "dist-$_" } qw(shar zip tarZ bzip2 lzma xz);
      error (option 'no-dist-gzip',
	     "no-dist-gzip specified but no dist-* specified, "
	     . "at least one archive format must be enabled")
	unless $archive_defined;
    }

  # Look for common files that should be included in distribution.
  # If the aux dir is set, and it does not have a Makefile.am, then
  # we check for these files there as well.
  my $check_aux = 0;
  if ($relative_dir eq '.'
      && $config_aux_dir_set_in_configure_ac)
    {
      if (! &is_make_dir ($config_aux_dir))
	{
	  $check_aux = 1;
	}
    }
  foreach my $cfile (@common_files)
    {
      if (dir_has_case_matching_file ($relative_dir, $cfile)
	  # The file might be absent, but if it can be built it's ok.
	  || rule $cfile)
	{
	  &push_dist_common ($cfile);
	}

      # Don't use `elsif' here because a file might meaningfully
      # appear in both directories.
      if ($check_aux && dir_has_case_matching_file ($config_aux_dir, $cfile))
	{
	  &push_dist_common ("$config_aux_dir/$cfile")
	}
    }

  # We might copy elements from $configure_dist_common to
  # %dist_common if we think we need to.  If the file appears in our
  # directory, we would have discovered it already, so we don't
  # check that.  But if the file is in a subdir without a Makefile,
  # we want to distribute it here if we are doing `.'.  Ugly!
  if ($relative_dir eq '.')
    {
      foreach my $file (split (' ' , $configure_dist_common))
	{
	  push_dist_common ($file)
	    unless is_make_dir (dirname ($file));
	}
    }

  # Files to distributed.  Don't use ->value_as_list_recursive
  # as it recursively expands `$(dist_pkgdata_DATA)' etc.
  my @dist_common = split (' ', rvar ('DIST_COMMON')->variable_value);
  @dist_common = uniq (sort for_dist_common (@dist_common));
  variable_delete 'DIST_COMMON';
  define_pretty_variable ('DIST_COMMON', TRUE, INTERNAL, @dist_common);

  # Now that we've processed DIST_COMMON, disallow further attempts
  # to set it.
  $handle_dist_run = 1;

  # Scan EXTRA_DIST to see if we need to distribute anything from a
  # subdir.  If so, add it to the list.  I didn't want to do this
  # originally, but there were so many requests that I finally
  # relented.
  my $extra_dist = var ('EXTRA_DIST');

  $transform{'DISTCHECK-HOOK'} = !! rule 'distcheck-hook';
  $transform{'GETTEXT'} = $seen_gettext && !$seen_gettext_external;

  # If the target `dist-hook' exists, make sure it is run.  This
  # allows users to do random weird things to the distribution
  # before it is packaged up.
  push (@dist_targets, 'dist-hook')
    if user_phony_rule 'dist-hook';
  $transform{'DIST-TARGETS'} = join (' ', @dist_targets);

  my $flm = option ('filename-length-max');
  my $filename_filter = $flm ? '.' x $flm->[1] : '';

  $output_rules .= &file_contents ('distdir',
				   new Automake::Location,
				   %transform,
				   FILENAME_FILTER => $filename_filter);
}


# check_directory ($NAME, $WHERE)
# -------------------------------
# Ensure $NAME is a directory, and that it uses a sane name.
# Use $WHERE as a location in the diagnostic, if any.
sub check_directory ($$)
{
  my ($dir, $where) = @_;

  error $where, "required directory $relative_dir/$dir does not exist"
    unless -d "$relative_dir/$dir";

  # If an `obj/' directory exists, BSD make will enter it before
  # reading `Makefile'.  Hence the `Makefile' in the current directory
  # will not be read.
  #
  #  % cat Makefile
  #  all:
  #          echo Hello
  #  % cat obj/Makefile
  #  all:
  #          echo World
  #  % make      # GNU make
  #  echo Hello
  #  Hello
  #  % pmake     # BSD make
  #  echo World
  #  World
  msg ('portability', $where,
       "naming a subdirectory `obj' causes troubles with BSD make")
    if $dir eq 'obj';

  # `aux' is probably the most important of the following forbidden name,
  # since it's tempting to use it as an AC_CONFIG_AUX_DIR.
  msg ('portability', $where,
       "name `$dir' is reserved on W32 and DOS platforms")
    if grep (/^\Q$dir\E$/i, qw/aux lpt1 lpt2 lpt3 com1 com2 com3 com4 con prn/);
}

# check_directories_in_var ($VARIABLE)
# ------------------------------------
# Recursively check all items in variables $VARIABLE as directories
sub check_directories_in_var ($)
{
  my ($var) = @_;
  $var->traverse_recursively
    (sub
     {
       my ($var, $val, $cond, $full_cond) = @_;
       check_directory ($val, $var->rdef ($cond)->location);
       return ();
     },
     undef,
     skip_ac_subst => 1);
}

# &handle_subdirs ()
# ------------------
# Handle subdirectories.
sub handle_subdirs ()
{
  my $subdirs = var ('SUBDIRS');
  return
    unless $subdirs;

  check_directories_in_var $subdirs;

  my $dsubdirs = var ('DIST_SUBDIRS');
  check_directories_in_var $dsubdirs
    if $dsubdirs;

  $output_rules .= &file_contents ('subdirs', new Automake::Location);
  rvar ('RECURSIVE_TARGETS')->rdef (TRUE)->{'pretty'} = VAR_SORTED; # Gross!
}


# ($REGEN, @DEPENDENCIES)
# &scan_aclocal_m4
# ----------------
# If aclocal.m4 creation is automated, return the list of its dependencies.
sub scan_aclocal_m4 ()
{
  my $regen_aclocal = 0;

  set_seen 'CONFIG_STATUS_DEPENDENCIES';
  set_seen 'CONFIGURE_DEPENDENCIES';

  if (-f 'aclocal.m4')
    {
      &define_variable ("ACLOCAL_M4", '$(top_srcdir)/aclocal.m4', INTERNAL);

      my $aclocal = new Automake::XFile "< aclocal.m4";
      my $line = $aclocal->getline;
      $regen_aclocal = $line =~ 'generated automatically by aclocal';
    }

  my @ac_deps = ();

  if (set_seen ('ACLOCAL_M4_SOURCES'))
    {
      push (@ac_deps, '$(ACLOCAL_M4_SOURCES)');
      msg_var ('obsolete', 'ACLOCAL_M4_SOURCES',
	       "`ACLOCAL_M4_SOURCES' is obsolete.\n"
	       . "It should be safe to simply remove it.");
    }

  # Note that it might be possible that aclocal.m4 doesn't exist but
  # should be auto-generated.  This case probably isn't very
  # important.

  return ($regen_aclocal, @ac_deps);
}


# Helper function for substitute_ac_subst_variables.
sub substitute_ac_subst_variables_worker($)
{
  my ($token) = @_;
  return "\@$token\@" if var $token;
  return "\${$token\}";
}

# substitute_ac_subst_variables ($TEXT)
# -------------------------------------
# Replace any occurrence of ${FOO} in $TEXT by @FOO@ if FOO is an AC_SUBST
# variable.
sub substitute_ac_subst_variables ($)
{
  my ($text) = @_;
  $text =~ s/\${([^ \t=:+{}]+)}/&substitute_ac_subst_variables_worker ($1)/ge;
  return $text;
}

# @DEPENDENCIES
# &prepend_srcdir (@INPUTS)
# -------------------------
# Prepend $(srcdir) or $(top_srcdir) to all @INPUTS.  The idea is that
# if an input file has a directory part the same as the current
# directory, then the directory part is simply replaced by $(srcdir).
# But if the directory part is different, then $(top_srcdir) is
# prepended.
sub prepend_srcdir (@)
{
  my (@inputs) = @_;
  my @newinputs;

  foreach my $single (@inputs)
    {
      if (dirname ($single) eq $relative_dir)
	{
	  push (@newinputs, '$(srcdir)/' . basename ($single));
	}
      else
	{
	  push (@newinputs, '$(top_srcdir)/' . $single);
	}
    }
  return @newinputs;
}

# @DEPENDENCIES
# rewrite_inputs_into_dependencies ($OUTPUT, @INPUTS)
# ---------------------------------------------------
# Compute a list of dependencies appropriate for the rebuild
# rule of
#   AC_CONFIG_FILES($OUTPUT:$INPUT[0]:$INPUTS[1]:...)
# Also distribute $INPUTs which are not built by another AC_CONFIG_FOOS.
sub rewrite_inputs_into_dependencies ($@)
{
  my ($file, @inputs) = @_;
  my @res = ();

  for my $i (@inputs)
    {
      # We cannot create dependencies on shell variables.
      next if (substitute_ac_subst_variables $i) =~ /\$/;

      if (exists $ac_config_files_location{$i} && $i ne $file)
	{
	  my $di = dirname $i;
	  if ($di eq $relative_dir)
	    {
	      $i = basename $i;
	    }
	  # In the top-level Makefile we do not use $(top_builddir), because
	  # we are already there, and since the targets are built without
	  # a $(top_builddir), it helps BSD Make to match them with
	  # dependencies.
	  elsif ($relative_dir ne '.')
	    {
	      $i = '$(top_builddir)/' . $i;
	    }
	}
      else
	{
	  msg ('error', $ac_config_files_location{$file},
	       "required file `$i' not found")
	    unless $i =~ /\$/ || exists $output_files{$i} || -f $i;
	  ($i) = prepend_srcdir ($i);
	  push_dist_common ($i);
	}
      push @res, $i;
    }
  return @res;
}



# &handle_configure ($MAKEFILE_AM, $MAKEFILE_IN, $MAKEFILE, @INPUTS)
# ------------------------------------------------------------------
# Handle remaking and configure stuff.
# We need the name of the input file, to do proper remaking rules.
sub handle_configure ($$$@)
{
  my ($makefile_am, $makefile_in, $makefile, @inputs) = @_;

  prog_error 'empty @inputs'
    unless @inputs;

  my ($rel_makefile_am, $rel_makefile_in) = prepend_srcdir ($makefile_am,
							    $makefile_in);
  my $rel_makefile = basename $makefile;

  my $colon_infile = ':' . join (':', @inputs);
  $colon_infile = '' if $colon_infile eq ":$makefile.in";
  my @rewritten = rewrite_inputs_into_dependencies ($makefile, @inputs);
  my ($regen_aclocal_m4, @aclocal_m4_deps) = scan_aclocal_m4;
  define_pretty_variable ('am__aclocal_m4_deps', TRUE, INTERNAL,
			  @configure_deps, @aclocal_m4_deps,
			  '$(top_srcdir)/' . $configure_ac);
  my @configuredeps = ('$(am__aclocal_m4_deps)', '$(CONFIGURE_DEPENDENCIES)');
  push @configuredeps, '$(ACLOCAL_M4)' if -f 'aclocal.m4';
  define_pretty_variable ('am__configure_deps', TRUE, INTERNAL,
			  @configuredeps);

  my $automake_options = '--' . (global_option 'cygnus' ? 'cygnus' : $strictness_name)
			 . (global_option 'no-dependencies' ? ' --ignore-deps' : '');

  $output_rules .= file_contents
    ('configure',
     new Automake::Location,
     MAKEFILE              => $rel_makefile,
     'MAKEFILE-DEPS'       => "@rewritten",
     'CONFIG-MAKEFILE'     => ($relative_dir eq '.') ? '$@' : '$(subdir)/$@',
     'MAKEFILE-IN'         => $rel_makefile_in,
     'MAKEFILE-IN-DEPS'    => "@include_stack",
     'MAKEFILE-AM'         => $rel_makefile_am,
     'AUTOMAKE-OPTIONS'    => $automake_options,
     'MAKEFILE-AM-SOURCES' => "$makefile$colon_infile",
     'REGEN-ACLOCAL-M4'    => $regen_aclocal_m4,
     VERBOSE               => verbose_flag ('GEN'));

  if ($relative_dir eq '.')
    {
      &push_dist_common ('acconfig.h')
	if -f 'acconfig.h';
    }

  # If we have a configure header, require it.
  my $hdr_index = 0;
  my @distclean_config;
  foreach my $spec (@config_headers)
    {
      $hdr_index += 1;
      # $CONFIG_H_PATH: config.h from top level.
      my ($config_h_path, @ins) = split_config_file_spec ($spec);
      my $config_h_dir = dirname ($config_h_path);

      # If the header is in the current directory we want to build
      # the header here.  Otherwise, if we're at the topmost
      # directory and the header's directory doesn't have a
      # Makefile, then we also want to build the header.
      if ($relative_dir eq $config_h_dir
	  || ($relative_dir eq '.' && ! &is_make_dir ($config_h_dir)))
	{
	  my ($cn_sans_dir, $stamp_dir);
	  if ($relative_dir eq $config_h_dir)
	    {
	      $cn_sans_dir = basename ($config_h_path);
	      $stamp_dir = '';
	    }
	  else
	    {
	      $cn_sans_dir = $config_h_path;
	      if ($config_h_dir eq '.')
		{
		  $stamp_dir = '';
		}
	      else
		{
		  $stamp_dir = $config_h_dir . '/';
		}
	    }

	  # This will also distribute all inputs.
	  @ins = rewrite_inputs_into_dependencies ($config_h_path, @ins);

	  # Cannot define rebuild rules for filenames with shell variables.
	  next if (substitute_ac_subst_variables $config_h_path) =~ /\$/;

	  # Header defined in this directory.
	  my @files;
	  if (-f $config_h_path . '.top')
	    {
	      push (@files, "$cn_sans_dir.top");
	    }
	  if (-f $config_h_path . '.bot')
	    {
	      push (@files, "$cn_sans_dir.bot");
	    }

	  push_dist_common (@files);

	  # For now, acconfig.h can only appear in the top srcdir.
	  if (-f 'acconfig.h')
	    {
	      push (@files, '$(top_srcdir)/acconfig.h');
	    }

	  my $stamp = "${stamp_dir}stamp-h${hdr_index}";
	  $output_rules .=
	    file_contents ('remake-hdr',
			   new Automake::Location,
			   FILES            => "@files",
			   CONFIG_H         => $cn_sans_dir,
			   CONFIG_HIN       => $ins[0],
			   CONFIG_H_DEPS    => "@ins",
			   CONFIG_H_PATH    => $config_h_path,
			   STAMP            => "$stamp");

	  push @distclean_config, $cn_sans_dir, $stamp;
	}
    }

  $output_rules .= file_contents ('clean-hdr',
				  new Automake::Location,
				  FILES => "@distclean_config")
    if @distclean_config;

  # Distribute and define mkinstalldirs only if it is already present
  # in the package, for backward compatibility (some people may still
  # use $(mkinstalldirs)).
  my $mkidpath = "$config_aux_dir/mkinstalldirs";
  if (-f $mkidpath)
    {
      # Use require_file so that any existing script gets updated
      # by --force-missing.
      require_conf_file ($mkidpath, FOREIGN, 'mkinstalldirs');
      define_variable ('mkinstalldirs',
		       "\$(SHELL) $am_config_aux_dir/mkinstalldirs", INTERNAL);
    }
  else
    {
      # Use $(install_sh), not $(MKDIR_P) because the latter requires
      # at least one argument, and $(mkinstalldirs) used to work
      # even without arguments (e.g. $(mkinstalldirs) $(conditional_dir)).
      define_variable ('mkinstalldirs', '$(install_sh) -d', INTERNAL);
    }

  reject_var ('CONFIG_HEADER',
	      "`CONFIG_HEADER' is an anachronism; now determined "
	      . "automatically\nfrom `$configure_ac'");

  my @config_h;
  foreach my $spec (@config_headers)
    {
      my ($out, @ins) = split_config_file_spec ($spec);
      # Generate CONFIG_HEADER define.
      if ($relative_dir eq dirname ($out))
	{
	  push @config_h, basename ($out);
	}
      else
	{
	  push @config_h, "\$(top_builddir)/$out";
	}
    }
  define_variable ("CONFIG_HEADER", "@config_h", INTERNAL)
    if @config_h;

  # Now look for other files in this directory which must be remade
  # by config.status, and generate rules for them.
  my @actual_other_files = ();
  # These get cleaned only in a VPATH build.
  my @actual_other_vpath_files = ();
  foreach my $lfile (@other_input_files)
    {
      my $file;
      my @inputs;
      if ($lfile =~ /^([^:]*):(.*)$/)
	{
	  # This is the ":" syntax of AC_OUTPUT.
	  $file = $1;
	  @inputs = split (':', $2);
	}
      else
	{
	  # Normal usage.
	  $file = $lfile;
	  @inputs = $file . '.in';
	}

      # Automake files should not be stored in here, but in %MAKE_LIST.
      prog_error ("$lfile in \@other_input_files\n"
		  . "\@other_input_files = (@other_input_files)")
	if -f $file . '.am';

      my $local = basename ($file);

      # We skip files that aren't in this directory.  However, if
      # the file's directory does not have a Makefile, and we are
      # currently doing `.', then we create a rule to rebuild the
      # file in the subdir.
      my $fd = dirname ($file);
      if ($fd ne $relative_dir)
	{
	  if ($relative_dir eq '.' && ! &is_make_dir ($fd))
	    {
	      $local = $file;
	    }
	  else
	    {
	      next;
	    }
	}

      my @rewritten_inputs = rewrite_inputs_into_dependencies ($file, @inputs);

      # Cannot output rules for shell variables.
      next if (substitute_ac_subst_variables $local) =~ /\$/;

      my $condstr = '';
      my $cond = $ac_config_files_condition{$lfile};
      if (defined $cond)
        {
	  $condstr = $cond->subst_string;
	  Automake::Rule::define ($local, $configure_ac, RULE_AUTOMAKE, $cond,
				  $ac_config_files_location{$file});
        }
      $output_rules .= ($condstr . $local . ': '
			. '$(top_builddir)/config.status '
			. "@rewritten_inputs\n"
			. $condstr . "\t"
			. 'cd $(top_builddir) && '
			. '$(SHELL) ./config.status '
			. ($relative_dir eq '.' ? '' : '$(subdir)/')
			. '$@'
			. "\n");
      push (@actual_other_files, $local);
    }

  # For links we should clean destinations and distribute sources.
  foreach my $spec (@config_links)
    {
      my ($link, $file) = split /:/, $spec;
      # Some people do AC_CONFIG_LINKS($computed).  We only handle
      # the DEST:SRC form.
      next unless $file;
      my $where = $ac_config_files_location{$link};

      # Skip destinations that contain shell variables.
      if ((substitute_ac_subst_variables $link) !~ /\$/)
	{
	  # We skip links that aren't in this directory.  However, if
	  # the link's directory does not have a Makefile, and we are
	  # currently doing `.', then we add the link to CONFIG_CLEAN_FILES
	  # in `.'s Makefile.in.
	  my $local = basename ($link);
	  my $fd = dirname ($link);
	  if ($fd ne $relative_dir)
	    {
	      if ($relative_dir eq '.' && ! &is_make_dir ($fd))
		{
		  $local = $link;
		}
	      else
		{
		  $local = undef;
		}
	    }
	  if ($file ne $link)
	    {
	      push @actual_other_files, $local if $local;
	    }
	  else
	    {
	      push @actual_other_vpath_files, $local if $local;
	    }
	}

      # Do not process sources that contain shell variables.
      if ((substitute_ac_subst_variables $file) !~ /\$/)
	{
	  my $fd = dirname ($file);

	  # We distribute files that are in this directory.
	  # At the top-level (`.') we also distribute files whose
	  # directory does not have a Makefile.
	  if (($fd eq $relative_dir)
	      || ($relative_dir eq '.' && ! &is_make_dir ($fd)))
	    {
	      # The following will distribute $file as a side-effect when
	      # it is appropriate (i.e., when $file is not already an output).
	      # We do not need the result, just the side-effect.
	      rewrite_inputs_into_dependencies ($link, $file);
	    }
	}
    }

  # These files get removed by "make distclean".
  define_pretty_variable ('CONFIG_CLEAN_FILES', TRUE, INTERNAL,
			  @actual_other_files);
  define_pretty_variable ('CONFIG_CLEAN_VPATH_FILES', TRUE, INTERNAL,
			  @actual_other_vpath_files);
}

# Handle C headers.
sub handle_headers
{
    my @r = &am_install_var ('-defaultdist', 'header', 'HEADERS', 'include',
			     'oldinclude', 'pkginclude',
			     'noinst', 'check');
    foreach (@r)
    {
      next unless $_->[1] =~ /\..*$/;
      &saw_extension ($&);
    }
}

sub handle_gettext
{
  return if ! $seen_gettext || $relative_dir ne '.';

  my $subdirs = var 'SUBDIRS';

  if (! $subdirs)
    {
      err_ac "AM_GNU_GETTEXT used but SUBDIRS not defined";
      return;
    }

  # Perform some sanity checks to help users get the right setup.
  # We disable these tests when po/ doesn't exist in order not to disallow
  # unusual gettext setups.
  #
  # Bruno Haible:
  # | The idea is:
  # |
  # |  1) If a package doesn't have a directory po/ at top level, it
  # |     will likely have multiple po/ directories in subpackages.
  # |
  # |  2) It is useful to warn for the absence of intl/ if AM_GNU_GETTEXT
  # |     is used without 'external'. It is also useful to warn for the
  # |     presence of intl/ if AM_GNU_GETTEXT([external]) is used. Both
  # |     warnings apply only to the usual layout of packages, therefore
  # |     they should both be disabled if no po/ directory is found at
  # |     top level.

  if (-d 'po')
    {
      my @subdirs = $subdirs->value_as_list_recursive;

      msg_var ('syntax', $subdirs,
	       "AM_GNU_GETTEXT used but `po' not in SUBDIRS")
	if ! grep ($_ eq 'po', @subdirs);

      # intl/ is not required when AM_GNU_GETTEXT is called with the
      # `external' option and AM_GNU_GETTEXT_INTL_SUBDIR is not called.
      msg_var ('syntax', $subdirs,
	       "AM_GNU_GETTEXT used but `intl' not in SUBDIRS")
	if (! ($seen_gettext_external && ! $seen_gettext_intl)
	    && ! grep ($_ eq 'intl', @subdirs));

      # intl/ should not be used with AM_GNU_GETTEXT([external]), except
      # if AM_GNU_GETTEXT_INTL_SUBDIR is called.
      msg_var ('syntax', $subdirs,
	       "`intl' should not be in SUBDIRS when "
	       . "AM_GNU_GETTEXT([external]) is used")
	if ($seen_gettext_external && ! $seen_gettext_intl
	    && grep ($_ eq 'intl', @subdirs));
    }

  require_file ($ac_gettext_location, GNU, 'ABOUT-NLS');
}

# Handle footer elements.
sub handle_footer
{
    reject_rule ('.SUFFIXES',
		 "use variable `SUFFIXES', not target `.SUFFIXES'");

    # Note: AIX 4.1 /bin/make will fail if any suffix rule appears
    # before .SUFFIXES.  So we make sure that .SUFFIXES appears before
    # anything else, by sticking it right after the default: target.
    $output_header .= ".SUFFIXES:\n";
    my $suffixes = var 'SUFFIXES';
    my @suffixes = Automake::Rule::suffixes;
    if (@suffixes || $suffixes)
    {
	# Make sure SUFFIXES has unique elements.  Sort them to ensure
	# the output remains consistent.  However, $(SUFFIXES) is
	# always at the start of the list, unsorted.  This is done
	# because make will choose rules depending on the ordering of
	# suffixes, and this lets the user have some control.  Push
	# actual suffixes, and not $(SUFFIXES).  Some versions of make
	# do not like variable substitutions on the .SUFFIXES line.
	my @user_suffixes = ($suffixes
			     ? $suffixes->value_as_list_recursive : ());

	my %suffixes = map { $_ => 1 } @suffixes;
	delete @suffixes{@user_suffixes};

	$output_header .= (".SUFFIXES: "
			   . join (' ', @user_suffixes, sort keys %suffixes)
			   . "\n");
    }

    $output_trailer .= file_contents ('footer', new Automake::Location);
}


# Generate `make install' rules.
sub handle_install ()
{
  $output_rules .= &file_contents
    ('install',
     new Automake::Location,
     maybe_BUILT_SOURCES => (set_seen ('BUILT_SOURCES')
			     ? (" \$(BUILT_SOURCES)\n"
				. "\t\$(MAKE) \$(AM_MAKEFLAGS)")
			     : ''),
     'installdirs-local' => (user_phony_rule 'installdirs-local'
			     ? ' installdirs-local' : ''),
     am__installdirs => variable_value ('am__installdirs') || '');
}


# Deal with all and all-am.
sub handle_all ($)
{
    my ($makefile) = @_;

    # Output `all-am'.

    # Put this at the beginning for the sake of non-GNU makes.  This
    # is still wrong if these makes can run parallel jobs.  But it is
    # right enough.
    unshift (@all, basename ($makefile));

    foreach my $spec (@config_headers)
      {
	my ($out, @ins) = split_config_file_spec ($spec);
	push (@all, basename ($out))
	  if dirname ($out) eq $relative_dir;
      }

    # Install `all' hooks.
    push (@all, "all-local")
      if user_phony_rule "all-local";

    &pretty_print_rule ("all-am:", "\t\t", @all);
    &depend ('.PHONY', 'all-am', 'all');


    # Output `all'.

    my @local_headers = ();
    push @local_headers, '$(BUILT_SOURCES)'
      if var ('BUILT_SOURCES');
    foreach my $spec (@config_headers)
      {
	my ($out, @ins) = split_config_file_spec ($spec);
	push @local_headers, basename ($out)
	  if dirname ($out) eq $relative_dir;
      }

    if (@local_headers)
      {
	# We need to make sure config.h is built before we recurse.
	# We also want to make sure that built sources are built
	# before any ordinary `all' targets are run.  We can't do this
	# by changing the order of dependencies to the "all" because
	# that breaks when using parallel makes.  Instead we handle
	# things explicitly.
	$output_all .= ("all: @local_headers"
			. "\n\t"
			. '$(MAKE) $(AM_MAKEFLAGS) '
			. (var ('SUBDIRS') ? 'all-recursive' : 'all-am')
			. "\n\n");
        depend ('.MAKE', 'all');
      }
    else
      {
	$output_all .= "all: " . (var ('SUBDIRS')
				  ? 'all-recursive' : 'all-am') . "\n\n";
      }
}


# &do_check_merge_target ()
# -------------------------
# Handle check merge target specially.
sub do_check_merge_target ()
{
  # Include user-defined local form of target.
  push @check_tests, 'check-local'
    if user_phony_rule 'check-local';

  # In --cygnus mode, check doesn't depend on all.
  if (option 'cygnus')
    {
      # Just run the local check rules.
      pretty_print_rule ('check-am:', "\t\t", @check);
    }
  else
    {
      # The check target must depend on the local equivalent of
      # `all', to ensure all the primary targets are built.  Then it
      # must build the local check rules.
      $output_rules .= "check-am: all-am\n";
      if (@check)
        {
	  pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			     @check);
	  depend ('.MAKE', 'check-am');
	}
    }
  if (@check_tests)
    {
      pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			 @check_tests);
      depend ('.MAKE', 'check-am');
    }

  depend '.PHONY', 'check', 'check-am';
  # Handle recursion.  We have to honor BUILT_SOURCES like for `all:'.
  $output_rules .= ("check: "
		    . (var ('BUILT_SOURCES')
		       ? "\$(BUILT_SOURCES)\n\t\$(MAKE) \$(AM_MAKEFLAGS) "
		       : '')
		    . (var ('SUBDIRS') ? 'check-recursive' : 'check-am')
		    . "\n");
  depend ('.MAKE', 'check')
    if var ('BUILT_SOURCES');
}

# handle_clean ($MAKEFILE)
# ------------------------
# Handle all 'clean' targets.
sub handle_clean ($)
{
  my ($makefile) = @_;

  # Clean the files listed in user variables if they exist.
  $clean_files{'$(MOSTLYCLEANFILES)'} = MOSTLY_CLEAN
    if var ('MOSTLYCLEANFILES');
  $clean_files{'$(CLEANFILES)'} = CLEAN
    if var ('CLEANFILES');
  $clean_files{'$(DISTCLEANFILES)'} = DIST_CLEAN
    if var ('DISTCLEANFILES');
  $clean_files{'$(MAINTAINERCLEANFILES)'} = MAINTAINER_CLEAN
    if var ('MAINTAINERCLEANFILES');

  # Built sources are automatically removed by maintainer-clean.
  $clean_files{'$(BUILT_SOURCES)'} = MAINTAINER_CLEAN
    if var ('BUILT_SOURCES');

  # Compute a list of "rm"s to run for each target.
  my %rms = (MOSTLY_CLEAN, [],
	     CLEAN, [],
	     DIST_CLEAN, [],
	     MAINTAINER_CLEAN, []);

  foreach my $file (keys %clean_files)
    {
      my $when = $clean_files{$file};
      prog_error 'invalid entry in %clean_files'
	unless exists $rms{$when};

      my $rm = "rm -f $file";
      # If file is a variable, make sure when don't call `rm -f' without args.
      $rm ="test -z \"$file\" || $rm"
	if ($file =~ /^\s*\$(\(.*\)|\{.*\})\s*$/);

      push @{$rms{$when}}, "\t-$rm\n";
    }

  $output_rules .= &file_contents
    ('clean',
     new Automake::Location,
     MOSTLYCLEAN_RMS      => join ('', sort @{$rms{&MOSTLY_CLEAN}}),
     CLEAN_RMS            => join ('', sort @{$rms{&CLEAN}}),
     DISTCLEAN_RMS        => join ('', sort @{$rms{&DIST_CLEAN}}),
     MAINTAINER_CLEAN_RMS => join ('', sort @{$rms{&MAINTAINER_CLEAN}}),
     MAKEFILE             => basename $makefile,
     );
}


# &target_cmp ($A, $B)
# --------------------
# Subroutine for &handle_factored_dependencies to let `.PHONY' and
# other `.TARGETS' be last.
sub target_cmp
{
  return 0 if $a eq $b;

  my $a1 = substr ($a, 0, 1);
  my $b1 = substr ($b, 0, 1);
  if ($a1 ne $b1)
    {
      return -1 if $b1 eq '.';
      return 1 if $a1 eq '.';
    }
  return $a cmp $b;
}


# &handle_factored_dependencies ()
# --------------------------------
# Handle everything related to gathered targets.
sub handle_factored_dependencies
{
  # Reject bad hooks.
  foreach my $utarg ('uninstall-data-local', 'uninstall-data-hook',
		     'uninstall-exec-local', 'uninstall-exec-hook',
		     'uninstall-dvi-local',
		     'uninstall-html-local',
		     'uninstall-info-local',
		     'uninstall-pdf-local',
		     'uninstall-ps-local')
    {
      my $x = $utarg;
      $x =~ s/-.*-/-/;
      reject_rule ($utarg, "use `$x', not `$utarg'");
    }

  reject_rule ('install-local',
	       "use `install-data-local' or `install-exec-local', "
	       . "not `install-local'");

  reject_rule ('install-hook',
	       "use `install-data-hook' or `install-exec-hook', "
	       . "not `install-hook'");

  # Install the -local hooks.
  foreach (keys %dependencies)
    {
      # Hooks are installed on the -am targets.
      s/-am$// or next;
      depend ("$_-am", "$_-local")
	if user_phony_rule "$_-local";
    }

  # Install the -hook hooks.
  # FIXME: Why not be as liberal as we are with -local hooks?
  foreach ('install-exec', 'install-data', 'uninstall')
    {
      if (user_phony_rule "$_-hook")
	{
	  depend ('.MAKE', "$_-am");
	  register_action("$_-am",
			  ("\t\@\$(NORMAL_INSTALL)\n"
			   . "\t\$(MAKE) \$(AM_MAKEFLAGS) $_-hook"));
	}
    }

  # All the required targets are phony.
  depend ('.PHONY', keys %required_targets);

  # Actually output gathered targets.
  foreach (sort target_cmp keys %dependencies)
    {
      # If there is nothing about this guy, skip it.
      next
	unless (@{$dependencies{$_}}
		|| $actions{$_}
		|| $required_targets{$_});

      # Define gathered targets in undefined conditions.
      # FIXME: Right now we must handle .PHONY as an exception,
      # because people write things like
      #    .PHONY: myphonytarget
      # to append dependencies.  This would not work if Automake
      # refrained from defining its own .PHONY target as it does
      # with other overridden targets.
      # Likewise for `.MAKE'.
      my @undefined_conds = (TRUE,);
      if ($_ ne '.PHONY' && $_ ne '.MAKE')
	{
	  @undefined_conds =
	    Automake::Rule::define ($_, 'internal',
				    RULE_AUTOMAKE, TRUE, INTERNAL);
	}
      my @uniq_deps = uniq (sort @{$dependencies{$_}});
      foreach my $cond (@undefined_conds)
	{
	  my $condstr = $cond->subst_string;
	  &pretty_print_rule ("$condstr$_:", "$condstr\t", @uniq_deps);
	  $output_rules .= $actions{$_} if defined $actions{$_};
	  $output_rules .= "\n";
	}
    }
}


# &handle_tests_dejagnu ()
# ------------------------
sub handle_tests_dejagnu
{
    push (@check_tests, 'check-DEJAGNU');
    $output_rules .= file_contents ('dejagnu', new Automake::Location);
}


# Handle TESTS variable and other checks.
sub handle_tests
{
  if (option 'dejagnu')
    {
      &handle_tests_dejagnu;
    }
  else
    {
      foreach my $c ('DEJATOOL', 'RUNTEST', 'RUNTESTFLAGS')
	{
	  reject_var ($c, "`$c' defined but `dejagnu' not in "
		      . "`AUTOMAKE_OPTIONS'");
	}
    }

  if (var ('TESTS'))
    {
      push (@check_tests, 'check-TESTS');
      $output_rules .= &file_contents ('check', new Automake::Location,
				       COLOR => !! option 'color-tests',
				       PARALLEL_TESTS => !! option 'parallel-tests');

      # Tests that are known programs should have $(EXEEXT) appended.
      # For matching purposes, we need to adjust XFAIL_TESTS as well.
      append_exeext { exists $known_programs{$_[0]} } 'TESTS';
      append_exeext { exists $known_programs{$_[0]} } 'XFAIL_TESTS'
	if (var ('XFAIL_TESTS'));

      if (option 'parallel-tests')
        {
	  define_variable ('TEST_SUITE_LOG', 'test-suite.log', INTERNAL);
	  define_variable ('TEST_SUITE_HTML', '$(TEST_SUITE_LOG:.log=.html)', INTERNAL);
	  my $suff = '.test';
	  my $at_exeext = '';
	  my $handle_exeext = exists $configure_vars{'EXEEXT'};
	  if ($handle_exeext)
	    {
	      $at_exeext = subst ('EXEEXT');
	      $suff = $at_exeext  . ' ' . $suff;
	    }
	  define_variable ('TEST_EXTENSIONS', $suff, INTERNAL);
	  # FIXME: this mishandles conditions.
	  my @test_suffixes = (var 'TEST_EXTENSIONS')->value_as_list_recursive;
	  if ($handle_exeext)
	    {
	      unshift (@test_suffixes, $at_exeext)
	        unless $test_suffixes[0] eq $at_exeext;
	    }
	  unshift (@test_suffixes, '');

	  transform_variable_recursively
	    ('TESTS', 'TEST_LOGS', 'am__testlogs', 1, INTERNAL,
	      sub {
	        my ($subvar, $val, $cond, $full_cond) = @_;
		my $obj = $val;
		return $obj
		  if $val =~ /^\@.*\@$/;
		$obj =~ s/\$\(EXEEXT\)$//o;

		if ($val =~ /(\$\((top_)?srcdir\))\//o)
		  {
		    msg ('error', $subvar->rdef ($cond)->location,
			 "parallel-tests: using `$1' in TESTS is currently broken: `$val'");
		  }

		foreach my $test_suffix (@test_suffixes)
		  {
		    next
		      if $test_suffix eq $at_exeext || $test_suffix eq '';
		    return substr ($obj, 0, length ($obj) - length ($test_suffix)) . '.log'
		      if substr ($obj, - length ($test_suffix)) eq $test_suffix;
		  }
		$obj .= '.log';
		my $compile = 'LOG_COMPILE';
		define_variable ($compile,
				 '$(LOG_COMPILER) $(AM_LOG_FLAGS) $(LOG_FLAGS)', INTERNAL);
		$output_rules .= file_contents ('check2', new Automake::Location,
						GENERIC => 0,
						OBJ => $obj,
						SOURCE => $val,
						COMPILE =>'$(' . $compile . ')',
						EXT => '',
						am__EXEEXT => 'FALSE');
	        return $obj;
	      });

	  my $nhelper=1;
	  my $prev = 'TESTS';
	  my $post = '';
	  my $last_suffix = $test_suffixes[$#test_suffixes];
	  my $cur = '';
	  foreach my $test_suffix (@test_suffixes)
	    {
	      if ($test_suffix eq $last_suffix)
	        {
		  $cur = 'TEST_LOGS';
		}
	      else
	        {
		  $cur = 'am__test_logs' . $nhelper;
		}
	      define_variable ($cur,
		'$(' . $prev . ':' . $test_suffix . $post . '=.log)', INTERNAL);
	      $post = '.log';
	      $prev = $cur;
	      $nhelper++;
	      if ($test_suffix ne $at_exeext && $test_suffix ne '')
	        {
		  (my $ext = $test_suffix) =~ s/^\.//;
		  $ext = uc $ext;
		  my $compile = $ext . '_LOG_COMPILE';
		  define_variable ($compile,
				   '$(' . $ext . '_LOG_COMPILER) $(AM_' .  $ext . '_LOG_FLAGS)'
				   . ' $(' . $ext . '_LOG_FLAGS)', INTERNAL);
		  my $am_exeext = $handle_exeext ? 'am__EXEEXT' : 'FALSE';
		  $output_rules .= file_contents ('check2', new Automake::Location,
						  GENERIC => 1,
						  OBJ => '',
						  SOURCE => '$<',
						  COMPILE => '$(' . $compile . ')',
						  EXT => $test_suffix,
						  am__EXEEXT => $am_exeext);
	        }
	    }

	  define_variable ('TEST_LOGS_TMP', '$(TEST_LOGS:.log=.log-t)', INTERNAL);

	  $clean_files{'$(TEST_LOGS_TMP)'} = MOSTLY_CLEAN;
	  $clean_files{'$(TEST_LOGS)'} = MOSTLY_CLEAN;
	  $clean_files{'$(TEST_SUITE_LOG)'} = MOSTLY_CLEAN;
	  $clean_files{'$(TEST_SUITE_HTML)'} = MOSTLY_CLEAN;
	}
    }
}

# Handle Emacs Lisp.
sub handle_emacs_lisp
{
  my @elfiles = &am_install_var ('-candist', 'lisp', 'LISP',
				 'lisp', 'noinst');

  return if ! @elfiles;

  define_pretty_variable ('am__ELFILES', TRUE, INTERNAL,
			  map { $_->[1] } @elfiles);
  define_pretty_variable ('am__ELCFILES', TRUE, INTERNAL,
			  '$(am__ELFILES:.el=.elc)');
  # This one can be overridden by users.
  define_pretty_variable ('ELCFILES', TRUE, INTERNAL, '$(LISP:.el=.elc)');

  push @all, '$(ELCFILES)';

  require_variables ($elfiles[0][0], "Emacs Lisp sources seen", TRUE,
		     'EMACS', 'lispdir');
  require_conf_file ($elfiles[0][0], FOREIGN, 'elisp-comp');
  &define_variable ('elisp_comp', "$am_config_aux_dir/elisp-comp", INTERNAL);
}

# Handle Python
sub handle_python
{
  my @pyfiles = &am_install_var ('-defaultdist', 'python', 'PYTHON',
				 'noinst');
  return if ! @pyfiles;

  require_variables ($pyfiles[0][0], "Python sources seen", TRUE, 'PYTHON');
  require_conf_file ($pyfiles[0][0], FOREIGN, 'py-compile');
  &define_variable ('py_compile', "$am_config_aux_dir/py-compile", INTERNAL);
}

# Handle Java.
sub handle_java
{
    my @sourcelist = &am_install_var ('-candist',
				      'java', 'JAVA',
				      'java', 'noinst', 'check');
    return if ! @sourcelist;

    my @prefix = am_primary_prefixes ('JAVA', 1,
				      'java', 'noinst', 'check');

    my $dir;
    foreach my $curs (@prefix)
      {
	next
	  if $curs eq 'EXTRA';

	err_var "${curs}_JAVA", "multiple _JAVA primaries in use"
	  if defined $dir;
	$dir = $curs;
      }


    push (@all, 'class' . $dir . '.stamp');
}


# Handle some of the minor options.
sub handle_minor_options
{
  if (option 'readme-alpha')
    {
      if ($relative_dir eq '.')
	{
	  if ($package_version !~ /^$GNITS_VERSION_PATTERN$/)
	    {
	      msg ('error-gnits', $package_version_location,
		   "version `$package_version' doesn't follow " .
		   "Gnits standards");
	    }
	  if (defined $1 && -f 'README-alpha')
	    {
	      # This means we have an alpha release.  See
	      # GNITS_VERSION_PATTERN for details.
	      push_dist_common ('README-alpha');
	    }
	}
    }
}

################################################################

# ($OUTPUT, @INPUTS)
# &split_config_file_spec ($SPEC)
# -------------------------------
# Decode the Autoconf syntax for config files (files, headers, links
# etc.).
sub split_config_file_spec ($)
{
  my ($spec) = @_;
  my ($output, @inputs) = split (/:/, $spec);

  push @inputs, "$output.in"
    unless @inputs;

  return ($output, @inputs);
}

# $input
# locate_am (@POSSIBLE_SOURCES)
# -----------------------------
# AC_CONFIG_FILES allow specifications such as Makefile:top.in:mid.in:bot.in
# This functions returns the first *.in file for which a *.am exists.
# It returns undef otherwise.
sub locate_am (@)
{
  my (@rest) = @_;
  my $input;
  foreach my $file (@rest)
    {
      if (($file =~ /^(.*)\.in$/) && -f "$1.am")
	{
	  $input = $file;
	  last;
	}
    }
  return $input;
}

my %make_list;

# &scan_autoconf_config_files ($WHERE, $CONFIG-FILES)
# ---------------------------------------------------
# Study $CONFIG-FILES which is the first argument to AC_CONFIG_FILES
# (or AC_OUTPUT).
sub scan_autoconf_config_files ($$)
{
  my ($where, $config_files) = @_;

  # Look at potential Makefile.am's.
  foreach (split ' ', $config_files)
    {
      # Must skip empty string for Perl 4.
      next if $_ eq "\\" || $_ eq '';

      # Handle $local:$input syntax.
      my ($local, @rest) = split (/:/);
      @rest = ("$local.in",) unless @rest;
      msg ('portability', $where,
	  "Omit leading `./' from config file names such as `$local',"
	  . "\nas not all make implementations treat `file' and `./file' equally.")
	if ($local =~ /^\.\//);
      my $input = locate_am @rest;
      if ($input)
	{
	  # We have a file that automake should generate.
	  $make_list{$input} = join (':', ($local, @rest));
	}
      else
	{
	  # We have a file that automake should cause to be
	  # rebuilt, but shouldn't generate itself.
	  push (@other_input_files, $_);
	}
      $ac_config_files_location{$local} = $where;
      $ac_config_files_condition{$local} =
        new Automake::Condition (@cond_stack)
          if (@cond_stack);
    }
}


# &scan_autoconf_traces ($FILENAME)
# ---------------------------------
sub scan_autoconf_traces ($)
{
  my ($filename) = @_;

  # Macros to trace, with their minimal number of arguments.
  #
  # IMPORTANT: If you add a macro here, you should also add this macro
  # =========  to Automake-preselection in autoconf/lib/autom4te.in.
  my %traced = (
		AC_CANONICAL_BUILD => 0,
		AC_CANONICAL_HOST => 0,
		AC_CANONICAL_TARGET => 0,
		AC_CONFIG_AUX_DIR => 1,
		AC_CONFIG_FILES => 1,
		AC_CONFIG_HEADERS => 1,
		AC_CONFIG_LIBOBJ_DIR => 1,
		AC_CONFIG_LINKS => 1,
		AC_FC_SRCEXT => 1,
		AC_INIT => 0,
		AC_LIBSOURCE => 1,
		AC_REQUIRE_AUX_FILE => 1,
		AC_SUBST_TRACE => 1,
		AM_AUTOMAKE_VERSION => 1,
		AM_CONDITIONAL => 2,
		AM_ENABLE_MULTILIB => 0,
		AM_GNU_GETTEXT => 0,
		AM_GNU_GETTEXT_INTL_SUBDIR => 0,
		AM_INIT_AUTOMAKE => 0,
		AM_MAINTAINER_MODE => 0,
		AM_PROG_CC_C_O => 0,
		AM_SILENT_RULES => 0,
		_AM_SUBST_NOTMAKE => 1,
		_AM_COND_IF => 1,
		_AM_COND_ELSE => 1,
		_AM_COND_ENDIF => 1,
		LT_SUPPORTED_TAG => 1,
		_LT_AC_TAGCONFIG => 0,
		m4_include => 1,
		m4_sinclude => 1,
		sinclude => 1,
	      );

  my $traces = ($ENV{AUTOCONF} || 'autoconf') . " ";

  # Use a separator unlikely to be used, not `:', the default, which
  # has a precise meaning for AC_CONFIG_FILES and so on.
  $traces .= join (' ',
		   map { "--trace=$_" . ':\$f:\$l::\$d::\$n::\${::}%' }
		   (keys %traced));

  my $tracefh = new Automake::XFile ("$traces $filename |");
  verb "reading $traces";

  @cond_stack = ();
  my $where;

  while ($_ = $tracefh->getline)
    {
      chomp;
      my ($here, $depth, @args) = split (/::/);
      $where = new Automake::Location $here;
      my $macro = $args[0];

      prog_error ("unrequested trace `$macro'")
	unless exists $traced{$macro};

      # Skip and diagnose malformed calls.
      if ($#args < $traced{$macro})
	{
	  msg ('syntax', $where, "not enough arguments for $macro");
	  next;
	}

      # Alphabetical ordering please.
      if ($macro eq 'AC_CANONICAL_BUILD')
	{
	  if ($seen_canonical <= AC_CANONICAL_BUILD)
	    {
	      $seen_canonical = AC_CANONICAL_BUILD;
	      $canonical_location = $where;
	    }
	}
      elsif ($macro eq 'AC_CANONICAL_HOST')
	{
	  if ($seen_canonical <= AC_CANONICAL_HOST)
	    {
	      $seen_canonical = AC_CANONICAL_HOST;
	      $canonical_location = $where;
	    }
	}
      elsif ($macro eq 'AC_CANONICAL_TARGET')
	{
	  $seen_canonical = AC_CANONICAL_TARGET;
	  $canonical_location = $where;
	}
      elsif ($macro eq 'AC_CONFIG_AUX_DIR')
	{
	  if ($seen_init_automake)
	    {
	      error ($where, "AC_CONFIG_AUX_DIR must be called before "
		     . "AM_INIT_AUTOMAKE...", partial => 1);
	      error ($seen_init_automake, "... AM_INIT_AUTOMAKE called here");
	    }
	  $config_aux_dir = $args[1];
	  $config_aux_dir_set_in_configure_ac = 1;
	  $relative_dir = '.';
	  check_directory ($config_aux_dir, $where);
	}
      elsif ($macro eq 'AC_CONFIG_FILES')
	{
	  # Look at potential Makefile.am's.
	  scan_autoconf_config_files ($where, $args[1]);
	}
      elsif ($macro eq 'AC_CONFIG_HEADERS')
	{
	  foreach my $spec (split (' ', $args[1]))
	    {
	      my ($dest, @src) = split (':', $spec);
	      $ac_config_files_location{$dest} = $where;
	      push @config_headers, $spec;
	    }
	}
      elsif ($macro eq 'AC_CONFIG_LIBOBJ_DIR')
	{
	  $config_libobj_dir = $args[1];
	  $relative_dir = '.';
	  check_directory ($config_libobj_dir, $where);
	}
      elsif ($macro eq 'AC_CONFIG_LINKS')
	{
	  foreach my $spec (split (' ', $args[1]))
	    {
	      my ($dest, $src) = split (':', $spec);
	      $ac_config_files_location{$dest} = $where;
	      push @config_links, $spec;
	    }
	}
      elsif ($macro eq 'AC_FC_SRCEXT')
	{
	  my $suffix = $args[1];
	  # These flags are used as %SOURCEFLAG% in depend2.am,
	  # where the trailing space is important.
	  $sourceflags{'.' . $suffix} = '$(FCFLAGS_' . $suffix . ') '
	    if ($suffix eq 'f90' || $suffix eq 'f95' || $suffix eq 'f03' || $suffix eq 'f08');
	}
      elsif ($macro eq 'AC_INIT')
	{
	  if (defined $args[2])
	    {
	      $package_version = $args[2];
	      $package_version_location = $where;
	    }
	}
      elsif ($macro eq 'AC_LIBSOURCE')
	{
	  $libsources{$args[1]} = $here;
	}
      elsif ($macro eq 'AC_REQUIRE_AUX_FILE')
	{
	  # Only remember the first time a file is required.
	  $required_aux_file{$args[1]} = $where
	    unless exists $required_aux_file{$args[1]};
	}
      elsif ($macro eq 'AC_SUBST_TRACE')
	{
	  # Just check for alphanumeric in AC_SUBST_TRACE.  If you do
	  # AC_SUBST(5), then too bad.
	  $configure_vars{$args[1]} = $where
	    if $args[1] =~ /^\w+$/;
	}
      elsif ($macro eq 'AM_AUTOMAKE_VERSION')
	{
	  error ($where,
		 "version mismatch.  This is Automake $VERSION,\n" .
		 "but the definition used by this AM_INIT_AUTOMAKE\n" .
		 "comes from Automake $args[1].  You should recreate\n" .
		 "aclocal.m4 with aclocal and run automake again.\n",
		 # $? = 63 is used to indicate version mismatch to missing.
		 exit_code => 63)
	    if $VERSION ne $args[1];

	  $seen_automake_version = 1;
	}
      elsif ($macro eq 'AM_CONDITIONAL')
	{
	  $configure_cond{$args[1]} = $where;
	}
      elsif ($macro eq 'AM_ENABLE_MULTILIB')
	{
	  $seen_multilib = $where;
	}
      elsif ($macro eq 'AM_GNU_GETTEXT')
	{
	  $seen_gettext = $where;
	  $ac_gettext_location = $where;
	  $seen_gettext_external = grep ($_ eq 'external', @args);
	}
      elsif ($macro eq 'AM_GNU_GETTEXT_INTL_SUBDIR')
	{
	  $seen_gettext_intl = $where;
	}
      elsif ($macro eq 'AM_INIT_AUTOMAKE')
	{
	  $seen_init_automake = $where;
	  if (defined $args[2])
	    {
	      $package_version = $args[2];
	      $package_version_location = $where;
	    }
	  elsif (defined $args[1])
	    {
	      exit $exit_code
		if (process_global_option_list ($where,
						split (' ', $args[1])));
	    }
	}
      elsif ($macro eq 'AM_MAINTAINER_MODE')
	{
	  $seen_maint_mode = $where;
	}
      elsif ($macro eq 'AM_PROG_CC_C_O')
	{
	  $seen_cc_c_o = $where;
	}
      elsif ($macro eq 'AM_SILENT_RULES')
        {
	  set_global_option ('silent-rules', $where);
	}
      elsif ($macro eq '_AM_COND_IF')
        {
	  cond_stack_if ('', $args[1], $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_COND_ELSE')
        {
	  cond_stack_else ('!', $args[1], $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_COND_ENDIF')
        {
	  cond_stack_endif (undef, undef, $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_SUBST_NOTMAKE')
	{
	  $ignored_configure_vars{$args[1]} = $where;
	}
      elsif ($macro eq 'm4_include'
	     || $macro eq 'm4_sinclude'
	     || $macro eq 'sinclude')
	{
	  # Skip missing `sinclude'd files.
	  next if $macro ne 'm4_include' && ! -f $args[1];

	  # Some modified versions of Autoconf don't use
	  # frozen files.  Consequently it's possible that we see all
	  # m4_include's performed during Autoconf's startup.
	  # Obviously we don't want to distribute Autoconf's files
	  # so we skip absolute filenames here.
	  push @configure_deps, '$(top_srcdir)/' . $args[1]
	    unless $here =~ m,^(?:\w:)?[\\/],;
	  # Keep track of the greatest timestamp.
	  if (-e $args[1])
	    {
	      my $mtime = mtime $args[1];
	      $configure_deps_greatest_timestamp = $mtime
		if $mtime > $configure_deps_greatest_timestamp;
	    }
	}
      elsif ($macro eq 'LT_SUPPORTED_TAG')
	{
	  $libtool_tags{$args[1]} = 1;
	  $libtool_new_api = 1;
	}
      elsif ($macro eq '_LT_AC_TAGCONFIG')
	{
	  # _LT_AC_TAGCONFIG is an old macro present in Libtool 1.5.
	  # We use it to detect whether tags are supported.  Our
	  # preferred interface is LT_SUPPORTED_TAG, but it was
	  # introduced in Libtool 1.6.
	  if (0 == keys %libtool_tags)
	    {
	      # Hardcode the tags supported by Libtool 1.5.
	      %libtool_tags = (CC => 1, CXX => 1, GCJ => 1, F77 => 1);
	    }
	}
    }

  error ($where, "condition stack not properly closed")
    if (@cond_stack);

  $tracefh->close;
}


# &scan_autoconf_files ()
# -----------------------
# Check whether we use `configure.ac' or `configure.in'.
# Scan it (and possibly `aclocal.m4') for interesting things.
# We must scan aclocal.m4 because there might be AC_SUBSTs and such there.
sub scan_autoconf_files ()
{
  # Reinitialize libsources here.  This isn't really necessary,
  # since we currently assume there is only one configure.ac.  But
  # that won't always be the case.
  %libsources = ();

  # Keep track of the youngest configure dependency.
  $configure_deps_greatest_timestamp = mtime $configure_ac;
  if (-e 'aclocal.m4')
    {
      my $mtime = mtime 'aclocal.m4';
      $configure_deps_greatest_timestamp = $mtime
	if $mtime > $configure_deps_greatest_timestamp;
    }

  scan_autoconf_traces ($configure_ac);

  @configure_input_files = sort keys %make_list;
  # Set input and output files if not specified by user.
  if (! @input_files)
    {
      @input_files = @configure_input_files;
      %output_files = %make_list;
    }


  if (! $seen_init_automake)
    {
      err_ac ("no proper invocation of AM_INIT_AUTOMAKE was found.\nYou "
	      . "should verify that $configure_ac invokes AM_INIT_AUTOMAKE,"
	      . "\nthat aclocal.m4 is present in the top-level directory,\n"
	      . "and that aclocal.m4 was recently regenerated "
	      . "(using aclocal).");
    }
  else
    {
      if (! $seen_automake_version)
	{
	  if (-f 'aclocal.m4')
	    {
	      error ($seen_init_automake,
		     "your implementation of AM_INIT_AUTOMAKE comes from " .
		     "an\nold Automake version.  You should recreate " .
		     "aclocal.m4\nwith aclocal and run automake again.\n",
		     # $? = 63 is used to indicate version mismatch to missing.
		     exit_code => 63);
	    }
	  else
	    {
	      error ($seen_init_automake,
		     "no proper implementation of AM_INIT_AUTOMAKE was " .
		     "found,\nprobably because aclocal.m4 is missing...\n" .
		     "You should run aclocal to create this file, then\n" .
		     "run automake again.\n");
	    }
	}
    }

  locate_aux_dir ();

  # Reorder @input_files so that the Makefile that distributes aux
  # files is processed last.  This is important because each directory
  # can require auxiliary scripts and we should wait until they have
  # been installed before distributing them.

  # The Makefile.in that distribute the aux files is the one in
  # $config_aux_dir or the top-level Makefile.
  my $auxdirdist = is_make_dir ($config_aux_dir) ? $config_aux_dir : '.';
  my @new_input_files = ();
  while (@input_files)
    {
      my $in = pop @input_files;
      my @ins = split (/:/, $output_files{$in});
      if (dirname ($ins[0]) eq $auxdirdist)
	{
	  push @new_input_files, $in;
	  $automake_will_process_aux_dir = 1;
	}
      else
	{
	  unshift @new_input_files, $in;
	}
    }
  @input_files = @new_input_files;

  # If neither the auxdir/Makefile nor the ./Makefile are generated
  # by Automake, we won't distribute the aux files anyway.  Assume
  # the user know what (s)he does, and pretend we will distribute
  # them to disable the error in require_file_internal.
  $automake_will_process_aux_dir = 1 if ! is_make_dir ($auxdirdist);

  # Look for some files we need.  Always check for these.  This
  # check must be done for every run, even those where we are only
  # looking at a subdir Makefile.  We must set relative_dir for
  # maybe_push_required_file to work.
  # Sort the files for stable verbose output.
  $relative_dir = '.';
  foreach my $file (sort keys %required_aux_file)
    {
      require_conf_file ($required_aux_file{$file}->get, FOREIGN, $file)
    }
  err_am "`install.sh' is an anachronism; use `install-sh' instead"
    if -f $config_aux_dir . '/install.sh';

  # Preserve dist_common for later.
  $configure_dist_common = variable_value ('DIST_COMMON') || '';

}

################################################################

# Set up for Cygnus mode.
sub check_cygnus
{
  my $cygnus = option 'cygnus';
  return unless $cygnus;

  set_strictness ('foreign');
  set_option ('no-installinfo', $cygnus);
  set_option ('no-dependencies', $cygnus);
  set_option ('no-dist', $cygnus);

  err_ac "`AM_MAINTAINER_MODE' required when --cygnus specified"
    if !$seen_maint_mode;
}

# Do any extra checking for GNU standards.
sub check_gnu_standards
{
  if ($relative_dir eq '.')
    {
      # In top level (or only) directory.
      require_file ("$am_file.am", GNU,
		    qw/INSTALL NEWS README AUTHORS ChangeLog/);

      # Accept one of these three licenses; default to COPYING.
      # Make sure we do not overwrite an existing license.
      my $license;
      foreach (qw /COPYING COPYING.LIB COPYING.LESSER/)
	{
	  if (-f $_)
	    {
	      $license = $_;
	      last;
	    }
	}
      require_file ("$am_file.am", GNU, 'COPYING')
	unless $license;
    }

  for my $opt ('no-installman', 'no-installinfo')
    {
      msg ('error-gnu', option $opt,
	   "option `$opt' disallowed by GNU standards")
	if option $opt;
    }
}

# Do any extra checking for GNITS standards.
sub check_gnits_standards
{
  if ($relative_dir eq '.')
    {
      # In top level (or only) directory.
      require_file ("$am_file.am", GNITS, 'THANKS');
    }
}

################################################################
#
# Functions to handle files of each language.

# Each `lang_X_rewrite($DIRECTORY, $BASE, $EXT)' function follows a
# simple formula: Return value is LANG_SUBDIR if the resulting object
# file should be in a subdir if the source file is, LANG_PROCESS if
# file is to be dealt with, LANG_IGNORE otherwise.

# Much of the actual processing is handled in
# handle_single_transform.  These functions exist so that
# auxiliary information can be recorded for a later cleanup pass.
# Note that the calls to these functions are computed, so don't bother
# searching for their precise names in the source.

# This is just a convenience function that can be used to determine
# when a subdir object should be used.
sub lang_sub_obj
{
    return option 'subdir-objects' ? LANG_SUBDIR : LANG_PROCESS;
}

# Rewrite a single C source file.
sub lang_c_rewrite
{
  my ($directory, $base, $ext, $nonansi_obj, $have_per_exec_flags, $var) = @_;

  if (option 'ansi2knr' && $base =~ /_$/)
    {
      # FIXME: include line number in error.
      err_am "C source file `$base.c' would be deleted by ansi2knr rules";
    }

  my $r = LANG_PROCESS;
  if (option 'subdir-objects')
    {
      $r = LANG_SUBDIR;
      if ($directory && $directory ne '.')
	{
	  $base = $directory . '/' . $base;

	  # libtool is always able to put the object at the proper place,
	  # so we do not have to require AM_PROG_CC_C_O when building .lo files.
	  msg_var ('portability', $var,
		   "compiling `$base.c' in subdir requires "
		   . "`AM_PROG_CC_C_O' in `$configure_ac'",
		   uniq_scope => US_GLOBAL,
		   uniq_part => 'AM_PROG_CC_C_O subdir')
	    unless $seen_cc_c_o || $nonansi_obj eq '.lo';
	}

      # In this case we already have the directory information, so
      # don't add it again.
      $de_ansi_files{$base} = '';
    }
  else
    {
      $de_ansi_files{$base} = (($directory eq '.' || $directory eq '')
			       ? ''
			       : "$directory/");
    }

  if (! $seen_cc_c_o
      && $have_per_exec_flags
      && ! option 'subdir-objects'
      && $nonansi_obj ne '.lo')
    {
      msg_var ('portability',
	       $var, "compiling `$base.c' with per-target flags requires "
	       . "`AM_PROG_CC_C_O' in `$configure_ac'",
	       uniq_scope => US_GLOBAL,
	       uniq_part => 'AM_PROG_CC_C_O per-target')
    }

    return $r;
}

# Rewrite a single C++ source file.
sub lang_cxx_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single header file.
sub lang_header_rewrite
{
    # Header files are simply ignored.
    return LANG_IGNORE;
}

# Rewrite a single Vala source file.
sub lang_vala_rewrite
{
    my ($directory, $base, $ext) = @_;

    (my $newext = $ext) =~ s/vala$/c/;
    return (LANG_SUBDIR, $newext);
}

# Rewrite a single yacc file.
sub lang_yacc_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = &lang_sub_obj;
    (my $newext = $ext) =~ tr/y/c/;
    return ($r, $newext);
}

# Rewrite a single yacc++ file.
sub lang_yaccxx_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = &lang_sub_obj;
    (my $newext = $ext) =~ tr/y/c/;
    return ($r, $newext);
}

# Rewrite a single lex file.
sub lang_lex_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = &lang_sub_obj;
    (my $newext = $ext) =~ tr/l/c/;
    return ($r, $newext);
}

# Rewrite a single lex++ file.
sub lang_lexxx_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = &lang_sub_obj;
    (my $newext = $ext) =~ tr/l/c/;
    return ($r, $newext);
}

# Rewrite a single assembly file.
sub lang_asm_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single preprocessed assembly file.
sub lang_cppasm_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Fortran 77 file.
sub lang_f77_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Fortran file.
sub lang_fc_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single preprocessed Fortran file.
sub lang_ppfc_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single preprocessed Fortran 77 file.
sub lang_ppf77_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single ratfor file.
sub lang_ratfor_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Objective C file.
sub lang_objc_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Unified Parallel C file.
sub lang_upc_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Java file.
sub lang_java_rewrite
{
    return LANG_SUBDIR;
}

# The lang_X_finish functions are called after all source file
# processing is done.  Each should handle defining rules for the
# language, etc.  A finish function is only called if a source file of
# the appropriate type has been seen.

sub lang_c_finish
{
    # Push all libobjs files onto de_ansi_files.  We actually only
    # push files which exist in the current directory, and which are
    # genuine source files.
    foreach my $file (keys %libsources)
    {
	if ($file =~ /^(.*)\.[cly]$/ && -f "$relative_dir/$file")
	{
	    $de_ansi_files{$1} = ''
	}
    }

    if (option 'ansi2knr' && keys %de_ansi_files)
    {
	# Make all _.c files depend on their corresponding .c files.
	my @objects;
	foreach my $base (sort keys %de_ansi_files)
	{
	    # Each _.c file must depend on ansi2knr; otherwise it
	    # might be used in a parallel build before it is built.
	    # We need to support files in the srcdir and in the build
	    # dir (because these files might be auto-generated.  But
	    # we can't use $< -- some makes only define $< during a
	    # suffix rule.
	    my $ansfile = $de_ansi_files{$base} . $base . '.c';
	    $output_rules .= ($base . "_.c: $ansfile \$(ANSI2KNR)\n\t"
			      . '$(CPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) '
			      . '`if test -f $(srcdir)/' . $ansfile
			      . '; then echo $(srcdir)/' . $ansfile
			      . '; else echo ' . $ansfile . '; fi` '
			      . "| sed 's/^# \\([0-9]\\)/#line \\1/' "
			      . '| $(ANSI2KNR) > $@'
			      # If ansi2knr fails then we shouldn't
			      # create the _.c file
			      . " || rm -f \$\@\n");
	    push (@objects, $base . '_.$(OBJEXT)');
	    push (@objects, $base . '_.lo')
	      if var ('LIBTOOL');

	    # Explicitly clean the _.c files if they are in a
	    # subdirectory. (In the current directory they get erased
	    # by a `rm -f *_.c' rule.)
	    $clean_files{$base . '_.c'} = MOSTLY_CLEAN
	      if dirname ($base) ne '.';
	}

	# Make all _.o (and _.lo) files depend on ansi2knr.
	# Use a sneaky little hack to make it print nicely.
	&pretty_print_rule ('', '', @objects, ':', '$(ANSI2KNR)');
    }
}

sub lang_vala_finish_target ($$)
{
  my ($self, $name) = @_;

  my $derived = canonicalize ($name);
  my $varname = $derived . '_SOURCES';
  my $var = var ($varname);

  if ($var)
    {
      foreach my $file ($var->value_as_list_recursive)
        {
          $output_rules .= "\$(srcdir)/$file: \$(srcdir)/${derived}_vala.stamp\n".
            "\t\@if test -f \$@; then :; else \\\n".
            "\t  rm -f \$(srcdir)/${derived}_vala.stamp; \\\n".
            "\t  \$(am__cd) \$(srcdir) && \$(MAKE) \$(AM_MAKEFLAGS) ${derived}_vala.stamp; \\\n".
            "\tfi\n"
            if $file =~ s/(.*)\.vala$/$1.c/;
        }
    }

  # Add rebuild rules for generated header and vapi files
  my $flags = var ($derived . '_VALAFLAGS');
  if ($flags)
    {
      my $lastflag = '';
      foreach my $flag ($flags->value_as_list_recursive)
	{
	  if (grep (/$lastflag/, ('-H', '-h', '--header', '--internal-header',
	                          '--vapi', '--internal-vapi', '--gir')))
	    {
	      my $headerfile = $flag;
	      $output_rules .= "\$(srcdir)/$headerfile: \$(srcdir)/${derived}_vala.stamp\n".
		"\t\@if test -f \$@; then :; else \\\n".
		"\t  rm -f \$(srcdir)/${derived}_vala.stamp; \\\n".
		"\t  \$(am__cd) \$(srcdir) && \$(MAKE) \$(AM_MAKEFLAGS) ${derived}_vala.stamp; \\\n".
		"\tfi\n";

	      # valac is not used when building from dist tarballs
	      # distribute the generated files
	      push_dist_common ($headerfile);
	      $clean_files{$headerfile} = MAINTAINER_CLEAN;
	    }
	  $lastflag = $flag;
	}
    }

  my $compile = $self->compile;

  # Rewrite each occurrence of `AM_VALAFLAGS' in the compile
  # rule into `${derived}_VALAFLAGS' if it exists.
  my $val = "${derived}_VALAFLAGS";
  $compile =~ s/\(AM_VALAFLAGS\)/\($val\)/
    if set_seen ($val);

  # VALAFLAGS is a user variable (per GNU Standards),
  # it should not be overridden in the Makefile...
  check_user_variables ['VALAFLAGS'];

  my $dirname = dirname ($name);

  # Only generate C code, do not run C compiler
  $compile .= " -C";

  my $verbose = verbose_flag ('VALAC');
  my $silent = silent_flag ();

  $output_rules .=
    "${derived}_vala.stamp: \$(${derived}_SOURCES)\n".
    "\t${verbose}${compile} \$(${derived}_SOURCES)\n".
    "\t${silent}touch \$@\n";

  push_dist_common ("${derived}_vala.stamp");

  $clean_files{"${derived}_vala.stamp"} = MAINTAINER_CLEAN;
}

# Add output rules to invoke valac and create stamp file as a witness
# to handle multiple outputs. This function is called after all source
# file processing is done.
sub lang_vala_finish
{
  my ($self) = @_;

  foreach my $prog (keys %known_programs)
    {
      lang_vala_finish_target ($self, $prog);
    }

  while (my ($name) = each %known_libraries)
    {
      lang_vala_finish_target ($self, $name);
    }
}

# The built .c files should be cleaned only on maintainer-clean
# as the .c files are distributed. This function is called for each
# .vala source file.
sub lang_vala_target_hook
{
  my ($self, $aggregate, $output, $input, %transform) = @_;

  $clean_files{$output} = MAINTAINER_CLEAN;
}

# This is a yacc helper which is called whenever we have decided to
# compile a yacc file.
sub lang_yacc_target_hook
{
    my ($self, $aggregate, $output, $input, %transform) = @_;

    my $flag = $aggregate . "_YFLAGS";
    my $flagvar = var $flag;
    my $YFLAGSvar = var 'YFLAGS';
    if (($flagvar && $flagvar->variable_value =~ /$DASH_D_PATTERN/o)
	|| ($YFLAGSvar && $YFLAGSvar->variable_value =~ /$DASH_D_PATTERN/o))
    {
	(my $output_base = $output) =~ s/$KNOWN_EXTENSIONS_PATTERN$//;
	my $header = $output_base . '.h';

	# Found a `-d' that applies to the compilation of this file.
	# Add a dependency for the generated header file, and arrange
	# for that file to be included in the distribution.
	foreach my $cond (Automake::Rule::define (${header}, 'internal',
						  RULE_AUTOMAKE, TRUE,
						  INTERNAL))
	  {
	    my $condstr = $cond->subst_string;
	    $output_rules .=
	      "$condstr${header}: $output\n"
	      # Recover from removal of $header
	      . "$condstr\t\@if test ! -f \$@; then \\\n"
	      . "$condstr\t  rm -f $output; \\\n"
	      . "$condstr\t  \$(MAKE) \$(AM_MAKEFLAGS) $output; \\\n"
	      . "$condstr\telse :; fi\n";
	  }
	# Distribute the generated file, unless its .y source was
	# listed in a nodist_ variable.  (&handle_source_transform
	# will set DIST_SOURCE.)
	&push_dist_common ($header)
	  if $transform{'DIST_SOURCE'};

	# If the files are built in the build directory, then we want
	# to remove them with `make clean'.  If they are in srcdir
	# they shouldn't be touched.  However, we can't determine this
	# statically, and the GNU rules say that yacc/lex output files
	# should be removed by maintainer-clean.  So that's what we
	# do.
	$clean_files{$header} = MAINTAINER_CLEAN;
    }
    # Erase $OUTPUT on `make maintainer-clean' (by GNU standards).
    # See the comment above for $HEADER.
    $clean_files{$output} = MAINTAINER_CLEAN;
}

# This is a lex helper which is called whenever we have decided to
# compile a lex file.
sub lang_lex_target_hook
{
    my ($self, $aggregate, $output, $input) = @_;
    # If the files are built in the build directory, then we want to
    # remove them with `make clean'.  If they are in srcdir they
    # shouldn't be touched.  However, we can't determine this
    # statically, and the GNU rules say that yacc/lex output files
    # should be removed by maintainer-clean.  So that's what we do.
    $clean_files{$output} = MAINTAINER_CLEAN;
}

# This is a helper for both lex and yacc.
sub yacc_lex_finish_helper
{
  return if defined $language_scratch{'lex-yacc-done'};
  $language_scratch{'lex-yacc-done'} = 1;

  # FIXME: for now, no line number.
  require_conf_file ($configure_ac, FOREIGN, 'ylwrap');
  &define_variable ('YLWRAP', "$am_config_aux_dir/ylwrap", INTERNAL);
}

sub lang_yacc_finish
{
  return if defined $language_scratch{'yacc-done'};
  $language_scratch{'yacc-done'} = 1;

  reject_var 'YACCFLAGS', "`YACCFLAGS' obsolete; use `YFLAGS' instead";

  yacc_lex_finish_helper;
}


sub lang_lex_finish
{
  return if defined $language_scratch{'lex-done'};
  $language_scratch{'lex-done'} = 1;

  yacc_lex_finish_helper;
}


# Given a hash table of linker names, pick the name that has the most
# precedence.  This is lame, but something has to have global
# knowledge in order to eliminate the conflict.  Add more linkers as
# required.
sub resolve_linker
{
    my (%linkers) = @_;

    foreach my $l (qw(GCJLINK CXXLINK F77LINK FCLINK OBJCLINK UPCLINK))
    {
	return $l if defined $linkers{$l};
    }
    return 'LINK';
}

# Called to indicate that an extension was used.
sub saw_extension
{
    my ($ext) = @_;
    if (! defined $extension_seen{$ext})
    {
	$extension_seen{$ext} = 1;
    }
    else
    {
	++$extension_seen{$ext};
    }
}

# Return the number of files seen for a given language.  Knows about
# special cases we care about.  FIXME: this is hideous.  We need
# something that involves real language objects.  For instance yacc
# and yaccxx could both derive from a common yacc class which would
# know about the strange ylwrap requirement.  (Or better yet we could
# just not support legacy yacc!)
sub count_files_for_language
{
    my ($name) = @_;

    my @names;
    if ($name eq 'yacc' || $name eq 'yaccxx')
    {
	@names = ('yacc', 'yaccxx');
    }
    elsif ($name eq 'lex' || $name eq 'lexxx')
    {
	@names = ('lex', 'lexxx');
    }
    else
    {
	@names = ($name);
    }

    my $r = 0;
    foreach $name (@names)
    {
	my $lang = $languages{$name};
	foreach my $ext (@{$lang->extensions})
	{
	    $r += $extension_seen{$ext}
		if defined $extension_seen{$ext};
	}
    }

    return $r
}

# Called to ask whether source files have been seen . If HEADERS is 1,
# headers can be included.
sub saw_sources_p
{
    my ($headers) = @_;

    # count all the sources
    my $count = 0;
    foreach my $val (values %extension_seen)
    {
	$count += $val;
    }

    if (!$headers)
    {
	$count -= count_files_for_language ('header');
    }

    return $count > 0;
}


# register_language (%ATTRIBUTE)
# ------------------------------
# Register a single language.
# Each %ATTRIBUTE is of the form ATTRIBUTE => VALUE.
sub register_language (%)
{
  my (%option) = @_;

  # Set the defaults.
  $option{'ansi'} = 0
    unless defined $option{'ansi'};
  $option{'autodep'} = 'no'
    unless defined $option{'autodep'};
  $option{'linker'} = ''
    unless defined $option{'linker'};
  $option{'flags'} = []
    unless defined $option{'flags'};
  $option{'output_extensions'} = sub { return ( '.$(OBJEXT)', '.lo' ) }
    unless defined $option{'output_extensions'};
  $option{'nodist_specific'} = 0
    unless defined $option{'nodist_specific'};

  my $lang = new Language (%option);

  # Fill indexes.
  $extension_map{$_} = $lang->name foreach @{$lang->extensions};
  $languages{$lang->name} = $lang;
  my $link = $lang->linker;
  if ($link)
    {
      if (exists $link_languages{$link})
	{
	  prog_error ("`$link' has different definitions in "
		      . $lang->name . " and " . $link_languages{$link}->name)
	    if $lang->link ne $link_languages{$link}->link;
	}
      else
	{
	  $link_languages{$link} = $lang;
	}
    }

  # Update the pattern of known extensions.
  accept_extensions (@{$lang->extensions});

  # Upate the $suffix_rule map.
  foreach my $suffix (@{$lang->extensions})
    {
      foreach my $dest (&{$lang->output_extensions} ($suffix))
	{
	  register_suffix_rule (INTERNAL, $suffix, $dest);
	}
    }
}

# derive_suffix ($EXT, $OBJ)
# --------------------------
# This function is used to find a path from a user-specified suffix $EXT
# to $OBJ or to some other suffix we recognize internally, e.g. `cc'.
sub derive_suffix ($$)
{
  my ($source_ext, $obj) = @_;

  while (! $extension_map{$source_ext}
	 && $source_ext ne $obj
	 && exists $suffix_rules->{$source_ext}
	 && exists $suffix_rules->{$source_ext}{$obj})
    {
      $source_ext = $suffix_rules->{$source_ext}{$obj}[0];
    }

  return $source_ext;
}


################################################################

# Pretty-print something and append to output_rules.
sub pretty_print_rule
{
    $output_rules .= &makefile_wrap (@_);
}


################################################################


## -------------------------------- ##
## Handling the conditional stack.  ##
## -------------------------------- ##


# $STRING
# make_conditional_string ($NEGATE, $COND)
# ----------------------------------------
sub make_conditional_string ($$)
{
  my ($negate, $cond) = @_;
  $cond = "${cond}_TRUE"
    unless $cond =~ /^TRUE|FALSE$/;
  $cond = Automake::Condition::conditional_negate ($cond)
    if $negate;
  return $cond;
}


my %_am_macro_for_cond =
  (
  AMDEP => "one of the compiler tests\n"
	   . "    AC_PROG_CC, AC_PROG_CXX, AC_PROG_CXX, AC_PROG_OBJC,\n"
	   . "    AM_PROG_AS, AM_PROG_GCJ, AM_PROG_UPC",
  am__fastdepCC => 'AC_PROG_CC',
  am__fastdepCCAS => 'AM_PROG_AS',
  am__fastdepCXX => 'AC_PROG_CXX',
  am__fastdepGCJ => 'AM_PROG_GCJ',
  am__fastdepOBJC => 'AC_PROG_OBJC',
  am__fastdepUPC => 'AM_PROG_UPC'
  );

# $COND
# cond_stack_if ($NEGATE, $COND, $WHERE)
# --------------------------------------
sub cond_stack_if ($$$)
{
  my ($negate, $cond, $where) = @_;

  if (! $configure_cond{$cond} && $cond !~ /^TRUE|FALSE$/)
    {
      my $text = "$cond does not appear in AM_CONDITIONAL";
      my $scope = US_LOCAL;
      if (exists $_am_macro_for_cond{$cond})
	{
	  my $mac = $_am_macro_for_cond{$cond};
	  $text .= "\n  The usual way to define `$cond' is to add ";
	  $text .= ($mac =~ / /) ? $mac : "`$mac'";
	  $text .= "\n  to `$configure_ac' and run `aclocal' and `autoconf' again.";
	  # These warnings appear in Automake files (depend2.am),
	  # so there is no need to display them more than once:
	  $scope = US_GLOBAL;
	}
      error $where, $text, uniq_scope => $scope;
    }

  push (@cond_stack, make_conditional_string ($negate, $cond));

  return new Automake::Condition (@cond_stack);
}


# $COND
# cond_stack_else ($NEGATE, $COND, $WHERE)
# ----------------------------------------
sub cond_stack_else ($$$)
{
  my ($negate, $cond, $where) = @_;

  if (! @cond_stack)
    {
      error $where, "else without if";
      return FALSE;
    }

  $cond_stack[$#cond_stack] =
    Automake::Condition::conditional_negate ($cond_stack[$#cond_stack]);

  # If $COND is given, check against it.
  if (defined $cond)
    {
      $cond = make_conditional_string ($negate, $cond);

      error ($where, "else reminder ($negate$cond) incompatible with "
	     . "current conditional: $cond_stack[$#cond_stack]")
	if $cond_stack[$#cond_stack] ne $cond;
    }

  return new Automake::Condition (@cond_stack);
}


# $COND
# cond_stack_endif ($NEGATE, $COND, $WHERE)
# -----------------------------------------
sub cond_stack_endif ($$$)
{
  my ($negate, $cond, $where) = @_;
  my $old_cond;

  if (! @cond_stack)
    {
      error $where, "endif without if";
      return TRUE;
    }

  # If $COND is given, check against it.
  if (defined $cond)
    {
      $cond = make_conditional_string ($negate, $cond);

      error ($where, "endif reminder ($negate$cond) incompatible with "
	     . "current conditional: $cond_stack[$#cond_stack]")
	if $cond_stack[$#cond_stack] ne $cond;
    }

  pop @cond_stack;

  return new Automake::Condition (@cond_stack);
}





## ------------------------ ##
## Handling the variables.  ##
## ------------------------ ##


# &define_pretty_variable ($VAR, $COND, $WHERE, @VALUE)
# -----------------------------------------------------
# Like define_variable, but the value is a list, and the variable may
# be defined conditionally.  The second argument is the condition
# under which the value should be defined; this should be the empty
# string to define the variable unconditionally.  The third argument
# is a list holding the values to use for the variable.  The value is
# pretty printed in the output file.
sub define_pretty_variable ($$$@)
{
    my ($var, $cond, $where, @value) = @_;

    if (! vardef ($var, $cond))
    {
	Automake::Variable::define ($var, VAR_AUTOMAKE, '', $cond, "@value",
				    '', $where, VAR_PRETTY);
	rvar ($var)->rdef ($cond)->set_seen;
    }
}


# define_variable ($VAR, $VALUE, $WHERE)
# --------------------------------------
# Define a new Automake Makefile variable VAR to VALUE, but only if
# not already defined.
sub define_variable ($$$)
{
    my ($var, $value, $where) = @_;
    define_pretty_variable ($var, TRUE, $where, $value);
}


# define_files_variable ($VAR, \@BASENAME, $EXTENSION, $WHERE)
# -----------------------------------------------------------
# Define the $VAR which content is the list of file names composed of
# a @BASENAME and the $EXTENSION.
sub define_files_variable ($\@$$)
{
  my ($var, $basename, $extension, $where) = @_;
  define_variable ($var,
		   join (' ', map { "$_.$extension" } @$basename),
		   $where);
}


# Like define_variable, but define a variable to be the configure
# substitution by the same name.
sub define_configure_variable ($)
{
  my ($var) = @_;

  my $pretty = VAR_ASIS;
  my $owner = VAR_CONFIGURE;

  # Some variables we do not want to output.  For instance it
  # would be a bad idea to output `U = @U@` when `@U@` can be
  # substituted as `\`.
  $pretty = VAR_SILENT if exists $ignored_configure_vars{$var};

  # ANSI2KNR is a variable that Automake wants to redefine, so
  # it must be owned by Automake.  (It is also used as a proof
  # that AM_C_PROTOTYPES has been run, that's why we do not simply
  # omit the AC_SUBST.)
  $owner = VAR_AUTOMAKE if $var eq 'ANSI2KNR';

  Automake::Variable::define ($var, $owner, '', TRUE, subst $var,
			      '', $configure_vars{$var}, $pretty);
}


# define_compiler_variable ($LANG)
# --------------------------------
# Define a compiler variable.  We also handle defining the `LT'
# version of the command when using libtool.
sub define_compiler_variable ($)
{
    my ($lang) = @_;

    my ($var, $value) = ($lang->compiler, $lang->compile);
    my $libtool_tag = '';
    $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
      if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};
    &define_variable ($var, $value, INTERNAL);
    if (var ('LIBTOOL'))
      {
	my $verbose = define_verbose_libtool ();
	&define_variable ("LT$var",
			  "\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS) "
			  . "\$(LIBTOOLFLAGS) --mode=compile $value",
			  INTERNAL);
      }
    define_verbose_tagvar ($lang->ccer || 'GEN');
}


# define_linker_variable ($LANG)
# ------------------------------
# Define linker variables.
sub define_linker_variable ($)
{
    my ($lang) = @_;

    my $libtool_tag = '';
    $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
      if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};
    # CCLD = $(CC).
    &define_variable ($lang->lder, $lang->ld, INTERNAL);
    # CCLINK = $(CCLD) blah blah...
    my $link = '';
    if (var ('LIBTOOL'))
      {
	my $verbose = define_verbose_libtool ();
	$link = "\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS) "
		. "\$(LIBTOOLFLAGS) --mode=link ";
      }
    &define_variable ($lang->linker, $link . $lang->link, INTERNAL);
    &define_variable ($lang->compiler,  $lang);
    &define_verbose_tagvar ($lang->lder || 'GEN');
}

sub define_per_target_linker_variable ($$)
{
  my ($linker, $target) = @_;

  # If the user wrote a custom link command, we don't define ours.
  return "${target}_LINK"
    if set_seen "${target}_LINK";

  my $xlink = $linker ? $linker : 'LINK';

  my $lang = $link_languages{$xlink};
  prog_error "Unknown language for linker variable `$xlink'"
    unless $lang;

  my $link_command = $lang->link;
  if (var 'LIBTOOL')
    {
      my $libtool_tag = '';
      $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
	if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};

      my $verbose = define_verbose_libtool ();
      $link_command =
	"\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS) \$(LIBTOOLFLAGS) "
	. "--mode=link " . $link_command;
    }

  # Rewrite each occurrence of `AM_$flag' in the link
  # command into `${derived}_$flag' if it exists.
  my $orig_command = $link_command;
  my @flags = (@{$lang->flags}, 'LDFLAGS');
  push @flags, 'LIBTOOLFLAGS' if var 'LIBTOOL';
  for my $flag (@flags)
    {
      my $val = "${target}_$flag";
      $link_command =~ s/\(AM_$flag\)/\($val\)/
	if set_seen ($val);
    }

  # If the computed command is the same as the generic command, use
  # the command linker variable.
  return ($lang->linker, $lang->lder)
    if $link_command eq $orig_command;

  &define_variable ("${target}_LINK", $link_command, INTERNAL);
  return ("${target}_LINK", $lang->lder);
}

################################################################

# &check_trailing_slash ($WHERE, $LINE)
# --------------------------------------
# Return 1 iff $LINE ends with a slash.
# Might modify $LINE.
sub check_trailing_slash ($\$)
{
  my ($where, $line) = @_;

  # Ignore `##' lines.
  return 0 if $$line =~ /$IGNORE_PATTERN/o;

  # Catch and fix a common error.
  msg "syntax", $where, "whitespace following trailing backslash"
    if $$line =~ s/\\\s+\n$/\\\n/;

  return $$line =~ /\\$/;
}


# &read_am_file ($AMFILE, $WHERE)
# -------------------------------
# Read Makefile.am and set up %contents.  Simultaneously copy lines
# from Makefile.am into $output_trailer, or define variables as
# appropriate.  NOTE we put rules in the trailer section.  We want
# user rules to come after our generated stuff.
sub read_am_file ($$)
{
    my ($amfile, $where) = @_;

    my $am_file = new Automake::XFile ("< $amfile");
    verb "reading $amfile";

    # Keep track of the youngest output dependency.
    my $mtime = mtime $amfile;
    $output_deps_greatest_timestamp = $mtime
      if $mtime > $output_deps_greatest_timestamp;

    my $spacing = '';
    my $comment = '';
    my $blank = 0;
    my $saw_bk = 0;
    my $var_look = VAR_ASIS;

    use constant IN_VAR_DEF => 0;
    use constant IN_RULE_DEF => 1;
    use constant IN_COMMENT => 2;
    my $prev_state = IN_RULE_DEF;

    while ($_ = $am_file->getline)
    {
	$where->set ("$amfile:$.");
	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    error $where, "blank line following trailing backslash"
	      if $saw_bk;
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    $blank = 1;
	    # Flush all comments seen so far.
	    if ($comment ne '')
	    {
		$output_vars .= $comment;
		$comment = '';
	    }
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    # Stick comments before the incoming macro or rule.  Make
	    # sure a blank line precedes the first block of comments.
	    $spacing = "\n" unless $blank;
	    $blank = 1;
	    $comment .= $spacing . $_;
	    $spacing = '';
	    $prev_state = IN_COMMENT;
	}
	else
	{
	    last;
	}
	$saw_bk = check_trailing_slash ($where, $_);
    }

    # We save the conditional stack on entry, and then check to make
    # sure it is the same on exit.  This lets us conditionally include
    # other files.
    my @saved_cond_stack = @cond_stack;
    my $cond = new Automake::Condition (@cond_stack);

    my $last_var_name = '';
    my $last_var_type = '';
    my $last_var_value = '';
    my $last_where;
    # FIXME: shouldn't use $_ in this loop; it is too big.
    while ($_)
    {
	$where->set ("$amfile:$.");

	# Make sure the line is \n-terminated.
	chomp;
	$_ .= "\n";

	# Don't look at MAINTAINER_MODE_TRUE here.  That shouldn't be
	# used by users.  @MAINT@ is an anachronism now.
	$_ =~ s/\@MAINT\@//g
	    unless $seen_maint_mode;

	my $new_saw_bk = check_trailing_slash ($where, $_);

	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.

	    # Keep any backslash from the previous line.
	    $new_saw_bk = $saw_bk;
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    error $where, "blank line following trailing backslash"
	      if $saw_bk;
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    error $where, "comment following trailing backslash"
	      if $saw_bk && $prev_state != IN_COMMENT;

	    # Stick comments before the incoming macro or rule.
	    $comment .= $spacing . $_;
	    $spacing = '';
	    $prev_state = IN_COMMENT;
	}
	elsif ($saw_bk)
	{
	    if ($prev_state == IN_RULE_DEF)
	    {
	      my $cond = new Automake::Condition @cond_stack;
	      $output_trailer .= $cond->subst_string;
	      $output_trailer .= $_;
	    }
	    elsif ($prev_state == IN_COMMENT)
	    {
		# If the line doesn't start with a `#', add it.
		# We do this because a continued comment like
		#   # A = foo \
		#         bar \
		#         baz
		# is not portable.  BSD make doesn't honor
		# escaped newlines in comments.
		s/^#?/#/;
		$comment .= $spacing . $_;
	    }
	    else # $prev_state == IN_VAR_DEF
	    {
	      $last_var_value .= ' '
		unless $last_var_value =~ /\s$/;
	      $last_var_value .= $_;

	      if (!/\\$/)
		{
		  Automake::Variable::define ($last_var_name, VAR_MAKEFILE,
					      $last_var_type, $cond,
					      $last_var_value, $comment,
					      $last_where, VAR_ASIS)
		    if $cond != FALSE;
		  $comment = $spacing = '';
		}
	    }
	}

	elsif (/$IF_PATTERN/o)
	  {
	    $cond = cond_stack_if ($1, $2, $where);
	  }
	elsif (/$ELSE_PATTERN/o)
	  {
	    $cond = cond_stack_else ($1, $2, $where);
	  }
	elsif (/$ENDIF_PATTERN/o)
	  {
	    $cond = cond_stack_endif ($1, $2, $where);
	  }

	elsif (/$RULE_PATTERN/o)
	{
	    # Found a rule.
	    $prev_state = IN_RULE_DEF;

	    # For now we have to output all definitions of user rules
	    # and can't diagnose duplicates (see the comment in
	    # Automake::Rule::define). So we go on and ignore the return value.
	    Automake::Rule::define ($1, $amfile, RULE_USER, $cond, $where);

	    check_variable_expansions ($_, $where);

	    $output_trailer .= $comment . $spacing;
	    my $cond = new Automake::Condition @cond_stack;
	    $output_trailer .= $cond->subst_string;
	    $output_trailer .= $_;
	    $comment = $spacing = '';
	}
	elsif (/$ASSIGNMENT_PATTERN/o)
	{
	    # Found a macro definition.
	    $prev_state = IN_VAR_DEF;
	    $last_var_name = $1;
	    $last_var_type = $2;
	    $last_var_value = $3;
	    $last_where = $where->clone;
	    if ($3 ne '' && substr ($3, -1) eq "\\")
	      {
		# We preserve the `\' because otherwise the long lines
		# that are generated will be truncated by broken
		# `sed's.
		$last_var_value = $3 . "\n";
	      }
	    # Normally we try to output variable definitions in the
	    # same format they were input.  However, POSIX compliant
	    # systems are not required to support lines longer than
	    # 2048 bytes (most notably, some sed implementation are
	    # limited to 4000 bytes, and sed is used by config.status
	    # to rewrite Makefile.in into Makefile).  Moreover nobody
	    # would really write such long lines by hand since it is
	    # hardly maintainable.  So if a line is longer that 1000
	    # bytes (an arbitrary limit), assume it has been
	    # automatically generated by some tools, and flatten the
	    # variable definition.  Otherwise, keep the variable as it
	    # as been input.
	    $var_look = VAR_PRETTY if length ($last_var_value) >= 1000;

	    if (!/\\$/)
	      {
		Automake::Variable::define ($last_var_name, VAR_MAKEFILE,
					    $last_var_type, $cond,
					    $last_var_value, $comment,
					    $last_where, $var_look)
		  if $cond != FALSE;
		$comment = $spacing = '';
		$var_look = VAR_ASIS;
	      }
	}
	elsif (/$INCLUDE_PATTERN/o)
	{
	    my $path = $1;

	    if ($path =~ s/^\$\(top_srcdir\)\///)
	      {
		push (@include_stack, "\$\(top_srcdir\)/$path");
		# Distribute any included file.

		# Always use the $(top_srcdir) prefix in DIST_COMMON,
		# otherwise OSF make will implicitly copy the included
		# file in the build tree during `make distdir' to satisfy
		# the dependency.
		# (subdircond2.test and subdircond3.test will fail.)
		push_dist_common ("\$\(top_srcdir\)/$path");
	      }
	    else
	      {
		$path =~ s/\$\(srcdir\)\///;
		push (@include_stack, "\$\(srcdir\)/$path");
		# Always use the $(srcdir) prefix in DIST_COMMON,
		# otherwise OSF make will implicitly copy the included
		# file in the build tree during `make distdir' to satisfy
		# the dependency.
		# (subdircond2.test and subdircond3.test will fail.)
		push_dist_common ("\$\(srcdir\)/$path");
		$path = $relative_dir . "/" . $path if $relative_dir ne '.';
	      }
	    $where->push_context ("`$path' included from here");
	    &read_am_file ($path, $where);
	    $where->pop_context;
	}
	else
	{
	    # This isn't an error; it is probably a continued rule.
	    # In fact, this is what we assume.
	    $prev_state = IN_RULE_DEF;
	    check_variable_expansions ($_, $where);
	    $output_trailer .= $comment . $spacing;
	    my $cond = new Automake::Condition @cond_stack;
	    $output_trailer .= $cond->subst_string;
	    $output_trailer .= $_;
	    $comment = $spacing = '';
	    error $where, "`#' comment at start of rule is unportable"
	      if $_ =~ /^\t\s*\#/;
	}

	$saw_bk = $new_saw_bk;
	$_ = $am_file->getline;
    }

    $output_trailer .= $comment;

    error ($where, "trailing backslash on last line")
      if $saw_bk;

    error ($where, (@cond_stack ? "unterminated conditionals: @cond_stack"
		    : "too many conditionals closed in include file"))
      if "@saved_cond_stack" ne "@cond_stack";
}


# define_standard_variables ()
# ----------------------------
# A helper for read_main_am_file which initializes configure variables
# and variables from header-vars.am.
sub define_standard_variables
{
  my $saved_output_vars = $output_vars;
  my ($comments, undef, $rules) =
    file_contents_internal (1, "$libdir/am/header-vars.am",
			    new Automake::Location);

  foreach my $var (sort keys %configure_vars)
    {
      &define_configure_variable ($var);
    }

  $output_vars .= $comments . $rules;
}

# Read main am file.
sub read_main_am_file
{
    my ($amfile) = @_;

    # This supports the strange variable tricks we are about to play.
    prog_error (macros_dump () . "variable defined before read_main_am_file")
      if (scalar (variables) > 0);

    # Generate copyright header for generated Makefile.in.
    # We do discard the output of predefined variables, handled below.
    $output_vars = ("# $in_file_name generated by automake "
		   . $VERSION . " from $am_file_name.\n");
    $output_vars .= '# ' . subst ('configure_input') . "\n";
    $output_vars .= $gen_copyright;

    # We want to predefine as many variables as possible.  This lets
    # the user set them with `+=' in Makefile.am.
    &define_standard_variables;

    # Read user file, which might override some of our values.
    &read_am_file ($amfile, new Automake::Location);
}



################################################################

# $FLATTENED
# &flatten ($STRING)
# ------------------
# Flatten the $STRING and return the result.
sub flatten
{
  $_ = shift;

  s/\\\n//somg;
  s/\s+/ /g;
  s/^ //;
  s/ $//;

  return $_;
}


# transform_token ($TOKEN, \%PAIRS, $KEY)
# =======================================
# Return the value associated to $KEY in %PAIRS, as used on $TOKEN
# (which should be ?KEY? or any of the special %% requests)..
sub transform_token ($$$)
{
  my ($token, $transform, $key) = @_;
  my $res = $transform->{$key};
  prog_error "Unknown key `$key' in `$token'" unless defined $res;
  return $res;
}


# transform ($TOKEN, \%PAIRS)
# ===========================
# If ($TOKEN, $VAL) is in %PAIRS:
#   - replaces %KEY% with $VAL,
#   - enables/disables ?KEY? and ?!KEY?,
#   - replaces %?KEY% with TRUE or FALSE.
#   - replaces %KEY?IFTRUE%, %KEY:IFFALSE%, and %KEY?IFTRUE:IFFALSE% with
#     IFTRUE / IFFALSE, as appropriate.
sub transform ($$)
{
  my ($token, $transform) = @_;

  # %KEY%.
  # Must be before the following pattern to exclude the case
  # when there is neither IFTRUE nor IFFALSE.
  if ($token =~ /^%([\w\-]+)%$/)
    {
      return transform_token ($token, $transform, $1);
    }
  # %KEY?IFTRUE%, %KEY:IFFALSE%, and %KEY?IFTRUE:IFFALSE%.
  elsif ($token =~ /^%([\w\-]+)(?:\?([^?:%]+))?(?::([^?:%]+))?%$/)
    {
      return transform_token ($token, $transform, $1) ? ($2 || '') : ($3 || '');
    }
  # %?KEY%.
  elsif ($token =~ /^%\?([\w\-]+)%$/)
    {
      return transform_token ($token, $transform, $1) ? 'TRUE' : 'FALSE';
    }
  # ?KEY? and ?!KEY?.
  elsif ($token =~ /^ \? (!?) ([\w\-]+) \? $/x)
    {
      my $neg = ($1 eq '!') ? 1 : 0;
      my $val = transform_token ($token, $transform, $2);
      return (!!$val == $neg) ? '##%' : '';
    }
  else
    {
      prog_error "Unknown request format: $token";
    }
}


# @PARAGRAPHS
# &make_paragraphs ($MAKEFILE, [%TRANSFORM])
# ------------------------------------------
# Load a $MAKEFILE, apply the %TRANSFORM, and return it as a list of
# paragraphs.
sub make_paragraphs ($%)
{
  my ($file, %transform) = @_;

  # Complete %transform with global options.
  # Note that %transform goes last, so it overrides global options.
  %transform = ('CYGNUS'      => !! option 'cygnus',
		 'MAINTAINER-MODE'
		 => $seen_maint_mode ? subst ('MAINTAINER_MODE_TRUE') : '',

		 'XZ'          => !! option 'dist-xz',
		 'LZMA'        => !! option 'dist-lzma',
		 'BZIP2'       => !! option 'dist-bzip2',
		 'COMPRESS'    => !! option 'dist-tarZ',
		 'GZIP'        =>  ! option 'no-dist-gzip',
		 'SHAR'        => !! option 'dist-shar',
		 'ZIP'         => !! option 'dist-zip',

		 'INSTALL-INFO' =>  ! option 'no-installinfo',
		 'INSTALL-MAN'  =>  ! option 'no-installman',
		 'HAVE-MANS'    => !! var ('MANS'),
		 'CK-NEWS'      => !! option 'check-news',

		 'SUBDIRS'      => !! var ('SUBDIRS'),
		 'TOPDIR_P'     => $relative_dir eq '.',

		 'BUILD'    => ($seen_canonical >= AC_CANONICAL_BUILD),
		 'HOST'     => ($seen_canonical >= AC_CANONICAL_HOST),
		 'TARGET'   => ($seen_canonical >= AC_CANONICAL_TARGET),

		 'LIBTOOL'      => !! var ('LIBTOOL'),
		 'NONLIBTOOL'   => 1,
		 'FIRST'        => ! $transformed_files{$file},
		%transform);

  $transformed_files{$file} = 1;
  $_ = $am_file_cache{$file};

  if (! defined $_)
    {
      verb "reading $file";
      # Swallow the whole file.
      my $fc_file = new Automake::XFile "< $file";
      my $saved_dollar_slash = $/;
      undef $/;
      $_ = $fc_file->getline;
      $/ = $saved_dollar_slash;
      $fc_file->close;

      # Remove ##-comments.
      # Besides we don't need more than two consecutive new-lines.
      s/(?:$IGNORE_PATTERN|(?<=\n\n)\n+)//gom;

      $am_file_cache{$file} = $_;
    }

  # Substitute Automake template tokens.
  s/(?: % \?? [\w\-]+ %
      | % [\w\-]+ (?:\?[^?:%]+)? (?::[^?:%]+)? %
      | \? !? [\w\-]+ \?
    )/transform($&, \%transform)/gex;
  # transform() may have added some ##%-comments to strip.
  # (we use `##%' instead of `##' so we can distinguish ##%##%##% from
  # ####### and do not remove the latter.)
  s/^[ \t]*(?:##%)+.*\n//gm;

  # Split at unescaped new lines.
  my @lines = split (/(?<!\\)\n/, $_);
  my @res;

  while (defined ($_ = shift @lines))
    {
      my $paragraph = $_;
      # If we are a rule, eat as long as we start with a tab.
      if (/$RULE_PATTERN/smo)
	{
	  while (defined ($_ = shift @lines) && $_ =~ /^\t/)
	    {
	      $paragraph .= "\n$_";
	    }
	  unshift (@lines, $_);
	}

      # If we are a comments, eat as much comments as you can.
      elsif (/$COMMENT_PATTERN/smo)
	{
	  while (defined ($_ = shift @lines)
		 && $_ =~ /$COMMENT_PATTERN/smo)
	    {
	      $paragraph .= "\n$_";
	    }
	  unshift (@lines, $_);
	}

      push @res, $paragraph;
    }

  return @res;
}



# ($COMMENT, $VARIABLES, $RULES)
# &file_contents_internal ($IS_AM, $FILE, $WHERE, [%TRANSFORM])
# -------------------------------------------------------------
# Return contents of a file from $libdir/am, automatically skipping
# macros or rules which are already known. $IS_AM iff the caller is
# reading an Automake file (as opposed to the user's Makefile.am).
sub file_contents_internal ($$$%)
{
    my ($is_am, $file, $where, %transform) = @_;

    $where->set ($file);

    my $result_vars = '';
    my $result_rules = '';
    my $comment = '';
    my $spacing = '';

    # The following flags are used to track rules spanning across
    # multiple paragraphs.
    my $is_rule = 0;		# 1 if we are processing a rule.
    my $discard_rule = 0;	# 1 if the current rule should not be output.

    # We save the conditional stack on entry, and then check to make
    # sure it is the same on exit.  This lets us conditionally include
    # other files.
    my @saved_cond_stack = @cond_stack;
    my $cond = new Automake::Condition (@cond_stack);

    foreach (make_paragraphs ($file, %transform))
    {
	# FIXME: no line number available.
	$where->set ($file);

	# Sanity checks.
	error $where, "blank line following trailing backslash:\n$_"
	  if /\\$/;
	error $where, "comment following trailing backslash:\n$_"
	  if /\\#/;

	if (/^$/)
	{
	    $is_rule = 0;
	    # Stick empty line before the incoming macro or rule.
	    $spacing = "\n";
	}
	elsif (/$COMMENT_PATTERN/mso)
	{
	    $is_rule = 0;
	    # Stick comments before the incoming macro or rule.
	    $comment = "$_\n";
	}

	# Handle inclusion of other files.
	elsif (/$INCLUDE_PATTERN/o)
	{
	    if ($cond != FALSE)
	      {
		my $file = ($is_am ? "$libdir/am/" : '') . $1;
		$where->push_context ("`$file' included from here");
		# N-ary `.=' fails.
		my ($com, $vars, $rules)
		  = file_contents_internal ($is_am, $file, $where, %transform);
		$where->pop_context;
		$comment .= $com;
		$result_vars .= $vars;
		$result_rules .= $rules;
	      }
	}

	# Handling the conditionals.
	elsif (/$IF_PATTERN/o)
	  {
	    $cond = cond_stack_if ($1, $2, $file);
	  }
	elsif (/$ELSE_PATTERN/o)
	  {
	    $cond = cond_stack_else ($1, $2, $file);
	  }
	elsif (/$ENDIF_PATTERN/o)
	  {
	    $cond = cond_stack_endif ($1, $2, $file);
	  }

	# Handling rules.
	elsif (/$RULE_PATTERN/mso)
	{
	  $is_rule = 1;
	  $discard_rule = 0;
	  # Separate relationship from optional actions: the first
	  # `new-line tab" not preceded by backslash (continuation
	  # line).
	  my $paragraph = $_;
	  /^(.*?)(?:(?<!\\)\n(\t.*))?$/s;
	  my ($relationship, $actions) = ($1, $2 || '');

	  # Separate targets from dependencies: the first colon.
	  $relationship =~ /^([^:]+\S+) *: *(.*)$/som;
	  my ($targets, $dependencies) = ($1, $2);
	  # Remove the escaped new lines.
	  # I don't know why, but I have to use a tmp $flat_deps.
	  my $flat_deps = &flatten ($dependencies);
	  my @deps = split (' ', $flat_deps);

	  foreach (split (' ', $targets))
	    {
	      # FIXME: 1. We are not robust to people defining several targets
	      # at once, only some of them being in %dependencies.  The
	      # actions from the targets in %dependencies are usually generated
	      # from the content of %actions, but if some targets in $targets
	      # are not in %dependencies the ELSE branch will output
	      # a rule for all $targets (i.e. the targets which are both
	      # in %dependencies and $targets will have two rules).

	      # FIXME: 2. The logic here is not able to output a
	      # multi-paragraph rule several time (e.g. for each condition
	      # it is defined for) because it only knows the first paragraph.

	      # FIXME: 3. We are not robust to people defining a subset
	      # of a previously defined "multiple-target" rule.  E.g.
	      # `foo:' after `foo bar:'.

	      # Output only if not in FALSE.
	      if (defined $dependencies{$_} && $cond != FALSE)
		{
		  &depend ($_, @deps);
		  register_action ($_, $actions);
		}
	      else
		{
		  # Free-lance dependency.  Output the rule for all the
		  # targets instead of one by one.
		  my @undefined_conds =
		    Automake::Rule::define ($targets, $file,
					    $is_am ? RULE_AUTOMAKE : RULE_USER,
					    $cond, $where);
		  for my $undefined_cond (@undefined_conds)
		    {
		      my $condparagraph = $paragraph;
		      $condparagraph =~ s/^/$undefined_cond->subst_string/gme;
		      $result_rules .= "$spacing$comment$condparagraph\n";
		    }
		  if (scalar @undefined_conds == 0)
		    {
		      # Remember to discard next paragraphs
		      # if they belong to this rule.
		      # (but see also FIXME: #2 above.)
		      $discard_rule = 1;
		    }
		  $comment = $spacing = '';
		  last;
		}
	    }
	}

	elsif (/$ASSIGNMENT_PATTERN/mso)
	{
	    my ($var, $type, $val) = ($1, $2, $3);
	    error $where, "variable `$var' with trailing backslash"
	      if /\\$/;

	    $is_rule = 0;

	    Automake::Variable::define ($var,
					$is_am ? VAR_AUTOMAKE : VAR_MAKEFILE,
					$type, $cond, $val, $comment, $where,
					VAR_ASIS)
	      if $cond != FALSE;

	    $comment = $spacing = '';
	}
	else
	{
	    # This isn't an error; it is probably some tokens which
	    # configure is supposed to replace, such as `@SET-MAKE@',
	    # or some part of a rule cut by an if/endif.
	    if (! $cond->false && ! ($is_rule && $discard_rule))
	      {
		s/^/$cond->subst_string/gme;
		$result_rules .= "$spacing$comment$_\n";
	      }
	    $comment = $spacing = '';
	}
    }

    error ($where, @cond_stack ?
	   "unterminated conditionals: @cond_stack" :
	   "too many conditionals closed in include file")
      if "@saved_cond_stack" ne "@cond_stack";

    return ($comment, $result_vars, $result_rules);
}


# $CONTENTS
# &file_contents ($BASENAME, $WHERE, [%TRANSFORM])
# ------------------------------------------------
# Return contents of a file from $libdir/am, automatically skipping
# macros or rules which are already known.
sub file_contents ($$%)
{
    my ($basename, $where, %transform) = @_;
    my ($comments, $variables, $rules) =
      file_contents_internal (1, "$libdir/am/$basename.am", $where,
			      %transform);
    return "$comments$variables$rules";
}


# @PREFIX
# &am_primary_prefixes ($PRIMARY, $CAN_DIST, @PREFIXES)
# -----------------------------------------------------
# Find all variable prefixes that are used for install directories.  A
# prefix `zar' qualifies iff:
#
# * `zardir' is a variable.
# * `zar_PRIMARY' is a variable.
#
# As a side effect, it looks for misspellings.  It is an error to have
# a variable ending in a "reserved" suffix whose prefix is unknown, e.g.
# "bni_PROGRAMS".  However, unusual prefixes are allowed if a variable
# of the same name (with "dir" appended) exists.  For instance, if the
# variable "zardir" is defined, then "zar_PROGRAMS" becomes valid.
# This is to provide a little extra flexibility in those cases which
# need it.
sub am_primary_prefixes ($$@)
{
  my ($primary, $can_dist, @prefixes) = @_;

  local $_;
  my %valid = map { $_ => 0 } @prefixes;
  $valid{'EXTRA'} = 0;
  foreach my $var (variables $primary)
    {
      # Automake is allowed to define variables that look like primaries
      # but which aren't.  E.g. INSTALL_sh_DATA.
      # Autoconf can also define variables like INSTALL_DATA, so
      # ignore all configure variables (at least those which are not
      # redefined in Makefile.am).
      # FIXME: We should make sure that these variables are not
      # conditionally defined (or else adjust the condition below).
      my $def = $var->def (TRUE);
      next if $def && $def->owner != VAR_MAKEFILE;

      my $varname = $var->name;

      if ($varname =~ /^(nobase_)?(dist_|nodist_)?(.*)_[[:alnum:]]+$/)
	{
	  my ($base, $dist, $X) = ($1 || '', $2 || '', $3 || '');
	  if ($dist ne '' && ! $can_dist)
	    {
	      err_var ($var,
		       "invalid variable `$varname': `dist' is forbidden");
	    }
	  # Standard directories must be explicitly allowed.
	  elsif (! defined $valid{$X} && exists $standard_prefix{$X})
	    {
	      err_var ($var,
		       "`${X}dir' is not a legitimate directory " .
		       "for `$primary'");
	    }
	  # A not explicitly valid directory is allowed if Xdir is defined.
	  elsif (! defined $valid{$X} &&
		 $var->requires_variables ("`$varname' is used", "${X}dir"))
	    {
	      # Nothing to do.  Any error message has been output
	      # by $var->requires_variables.
	    }
	  else
	    {
	      # Ensure all extended prefixes are actually used.
	      $valid{"$base$dist$X"} = 1;
	    }
	}
      else
	{
	  prog_error "unexpected variable name: $varname";
	}
    }

  # Return only those which are actually defined.
  return sort grep { var ($_ . '_' . $primary) } keys %valid;
}


# Handle `where_HOW' variable magic.  Does all lookups, generates
# install code, and possibly generates code to define the primary
# variable.  The first argument is the name of the .am file to munge,
# the second argument is the primary variable (e.g. HEADERS), and all
# subsequent arguments are possible installation locations.
#
# Returns list of [$location, $value] pairs, where
# $value's are the values in all where_HOW variable, and $location
# there associated location (the place here their parent variables were
# defined).
#
# FIXME: this should be rewritten to be cleaner.  It should be broken
# up into multiple functions.
#
# Usage is: am_install_var (OPTION..., file, HOW, where...)
sub am_install_var
{
  my (@args) = @_;

  my $do_require = 1;
  my $can_dist = 0;
  my $default_dist = 0;
  while (@args)
    {
      if ($args[0] eq '-noextra')
	{
	  $do_require = 0;
	}
      elsif ($args[0] eq '-candist')
	{
	  $can_dist = 1;
	}
      elsif ($args[0] eq '-defaultdist')
	{
	  $default_dist = 1;
	  $can_dist = 1;
	}
      elsif ($args[0] !~ /^-/)
	{
	  last;
	}
      shift (@args);
    }

  my ($file, $primary, @prefix) = @args;

  # Now that configure substitutions are allowed in where_HOW
  # variables, it is an error to actually define the primary.  We
  # allow `JAVA', as it is customarily used to mean the Java
  # interpreter.  This is but one of several Java hacks.  Similarly,
  # `PYTHON' is customarily used to mean the Python interpreter.
  reject_var $primary, "`$primary' is an anachronism"
    unless $primary eq 'JAVA' || $primary eq 'PYTHON';

  # Get the prefixes which are valid and actually used.
  @prefix = am_primary_prefixes ($primary, $can_dist, @prefix);

  # If a primary includes a configure substitution, then the EXTRA_
  # form is required.  Otherwise we can't properly do our job.
  my $require_extra;

  my @used = ();
  my @result = ();

  foreach my $X (@prefix)
    {
      my $nodir_name = $X;
      my $one_name = $X . '_' . $primary;
      my $one_var = var $one_name;

      my $strip_subdir = 1;
      # If subdir prefix should be preserved, do so.
      if ($nodir_name =~ /^nobase_/)
	{
	  $strip_subdir = 0;
	  $nodir_name =~ s/^nobase_//;
	}

      # If files should be distributed, do so.
      my $dist_p = 0;
      if ($can_dist)
	{
	  $dist_p = (($default_dist && $nodir_name !~ /^nodist_/)
		     || (! $default_dist && $nodir_name =~ /^dist_/));
	  $nodir_name =~ s/^(dist|nodist)_//;
	}


      # Use the location of the currently processed variable.
      # We are not processing a particular condition, so pick the first
      # available.
      my $tmpcond = $one_var->conditions->one_cond;
      my $where = $one_var->rdef ($tmpcond)->location->clone;

      # Append actual contents of where_PRIMARY variable to
      # @result, skipping @substitutions@.
      foreach my $locvals ($one_var->value_as_list_recursive (location => 1))
	{
	  my ($loc, $value) = @$locvals;
	  # Skip configure substitutions.
	  if ($value =~ /^\@.*\@$/)
	    {
	      if ($nodir_name eq 'EXTRA')
		{
		  error ($where,
			 "`$one_name' contains configure substitution, "
			 . "but shouldn't");
		}
	      # Check here to make sure variables defined in
	      # configure.ac do not imply that EXTRA_PRIMARY
	      # must be defined.
	      elsif (! defined $configure_vars{$one_name})
		{
		  $require_extra = $one_name
		    if $do_require;
		}
	    }
	  else
	    {
	      # Strip any $(EXEEXT) suffix the user might have added, or this
	      # will confuse &handle_source_transform and &check_canonical_spelling.
	      # We'll add $(EXEEXT) back later anyway.
	      # Do it here rather than in handle_programs so the uniquifying at the
	      # end of this function works.
	      ${$locvals}[1] =~ s/\$\(EXEEXT\)$//
	        if $primary eq 'PROGRAMS';

	      push (@result, $locvals);
	    }
	}
      # A blatant hack: we rewrite each _PROGRAMS primary to include
      # EXEEXT.
      append_exeext { 1 } $one_name
	if $primary eq 'PROGRAMS';
      # "EXTRA" shouldn't be used when generating clean targets,
      # all, or install targets.  We used to warn if EXTRA_FOO was
      # defined uselessly, but this was annoying.
      next
	if $nodir_name eq 'EXTRA';

      if ($nodir_name eq 'check')
	{
	  push (@check, '$(' . $one_name . ')');
	}
      else
	{
	  push (@used, '$(' . $one_name . ')');
	}

      # Is this to be installed?
      my $install_p = $nodir_name ne 'noinst' && $nodir_name ne 'check';

      # If so, with install-exec? (or install-data?).
      my $exec_p = ($nodir_name =~ /$EXEC_DIR_PATTERN/o);

      my $check_options_p = $install_p && !! option 'std-options';

      # Use the location of the currently processed variable as context.
      $where->push_context ("while processing `$one_name'");

      # The variable containing all files to distribute.
      my $distvar = "\$($one_name)";
      $distvar = shadow_unconditionally ($one_name, $where)
	if ($dist_p && $one_var->has_conditional_contents);

      # Singular form of $PRIMARY.
      (my $one_primary = $primary) =~ s/S$//;
      $output_rules .= &file_contents ($file, $where,
				       PRIMARY     => $primary,
				       ONE_PRIMARY => $one_primary,
				       DIR         => $X,
				       NDIR        => $nodir_name,
				       BASE        => $strip_subdir,

				       EXEC      => $exec_p,
				       INSTALL   => $install_p,
				       DIST      => $dist_p,
				       DISTVAR   => $distvar,
				       'CK-OPTS' => $check_options_p);
    }

  # The JAVA variable is used as the name of the Java interpreter.
  # The PYTHON variable is used as the name of the Python interpreter.
  if (@used && $primary ne 'JAVA' && $primary ne 'PYTHON')
    {
      # Define it.
      define_pretty_variable ($primary, TRUE, INTERNAL, @used);
      $output_vars .= "\n";
    }

  err_var ($require_extra,
	   "`$require_extra' contains configure substitution,\n"
	   . "but `EXTRA_$primary' not defined")
    if ($require_extra && ! var ('EXTRA_' . $primary));

  # Push here because PRIMARY might be configure time determined.
  push (@all, '$(' . $primary . ')')
    if @used && $primary ne 'JAVA' && $primary ne 'PYTHON';

  # Make the result unique.  This lets the user use conditionals in
  # a natural way, but still lets us program lazily -- we don't have
  # to worry about handling a particular object more than once.
  # We will keep only one location per object.
  my %result = ();
  for my $pair (@result)
    {
      my ($loc, $val) = @$pair;
      $result{$val} = $loc;
    }
  my @l = sort keys %result;
  return map { [$result{$_}->clone, $_] } @l;
}


################################################################

# Each key in this hash is the name of a directory holding a
# Makefile.in.  These variables are local to `is_make_dir'.
my %make_dirs = ();
my $make_dirs_set = 0;

sub is_make_dir
{
    my ($dir) = @_;
    if (! $make_dirs_set)
    {
	foreach my $iter (@configure_input_files)
	{
	    $make_dirs{dirname ($iter)} = 1;
	}
	# We also want to notice Makefile.in's.
	foreach my $iter (@other_input_files)
	{
	    if ($iter =~ /Makefile\.in$/)
	    {
		$make_dirs{dirname ($iter)} = 1;
	    }
	}
	$make_dirs_set = 1;
    }
    return defined $make_dirs{$dir};
}

################################################################

# Find the aux dir.  This should match the algorithm used by
# ./configure. (See the Autoconf documentation for for
# AC_CONFIG_AUX_DIR.)
sub locate_aux_dir ()
{
  if (! $config_aux_dir_set_in_configure_ac)
    {
      # The default auxiliary directory is the first
      # of ., .., or ../.. that contains install-sh.
      # Assume . if install-sh doesn't exist yet.
      for my $dir (qw (. .. ../..))
	{
	  if (-f "$dir/install-sh")
	    {
	      $config_aux_dir = $dir;
	      last;
	    }
	}
      $config_aux_dir = '.' unless $config_aux_dir;
    }
  # Avoid unsightly '/.'s.
  $am_config_aux_dir =
    '$(top_srcdir)' . ($config_aux_dir eq '.' ? "" : "/$config_aux_dir");
  $am_config_aux_dir =~ s,/*$,,;
}


# &maybe_push_required_file ($DIR, $FILE, $FULLFILE)
# --------------------------------------------------
# See if we want to push this file onto dist_common.  This function
# encodes the rules for deciding when to do so.
sub maybe_push_required_file
{
  my ($dir, $file, $fullfile) = @_;

  if ($dir eq $relative_dir)
    {
      push_dist_common ($file);
      return 1;
    }
  elsif ($relative_dir eq '.' && ! &is_make_dir ($dir))
    {
      # If we are doing the topmost directory, and the file is in a
      # subdir which does not have a Makefile, then we distribute it
      # here.

      # If a required file is above the source tree, it is important
      # to prefix it with `$(srcdir)' so that no VPATH search is
      # performed.  Otherwise problems occur with Make implementations
      # that rewrite and simplify rules whose dependencies are found in a
      # VPATH location.  Here is an example with OSF1/Tru64 Make.
      #
      #   % cat Makefile
      #   VPATH = sub
      #   distdir: ../a
      #	          echo ../a
      #   % ls
      #   Makefile a
      #   % make
      #   echo a
      #   a
      #
      # Dependency `../a' was found in `sub/../a', but this make
      # implementation simplified it as `a'.  (Note that the sub/
      # directory does not even exist.)
      #
      # This kind of VPATH rewriting seems hard to cancel.  The
      # distdir.am hack against VPATH rewriting works only when no
      # simplification is done, i.e., for dependencies which are in
      # subdirectories, not in enclosing directories.  Hence, in
      # the latter case we use a full path to make sure no VPATH
      # search occurs.
      $fullfile = '$(srcdir)/' . $fullfile
	if $dir =~ m,^\.\.(?:$|/),;

      push_dist_common ($fullfile);
      return 1;
    }
  return 0;
}


# If a file name appears as a key in this hash, then it has already
# been checked for.  This allows us not to report the same error more
# than once.
my %required_file_not_found = ();

# &require_file_internal ($WHERE, $MYSTRICT, $DIRECTORY, @FILES)
# --------------------------------------------------------------
# Verify that the file must exist in $DIRECTORY, or install it.
# $MYSTRICT is the strictness level at which this file becomes required.
sub require_file_internal ($$$@)
{
  my ($where, $mystrict, $dir, @files) = @_;

  foreach my $file (@files)
    {
      my $fullfile = "$dir/$file";
      my $found_it = 0;
      my $dangling_sym = 0;

      if (-l $fullfile && ! -f $fullfile)
	{
	  $dangling_sym = 1;
	}
      elsif (dir_has_case_matching_file ($dir, $file))
	{
	  $found_it = 1;
	  maybe_push_required_file ($dir, $file, $fullfile);
	}

      # `--force-missing' only has an effect if `--add-missing' is
      # specified.
      if ($found_it && (! $add_missing || ! $force_missing))
	{
	  next;
	}
      else
	{
	  # If we've already looked for it, we're done.  You might
	  # wonder why we don't do this before searching for the
	  # file.  If we do that, then something like
	  # AC_OUTPUT(subdir/foo foo) will fail to put foo.in into
	  # DIST_COMMON.
	  if (! $found_it)
	    {
	      next if defined $required_file_not_found{$fullfile};
	      $required_file_not_found{$fullfile} = 1;
	    }

	  if ($strictness >= $mystrict)
	    {
	      if ($dangling_sym && $add_missing)
		{
		  unlink ($fullfile);
		}

	      my $trailer = '';
	      my $trailer2 = '';
	      my $suppress = 0;

	      # Only install missing files according to our desired
	      # strictness level.
	      my $message = "required file `$fullfile' not found";
	      if ($add_missing)
		{
		  if (-f "$libdir/$file")
		    {
		      $suppress = 1;

		      # Install the missing file.  Symlink if we
		      # can, copy if we must.  Note: delete the file
		      # first, in case it is a dangling symlink.
		      $message = "installing `$fullfile'";

		      # The license file should not be volatile.
		      if ($file eq "COPYING")
		        {
			  $message .= " using GNU General Public License v3 file";
			  $trailer2 = "\n    Consider adding the COPYING file"
				    . " to the version control system"
				    . "\n    for your code, to avoid questions"
				    . " about which license your project uses.";
			}

		      # Windows Perl will hang if we try to delete a
		      # file that doesn't exist.
		      unlink ($fullfile) if -f $fullfile;
		      if ($symlink_exists && ! $copy_missing)
			{
			  if (! symlink ("$libdir/$file", $fullfile)
			      || ! -e $fullfile)
			    {
			      $suppress = 0;
			      $trailer = "; error while making link: $!";
			    }
			}
		      elsif (system ('cp', "$libdir/$file", $fullfile))
			{
			  $suppress = 0;
			  $trailer = "\n    error while copying";
			}
		      set_dir_cache_file ($dir, $file);
		    }

		  if (! maybe_push_required_file (dirname ($fullfile),
						  $file, $fullfile))
		    {
		      if (! $found_it && ! $automake_will_process_aux_dir)
			{
			  # We have added the file but could not push it
			  # into DIST_COMMON, probably because this is
			  # an auxiliary file and we are not processing
			  # the top level Makefile.  Furthermore Automake
			  # hasn't been asked to create the Makefile.in
			  # that distributes the aux dir files.
			  error ($where, 'Please make a full run of automake'
				 . " so $fullfile gets distributed.");
			}
		    }
		}
	      else
		{
		  $trailer = "\n  `automake --add-missing' can install `$file'"
		    if -f "$libdir/$file";
		}

	      # If --force-missing was specified, and we have
	      # actually found the file, then do nothing.
	      next
		if $found_it && $force_missing;

	      # If we couldn't install the file, but it is a target in
	      # the Makefile, don't print anything.  This allows files
	      # like README, AUTHORS, or THANKS to be generated.
	      next
		if !$suppress && rule $file;

	      msg ($suppress ? 'note' : 'error', $where, "$message$trailer$trailer2");
	    }
	}
    }
}

# &require_file ($WHERE, $MYSTRICT, @FILES)
# -----------------------------------------
sub require_file ($$@)
{
    my ($where, $mystrict, @files) = @_;
    require_file_internal ($where, $mystrict, $relative_dir, @files);
}

# &require_file_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# -----------------------------------------------------------
sub require_file_with_macro ($$$@)
{
    my ($cond, $macro, $mystrict, @files) = @_;
    $macro = rvar ($macro) unless ref $macro;
    require_file ($macro->rdef ($cond)->location, $mystrict, @files);
}

# &require_libsource_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# ----------------------------------------------------------------
# Require an AC_LIBSOURCEd file.  If AC_CONFIG_LIBOBJ_DIR was called, it
# must be in that directory.  Otherwise expect it in the current directory.
sub require_libsource_with_macro ($$$@)
{
    my ($cond, $macro, $mystrict, @files) = @_;
    $macro = rvar ($macro) unless ref $macro;
    if ($config_libobj_dir)
      {
	require_file_internal ($macro->rdef ($cond)->location, $mystrict,
			       $config_libobj_dir, @files);
      }
    else
      {
	require_file ($macro->rdef ($cond)->location, $mystrict, @files);
      }
}

# Queue to push require_conf_file requirements to.
my $required_conf_file_queue;

# &queue_required_conf_file ($QUEUE, $KEY, $DIR, $WHERE, $MYSTRICT, @FILES)
# -------------------------------------------------------------------------
sub queue_required_conf_file ($$$$@)
{
    my ($queue, $key, $dir, $where, $mystrict, @files) = @_;
    my @serial_loc;
    if (ref $where)
      {
        @serial_loc = (QUEUE_LOCATION, $where->serialize ());
      }
    else
      {
        @serial_loc = (QUEUE_STRING, $where);
      }
    $queue->enqueue ($key, $dir, @serial_loc, $mystrict, 0 + @files, @files);
}

# &require_queued_conf_file ($QUEUE)
# ----------------------------------
sub require_queued_conf_file ($)
{
    my ($queue) = @_;
    my $where;
    my $dir = $queue->dequeue ();
    my $loc_key = $queue->dequeue ();
    if ($loc_key eq QUEUE_LOCATION)
      {
	$where = Automake::Location::deserialize ($queue);
      }
    elsif ($loc_key eq QUEUE_STRING)
      {
	$where = $queue->dequeue ();
      }
    else
      {
	prog_error "unexpected key $loc_key";
      }
    my $mystrict = $queue->dequeue ();
    my $nfiles = $queue->dequeue ();
    my @files;
    push @files, $queue->dequeue ()
      foreach (1 .. $nfiles);

    # Dequeuing happens outside of per-makefile context, so we have to
    # set the variables used by require_file_internal and the functions
    # it calls.  Gross!
    $relative_dir = $dir;
    require_file_internal ($where, $mystrict, $config_aux_dir, @files);
}

# &require_conf_file ($WHERE, $MYSTRICT, @FILES)
# ----------------------------------------------
# Looks in configuration path, as specified by AC_CONFIG_AUX_DIR;
# worker threads may queue up the action to be serialized by the master.
#
# FIXME: this seriously relies on the semantics of require_file_internal
# and maybe_push_required_file, in that we exploit the fact that only the
# contents of the last handled output file may be impacted (which in turn
# is dealt with by the master thread).
sub require_conf_file ($$@)
{
    my ($where, $mystrict, @files) = @_;
    if (defined $required_conf_file_queue)
      {
	queue_required_conf_file ($required_conf_file_queue, QUEUE_CONF_FILE,
				  $relative_dir, $where, $mystrict, @files);
      }
    else
      {
	require_file_internal ($where, $mystrict, $config_aux_dir, @files);
      }
}


# &require_conf_file_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# ----------------------------------------------------------------
sub require_conf_file_with_macro ($$$@)
{
    my ($cond, $macro, $mystrict, @files) = @_;
    require_conf_file (rvar ($macro)->rdef ($cond)->location,
		       $mystrict, @files);
}

################################################################

# &require_build_directory ($DIRECTORY)
# ------------------------------------
# Emit rules to create $DIRECTORY if needed, and return
# the file that any target requiring this directory should be made
# dependent upon.
# We don't want to emit the rule twice, and want to reuse it
# for directories with equivalent names (e.g., `foo/bar' and `./foo//bar').
sub require_build_directory ($)
{
  my $directory = shift;

  return $directory_map{$directory} if exists $directory_map{$directory};

  my $cdir = File::Spec->canonpath ($directory);

  if (exists $directory_map{$cdir})
    {
      my $stamp = $directory_map{$cdir};
      $directory_map{$directory} = $stamp;
      return $stamp;
    }

  my $dirstamp = "$cdir/\$(am__dirstamp)";

  $directory_map{$directory} = $dirstamp;
  $directory_map{$cdir} = $dirstamp;

  # Set a variable for the dirstamp basename.
  define_pretty_variable ('am__dirstamp', TRUE, INTERNAL,
			  '$(am__leading_dot)dirstamp');

  # Directory must be removed by `make distclean'.
  $clean_files{$dirstamp} = DIST_CLEAN;

  $output_rules .= ("$dirstamp:\n"
		    . "\t\@\$(MKDIR_P) $directory\n"
		    . "\t\@: > $dirstamp\n");

  return $dirstamp;
}

# &require_build_directory_maybe ($FILE)
# --------------------------------------
# If $FILE lies in a subdirectory, emit a rule to create this
# directory and return the file that $FILE should be made
# dependent upon.  Otherwise, just return the empty string.
sub require_build_directory_maybe ($)
{
    my $file = shift;
    my $directory = dirname ($file);

    if ($directory ne '.')
    {
	return require_build_directory ($directory);
    }
    else
    {
	return '';
    }
}

################################################################

# Push a list of files onto dist_common.
sub push_dist_common
{
  prog_error "push_dist_common run after handle_dist"
    if $handle_dist_run;
  Automake::Variable::define ('DIST_COMMON', VAR_AUTOMAKE, '+', TRUE, "@_",
			      '', INTERNAL, VAR_PRETTY);
}


################################################################

# generate_makefile ($MAKEFILE_AM, $MAKEFILE_IN)
# ----------------------------------------------
# Generate a Makefile.in given the name of the corresponding Makefile and
# the name of the file output by config.status.
sub generate_makefile ($$)
{
  my ($makefile_am, $makefile_in) = @_;

  # Reset all the Makefile.am related variables.
  initialize_per_input;

  # AUTOMAKE_OPTIONS can contains -W flags to disable or enable
  # warnings for this file.  So hold any warning issued before
  # we have processed AUTOMAKE_OPTIONS.
  buffer_messages ('warning');

  # Name of input file ("Makefile.am") and output file
  # ("Makefile.in").  These have no directory components.
  $am_file_name = basename ($makefile_am);
  $in_file_name = basename ($makefile_in);

  # $OUTPUT is encoded.  If it contains a ":" then the first element
  # is the real output file, and all remaining elements are input
  # files.  We don't scan or otherwise deal with these input files,
  # other than to mark them as dependencies.  See
  # &scan_autoconf_files for details.
  my ($makefile, @inputs) = split (/:/, $output_files{$makefile_in});

  $relative_dir = dirname ($makefile);
  $am_relative_dir = dirname ($makefile_am);
  $topsrcdir = backname ($relative_dir);

  read_main_am_file ($makefile_am);
  if (handle_options)
    {
      # Process buffered warnings.
      flush_messages;
      # Fatal error.  Just return, so we can continue with next file.
      return;
    }
  # Process buffered warnings.
  flush_messages;

  # There are a few install-related variables that you should not define.
  foreach my $var ('PRE_INSTALL', 'POST_INSTALL', 'NORMAL_INSTALL')
    {
      my $v = var $var;
      if ($v)
	{
	  my $def = $v->def (TRUE);
	  prog_error "$var not defined in condition TRUE"
	    unless $def;
	  reject_var $var, "`$var' should not be defined"
	    if $def->owner != VAR_AUTOMAKE;
	}
    }

  # Catch some obsolete variables.
  msg_var ('obsolete', 'INCLUDES',
	   "`INCLUDES' is the old name for `AM_CPPFLAGS' (or `*_CPPFLAGS')")
    if var ('INCLUDES');

  # Must do this after reading .am file.
  define_variable ('subdir', $relative_dir, INTERNAL);

  # If DIST_SUBDIRS is defined, make sure SUBDIRS is, so that
  # recursive rules are enabled.
  define_pretty_variable ('SUBDIRS', TRUE, INTERNAL, '')
    if var 'DIST_SUBDIRS' && ! var 'SUBDIRS';

  # Check first, because we might modify some state.
  check_cygnus;
  check_gnu_standards;
  check_gnits_standards;

  handle_configure ($makefile_am, $makefile_in, $makefile, @inputs);
  handle_gettext;
  handle_libraries;
  handle_ltlibraries;
  handle_programs;
  handle_scripts;

  # These must be run after all the sources are scanned.  They
  # use variables defined by &handle_libraries, &handle_ltlibraries,
  # or &handle_programs.
  handle_compile;
  handle_languages;
  handle_libtool;

  # Variables used by distdir.am and tags.am.
  define_pretty_variable ('SOURCES', TRUE, INTERNAL, @sources);
  if (! option 'no-dist')
    {
      define_pretty_variable ('DIST_SOURCES', TRUE, INTERNAL, @dist_sources);
    }

  handle_multilib;
  handle_texinfo;
  handle_emacs_lisp;
  handle_python;
  handle_java;
  handle_man_pages;
  handle_data;
  handle_headers;
  handle_subdirs;
  handle_tags;
  handle_minor_options;
  # Must come after handle_programs so that %known_programs is up-to-date.
  handle_tests;

  # This must come after most other rules.
  handle_dist;

  handle_footer;
  do_check_merge_target;
  handle_all ($makefile);

  # FIXME: Gross!
  if (var ('lib_LTLIBRARIES') && var ('bin_PROGRAMS'))
    {
      $output_rules .= "install-binPROGRAMS: install-libLTLIBRARIES\n\n";
    }
  if (var ('nobase_lib_LTLIBRARIES') && var ('bin_PROGRAMS'))
    {
      $output_rules .= "install-binPROGRAMS: install-nobase_libLTLIBRARIES\n\n";
    }

  handle_install;
  handle_clean ($makefile);
  handle_factored_dependencies;

  # Comes last, because all the above procedures may have
  # defined or overridden variables.
  $output_vars .= output_variables;

  check_typos;

  my ($out_file) = $output_directory . '/' . $makefile_in;

  if ($exit_code != 0)
    {
      verb "not writing $out_file because of earlier errors";
      return;
    }

  if (! -d ($output_directory . '/' . $am_relative_dir))
    {
      mkdir ($output_directory . '/' . $am_relative_dir, 0755);
    }

  # We make sure that `all:' is the first target.
  my $output =
    "$output_vars$output_all$output_header$output_rules$output_trailer";

  # Decide whether we must update the output file or not.
  # We have to update in the following situations.
  #  * $force_generation is set.
  #  * any of the output dependencies is younger than the output
  #  * the contents of the output is different (this can happen
  #    if the project has been populated with a file listed in
  #    @common_files since the last run).
  # Output's dependencies are split in two sets:
  #  * dependencies which are also configure dependencies
  #    These do not change between each Makefile.am
  #  * other dependencies, specific to the Makefile.am being processed
  #    (such as the Makefile.am itself, or any Makefile fragment
  #    it includes).
  my $timestamp = mtime $out_file;
  if (! $force_generation
      && $configure_deps_greatest_timestamp < $timestamp
      && $output_deps_greatest_timestamp < $timestamp
      && $output eq contents ($out_file))
    {
      verb "$out_file unchanged";
      # No need to update.
      return;
    }

  if (-e $out_file)
    {
      unlink ($out_file)
	or fatal "cannot remove $out_file: $!\n";
    }

  my $gm_file = new Automake::XFile "> $out_file";
  verb "creating $out_file";
  print $gm_file $output;
}

################################################################




################################################################

# Print usage information.
sub usage ()
{
    print "Usage: $0 [OPTION] ... [Makefile]...

Generate Makefile.in for configure from Makefile.am.

Operation modes:
      --help               print this help, then exit
      --version            print version number, then exit
  -v, --verbose            verbosely list files processed
      --no-force           only update Makefile.in's that are out of date
  -W, --warnings=CATEGORY  report the warnings falling in CATEGORY

Dependency tracking:
  -i, --ignore-deps      disable dependency tracking code
      --include-deps     enable dependency tracking code

Flavors:
      --cygnus           assume program is part of Cygnus-style tree
      --foreign          set strictness to foreign
      --gnits            set strictness to gnits
      --gnu              set strictness to gnu

Library files:
  -a, --add-missing      add missing standard files to package
      --libdir=DIR       directory storing library files
  -c, --copy             with -a, copy missing files (default is symlink)
  -f, --force-missing    force update of standard files

";
    Automake::ChannelDefs::usage;

    my ($last, @lcomm);
    $last = '';
    foreach my $iter (sort ((@common_files, @common_sometimes)))
    {
	push (@lcomm, $iter) unless $iter eq $last;
	$last = $iter;
    }

    my @four;
    print "\nFiles which are automatically distributed, if found:\n";
    format USAGE_FORMAT =
  @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<
  $four[0],           $four[1],           $four[2],           $four[3]
.
    $~ = "USAGE_FORMAT";

    my $cols = 4;
    my $rows = int(@lcomm / $cols);
    my $rest = @lcomm % $cols;

    if ($rest)
    {
	$rows++;
    }
    else
    {
	$rest = $cols;
    }

    for (my $y = 0; $y < $rows; $y++)
    {
	@four = ("", "", "", "");
	for (my $x = 0; $x < $cols; $x++)
	{
	    last if $y + 1 == $rows && $x == $rest;

	    my $idx = (($x > $rest)
		       ?  ($rows * $rest + ($rows - 1) * ($x - $rest))
		       : ($rows * $x));

	    $idx += $y;
	    $four[$x] = $lcomm[$idx];
	}
	write;
    }

    print "\nReport bugs to <bug-automake\@gnu.org>.\n";

    # --help always returns 0 per GNU standards.
    exit 0;
}


# &version ()
# -----------
# Print version information
sub version ()
{
  print <<EOF;
automake (GNU $PACKAGE) $VERSION
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl-2.0.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Tom Tromey <tromey\@redhat.com>
       and Alexandre Duret-Lutz <adl\@gnu.org>.
EOF
  # --version always returns 0 per GNU standards.
  exit 0;
}

################################################################

# Parse command line.
sub parse_arguments ()
{
  # Start off as gnu.
  set_strictness ('gnu');

  my $cli_where = new Automake::Location;
  my %cli_options =
    (
     'libdir=s'	=> \$libdir,
     'gnu'		=> sub { set_strictness ('gnu'); },
     'gnits'		=> sub { set_strictness ('gnits'); },
     'cygnus'	        => sub { set_global_option ('cygnus', $cli_where); },
     'foreign'          => sub { set_strictness ('foreign'); },
     'include-deps'	=> sub { unset_global_option ('no-dependencies'); },
     'i|ignore-deps'	=> sub { set_global_option ('no-dependencies',
						    $cli_where); },
     'no-force'	=> sub { $force_generation = 0; },
     'f|force-missing'  => \$force_missing,
     'o|output-dir=s'	=> \$output_directory,
     'a|add-missing'	=> \$add_missing,
     'c|copy'		=> \$copy_missing,
     'v|verbose'	=> sub { setup_channel 'verb', silent => 0; },
     'W|warnings=s'     => \&parse_warnings,
     # These long options (--Werror and --Wno-error) for backward
     # compatibility.  Use -Werror and -Wno-error today.
     'Werror'           => sub { parse_warnings 'W', 'error'; },
     'Wno-error'        => sub { parse_warnings 'W', 'no-error'; },
     );
  use Getopt::Long;
  Getopt::Long::config ("bundling", "pass_through");

  # See if --version or --help is used.  We want to process these before
  # anything else because the GNU Coding Standards require us to
  # `exit 0' after processing these options, and we can't guarantee this
  # if we treat other options first.  (Handling other options first
  # could produce error diagnostics, and in this condition it is
  # confusing if Automake does `exit 0'.)
  my %cli_options_1st_pass =
    (
     'version' => \&version,
     'help'    => \&usage,
     # Recognize all other options (and their arguments) but do nothing.
     map { $_ => sub {} } (keys %cli_options)
     );
  my @ARGV_backup = @ARGV;
  Getopt::Long::GetOptions %cli_options_1st_pass
    or exit 1;
  @ARGV = @ARGV_backup;

  # Now *really* process the options.  This time we know that --help
  # and --version are not present, but we specify them nonetheless so
  # that ambiguous abbreviation are diagnosed.
  Getopt::Long::GetOptions %cli_options, 'version' => sub {}, 'help' => sub {}
    or exit 1;

  if (defined $output_directory)
    {
      msg 'obsolete', "`--output-dir' is deprecated\n";
    }
  else
    {
      # In the next release we'll remove this entirely.
      $output_directory = '.';
    }

  return unless @ARGV;

  if ($ARGV[0] =~ /^-./)
    {
      my %argopts;
      for my $k (keys %cli_options)
	{
	  if ($k =~ /(.*)=s$/)
	    {
	      map { $argopts{(length ($_) == 1)
			     ? "-$_" : "--$_" } = 1; } (split (/\|/, $1));
	    }
	}
      if ($ARGV[0] eq '--')
	{
	  shift @ARGV;
	}
      elsif (exists $argopts{$ARGV[0]})
	{
	  fatal ("option `$ARGV[0]' requires an argument\n"
		 . "Try `$0 --help' for more information.");
	}
      else
	{
	  fatal ("unrecognized option `$ARGV[0]'.\n"
		 . "Try `$0 --help' for more information.");
	}
    }

  my $errspec = 0;
  foreach my $arg (@ARGV)
    {
      fatal ("empty argument\nTry `$0 --help' for more information.")
	if ($arg eq '');

      # Handle $local:$input syntax.
      my ($local, @rest) = split (/:/, $arg);
      @rest = ("$local.in",) unless @rest;
      my $input = locate_am @rest;
      if ($input)
	{
	  push @input_files, $input;
	  $output_files{$input} = join (':', ($local, @rest));
	}
      else
	{
	  error "no Automake input file found for `$arg'";
	  $errspec = 1;
	}
    }
  fatal "no input file found among supplied arguments"
    if $errspec && ! @input_files;
}


# handle_makefile ($MAKEFILE_IN)
# ------------------------------
# Deal with $MAKEFILE_IN.
sub handle_makefile ($)
{
  my ($file) =  @_;
  ($am_file = $file) =~ s/\.in$//;
  if (! -f ($am_file . '.am'))
    {
      error "`$am_file.am' does not exist";
    }
  else
    {
      # Any warning setting now local to this Makefile.am.
      dup_channel_setup;

      generate_makefile ($am_file . '.am', $file);

      # Back out any warning setting.
      drop_channel_setup;
    }
}

# handle_makefiles_serial ()
# --------------------------
# Deal with all makefiles, without threads.
sub handle_makefiles_serial ()
{
  foreach my $file (@input_files)
    {
      handle_makefile ($file);
    }
}

# get_number_of_threads ()
# ------------------------
# Logic for deciding how many worker threads to use.
sub get_number_of_threads
{
  my $nthreads = $ENV{'AUTOMAKE_JOBS'} || 0;

  $nthreads = 0
    unless $nthreads =~ /^[0-9]+$/;

  # It doesn't make sense to use more threads than makefiles,
  my $max_threads = @input_files;

  # but a single worker thread is helpful for exposing bugs.
  if ($automake_will_process_aux_dir && $max_threads > 1)
    {
      $max_threads--;
    }
  if ($nthreads > $max_threads)
    {
      $nthreads = $max_threads;
    }
  return $nthreads;
}

# handle_makefiles_threaded ($NTHREADS)
# -------------------------------------
# Deal with all makefiles, using threads.  The general strategy is to
# spawn NTHREADS worker threads, dispatch makefiles to them, and let the
# worker threads push back everything that needs serialization:
# * warning and (normal) error messages, for stable stderr output
#   order and content (avoiding duplicates, for example),
# * races when installing aux files (and respective messages),
# * races when collecting aux files for distribution.
#
# The latter requires that the makefile that deals with the aux dir
# files be handled last, done by the master thread.
sub handle_makefiles_threaded ($)
{
  my ($nthreads) = @_;

  my @queued_input_files = @input_files;
  my $last_input_file = undef;
  if ($automake_will_process_aux_dir)
    {
      $last_input_file = pop @queued_input_files;
    }

  # The file queue distributes all makefiles, the message queues
  # collect all serializations needed for respective files.
  my $file_queue = Thread::Queue->new;
  my %msg_queues;
  foreach my $file (@queued_input_files)
    {
      $msg_queues{$file} = Thread::Queue->new;
    }

  verb "spawning $nthreads worker threads";
  my @threads = (1 .. $nthreads);
  foreach my $t (@threads)
    {
      $t = threads->new (sub
	{
	  while (my $file = $file_queue->dequeue)
	    {
	      verb "handling $file";
	      my $queue = $msg_queues{$file};
	      setup_channel_queue ($queue, QUEUE_MESSAGE);
	      $required_conf_file_queue = $queue;
	      handle_makefile ($file);
	      $queue->enqueue (undef);
	      setup_channel_queue (undef, undef);
	      $required_conf_file_queue = undef;
	    }
	  return $exit_code;
	});
    }

  # Queue all normal makefiles.
  verb "queuing " . @queued_input_files . " input files";
  $file_queue->enqueue (@queued_input_files, (undef) x @threads);

  # Collect and process serializations.
  foreach my $file (@queued_input_files)
    {
      verb "dequeuing messages for " . $file;
      reset_local_duplicates ();
      my $queue = $msg_queues{$file};
      while (my $key = $queue->dequeue)
	{
	  if ($key eq QUEUE_MESSAGE)
	    {
	      pop_channel_queue ($queue);
	    }
	  elsif ($key eq QUEUE_CONF_FILE)
	    {
	      require_queued_conf_file ($queue);
	    }
	  else
	    {
	      prog_error "unexpected key $key";
	    }
	}
    }

  foreach my $t (@threads)
    {
      my @exit_thread = $t->join;
      $exit_code = $exit_thread[0]
	if ($exit_thread[0] > $exit_code);
    }

  # The master processes the last file.
  if ($automake_will_process_aux_dir)
    {
      verb "processing last input file";
      handle_makefile ($last_input_file);
    }
}

################################################################

# Parse the WARNINGS environment variable.
parse_WARNINGS;

# Parse command line.
parse_arguments;

$configure_ac = require_configure_ac;

# Do configure.ac scan only once.
scan_autoconf_files;

if (! @input_files)
  {
    my $msg = '';
    $msg = "\nDid you forget AC_CONFIG_FILES([Makefile]) in $configure_ac?"
      if -f 'Makefile.am';
    fatal ("no `Makefile.am' found for any configure output$msg");
  }

my $nthreads = get_number_of_threads ();

if ($perl_threads && $nthreads >= 1)
  {
    handle_makefiles_threaded ($nthreads);
  }
else
  {
    handle_makefiles_serial ();
  }

exit $exit_code;


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
